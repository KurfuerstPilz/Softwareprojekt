
TFM_Appli_NonSecure.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006ed8  08038400  08038400  00008400  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0803f2d8  0803f2d8  0000f2d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .copy.table   00000018  0803f2e0  0803f2e0  0000f2e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .zero.table   00000010  0803f2f8  0803f2f8  0000f2f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .testprotection 00000004  20000000  20000000  00020000  2**2
                  ALLOC
  5 .data         00000094  20000100  0803f308  00010100  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000540  20000194  0803f39c  00010194  2**2
                  ALLOC
  7 .msp_stack    00000400  200006e0  0803f900  000106e0  2**5
                  ALLOC
  8 .psp_stack    00000c00  20000ae0  0803fd00  000106e0  2**5
                  ALLOC
  9 .heap         00001000  200016e0  08040900  000106e0  2**3
                  ALLOC
 10 .ARM.attributes 00000034  00000000  00000000  00010194  2**0
                  CONTENTS, READONLY
 11 .comment      0000007b  00000000  00000000  000101c8  2**0
                  CONTENTS, READONLY
 12 .debug_line   00013647  00000000  00000000  00010243  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0001d6da  00000000  00000000  0002388a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00004d52  00000000  00000000  00040f64  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00000e48  00000000  00000000  00045cb8  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0010ec0c  00000000  00000000  00046b00  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000aa39  00000000  00000000  0015570c  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00001028  00000000  00000000  00160145  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macro  0002d604  00000000  00000000  0016116d  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_frame  00003038  00000000  00000000  0018e774  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .stab         00000084  00000000  00000000  001917ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .stabstr      00000117  00000000  00000000  00191830  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08038400 <__Vectors>:
 8038400:	20000ae0 	.word	0x20000ae0
 8038404:	080386a9 	.word	0x080386a9
 8038408:	08039125 	.word	0x08039125
 803840c:	08039127 	.word	0x08039127
 8038410:	08039129 	.word	0x08039129
 8038414:	0803912b 	.word	0x0803912b
 8038418:	0803912d 	.word	0x0803912d
 803841c:	0803870d 	.word	0x0803870d
	...
 803842c:	08038711 	.word	0x08038711
 8038430:	0803912f 	.word	0x0803912f
 8038434:	00000000 	.word	0x00000000
 8038438:	08038719 	.word	0x08038719
 803843c:	08039131 	.word	0x08039131
 8038440:	08038721 	.word	0x08038721
 8038444:	08038725 	.word	0x08038725
 8038448:	08038729 	.word	0x08038729
 803844c:	0803872d 	.word	0x0803872d
 8038450:	08038731 	.word	0x08038731
 8038454:	08038735 	.word	0x08038735
 8038458:	08039135 	.word	0x08039135
 803845c:	0803873d 	.word	0x0803873d
 8038460:	08038741 	.word	0x08038741
 8038464:	08038745 	.word	0x08038745
 8038468:	08038749 	.word	0x08038749
 803846c:	0803874d 	.word	0x0803874d
 8038470:	08038751 	.word	0x08038751
 8038474:	08038755 	.word	0x08038755
 8038478:	08038759 	.word	0x08038759
 803847c:	0803875d 	.word	0x0803875d
 8038480:	08038761 	.word	0x08038761
 8038484:	08038765 	.word	0x08038765
 8038488:	08038769 	.word	0x08038769
 803848c:	0803876d 	.word	0x0803876d
 8038490:	08038771 	.word	0x08038771
 8038494:	08038775 	.word	0x08038775
 8038498:	08038779 	.word	0x08038779
 803849c:	0803877d 	.word	0x0803877d
 80384a0:	08038781 	.word	0x08038781
 80384a4:	08038785 	.word	0x08038785
 80384a8:	08038789 	.word	0x08038789
 80384ac:	0803878d 	.word	0x0803878d
 80384b0:	08038791 	.word	0x08038791
 80384b4:	08038795 	.word	0x08038795
 80384b8:	08038799 	.word	0x08038799
 80384bc:	0803879d 	.word	0x0803879d
 80384c0:	080387a1 	.word	0x080387a1
 80384c4:	080387a5 	.word	0x080387a5
 80384c8:	080387a9 	.word	0x080387a9
 80384cc:	080387ad 	.word	0x080387ad
 80384d0:	080387b1 	.word	0x080387b1
 80384d4:	080387b5 	.word	0x080387b5
 80384d8:	080387b9 	.word	0x080387b9
 80384dc:	080387bd 	.word	0x080387bd
 80384e0:	080387c1 	.word	0x080387c1
 80384e4:	080387c5 	.word	0x080387c5
 80384e8:	080387c9 	.word	0x080387c9
 80384ec:	080387cd 	.word	0x080387cd
 80384f0:	080387d1 	.word	0x080387d1
 80384f4:	080387d5 	.word	0x080387d5
 80384f8:	080387d9 	.word	0x080387d9
 80384fc:	080387dd 	.word	0x080387dd
 8038500:	080387e1 	.word	0x080387e1
 8038504:	080387e5 	.word	0x080387e5
 8038508:	080387e9 	.word	0x080387e9
 803850c:	080387ed 	.word	0x080387ed
 8038510:	080387f1 	.word	0x080387f1
 8038514:	080387f5 	.word	0x080387f5
 8038518:	080387f9 	.word	0x080387f9
 803851c:	080387fd 	.word	0x080387fd
 8038520:	08038801 	.word	0x08038801
 8038524:	08038805 	.word	0x08038805
 8038528:	08038809 	.word	0x08038809
 803852c:	0803880d 	.word	0x0803880d
 8038530:	08038811 	.word	0x08038811
 8038534:	08038815 	.word	0x08038815
 8038538:	08038819 	.word	0x08038819
 803853c:	0803881d 	.word	0x0803881d
 8038540:	08038821 	.word	0x08038821
 8038544:	08038825 	.word	0x08038825
 8038548:	08038829 	.word	0x08038829
 803854c:	0803882d 	.word	0x0803882d
 8038550:	08038831 	.word	0x08038831
 8038554:	08038835 	.word	0x08038835
 8038558:	08038839 	.word	0x08038839
 803855c:	0803883d 	.word	0x0803883d
 8038560:	08038841 	.word	0x08038841
 8038564:	08038845 	.word	0x08038845
 8038568:	08038849 	.word	0x08038849
 803856c:	0803884d 	.word	0x0803884d
 8038570:	08038851 	.word	0x08038851
 8038574:	00000000 	.word	0x00000000
 8038578:	08038855 	.word	0x08038855
 803857c:	00000000 	.word	0x00000000
 8038580:	08038859 	.word	0x08038859
 8038584:	0803885d 	.word	0x0803885d
 8038588:	08038861 	.word	0x08038861
 803858c:	08038865 	.word	0x08038865
 8038590:	08038869 	.word	0x08038869
 8038594:	0803886d 	.word	0x0803886d
 8038598:	08038871 	.word	0x08038871
 803859c:	08038875 	.word	0x08038875
 80385a0:	08038879 	.word	0x08038879
 80385a4:	0803887d 	.word	0x0803887d
 80385a8:	08038881 	.word	0x08038881
 80385ac:	08038885 	.word	0x08038885
 80385b0:	08038889 	.word	0x08038889
 80385b4:	00000000 	.word	0x00000000
 80385b8:	0803888d 	.word	0x0803888d
 80385bc:	08038891 	.word	0x08038891
	...
 80385c8:	08038895 	.word	0x08038895
 80385cc:	08038899 	.word	0x08038899
 80385d0:	0803889d 	.word	0x0803889d
 80385d4:	080388a1 	.word	0x080388a1
 80385d8:	080388a5 	.word	0x080388a5
 80385dc:	080388a9 	.word	0x080388a9
 80385e0:	080388ad 	.word	0x080388ad
 80385e4:	080388b1 	.word	0x080388b1
 80385e8:	080388b5 	.word	0x080388b5
 80385ec:	080388b9 	.word	0x080388b9
 80385f0:	080388bd 	.word	0x080388bd

080385f4 <__do_global_dtors_aux>:
 80385f4:	b510      	push	{r4, lr}
 80385f6:	4c05      	ldr	r4, [pc, #20]	; (803860c <__do_global_dtors_aux+0x18>)
 80385f8:	7823      	ldrb	r3, [r4, #0]
 80385fa:	b933      	cbnz	r3, 803860a <__do_global_dtors_aux+0x16>
 80385fc:	4b04      	ldr	r3, [pc, #16]	; (8038610 <__do_global_dtors_aux+0x1c>)
 80385fe:	b113      	cbz	r3, 8038606 <__do_global_dtors_aux+0x12>
 8038600:	4804      	ldr	r0, [pc, #16]	; (8038614 <__do_global_dtors_aux+0x20>)
 8038602:	e000      	b.n	8038606 <__do_global_dtors_aux+0x12>
 8038604:	bf00      	nop
 8038606:	2301      	movs	r3, #1
 8038608:	7023      	strb	r3, [r4, #0]
 803860a:	bd10      	pop	{r4, pc}
 803860c:	20000194 	.word	0x20000194
 8038610:	00000000 	.word	0x00000000
 8038614:	0803f2d4 	.word	0x0803f2d4

08038618 <frame_dummy>:
 8038618:	b508      	push	{r3, lr}
 803861a:	4b03      	ldr	r3, [pc, #12]	; (8038628 <frame_dummy+0x10>)
 803861c:	b11b      	cbz	r3, 8038626 <frame_dummy+0xe>
 803861e:	4903      	ldr	r1, [pc, #12]	; (803862c <frame_dummy+0x14>)
 8038620:	4803      	ldr	r0, [pc, #12]	; (8038630 <frame_dummy+0x18>)
 8038622:	e000      	b.n	8038626 <frame_dummy+0xe>
 8038624:	bf00      	nop
 8038626:	bd08      	pop	{r3, pc}
 8038628:	00000000 	.word	0x00000000
 803862c:	20000198 	.word	0x20000198
 8038630:	0803f2d4 	.word	0x0803f2d4

08038634 <_mainCRTStartup>:
 8038634:	4b15      	ldr	r3, [pc, #84]	; (803868c <_mainCRTStartup+0x58>)
 8038636:	2b00      	cmp	r3, #0
 8038638:	bf08      	it	eq
 803863a:	4b13      	ldreq	r3, [pc, #76]	; (8038688 <_mainCRTStartup+0x54>)
 803863c:	469d      	mov	sp, r3
 803863e:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
 8038642:	2100      	movs	r1, #0
 8038644:	468b      	mov	fp, r1
 8038646:	460f      	mov	r7, r1
 8038648:	4813      	ldr	r0, [pc, #76]	; (8038698 <_mainCRTStartup+0x64>)
 803864a:	4a14      	ldr	r2, [pc, #80]	; (803869c <_mainCRTStartup+0x68>)
 803864c:	1a12      	subs	r2, r2, r0
 803864e:	f004 f843 	bl	803c6d8 <memset>
 8038652:	4b0f      	ldr	r3, [pc, #60]	; (8038690 <_mainCRTStartup+0x5c>)
 8038654:	2b00      	cmp	r3, #0
 8038656:	d000      	beq.n	803865a <_mainCRTStartup+0x26>
 8038658:	4798      	blx	r3
 803865a:	4b0e      	ldr	r3, [pc, #56]	; (8038694 <_mainCRTStartup+0x60>)
 803865c:	2b00      	cmp	r3, #0
 803865e:	d000      	beq.n	8038662 <_mainCRTStartup+0x2e>
 8038660:	4798      	blx	r3
 8038662:	2000      	movs	r0, #0
 8038664:	2100      	movs	r1, #0
 8038666:	0004      	movs	r4, r0
 8038668:	000d      	movs	r5, r1
 803866a:	480d      	ldr	r0, [pc, #52]	; (80386a0 <_mainCRTStartup+0x6c>)
 803866c:	2800      	cmp	r0, #0
 803866e:	d002      	beq.n	8038676 <_mainCRTStartup+0x42>
 8038670:	480c      	ldr	r0, [pc, #48]	; (80386a4 <_mainCRTStartup+0x70>)
 8038672:	e000      	b.n	8038676 <_mainCRTStartup+0x42>
 8038674:	bf00      	nop
 8038676:	f003 fff1 	bl	803c65c <__libc_init_array>
 803867a:	0020      	movs	r0, r4
 803867c:	0029      	movs	r1, r5
 803867e:	f000 fcdd 	bl	803903c <main>
 8038682:	f003 ffd7 	bl	803c634 <exit>
 8038686:	bf00      	nop
 8038688:	00080000 	.word	0x00080000
 803868c:	200016e0 	.word	0x200016e0
	...
 8038698:	20000194 	.word	0x20000194
 803869c:	200006d4 	.word	0x200006d4
	...

080386a8 <Reset_Handler>:
 *    offset 4: VMA of start of a section to copy to
 *    offset 8: size of the section to copy. Must be multiply of 4
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
    ldr    r4, =__copy_table_start__
 80386a8:	4c0f      	ldr	r4, [pc, #60]	; (80386e8 <Reset_Handler+0x40>)
    ldr    r5, =__copy_table_end__
 80386aa:	4d10      	ldr	r5, [pc, #64]	; (80386ec <Reset_Handler+0x44>)

.L_loop0:
    cmp    r4, r5
 80386ac:	42ac      	cmp	r4, r5
    bge    .L_loop0_done
 80386ae:	da09      	bge.n	80386c4 <Reset_Handler+0x1c>
    ldr    r1, [r4]
 80386b0:	6821      	ldr	r1, [r4, #0]
    ldr    r2, [r4, #4]
 80386b2:	6862      	ldr	r2, [r4, #4]
    ldr    r3, [r4, #8]
 80386b4:	68a3      	ldr	r3, [r4, #8]

.L_loop0_0:
    subs    r3, #4
 80386b6:	3b04      	subs	r3, #4
    ittt    ge
 80386b8:	bfa2      	ittt	ge
    ldrge    r0, [r1, r3]
 80386ba:	58c8      	ldrge	r0, [r1, r3]
    strge    r0, [r2, r3]
 80386bc:	50d0      	strge	r0, [r2, r3]
    bge    .L_loop0_0
 80386be:	e7fa      	bge.n	80386b6 <Reset_Handler+0xe>

    adds    r4, #12
 80386c0:	340c      	adds	r4, #12
    b    .L_loop0
 80386c2:	e7f3      	b.n	80386ac <Reset_Handler+0x4>
 *  Between symbol address __copy_table_start__ and __copy_table_end__,
 *  there are array of tuples specifying:
 *    offset 0: Start of a BSS section
 *    offset 4: Size of this BSS section. Must be multiply of 4
 */
    ldr    r3, =__zero_table_start__
 80386c4:	4b0a      	ldr	r3, [pc, #40]	; (80386f0 <Reset_Handler+0x48>)
    ldr    r4, =__zero_table_end__
 80386c6:	4c0b      	ldr	r4, [pc, #44]	; (80386f4 <Reset_Handler+0x4c>)

.L_loop2:
    cmp    r3, r4
 80386c8:	42a3      	cmp	r3, r4
    bge    .L_loop2_done
 80386ca:	da08      	bge.n	80386de <Reset_Handler+0x36>
    ldr    r1, [r3]
 80386cc:	6819      	ldr	r1, [r3, #0]
    ldr    r2, [r3, #4]
 80386ce:	685a      	ldr	r2, [r3, #4]
    movs    r0, 0
 80386d0:	2000      	movs	r0, #0

.L_loop2_0:
    subs    r2, #4
 80386d2:	3a04      	subs	r2, #4
    itt    ge
 80386d4:	bfa4      	itt	ge
    strge    r0, [r1, r2]
 80386d6:	5088      	strge	r0, [r1, r2]
    bge    .L_loop2_0
 80386d8:	e7fb      	bge.n	80386d2 <Reset_Handler+0x2a>

    adds    r3, #8
 80386da:	3308      	adds	r3, #8
    b    .L_loop2
 80386dc:	e7f4      	b.n	80386c8 <Reset_Handler+0x20>

/*    mrs     r0, control   */ /* Get control value */
/*   orr     r0, r0, #1     *//* Select switch to unprivilage mode */
 /*   orr     r0, r0, #2    */ /* Select switch to PSP */
/*    msr     control, r0 */
    bl    SystemInit
 80386de:	f000 fd2b 	bl	8039138 <SystemInit>


#ifndef __START
#define __START _start
#endif
    bl    __START
 80386e2:	f7ff ffa7 	bl	8038634 <_mainCRTStartup>
 80386e6:	0000      	.short	0x0000
    ldr    r4, =__copy_table_start__
 80386e8:	0803f2e0 	.word	0x0803f2e0
    ldr    r5, =__copy_table_end__
 80386ec:	0803f2f8 	.word	0x0803f2f8
    ldr    r3, =__zero_table_start__
 80386f0:	0803f2f8 	.word	0x0803f2f8
    ldr    r4, =__zero_table_end__
 80386f4:	0803f308 	.word	0x0803f308
    .weak    \handler_name
    \handler_name:
    b        \handler_name
    .endm

   def_irq_handler             NMI_Handler
 80386f8:	f000 bd14 	b.w	8039124 <NMI_Handler>
   def_irq_handler             HardFault_Handler
 80386fc:	f000 bd13 	b.w	8039126 <HardFault_Handler>
   def_irq_handler             MemManage_Handler
 8038700:	f000 bd12 	b.w	8039128 <MemManage_Handler>
   def_irq_handler             BusFault_Handler
 8038704:	f000 bd11 	b.w	803912a <BusFault_Handler>
   def_irq_handler             UsageFault_Handler
 8038708:	f000 bd10 	b.w	803912c <UsageFault_Handler>

0803870c <SecureFault_Handler>:
   def_irq_handler             SecureFault_Handler
 803870c:	f7ff bffe 	b.w	803870c <SecureFault_Handler>

08038710 <SVC_Handler>:
   def_irq_handler             SVC_Handler
 8038710:	f7ff bffe 	b.w	8038710 <SVC_Handler>
   def_irq_handler             DebugMon_Handler
 8038714:	f000 bd0b 	b.w	803912e <DebugMon_Handler>

08038718 <PendSV_Handler>:
   def_irq_handler             PendSV_Handler
 8038718:	f7ff bffe 	b.w	8038718 <PendSV_Handler>
   def_irq_handler             SysTick_Handler
 803871c:	f000 bd08 	b.w	8039130 <SysTick_Handler>

08038720 <WWDG_IRQHandler>:
   def_irq_handler             WWDG_IRQHandler
 8038720:	f7ff bffe 	b.w	8038720 <WWDG_IRQHandler>

08038724 <PVD_PVM_IRQHandler>:
   def_irq_handler             PVD_PVM_IRQHandler
 8038724:	f7ff bffe 	b.w	8038724 <PVD_PVM_IRQHandler>

08038728 <RTC_IRQHandler>:
   def_irq_handler             RTC_IRQHandler
 8038728:	f7ff bffe 	b.w	8038728 <RTC_IRQHandler>

0803872c <RTC_IRQHandler_S>:
   def_irq_handler             RTC_IRQHandler_S
 803872c:	f7ff bffe 	b.w	803872c <RTC_IRQHandler_S>

08038730 <TAMP_IRQHandler>:
   def_irq_handler             TAMP_IRQHandler
 8038730:	f7ff bffe 	b.w	8038730 <TAMP_IRQHandler>

08038734 <TAMP_IRQHandler_S>:
   def_irq_handler             TAMP_IRQHandler_S
 8038734:	f7ff bffe 	b.w	8038734 <TAMP_IRQHandler_S>
   def_irq_handler             FLASH_IRQHandler
 8038738:	f000 bcfc 	b.w	8039134 <FLASH_IRQHandler>

0803873c <FLASH_IRQHandler_S>:
   def_irq_handler             FLASH_IRQHandler_S
 803873c:	f7ff bffe 	b.w	803873c <FLASH_IRQHandler_S>

08038740 <SERR_IRQHandler>:
   def_irq_handler             SERR_IRQHandler
 8038740:	f7ff bffe 	b.w	8038740 <SERR_IRQHandler>

08038744 <RCC_IRQHandler>:
   def_irq_handler             RCC_IRQHandler
 8038744:	f7ff bffe 	b.w	8038744 <RCC_IRQHandler>

08038748 <RCC_IRQHandler_S>:
   def_irq_handler             RCC_IRQHandler_S
 8038748:	f7ff bffe 	b.w	8038748 <RCC_IRQHandler_S>

0803874c <EXTI0_IRQHandler>:
   def_irq_handler             EXTI0_IRQHandler
 803874c:	f7ff bffe 	b.w	803874c <EXTI0_IRQHandler>

08038750 <EXTI1_IRQHandler>:
   def_irq_handler             EXTI1_IRQHandler
 8038750:	f7ff bffe 	b.w	8038750 <EXTI1_IRQHandler>

08038754 <EXTI2_IRQHandler>:
   def_irq_handler             EXTI2_IRQHandler
 8038754:	f7ff bffe 	b.w	8038754 <EXTI2_IRQHandler>

08038758 <EXTI3_IRQHandler>:
   def_irq_handler             EXTI3_IRQHandler
 8038758:	f7ff bffe 	b.w	8038758 <EXTI3_IRQHandler>

0803875c <EXTI4_IRQHandler>:
   def_irq_handler             EXTI4_IRQHandler
 803875c:	f7ff bffe 	b.w	803875c <EXTI4_IRQHandler>

08038760 <EXTI5_IRQHandler>:
   def_irq_handler             EXTI5_IRQHandler
 8038760:	f7ff bffe 	b.w	8038760 <EXTI5_IRQHandler>

08038764 <EXTI6_IRQHandler>:
   def_irq_handler             EXTI6_IRQHandler
 8038764:	f7ff bffe 	b.w	8038764 <EXTI6_IRQHandler>

08038768 <EXTI7_IRQHandler>:
   def_irq_handler             EXTI7_IRQHandler
 8038768:	f7ff bffe 	b.w	8038768 <EXTI7_IRQHandler>

0803876c <EXTI8_IRQHandler>:
   def_irq_handler             EXTI8_IRQHandler
 803876c:	f7ff bffe 	b.w	803876c <EXTI8_IRQHandler>

08038770 <EXTI9_IRQHandler>:
   def_irq_handler             EXTI9_IRQHandler
 8038770:	f7ff bffe 	b.w	8038770 <EXTI9_IRQHandler>

08038774 <EXTI10_IRQHandler>:
   def_irq_handler             EXTI10_IRQHandler
 8038774:	f7ff bffe 	b.w	8038774 <EXTI10_IRQHandler>

08038778 <EXTI11_IRQHandler>:
   def_irq_handler             EXTI11_IRQHandler
 8038778:	f7ff bffe 	b.w	8038778 <EXTI11_IRQHandler>

0803877c <EXTI12_IRQHandler>:
   def_irq_handler             EXTI12_IRQHandler
 803877c:	f7ff bffe 	b.w	803877c <EXTI12_IRQHandler>

08038780 <EXTI13_IRQHandler>:
   def_irq_handler             EXTI13_IRQHandler
 8038780:	f7ff bffe 	b.w	8038780 <EXTI13_IRQHandler>

08038784 <EXTI14_IRQHandler>:
   def_irq_handler             EXTI14_IRQHandler
 8038784:	f7ff bffe 	b.w	8038784 <EXTI14_IRQHandler>

08038788 <EXTI15_IRQHandler>:
   def_irq_handler             EXTI15_IRQHandler
 8038788:	f7ff bffe 	b.w	8038788 <EXTI15_IRQHandler>

0803878c <DMAMUX1_IRQHandler>:
   def_irq_handler             DMAMUX1_IRQHandler
 803878c:	f7ff bffe 	b.w	803878c <DMAMUX1_IRQHandler>

08038790 <DMAMUX1_IRQHandler_S>:
   def_irq_handler             DMAMUX1_IRQHandler_S
 8038790:	f7ff bffe 	b.w	8038790 <DMAMUX1_IRQHandler_S>

08038794 <DMA1_Channel1_IRQHandler>:
   def_irq_handler             DMA1_Channel1_IRQHandler
 8038794:	f7ff bffe 	b.w	8038794 <DMA1_Channel1_IRQHandler>

08038798 <DMA1_Channel2_IRQHandler>:
   def_irq_handler             DMA1_Channel2_IRQHandler
 8038798:	f7ff bffe 	b.w	8038798 <DMA1_Channel2_IRQHandler>

0803879c <DMA1_Channel3_IRQHandler>:
   def_irq_handler             DMA1_Channel3_IRQHandler
 803879c:	f7ff bffe 	b.w	803879c <DMA1_Channel3_IRQHandler>

080387a0 <DMA1_Channel4_IRQHandler>:
   def_irq_handler             DMA1_Channel4_IRQHandler
 80387a0:	f7ff bffe 	b.w	80387a0 <DMA1_Channel4_IRQHandler>

080387a4 <DMA1_Channel5_IRQHandler>:
   def_irq_handler             DMA1_Channel5_IRQHandler
 80387a4:	f7ff bffe 	b.w	80387a4 <DMA1_Channel5_IRQHandler>

080387a8 <DMA1_Channel6_IRQHandler>:
   def_irq_handler             DMA1_Channel6_IRQHandler
 80387a8:	f7ff bffe 	b.w	80387a8 <DMA1_Channel6_IRQHandler>

080387ac <DMA1_Channel7_IRQHandler>:
   def_irq_handler             DMA1_Channel7_IRQHandler
 80387ac:	f7ff bffe 	b.w	80387ac <DMA1_Channel7_IRQHandler>

080387b0 <DMA1_Channel8_IRQHandler>:
   def_irq_handler             DMA1_Channel8_IRQHandler
 80387b0:	f7ff bffe 	b.w	80387b0 <DMA1_Channel8_IRQHandler>

080387b4 <ADC1_2_IRQHandler>:
   def_irq_handler             ADC1_2_IRQHandler
 80387b4:	f7ff bffe 	b.w	80387b4 <ADC1_2_IRQHandler>

080387b8 <DAC_IRQHandler>:
   def_irq_handler             DAC_IRQHandler
 80387b8:	f7ff bffe 	b.w	80387b8 <DAC_IRQHandler>

080387bc <FDCAN1_IT0_IRQHandler>:
   def_irq_handler             FDCAN1_IT0_IRQHandler
 80387bc:	f7ff bffe 	b.w	80387bc <FDCAN1_IT0_IRQHandler>

080387c0 <FDCAN1_IT1_IRQHandler>:
   def_irq_handler             FDCAN1_IT1_IRQHandler
 80387c0:	f7ff bffe 	b.w	80387c0 <FDCAN1_IT1_IRQHandler>

080387c4 <TIM1_BRK_IRQHandler>:
   def_irq_handler             TIM1_BRK_IRQHandler
 80387c4:	f7ff bffe 	b.w	80387c4 <TIM1_BRK_IRQHandler>

080387c8 <TIM1_UP_IRQHandler>:
   def_irq_handler             TIM1_UP_IRQHandler
 80387c8:	f7ff bffe 	b.w	80387c8 <TIM1_UP_IRQHandler>

080387cc <TIM1_TRG_COM_IRQHandler>:
   def_irq_handler             TIM1_TRG_COM_IRQHandler
 80387cc:	f7ff bffe 	b.w	80387cc <TIM1_TRG_COM_IRQHandler>

080387d0 <TIM1_CC_IRQHandler>:
   def_irq_handler             TIM1_CC_IRQHandler
 80387d0:	f7ff bffe 	b.w	80387d0 <TIM1_CC_IRQHandler>

080387d4 <TIM2_IRQHandler>:
   def_irq_handler             TIM2_IRQHandler
 80387d4:	f7ff bffe 	b.w	80387d4 <TIM2_IRQHandler>

080387d8 <TIM3_IRQHandler>:
   def_irq_handler             TIM3_IRQHandler
 80387d8:	f7ff bffe 	b.w	80387d8 <TIM3_IRQHandler>

080387dc <TIM4_IRQHandler>:
   def_irq_handler             TIM4_IRQHandler
 80387dc:	f7ff bffe 	b.w	80387dc <TIM4_IRQHandler>

080387e0 <TIM5_IRQHandler>:
   def_irq_handler             TIM5_IRQHandler
 80387e0:	f7ff bffe 	b.w	80387e0 <TIM5_IRQHandler>

080387e4 <TIM6_IRQHandler>:
   def_irq_handler             TIM6_IRQHandler
 80387e4:	f7ff bffe 	b.w	80387e4 <TIM6_IRQHandler>

080387e8 <TIM7_IRQHandler>:
   def_irq_handler             TIM7_IRQHandler
 80387e8:	f7ff bffe 	b.w	80387e8 <TIM7_IRQHandler>

080387ec <TIM8_BRK_IRQHandler>:
   def_irq_handler             TIM8_BRK_IRQHandler
 80387ec:	f7ff bffe 	b.w	80387ec <TIM8_BRK_IRQHandler>

080387f0 <TIM8_UP_IRQHandler>:
   def_irq_handler             TIM8_UP_IRQHandler
 80387f0:	f7ff bffe 	b.w	80387f0 <TIM8_UP_IRQHandler>

080387f4 <TIM8_TRG_COM_IRQHandler>:
   def_irq_handler             TIM8_TRG_COM_IRQHandler
 80387f4:	f7ff bffe 	b.w	80387f4 <TIM8_TRG_COM_IRQHandler>

080387f8 <TIM8_CC_IRQHandler>:
   def_irq_handler             TIM8_CC_IRQHandler
 80387f8:	f7ff bffe 	b.w	80387f8 <TIM8_CC_IRQHandler>

080387fc <I2C1_EV_IRQHandler>:
   def_irq_handler             I2C1_EV_IRQHandler
 80387fc:	f7ff bffe 	b.w	80387fc <I2C1_EV_IRQHandler>

08038800 <I2C1_ER_IRQHandler>:
   def_irq_handler             I2C1_ER_IRQHandler
 8038800:	f7ff bffe 	b.w	8038800 <I2C1_ER_IRQHandler>

08038804 <I2C2_EV_IRQHandler>:
   def_irq_handler             I2C2_EV_IRQHandler
 8038804:	f7ff bffe 	b.w	8038804 <I2C2_EV_IRQHandler>

08038808 <I2C2_ER_IRQHandler>:
   def_irq_handler             I2C2_ER_IRQHandler
 8038808:	f7ff bffe 	b.w	8038808 <I2C2_ER_IRQHandler>

0803880c <SPI1_IRQHandler>:
   def_irq_handler             SPI1_IRQHandler
 803880c:	f7ff bffe 	b.w	803880c <SPI1_IRQHandler>

08038810 <SPI2_IRQHandler>:
   def_irq_handler             SPI2_IRQHandler
 8038810:	f7ff bffe 	b.w	8038810 <SPI2_IRQHandler>

08038814 <USART1_IRQHandler>:
   def_irq_handler             USART1_IRQHandler
 8038814:	f7ff bffe 	b.w	8038814 <USART1_IRQHandler>

08038818 <USART2_IRQHandler>:
   def_irq_handler             USART2_IRQHandler
 8038818:	f7ff bffe 	b.w	8038818 <USART2_IRQHandler>

0803881c <USART3_IRQHandler>:
   def_irq_handler             USART3_IRQHandler
 803881c:	f7ff bffe 	b.w	803881c <USART3_IRQHandler>

08038820 <UART4_IRQHandler>:
   def_irq_handler             UART4_IRQHandler
 8038820:	f7ff bffe 	b.w	8038820 <UART4_IRQHandler>

08038824 <UART5_IRQHandler>:
   def_irq_handler             UART5_IRQHandler
 8038824:	f7ff bffe 	b.w	8038824 <UART5_IRQHandler>

08038828 <LPUART1_IRQHandler>:
   def_irq_handler             LPUART1_IRQHandler
 8038828:	f7ff bffe 	b.w	8038828 <LPUART1_IRQHandler>

0803882c <LPTIM1_IRQHandler>:
   def_irq_handler             LPTIM1_IRQHandler
 803882c:	f7ff bffe 	b.w	803882c <LPTIM1_IRQHandler>

08038830 <LPTIM2_IRQHandler>:
   def_irq_handler             LPTIM2_IRQHandler
 8038830:	f7ff bffe 	b.w	8038830 <LPTIM2_IRQHandler>

08038834 <TIM15_IRQHandler>:
   def_irq_handler             TIM15_IRQHandler
 8038834:	f7ff bffe 	b.w	8038834 <TIM15_IRQHandler>

08038838 <TIM16_IRQHandler>:
   def_irq_handler             TIM16_IRQHandler
 8038838:	f7ff bffe 	b.w	8038838 <TIM16_IRQHandler>

0803883c <TIM17_IRQHandler>:
   def_irq_handler             TIM17_IRQHandler
 803883c:	f7ff bffe 	b.w	803883c <TIM17_IRQHandler>

08038840 <COMP_IRQHandler>:
   def_irq_handler             COMP_IRQHandler
 8038840:	f7ff bffe 	b.w	8038840 <COMP_IRQHandler>

08038844 <USB_FS_IRQHandler>:
   def_irq_handler             USB_FS_IRQHandler
 8038844:	f7ff bffe 	b.w	8038844 <USB_FS_IRQHandler>

08038848 <CRS_IRQHandler>:
   def_irq_handler             CRS_IRQHandler
 8038848:	f7ff bffe 	b.w	8038848 <CRS_IRQHandler>

0803884c <FMC_IRQHandler>:
   def_irq_handler             FMC_IRQHandler
 803884c:	f7ff bffe 	b.w	803884c <FMC_IRQHandler>

08038850 <OCTOSPI1_IRQHandler>:
   def_irq_handler             OCTOSPI1_IRQHandler
 8038850:	f7ff bffe 	b.w	8038850 <OCTOSPI1_IRQHandler>

08038854 <SDMMC1_IRQHandler>:
   def_irq_handler             SDMMC1_IRQHandler
 8038854:	f7ff bffe 	b.w	8038854 <SDMMC1_IRQHandler>

08038858 <DMA2_Channel1_IRQHandler>:
   def_irq_handler             DMA2_Channel1_IRQHandler
 8038858:	f7ff bffe 	b.w	8038858 <DMA2_Channel1_IRQHandler>

0803885c <DMA2_Channel2_IRQHandler>:
   def_irq_handler             DMA2_Channel2_IRQHandler
 803885c:	f7ff bffe 	b.w	803885c <DMA2_Channel2_IRQHandler>

08038860 <DMA2_Channel3_IRQHandler>:
   def_irq_handler             DMA2_Channel3_IRQHandler
 8038860:	f7ff bffe 	b.w	8038860 <DMA2_Channel3_IRQHandler>

08038864 <DMA2_Channel4_IRQHandler>:
   def_irq_handler             DMA2_Channel4_IRQHandler
 8038864:	f7ff bffe 	b.w	8038864 <DMA2_Channel4_IRQHandler>

08038868 <DMA2_Channel5_IRQHandler>:
   def_irq_handler             DMA2_Channel5_IRQHandler
 8038868:	f7ff bffe 	b.w	8038868 <DMA2_Channel5_IRQHandler>

0803886c <DMA2_Channel6_IRQHandler>:
   def_irq_handler             DMA2_Channel6_IRQHandler
 803886c:	f7ff bffe 	b.w	803886c <DMA2_Channel6_IRQHandler>

08038870 <DMA2_Channel7_IRQHandler>:
   def_irq_handler             DMA2_Channel7_IRQHandler
 8038870:	f7ff bffe 	b.w	8038870 <DMA2_Channel7_IRQHandler>

08038874 <DMA2_Channel8_IRQHandler>:
   def_irq_handler             DMA2_Channel8_IRQHandler
 8038874:	f7ff bffe 	b.w	8038874 <DMA2_Channel8_IRQHandler>

08038878 <I2C3_EV_IRQHandler>:
   def_irq_handler             I2C3_EV_IRQHandler
 8038878:	f7ff bffe 	b.w	8038878 <I2C3_EV_IRQHandler>

0803887c <I2C3_ER_IRQHandler>:
   def_irq_handler             I2C3_ER_IRQHandler
 803887c:	f7ff bffe 	b.w	803887c <I2C3_ER_IRQHandler>

08038880 <SAI1_IRQHandler>:
   def_irq_handler             SAI1_IRQHandler
 8038880:	f7ff bffe 	b.w	8038880 <SAI1_IRQHandler>

08038884 <SAI2_IRQHandler>:
   def_irq_handler             SAI2_IRQHandler
 8038884:	f7ff bffe 	b.w	8038884 <SAI2_IRQHandler>

08038888 <TSC_IRQHandler>:
   def_irq_handler             TSC_IRQHandler
 8038888:	f7ff bffe 	b.w	8038888 <TSC_IRQHandler>

0803888c <RNG_IRQHandler>:
   def_irq_handler             RNG_IRQHandler
 803888c:	f7ff bffe 	b.w	803888c <RNG_IRQHandler>

08038890 <FPU_IRQHandler>:
   def_irq_handler             FPU_IRQHandler
 8038890:	f7ff bffe 	b.w	8038890 <FPU_IRQHandler>

08038894 <LPTIM3_IRQHandler>:
   def_irq_handler             LPTIM3_IRQHandler
 8038894:	f7ff bffe 	b.w	8038894 <LPTIM3_IRQHandler>

08038898 <SPI3_IRQHandler>:
   def_irq_handler             SPI3_IRQHandler
 8038898:	f7ff bffe 	b.w	8038898 <SPI3_IRQHandler>

0803889c <I2C4_ER_IRQHandler>:
   def_irq_handler             I2C4_ER_IRQHandler
 803889c:	f7ff bffe 	b.w	803889c <I2C4_ER_IRQHandler>

080388a0 <I2C4_EV_IRQHandler>:
   def_irq_handler             I2C4_EV_IRQHandler
 80388a0:	f7ff bffe 	b.w	80388a0 <I2C4_EV_IRQHandler>

080388a4 <DFSDM1_FLT0_IRQHandler>:
   def_irq_handler             DFSDM1_FLT0_IRQHandler
 80388a4:	f7ff bffe 	b.w	80388a4 <DFSDM1_FLT0_IRQHandler>

080388a8 <DFSDM1_FLT1_IRQHandler>:
   def_irq_handler             DFSDM1_FLT1_IRQHandler
 80388a8:	f7ff bffe 	b.w	80388a8 <DFSDM1_FLT1_IRQHandler>

080388ac <DFSDM1_FLT2_IRQHandler>:
   def_irq_handler             DFSDM1_FLT2_IRQHandler
 80388ac:	f7ff bffe 	b.w	80388ac <DFSDM1_FLT2_IRQHandler>

080388b0 <DFSDM1_FLT3_IRQHandler>:
   def_irq_handler             DFSDM1_FLT3_IRQHandler
 80388b0:	f7ff bffe 	b.w	80388b0 <DFSDM1_FLT3_IRQHandler>

080388b4 <UCPD1_IRQHandler>:
   def_irq_handler             UCPD1_IRQHandler
 80388b4:	f7ff bffe 	b.w	80388b4 <UCPD1_IRQHandler>

080388b8 <ICACHE_IRQHandler>:
   def_irq_handler             ICACHE_IRQHandler
 80388b8:	f7ff bffe 	b.w	80388b8 <ICACHE_IRQHandler>

080388bc <OTFDEC1_IRQHandler>:
   def_irq_handler             OTFDEC1_IRQHandler
 80388bc:	f7ff bffe 	b.w	80388bc <OTFDEC1_IRQHandler>

080388c0 <COM_Init>:
  * @brief  Initialize COM module.
  * @param  None.
  * @retval HAL Status.
  */
HAL_StatusTypeDef  COM_Init(void)
{
 80388c0:	b508      	push	{r3, lr}
#if defined(__GNUC__)
  setvbuf(stdout, NULL, _IONBF, 0);
 80388c2:	4b10      	ldr	r3, [pc, #64]	; (8038904 <COM_Init+0x44>)
 80388c4:	2202      	movs	r2, #2
 80388c6:	6818      	ldr	r0, [r3, #0]
 80388c8:	2300      	movs	r3, #0
 80388ca:	6880      	ldr	r0, [r0, #8]
 80388cc:	4619      	mov	r1, r3
 80388ce:	f003 ff87 	bl	803c7e0 <setvbuf>
  - No parity
  - Hardware flow control disabled (RTS and CTS signals)
  - Receive and transmit enabled
  */
  UartHandle.Instance = COM_UART;
  UartHandle.Init.BaudRate = 115200U;
 80388d2:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
  UartHandle.Instance = COM_UART;
 80388d6:	480c      	ldr	r0, [pc, #48]	; (8038908 <COM_Init+0x48>)
  UartHandle.Init.BaudRate = 115200U;
 80388d8:	4a0c      	ldr	r2, [pc, #48]	; (803890c <COM_Init+0x4c>)
 80388da:	e9c0 2300 	strd	r2, r3, [r0]
  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 80388de:	2300      	movs	r3, #0
  UartHandle.Init.StopBits = UART_STOPBITS_1;
 80388e0:	e9c0 3302 	strd	r3, r3, [r0, #8]
  UartHandle.Init.Parity = UART_PARITY_NONE;
 80388e4:	6103      	str	r3, [r0, #16]
  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80388e6:	6183      	str	r3, [r0, #24]
  UartHandle.Init.Mode = UART_MODE_RX | UART_MODE_TX;
 80388e8:	230c      	movs	r3, #12
 80388ea:	6143      	str	r3, [r0, #20]
  UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT;
 80388ec:	2310      	movs	r3, #16
 80388ee:	6283      	str	r3, [r0, #40]	; 0x28
  UartHandle.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;
 80388f0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80388f4:	63c3      	str	r3, [r0, #60]	; 0x3c
  UartHandle.FifoMode = UART_FIFOMODE_ENABLE;
 80388f6:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80388fa:	6643      	str	r3, [r0, #100]	; 0x64
  return HAL_UART_Init(&UartHandle);
}
 80388fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return HAL_UART_Init(&UartHandle);
 8038900:	f002 bdcb 	b.w	803b49a <HAL_UART_Init>
 8038904:	20000128 	.word	0x20000128
 8038908:	200001b0 	.word	0x200001b0
 803890c:	40008000 	.word	0x40008000

08038910 <HAL_UART_MspInit>:
  * @brief  UART MSP Init.
  * @param  huart: UART handler pointer.
  * @retval None.
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 8038910:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if (huart->Instance == COM_UART)
 8038912:	6802      	ldr	r2, [r0, #0]
 8038914:	4b22      	ldr	r3, [pc, #136]	; (80389a0 <HAL_UART_MspInit+0x90>)
{
 8038916:	b08b      	sub	sp, #44	; 0x2c
  if (huart->Instance == COM_UART)
 8038918:	429a      	cmp	r2, r3
 803891a:	d13f      	bne.n	803899c <HAL_UART_MspInit+0x8c>
  {
    /* Peripheral Clock Enable */
    COM_UART_CLK_ENABLE();
 803891c:	4c21      	ldr	r4, [pc, #132]	; (80389a4 <HAL_UART_MspInit+0x94>)
    COM_UART_TX_GPIO_CLK_ENABLE();
    COM_UART_RX_GPIO_CLK_ENABLE();

    /*Configure GPIO pins : COM_UART_TX_Pin  */
    GPIO_InitStruct.Pin = COM_UART_TX_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 803891e:	2702      	movs	r7, #2
    COM_UART_CLK_ENABLE();
 8038920:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8038922:	2600      	movs	r6, #0
    COM_UART_CLK_ENABLE();
 8038924:	f043 0301 	orr.w	r3, r3, #1
 8038928:	65e3      	str	r3, [r4, #92]	; 0x5c
 803892a:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 803892c:	2503      	movs	r5, #3
    COM_UART_CLK_ENABLE();
 803892e:	f003 0301 	and.w	r3, r3, #1
 8038932:	9301      	str	r3, [sp, #4]
 8038934:	9b01      	ldr	r3, [sp, #4]
 8038936:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8038938:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 803893c:	65a3      	str	r3, [r4, #88]	; 0x58
 803893e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8038940:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8038944:	9302      	str	r3, [sp, #8]
 8038946:	9b02      	ldr	r3, [sp, #8]
 8038948:	f001 fe82 	bl	803a650 <HAL_PWREx_EnableVddIO2>
    COM_UART_TX_GPIO_CLK_ENABLE();
 803894c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    GPIO_InitStruct.Alternate = COM_UART_TX_AF;
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 803894e:	a905      	add	r1, sp, #20
    COM_UART_TX_GPIO_CLK_ENABLE();
 8038950:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8038954:	64e3      	str	r3, [r4, #76]	; 0x4c
 8038956:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 8038958:	4813      	ldr	r0, [pc, #76]	; (80389a8 <HAL_UART_MspInit+0x98>)
    COM_UART_TX_GPIO_CLK_ENABLE();
 803895a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 803895e:	9303      	str	r3, [sp, #12]
 8038960:	9b03      	ldr	r3, [sp, #12]
    COM_UART_RX_GPIO_CLK_ENABLE();
 8038962:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8038964:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8038968:	64e3      	str	r3, [r4, #76]	; 0x4c
 803896a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    GPIO_InitStruct.Alternate = COM_UART_TX_AF;
 803896c:	2408      	movs	r4, #8
    COM_UART_RX_GPIO_CLK_ENABLE();
 803896e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8038972:	9304      	str	r3, [sp, #16]
 8038974:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8038976:	2380      	movs	r3, #128	; 0x80
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8038978:	e9cd 6507 	strd	r6, r5, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 803897c:	e9cd 3705 	strd	r3, r7, [sp, #20]
    GPIO_InitStruct.Alternate = COM_UART_TX_AF;
 8038980:	9409      	str	r4, [sp, #36]	; 0x24
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 8038982:	f001 fd97 	bl	803a4b4 <HAL_GPIO_Init>

    /*Configure GPIO pins : COM_UART_RX_Pin  */
    GPIO_InitStruct.Pin = COM_UART_RX_PIN;
 8038986:	f44f 7380 	mov.w	r3, #256	; 0x100
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = COM_UART_RX_AF;
    HAL_GPIO_Init(COM_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 803898a:	a905      	add	r1, sp, #20
 803898c:	4806      	ldr	r0, [pc, #24]	; (80389a8 <HAL_UART_MspInit+0x98>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 803898e:	e9cd 3705 	strd	r3, r7, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8038992:	e9cd 6507 	strd	r6, r5, [sp, #28]
    GPIO_InitStruct.Alternate = COM_UART_RX_AF;
 8038996:	9409      	str	r4, [sp, #36]	; 0x24
    HAL_GPIO_Init(COM_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 8038998:	f001 fd8c 	bl	803a4b4 <HAL_GPIO_Init>

  }

}
 803899c:	b00b      	add	sp, #44	; 0x2c
 803899e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80389a0:	40008000 	.word	0x40008000
 80389a4:	40021000 	.word	0x40021000
 80389a8:	42021800 	.word	0x42021800

080389ac <COM_Transmit>:
  * @param uTimeout: Timeout duration.
  * @retval Status of the Transmit operation.
  */
HAL_StatusTypeDef COM_Transmit(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
{
  return HAL_UART_Transmit(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
 80389ac:	4613      	mov	r3, r2
 80389ae:	460a      	mov	r2, r1
 80389b0:	4601      	mov	r1, r0
 80389b2:	4801      	ldr	r0, [pc, #4]	; (80389b8 <COM_Transmit+0xc>)
 80389b4:	f002 bc6c 	b.w	803b290 <HAL_UART_Transmit>
 80389b8:	200001b0 	.word	0x200001b0

080389bc <COM_Receive>:
  * @param uTimeout: Timeout duration.
  * @retval Status of the Receive operation.
  */
HAL_StatusTypeDef COM_Receive(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
{
  return HAL_UART_Receive(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
 80389bc:	4613      	mov	r3, r2
 80389be:	460a      	mov	r2, r1
 80389c0:	4601      	mov	r1, r0
 80389c2:	4801      	ldr	r0, [pc, #4]	; (80389c8 <COM_Receive+0xc>)
 80389c4:	f002 bcc0 	b.w	803b348 <HAL_UART_Receive>
 80389c8:	200001b0 	.word	0x200001b0

080389cc <COM_Flush>:
  * @retval HAL_Status.
  */
HAL_StatusTypeDef COM_Flush(void)
{
  /* Clean the input path */
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 80389cc:	4b05      	ldr	r3, [pc, #20]	; (80389e4 <COM_Flush+0x18>)
  return HAL_OK;
}
 80389ce:	2000      	movs	r0, #0
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 80389d0:	681b      	ldr	r3, [r3, #0]
 80389d2:	699a      	ldr	r2, [r3, #24]
 80389d4:	f042 0208 	orr.w	r2, r2, #8
 80389d8:	619a      	str	r2, [r3, #24]
 80389da:	699a      	ldr	r2, [r3, #24]
 80389dc:	f042 0210 	orr.w	r2, r2, #16
 80389e0:	619a      	str	r2, [r3, #24]
}
 80389e2:	4770      	bx	lr
 80389e4:	200001b0 	.word	0x200001b0

080389e8 <Str2Int>:
  * @param  pIntNum: The integer value
  * @retval 1: Correct
  *         0: Error
  */
uint32_t Str2Int(uint8_t *pInputStr, uint32_t *pIntNum)
{
 80389e8:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t i = 0U, res = 0U;
  uint32_t val = 0U;

  if ((pInputStr[0U] == '0') && ((pInputStr[1U] == 'x') || (pInputStr[1U] == 'X')))
 80389ea:	7803      	ldrb	r3, [r0, #0]
 80389ec:	2b30      	cmp	r3, #48	; 0x30
 80389ee:	d127      	bne.n	8038a40 <Str2Int+0x58>
 80389f0:	7843      	ldrb	r3, [r0, #1]
 80389f2:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80389f6:	2b58      	cmp	r3, #88	; 0x58
 80389f8:	d122      	bne.n	8038a40 <Str2Int+0x58>
 80389fa:	2400      	movs	r4, #0
 80389fc:	2502      	movs	r5, #2
  {
    i = 2U;
    while ((i < 11U) && (pInputStr[i] != '\0'))
 80389fe:	5d43      	ldrb	r3, [r0, r5]
 8038a00:	b193      	cbz	r3, 8038a28 <Str2Int+0x40>
    {
      if (ISVALIDHEX(pInputStr[i]))
 8038a02:	f023 0620 	bic.w	r6, r3, #32
 8038a06:	3e41      	subs	r6, #65	; 0x41
 8038a08:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8038a0c:	2e05      	cmp	r6, #5
 8038a0e:	b2d7      	uxtb	r7, r2
 8038a10:	d901      	bls.n	8038a16 <Str2Int+0x2e>
 8038a12:	2f09      	cmp	r7, #9
 8038a14:	d808      	bhi.n	8038a28 <Str2Int+0x40>
      {
        val = (val << 4U) + CONVERTHEX(pInputStr[i]);
 8038a16:	2f09      	cmp	r7, #9
 8038a18:	ea4f 1404 	mov.w	r4, r4, lsl #4
 8038a1c:	d809      	bhi.n	8038a32 <Str2Int+0x4a>
 8038a1e:	4613      	mov	r3, r2
      {
        /* Return 0, Invalid input */
        res = 0U;
        break;
      }
      i++;
 8038a20:	3501      	adds	r5, #1
    while ((i < 11U) && (pInputStr[i] != '\0'))
 8038a22:	2d0b      	cmp	r5, #11
        val = (val << 4U) + CONVERTHEX(pInputStr[i]);
 8038a24:	441c      	add	r4, r3
    while ((i < 11U) && (pInputStr[i] != '\0'))
 8038a26:	d1ea      	bne.n	80389fe <Str2Int+0x16>
    }

    /* valid result */
    if (pInputStr[i] == '\0')
 8038a28:	5d43      	ldrb	r3, [r0, r5]
 8038a2a:	bb4b      	cbnz	r3, 8038a80 <Str2Int+0x98>
    {
      *pIntNum = val;
 8038a2c:	600c      	str	r4, [r1, #0]
      res = 1U;
 8038a2e:	2001      	movs	r0, #1
 8038a30:	e027      	b.n	8038a82 <Str2Int+0x9a>
        val = (val << 4U) + CONVERTHEX(pInputStr[i]);
 8038a32:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8038a36:	2a05      	cmp	r2, #5
 8038a38:	bf94      	ite	ls
 8038a3a:	3b37      	subls	r3, #55	; 0x37
 8038a3c:	3b57      	subhi	r3, #87	; 0x57
 8038a3e:	e7ef      	b.n	8038a20 <Str2Int+0x38>
 8038a40:	2300      	movs	r3, #0
        *pIntNum = val;
        res = 1U;
      }
      else if (ISVALIDDEC(pInputStr[i]))
      {
        val = val * 10U + CONVERTDEC(pInputStr[i]);
 8038a42:	270a      	movs	r7, #10
 8038a44:	1e44      	subs	r4, r0, #1
 8038a46:	f100 060a 	add.w	r6, r0, #10
      if (pInputStr[i] == '\0')
 8038a4a:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 8038a4e:	b90a      	cbnz	r2, 8038a54 <Str2Int+0x6c>
        *pIntNum = val;
 8038a50:	600b      	str	r3, [r1, #0]
        res = 1U;
 8038a52:	e7ec      	b.n	8038a2e <Str2Int+0x46>
      else if (((pInputStr[i] == 'k') || (pInputStr[i] == 'K')) && (i > 0U))
 8038a54:	f002 05df 	and.w	r5, r2, #223	; 0xdf
 8038a58:	2d4b      	cmp	r5, #75	; 0x4b
 8038a5a:	d103      	bne.n	8038a64 <Str2Int+0x7c>
 8038a5c:	4284      	cmp	r4, r0
 8038a5e:	d007      	beq.n	8038a70 <Str2Int+0x88>
        val = val << 10U;
 8038a60:	029b      	lsls	r3, r3, #10
 8038a62:	e7f5      	b.n	8038a50 <Str2Int+0x68>
      else if (((pInputStr[i] == 'm') || (pInputStr[i] == 'M')) && (i > 0U))
 8038a64:	2d4d      	cmp	r5, #77	; 0x4d
 8038a66:	d103      	bne.n	8038a70 <Str2Int+0x88>
 8038a68:	4284      	cmp	r4, r0
 8038a6a:	d009      	beq.n	8038a80 <Str2Int+0x98>
        val = val << 20U;
 8038a6c:	051b      	lsls	r3, r3, #20
 8038a6e:	e7ef      	b.n	8038a50 <Str2Int+0x68>
      else if (ISVALIDDEC(pInputStr[i]))
 8038a70:	3a30      	subs	r2, #48	; 0x30
 8038a72:	b2d5      	uxtb	r5, r2
 8038a74:	2d09      	cmp	r5, #9
 8038a76:	d803      	bhi.n	8038a80 <Str2Int+0x98>
    while ((i < 11U) && (res != 1U))
 8038a78:	42b4      	cmp	r4, r6
        val = val * 10U + CONVERTDEC(pInputStr[i]);
 8038a7a:	fb07 2303 	mla	r3, r7, r3, r2
    while ((i < 11U) && (res != 1U))
 8038a7e:	d1e4      	bne.n	8038a4a <Str2Int+0x62>
      res = 1U;
 8038a80:	2000      	movs	r0, #0
      i++;
    }
  }

  return res;
}
 8038a82:	bdf0      	pop	{r4, r5, r6, r7, pc}

08038a84 <Serial_PutByte>:
  * @brief  Transmit a byte to the HyperTerminal
  * @param  param The byte to be sent
  * @retval HAL_StatusTypeDef HAL_OK if OK
  */
HAL_StatusTypeDef Serial_PutByte(uint8_t uParam)
{
 8038a84:	b507      	push	{r0, r1, r2, lr}
 8038a86:	ab02      	add	r3, sp, #8
 8038a88:	f803 0d01 	strb.w	r0, [r3, #-1]!
  return COM_Transmit(&uParam, 1U, TX_TIMEOUT);
 8038a8c:	2264      	movs	r2, #100	; 0x64
 8038a8e:	2101      	movs	r1, #1
 8038a90:	4618      	mov	r0, r3
 8038a92:	f7ff ff8b 	bl	80389ac <COM_Transmit>
}
 8038a96:	b003      	add	sp, #12
 8038a98:	f85d fb04 	ldr.w	pc, [sp], #4

08038a9c <GetPage>:
  */
static uint32_t GetPage(uint32_t uAddr)
{
  uint32_t page = 0U;

  if (uAddr < (FLASH_BASE + (FLASH_BANK_SIZE)))
 8038a9c:	4b0a      	ldr	r3, [pc, #40]	; (8038ac8 <GetPage+0x2c>)
 8038a9e:	8819      	ldrh	r1, [r3, #0]
 8038aa0:	f64f 73fd 	movw	r3, #65533	; 0xfffd
 8038aa4:	1e4a      	subs	r2, r1, #1
 8038aa6:	b292      	uxth	r2, r2
 8038aa8:	429a      	cmp	r2, r3
 8038aaa:	bf97      	itett	ls
 8038aac:	4b07      	ldrls	r3, [pc, #28]	; (8038acc <GetPage+0x30>)
 8038aae:	4b08      	ldrhi	r3, [pc, #32]	; (8038ad0 <GetPage+0x34>)
 8038ab0:	ea03 2341 	andls.w	r3, r3, r1, lsl #9
 8038ab4:	f103 6300 	addls.w	r3, r3, #134217728	; 0x8000000
 8038ab8:	4283      	cmp	r3, r0
  {
    /* Bank 1 */
    page = (uAddr - FLASH_BASE) / FLASH_PAGE_SIZE;
 8038aba:	bf8c      	ite	hi
 8038abc:	f100 4078 	addhi.w	r0, r0, #4160749568	; 0xf8000000
  }
  else
  {
    /* Bank 2 */
    page = (uAddr - (FLASH_BASE + (FLASH_BANK_SIZE))) / FLASH_PAGE_SIZE;
 8038ac0:	1ac0      	subls	r0, r0, r3
 8038ac2:	0ac0      	lsrs	r0, r0, #11
  }

  return page;
}
 8038ac4:	4770      	bx	lr
 8038ac6:	bf00      	nop
 8038ac8:	0bfa05e0 	.word	0x0bfa05e0
 8038acc:	001ffe00 	.word	0x001ffe00
 8038ad0:	08040000 	.word	0x08040000

08038ad4 <GetBank>:
/*
  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0U)
  {
*/
    /* No Bank swap */
    if (uAddr < (FLASH_BASE + (FLASH_BANK_SIZE)))
 8038ad4:	4b09      	ldr	r3, [pc, #36]	; (8038afc <GetBank+0x28>)
 8038ad6:	8819      	ldrh	r1, [r3, #0]
 8038ad8:	f64f 73fd 	movw	r3, #65533	; 0xfffd
 8038adc:	1e4a      	subs	r2, r1, #1
 8038ade:	b292      	uxth	r2, r2
 8038ae0:	429a      	cmp	r2, r3
 8038ae2:	bf97      	itett	ls
 8038ae4:	4b06      	ldrls	r3, [pc, #24]	; (8038b00 <GetBank+0x2c>)
 8038ae6:	4b07      	ldrhi	r3, [pc, #28]	; (8038b04 <GetBank+0x30>)
 8038ae8:	ea03 2341 	andls.w	r3, r3, r1, lsl #9
 8038aec:	f103 6300 	addls.w	r3, r3, #134217728	; 0x8000000
      bank = FLASH_BANK_1;
    }
  }
#endif
  return bank;
}
 8038af0:	4283      	cmp	r3, r0
 8038af2:	bf8c      	ite	hi
 8038af4:	2001      	movhi	r0, #1
 8038af6:	2002      	movls	r0, #2
 8038af8:	4770      	bx	lr
 8038afa:	bf00      	nop
 8038afc:	0bfa05e0 	.word	0x0bfa05e0
 8038b00:	001ffe00 	.word	0x001ffe00
 8038b04:	08040000 	.word	0x08040000

08038b08 <FLASH_If_Init>:
#ifdef USE_SVC
static HAL_StatusTypeDef FLASH_If_Init_svc(void)
#else
static HAL_StatusTypeDef FLASH_If_Init(void)
#endif
{
 8038b08:	b508      	push	{r3, lr}
  HAL_StatusTypeDef ret = HAL_ERROR;

  /* Unlock the Program memory */
  if (HAL_FLASH_Unlock() == HAL_OK)
 8038b0a:	f001 fbb7 	bl	803a27c <HAL_FLASH_Unlock>
 8038b0e:	b978      	cbnz	r0, 8038b30 <FLASH_If_Init+0x28>
  {
    /* Clear all FLASH flags */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 8038b10:	4b08      	ldr	r3, [pc, #32]	; (8038b34 <FLASH_If_Init+0x2c>)
 8038b12:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8038b14:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 8038b18:	631a      	str	r2, [r3, #48]	; 0x30
 8038b1a:	f242 02fa 	movw	r2, #8442	; 0x20fa
 8038b1e:	621a      	str	r2, [r3, #32]
    /* Unlock the Program memory */
    if (HAL_FLASH_Lock() == HAL_OK)
 8038b20:	f001 fbbe 	bl	803a2a0 <HAL_FLASH_Lock>
 8038b24:	b118      	cbz	r0, 8038b2e <FLASH_If_Init+0x26>
      ret = HAL_OK;
    }
#ifdef FLASH_IF_DBG
    else
    {
      FLASH_IF_TRACE("[FLASH_IF] Lock failure\r\n");
 8038b26:	4804      	ldr	r0, [pc, #16]	; (8038b38 <FLASH_If_Init+0x30>)
#endif /* FLASH_IF_DBG */
  }
#ifdef FLASH_IF_DBG
  else
  {
    FLASH_IF_TRACE("[FLASH_IF] Unlock failure\r\n");
 8038b28:	f003 fe52 	bl	803c7d0 <puts>
  HAL_StatusTypeDef ret = HAL_ERROR;
 8038b2c:	2001      	movs	r0, #1
  }
#endif /* FLASH_IF_DBG */
  return ret;
}
 8038b2e:	bd08      	pop	{r3, pc}
    FLASH_IF_TRACE("[FLASH_IF] Unlock failure\r\n");
 8038b30:	4802      	ldr	r0, [pc, #8]	; (8038b3c <FLASH_If_Init+0x34>)
 8038b32:	e7f9      	b.n	8038b28 <FLASH_If_Init+0x20>
 8038b34:	40022000 	.word	0x40022000
 8038b38:	0803dabc 	.word	0x0803dabc
 8038b3c:	0803dad5 	.word	0x0803dad5

08038b40 <FLASH_If_Erase_Size>:
static HAL_StatusTypeDef FLASH_If_Erase_Size_svc(void *pStart, uint32_t uLength)
#else
HAL_StatusTypeDef FLASH_If_Erase_Size(void *pStart, uint32_t uLength)
#endif
{
  uint32_t page_error = 0U;
 8038b40:	2300      	movs	r3, #0
{
 8038b42:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8038b46:	b087      	sub	sp, #28
 8038b48:	4604      	mov	r4, r0
 8038b4a:	460f      	mov	r7, r1
  uint32_t page_error = 0U;
 8038b4c:	9301      	str	r3, [sp, #4]

  /* Initialize Flash */
	#ifdef USE_SVC
  e_ret_status = FLASH_If_Init_svc();
  #else
	e_ret_status = FLASH_If_Init();
 8038b4e:	f7ff ffdb 	bl	8038b08 <FLASH_If_Init>
	#endif


  if (e_ret_status == HAL_OK)
 8038b52:	4606      	mov	r6, r0
 8038b54:	2800      	cmp	r0, #0
 8038b56:	d167      	bne.n	8038c28 <FLASH_If_Erase_Size+0xe8>
  {
    /* Unlock the Flash to enable the flash control register access *************/
    if (HAL_FLASH_Unlock() == HAL_OK)
 8038b58:	f001 fb90 	bl	803a27c <HAL_FLASH_Unlock>
 8038b5c:	4606      	mov	r6, r0
 8038b5e:	2800      	cmp	r0, #0
 8038b60:	d161      	bne.n	8038c26 <FLASH_If_Erase_Size+0xe6>
    return  FLASH_BASE + (FLASH_BANK_SIZE);
 8038b62:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 8038c34 <FLASH_If_Erase_Size+0xf4>
    {
      do
      {
        /* Get the 1st page to erase */
        first_page = GetPage(uStart);
 8038b66:	4620      	mov	r0, r4
 8038b68:	f7ff ff98 	bl	8038a9c <GetPage>
 8038b6c:	4605      	mov	r5, r0
        bank_number = GetBank(uStart);
 8038b6e:	4620      	mov	r0, r4
 8038b70:	f7ff ffb0 	bl	8038ad4 <GetBank>
        if (GetBank(uStart + uLength - 1U) == bank_number)
 8038b74:	193a      	adds	r2, r7, r4
 8038b76:	f102 3aff 	add.w	sl, r2, #4294967295
        bank_number = GetBank(uStart);
 8038b7a:	4680      	mov	r8, r0
        if (GetBank(uStart + uLength - 1U) == bank_number)
 8038b7c:	4650      	mov	r0, sl
 8038b7e:	f7ff ffa9 	bl	8038ad4 <GetBank>
 8038b82:	4540      	cmp	r0, r8
 8038b84:	4681      	mov	r9, r0
 8038b86:	d11c      	bne.n	8038bc2 <FLASH_If_Erase_Size+0x82>
        {
          /* Get the number of pages to erase from 1st page */
          nb_pages = GetPage(uStart + uLength - 1U) - first_page + 1U;
 8038b88:	4650      	mov	r0, sl
 8038b8a:	f7ff ff87 	bl	8038a9c <GetPage>

          /* Fill EraseInit structure*/
          x_erase_init.TypeErase = FLASH_TYPEERASE_PAGES;
 8038b8e:	2202      	movs	r2, #2
          x_erase_init.Banks = bank_number;
 8038b90:	e9cd 2902 	strd	r2, r9, [sp, #8]
          nb_pages = GetPage(uStart + uLength - 1U) - first_page + 1U;
 8038b94:	3001      	adds	r0, #1
 8038b96:	1b44      	subs	r4, r0, r5

          /* Erase flash per NB_PAGE_SECTOR_PER_ERASE to avoid watch-dog */
          do
          {
            chunk_nb_pages = (nb_pages >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_pages;
 8038b98:	2c02      	cmp	r4, #2
 8038b9a:	4623      	mov	r3, r4
 8038b9c:	bf28      	it	cs
 8038b9e:	2302      	movcs	r3, #2
            x_erase_init.Page = first_page;
            x_erase_init.NbPages = chunk_nb_pages;
            first_page += chunk_nb_pages;
            nb_pages -= chunk_nb_pages;
            if (HAL_FLASHEx_Erase(&x_erase_init, &page_error) != HAL_OK)
 8038ba0:	a901      	add	r1, sp, #4
 8038ba2:	a802      	add	r0, sp, #8
            x_erase_init.NbPages = chunk_nb_pages;
 8038ba4:	e9cd 5304 	strd	r5, r3, [sp, #16]
            nb_pages -= chunk_nb_pages;
 8038ba8:	1ae4      	subs	r4, r4, r3
            first_page += chunk_nb_pages;
 8038baa:	441d      	add	r5, r3
            if (HAL_FLASHEx_Erase(&x_erase_init, &page_error) != HAL_OK)
 8038bac:	f001 fc34 	bl	803a418 <HAL_FLASHEx_Erase>
 8038bb0:	b110      	cbz	r0, 8038bb8 <FLASH_If_Erase_Size+0x78>
            {
              HAL_FLASH_GetError();
 8038bb2:	f001 fb81 	bl	803a2b8 <HAL_FLASH_GetError>
              e_ret_status = HAL_ERROR;
 8038bb6:	2601      	movs	r6, #1
            /* Refresh Watchdog */
#if 0
            WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
#endif
          }
          while (nb_pages > 0);
 8038bb8:	2c00      	cmp	r4, #0
 8038bba:	d1ed      	bne.n	8038b98 <FLASH_If_Erase_Size+0x58>
        }
      }
      while (erase_command == 0);
      /* Lock the Flash to disable the flash control register access (recommended
      to protect the FLASH memory against possible unwanted operation) *********/
      HAL_FLASH_Lock();
 8038bbc:	f001 fb70 	bl	803a2a0 <HAL_FLASH_Lock>
    {
      e_ret_status = HAL_ERROR;
    }
  }

  return e_ret_status;
 8038bc0:	e032      	b.n	8038c28 <FLASH_If_Erase_Size+0xe8>
    return  FLASH_BASE + (FLASH_BANK_SIZE);
 8038bc2:	f64f 71fd 	movw	r1, #65533	; 0xfffd
 8038bc6:	4b1a      	ldr	r3, [pc, #104]	; (8038c30 <FLASH_If_Erase_Size+0xf0>)
 8038bc8:	881b      	ldrh	r3, [r3, #0]
 8038bca:	1e5a      	subs	r2, r3, #1
 8038bcc:	b292      	uxth	r2, r2
 8038bce:	428a      	cmp	r2, r1
 8038bd0:	bf8e      	itee	hi
 8038bd2:	f8df a064 	ldrhi.w	sl, [pc, #100]	; 8038c38 <FLASH_If_Erase_Size+0xf8>
 8038bd6:	ea0b 2343 	andls.w	r3, fp, r3, lsl #9
 8038bda:	f103 6a00 	addls.w	sl, r3, #134217728	; 0x8000000
          nb_pages = GetPage(startbank2 - 1U) - first_page + 1U;
 8038bde:	f10a 30ff 	add.w	r0, sl, #4294967295
 8038be2:	f7ff ff5b 	bl	8038a9c <GetPage>
          x_erase_init.TypeErase   = FLASH_TYPEERASE_PAGES;
 8038be6:	2102      	movs	r1, #2
          uLength = uLength  - (startbank2 - uStart);
 8038be8:	eba4 040a 	sub.w	r4, r4, sl
 8038bec:	4427      	add	r7, r4
          uStart = startbank2;
 8038bee:	4654      	mov	r4, sl
          x_erase_init.Banks       = bank_number;
 8038bf0:	e9cd 1802 	strd	r1, r8, [sp, #8]
          nb_pages = GetPage(startbank2 - 1U) - first_page + 1U;
 8038bf4:	f1c5 0201 	rsb	r2, r5, #1
 8038bf8:	eb02 0900 	add.w	r9, r2, r0
            chunk_nb_pages = (nb_pages >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_pages;
 8038bfc:	464b      	mov	r3, r9
 8038bfe:	2b02      	cmp	r3, #2
 8038c00:	bf28      	it	cs
 8038c02:	2302      	movcs	r3, #2
            if (HAL_FLASHEx_Erase(&x_erase_init, &page_error) != HAL_OK)
 8038c04:	a901      	add	r1, sp, #4
 8038c06:	a802      	add	r0, sp, #8
            x_erase_init.NbPages = chunk_nb_pages;
 8038c08:	e9cd 5304 	strd	r5, r3, [sp, #16]
            nb_pages -= chunk_nb_pages;
 8038c0c:	eba9 0903 	sub.w	r9, r9, r3
            first_page += chunk_nb_pages;
 8038c10:	441d      	add	r5, r3
            if (HAL_FLASHEx_Erase(&x_erase_init, &page_error) != HAL_OK)
 8038c12:	f001 fc01 	bl	803a418 <HAL_FLASHEx_Erase>
 8038c16:	b110      	cbz	r0, 8038c1e <FLASH_If_Erase_Size+0xde>
              HAL_FLASH_GetError();
 8038c18:	f001 fb4e 	bl	803a2b8 <HAL_FLASH_GetError>
              e_ret_status = HAL_ERROR;
 8038c1c:	2601      	movs	r6, #1
          while (nb_pages > 0);
 8038c1e:	f1b9 0f00 	cmp.w	r9, #0
 8038c22:	d1eb      	bne.n	8038bfc <FLASH_If_Erase_Size+0xbc>
 8038c24:	e79f      	b.n	8038b66 <FLASH_If_Erase_Size+0x26>
      e_ret_status = HAL_ERROR;
 8038c26:	2601      	movs	r6, #1
}
 8038c28:	4630      	mov	r0, r6
 8038c2a:	b007      	add	sp, #28
 8038c2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8038c30:	0bfa05e0 	.word	0x0bfa05e0
 8038c34:	001ffe00 	.word	0x001ffe00
 8038c38:	08040000 	.word	0x08040000

08038c3c <FLASH_If_Write>:
#ifdef USE_SVC
static HAL_StatusTypeDef FLASH_If_Write_svc(void *pDestination, const void *pSource, uint32_t uLength)
#else
HAL_StatusTypeDef FLASH_If_Write(void *pDestination, const void *pSource, uint32_t uLength)
#endif
{
 8038c3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8038c40:	4606      	mov	r6, r0
 8038c42:	460f      	mov	r7, r1
 8038c44:	4690      	mov	r8, r2
  uint32_t pdata = (uint32_t)pSource;
  /* Initialize Flash */
	#ifdef USE_SVC
  e_ret_status = FLASH_If_Init_svc();
  #else
	e_ret_status = FLASH_If_Init();
 8038c46:	f7ff ff5f 	bl	8038b08 <FLASH_If_Init>
	#endif
  if (e_ret_status == HAL_OK)
 8038c4a:	4604      	mov	r4, r0
 8038c4c:	b948      	cbnz	r0, 8038c62 <FLASH_If_Write+0x26>
  {
    /* Unlock the Flash to enable the flash control register access *************/
    if (HAL_FLASH_Unlock() != HAL_OK)
 8038c4e:	f001 fb15 	bl	803a27c <HAL_FLASH_Unlock>
 8038c52:	4604      	mov	r4, r0
 8038c54:	b9e0      	cbnz	r0, 8038c90 <FLASH_If_Write+0x54>
 8038c56:	463d      	mov	r5, r7

    }
    else
    {
      /* DataLength must be a multiple of 64 bit */
      for (i = 0U; i < uLength; i += 8U)
 8038c58:	1beb      	subs	r3, r5, r7
 8038c5a:	4598      	cmp	r8, r3
 8038c5c:	d804      	bhi.n	8038c68 <FLASH_If_Write+0x2c>
          break;
        }
      }
      /* Lock the Flash to disable the flash control register access (recommended
      to protect the FLASH memory against possible unwanted operation) *********/
      HAL_FLASH_Lock();
 8038c5e:	f001 fb1f 	bl	803a2a0 <HAL_FLASH_Lock>
    }
  }
  return e_ret_status;
}
 8038c62:	4620      	mov	r0, r4
 8038c64:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, (uint32_t)pDestination,  *((uint64_t *)(pdata + i))) == HAL_OK)
 8038c68:	e9d5 2300 	ldrd	r2, r3, [r5]
 8038c6c:	4631      	mov	r1, r6
 8038c6e:	2001      	movs	r0, #1
 8038c70:	46a9      	mov	r9, r5
 8038c72:	f001 fb53 	bl	803a31c <HAL_FLASH_Program>
 8038c76:	b948      	cbnz	r0, 8038c8c <FLASH_If_Write+0x50>
          if (*(uint64_t *)pDestination != *(uint64_t *)(pdata + i))
 8038c78:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 8038c7c:	e9d9 2300 	ldrd	r2, r3, [r9]
 8038c80:	4299      	cmp	r1, r3
 8038c82:	bf08      	it	eq
 8038c84:	4290      	cmpeq	r0, r2
 8038c86:	f105 0508 	add.w	r5, r5, #8
 8038c8a:	d0e5      	beq.n	8038c58 <FLASH_If_Write+0x1c>
          e_ret_status = HAL_ERROR;
 8038c8c:	2401      	movs	r4, #1
 8038c8e:	e7e6      	b.n	8038c5e <FLASH_If_Write+0x22>
      return HAL_ERROR;
 8038c90:	2401      	movs	r4, #1
 8038c92:	e7e6      	b.n	8038c62 <FLASH_If_Write+0x26>

08038c94 <FW_UPDATE_PrintWelcome>:
  * @brief  Display the FW_UPDATE Main Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
static void FW_UPDATE_PrintWelcome(void)
{
 8038c94:	b508      	push	{r3, lr}
  printf("\r\n================ New Fw Download =========================\r\n\n");
 8038c96:	4808      	ldr	r0, [pc, #32]	; (8038cb8 <FW_UPDATE_PrintWelcome+0x24>)
 8038c98:	f003 fd9a 	bl	803c7d0 <puts>
  printf("  Download Secure Image --------------------------------- 1\r\n\n");
 8038c9c:	4807      	ldr	r0, [pc, #28]	; (8038cbc <FW_UPDATE_PrintWelcome+0x28>)
 8038c9e:	f003 fd97 	bl	803c7d0 <puts>
  printf("  Download NonSecure Image------------------------------- 2\r\n\n");
 8038ca2:	4807      	ldr	r0, [pc, #28]	; (8038cc0 <FW_UPDATE_PrintWelcome+0x2c>)
 8038ca4:	f003 fd94 	bl	803c7d0 <puts>
  printf("  Reset to trigger Installation-------------------------- 3\r\n\n");
 8038ca8:	4806      	ldr	r0, [pc, #24]	; (8038cc4 <FW_UPDATE_PrintWelcome+0x30>)
 8038caa:	f003 fd91 	bl	803c7d0 <puts>
  printf("  Exit New FW Download Menu ----------------------------- x\r\n\n");
}
 8038cae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("  Exit New FW Download Menu ----------------------------- x\r\n\n");
 8038cb2:	4805      	ldr	r0, [pc, #20]	; (8038cc8 <FW_UPDATE_PrintWelcome+0x34>)
 8038cb4:	f003 bd8c 	b.w	803c7d0 <puts>
 8038cb8:	0803dbb8 	.word	0x0803dbb8
 8038cbc:	0803dbf7 	.word	0x0803dbf7
 8038cc0:	0803dc35 	.word	0x0803dc35
 8038cc4:	0803dc73 	.word	0x0803dc73
 8038cc8:	0803dcb1 	.word	0x0803dcb1

08038ccc <FW_UPDATE_DownloadNewFirmware.constprop.1>:
/**
  * @brief Download a new Firmware from the host.
  * @retval HAL status
  */
static HAL_StatusTypeDef FW_UPDATE_DownloadNewFirmware(SFU_FwImageFlashTypeDef *pFwImageDwlArea)
 8038ccc:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8038cce:	4605      	mov	r5, r0
{
  HAL_StatusTypeDef ret = HAL_ERROR;
  COM_StatusTypeDef e_result;
  uint32_t u_fw_size = pFwImageDwlArea->MaxSizeInBytes ;
 8038cd0:	6803      	ldr	r3, [r0, #0]
 8038cd2:	ac02      	add	r4, sp, #8

  printf("  -- Send Firmware \r\n\n");
 8038cd4:	4816      	ldr	r0, [pc, #88]	; (8038d30 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x64>)
  uint32_t u_fw_size = pFwImageDwlArea->MaxSizeInBytes ;
 8038cd6:	f844 3d04 	str.w	r3, [r4, #-4]!
  printf("  -- Send Firmware \r\n\n");
 8038cda:	f003 fd79 	bl	803c7d0 <puts>
  /* Download binary */
  printf("  -- -- File> Transfer> YMODEM> Send \t\n");
 8038cde:	4815      	ldr	r0, [pc, #84]	; (8038d34 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x68>)
 8038ce0:	f003 fd76 	bl	803c7d0 <puts>

  /*Init of Ymodem*/
  Ymodem_Init();
 8038ce4:	f000 ff72 	bl	8039bcc <Ymodem_Init>

  /*Receive through Ymodem*/
  e_result = Ymodem_Receive(&u_fw_size, pFwImageDwlArea->DownloadAddr);
 8038ce8:	4620      	mov	r0, r4
 8038cea:	6869      	ldr	r1, [r5, #4]
 8038cec:	f000 ff98 	bl	8039c20 <Ymodem_Receive>
 8038cf0:	4604      	mov	r4, r0
  printf("\r\n\n");
 8038cf2:	4811      	ldr	r0, [pc, #68]	; (8038d38 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x6c>)
 8038cf4:	f003 fd6c 	bl	803c7d0 <puts>

  if ((e_result == COM_OK))
 8038cf8:	b94c      	cbnz	r4, 8038d0e <FW_UPDATE_DownloadNewFirmware.constprop.1+0x42>
  {
    printf("  -- -- Programming Completed Successfully!\r\n\n");
 8038cfa:	4810      	ldr	r0, [pc, #64]	; (8038d3c <FW_UPDATE_DownloadNewFirmware.constprop.1+0x70>)
 8038cfc:	f003 fd68 	bl	803c7d0 <puts>
#if defined(__ARMCC_VERSION)
    printf("  -- -- Bytes: %u\r\n\n", u_fw_size);
#else
    printf("  -- -- Bytes: %lu\r\n\n", u_fw_size);
 8038d00:	9901      	ldr	r1, [sp, #4]
 8038d02:	480f      	ldr	r0, [pc, #60]	; (8038d40 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x74>)
 8038d04:	f003 fcf0 	bl	803c6e8 <iprintf>
#endif /*  __ARMCC_VERSION */
    ret = HAL_OK;
 8038d08:	4620      	mov	r0, r4
    HAL_Delay(500U);
    COM_Flush();
  }

  return ret;
}
 8038d0a:	b003      	add	sp, #12
 8038d0c:	bd30      	pop	{r4, r5, pc}
  else if (e_result == COM_ABORT)
 8038d0e:	2c02      	cmp	r4, #2
 8038d10:	d106      	bne.n	8038d20 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x54>
    printf("  -- -- !!Aborted by user!!\r\n\n");
 8038d12:	480c      	ldr	r0, [pc, #48]	; (8038d44 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x78>)
 8038d14:	f003 fd5c 	bl	803c7d0 <puts>
    COM_Flush();
 8038d18:	f7ff fe58 	bl	80389cc <COM_Flush>
    ret = HAL_ERROR;
 8038d1c:	2001      	movs	r0, #1
 8038d1e:	e7f4      	b.n	8038d0a <FW_UPDATE_DownloadNewFirmware.constprop.1+0x3e>
    printf("  -- -- !!Error during file download!!\r\n\n");
 8038d20:	4809      	ldr	r0, [pc, #36]	; (8038d48 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x7c>)
 8038d22:	f003 fd55 	bl	803c7d0 <puts>
    HAL_Delay(500U);
 8038d26:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8038d2a:	f001 f90f 	bl	8039f4c <HAL_Delay>
 8038d2e:	e7f3      	b.n	8038d18 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x4c>
 8038d30:	0803daf0 	.word	0x0803daf0
 8038d34:	0803db06 	.word	0x0803db06
 8038d38:	0803dd2d 	.word	0x0803dd2d
 8038d3c:	0803db2d 	.word	0x0803db2d
 8038d40:	0803db5b 	.word	0x0803db5b
 8038d44:	0803db71 	.word	0x0803db71
 8038d48:	0803db8f 	.word	0x0803db8f

08038d4c <FW_UPDATE_Run>:
  uint8_t key = 0U;
 8038d4c:	2300      	movs	r3, #0
{
 8038d4e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8038d52:	b086      	sub	sp, #24
  uint8_t key = 0U;
 8038d54:	f88d 3007 	strb.w	r3, [sp, #7]
  FW_UPDATE_PrintWelcome();
 8038d58:	f7ff ff9c 	bl	8038c94 <FW_UPDATE_PrintWelcome>
  printf("Download NonSecure Image\r\n");
 8038d5c:	4d2e      	ldr	r5, [pc, #184]	; (8038e18 <FW_UPDATE_Run+0xcc>)
  fw_image_dwl_area.DownloadAddr =  FLASH_AREA_3_OFFSET + FLASH_BASE;
 8038d5e:	4e2f      	ldr	r6, [pc, #188]	; (8038e1c <FW_UPDATE_Run+0xd0>)
    printf("  -- NonSecure Image correctly downloaded \r\n\n");
 8038d60:	4f2f      	ldr	r7, [pc, #188]	; (8038e20 <FW_UPDATE_Run+0xd4>)
    key = 0U;
 8038d62:	f04f 0800 	mov.w	r8, #0
 8038d66:	f88d 8007 	strb.w	r8, [sp, #7]
    COM_Flush();
 8038d6a:	f7ff fe2f 	bl	80389cc <COM_Flush>
    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
 8038d6e:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8038d72:	2101      	movs	r1, #1
 8038d74:	f10d 0007 	add.w	r0, sp, #7
 8038d78:	f7ff fe20 	bl	80389bc <COM_Receive>
 8038d7c:	4604      	mov	r4, r0
 8038d7e:	2800      	cmp	r0, #0
 8038d80:	d1f1      	bne.n	8038d66 <FW_UPDATE_Run+0x1a>
      switch (key)
 8038d82:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8038d86:	2b32      	cmp	r3, #50	; 0x32
 8038d88:	d026      	beq.n	8038dd8 <FW_UPDATE_Run+0x8c>
 8038d8a:	d805      	bhi.n	8038d98 <FW_UPDATE_Run+0x4c>
 8038d8c:	2b31      	cmp	r3, #49	; 0x31
 8038d8e:	d00c      	beq.n	8038daa <FW_UPDATE_Run+0x5e>
          printf("Invalid Number !\r");
 8038d90:	4824      	ldr	r0, [pc, #144]	; (8038e24 <FW_UPDATE_Run+0xd8>)
 8038d92:	f003 fca9 	bl	803c6e8 <iprintf>
          break;
 8038d96:	e01c      	b.n	8038dd2 <FW_UPDATE_Run+0x86>
      switch (key)
 8038d98:	2b33      	cmp	r3, #51	; 0x33
 8038d9a:	d02c      	beq.n	8038df6 <FW_UPDATE_Run+0xaa>
 8038d9c:	2b78      	cmp	r3, #120	; 0x78
 8038d9e:	d1f7      	bne.n	8038d90 <FW_UPDATE_Run+0x44>
      FW_UPDATE_PrintWelcome();
 8038da0:	f7ff ff78 	bl	8038c94 <FW_UPDATE_PrintWelcome>
}
 8038da4:	b006      	add	sp, #24
 8038da6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  printf("Download Secure Image\r\n");
 8038daa:	481f      	ldr	r0, [pc, #124]	; (8038e28 <FW_UPDATE_Run+0xdc>)
 8038dac:	f003 fd10 	bl	803c7d0 <puts>
  fw_image_dwl_area.MaxSizeInBytes = FLASH_S_PARTITION_SIZE;
 8038db0:	f44f 3310 	mov.w	r3, #147456	; 0x24000
 8038db4:	4a1d      	ldr	r2, [pc, #116]	; (8038e2c <FW_UPDATE_Run+0xe0>)
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 8038db6:	a802      	add	r0, sp, #8
  fw_image_dwl_area.MaxSizeInBytes = FLASH_S_PARTITION_SIZE;
 8038db8:	e9cd 3202 	strd	r3, r2, [sp, #8]
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 8038dbc:	9404      	str	r4, [sp, #16]
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 8038dbe:	f7ff ff85 	bl	8038ccc <FW_UPDATE_DownloadNewFirmware.constprop.1>
  if (HAL_OK == ret)
 8038dc2:	b930      	cbnz	r0, 8038dd2 <FW_UPDATE_Run+0x86>
    printf("  -- Secure Image correctly downloaded \r\n\n");
 8038dc4:	481a      	ldr	r0, [pc, #104]	; (8038e30 <FW_UPDATE_Run+0xe4>)
    printf("  -- NonSecure Image correctly downloaded \r\n\n");
 8038dc6:	f003 fd03 	bl	803c7d0 <puts>
    HAL_Delay(1000U);
 8038dca:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8038dce:	f001 f8bd 	bl	8039f4c <HAL_Delay>
      FW_UPDATE_PrintWelcome();
 8038dd2:	f7ff ff5f 	bl	8038c94 <FW_UPDATE_PrintWelcome>
 8038dd6:	e7c4      	b.n	8038d62 <FW_UPDATE_Run+0x16>
  printf("Download NonSecure Image\r\n");
 8038dd8:	4628      	mov	r0, r5
 8038dda:	f003 fcf9 	bl	803c7d0 <puts>
  fw_image_dwl_area.MaxSizeInBytes = FLASH_NS_PARTITION_SIZE;
 8038dde:	f44f 3390 	mov.w	r3, #73728	; 0x12000
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 8038de2:	a802      	add	r0, sp, #8
  fw_image_dwl_area.DownloadAddr =  FLASH_AREA_3_OFFSET + FLASH_BASE;
 8038de4:	9603      	str	r6, [sp, #12]
  fw_image_dwl_area.MaxSizeInBytes = FLASH_NS_PARTITION_SIZE;
 8038de6:	9302      	str	r3, [sp, #8]
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 8038de8:	9404      	str	r4, [sp, #16]
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 8038dea:	f7ff ff6f 	bl	8038ccc <FW_UPDATE_DownloadNewFirmware.constprop.1>
  if (HAL_OK == ret)
 8038dee:	2800      	cmp	r0, #0
 8038df0:	d1ef      	bne.n	8038dd2 <FW_UPDATE_Run+0x86>
    printf("  -- NonSecure Image correctly downloaded \r\n\n");
 8038df2:	4638      	mov	r0, r7
 8038df4:	e7e7      	b.n	8038dc6 <FW_UPDATE_Run+0x7a>
          printf("  -- Install image : reboot\r\n\n");
 8038df6:	480f      	ldr	r0, [pc, #60]	; (8038e34 <FW_UPDATE_Run+0xe8>)
 8038df8:	f003 fcea 	bl	803c7d0 <puts>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8038dfc:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8038e00:	490d      	ldr	r1, [pc, #52]	; (8038e38 <FW_UPDATE_Run+0xec>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8038e02:	4b0e      	ldr	r3, [pc, #56]	; (8038e3c <FW_UPDATE_Run+0xf0>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8038e04:	68ca      	ldr	r2, [r1, #12]
 8038e06:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8038e0a:	4313      	orrs	r3, r2
 8038e0c:	60cb      	str	r3, [r1, #12]
 8038e0e:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8038e12:	bf00      	nop
 8038e14:	e7fd      	b.n	8038e12 <FW_UPDATE_Run+0xc6>
 8038e16:	bf00      	nop
 8038e18:	0803dd30 	.word	0x0803dd30
 8038e1c:	0806e000 	.word	0x0806e000
 8038e20:	0803dd4a 	.word	0x0803dd4a
 8038e24:	0803dd95 	.word	0x0803dd95
 8038e28:	0803dcef 	.word	0x0803dcef
 8038e2c:	0804a000 	.word	0x0804a000
 8038e30:	0803dd06 	.word	0x0803dd06
 8038e34:	0803dd77 	.word	0x0803dd77
 8038e38:	e000ed00 	.word	0xe000ed00
 8038e3c:	05fa0004 	.word	0x05fa0004

08038e40 <Ymodem_HeaderPktRxCpltCallback>:
  * @brief  Ymodem Header Packet Transfer completed callback.
  * @param  uFileSize Dimension of the file that will be received (Bytes).
  * @retval None
  */
HAL_StatusTypeDef Ymodem_HeaderPktRxCpltCallback(uint32_t uFlashDestination, uint32_t uFileSize)
{
 8038e40:	b510      	push	{r4, lr}
  HAL_StatusTypeDef ret = HAL_ERROR;
  /*Reset of the ymodem variables */
  m_uFileSizeYmodem = 0U;
  m_uPacketsReceived = 0U;
 8038e42:	2400      	movs	r4, #0
 8038e44:	4a0b      	ldr	r2, [pc, #44]	; (8038e74 <Ymodem_HeaderPktRxCpltCallback+0x34>)

  /*Filesize information is stored*/
  m_uFileSizeYmodem = uFileSize;

  /* compute the number of 1K blocks */
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (PACKET_1K_SIZE - 1U)) / PACKET_1K_SIZE;
 8038e46:	f201 33ff 	addw	r3, r1, #1023	; 0x3ff
  m_uPacketsReceived = 0U;
 8038e4a:	6014      	str	r4, [r2, #0]
  m_uFileSizeYmodem = uFileSize;
 8038e4c:	4a0a      	ldr	r2, [pc, #40]	; (8038e78 <Ymodem_HeaderPktRxCpltCallback+0x38>)
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (PACKET_1K_SIZE - 1U)) / PACKET_1K_SIZE;
 8038e4e:	0a9b      	lsrs	r3, r3, #10
  m_uFileSizeYmodem = uFileSize;
 8038e50:	6011      	str	r1, [r2, #0]
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (PACKET_1K_SIZE - 1U)) / PACKET_1K_SIZE;
 8038e52:	4a0a      	ldr	r2, [pc, #40]	; (8038e7c <Ymodem_HeaderPktRxCpltCallback+0x3c>)
 8038e54:	6013      	str	r3, [r2, #0]
  if ((uFlashDestination >= 0x8000000) && (uFlashDestination < 0x8080000))
 8038e56:	f100 4378 	add.w	r3, r0, #4160749568	; 0xf8000000
 8038e5a:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8038e5e:	d300      	bcc.n	8038e62 <Ymodem_HeaderPktRxCpltCallback+0x22>
 8038e60:	e7fe      	b.n	8038e60 <Ymodem_HeaderPktRxCpltCallback+0x20>
  {
    ret = FLASH_If_Erase_Size((void *)(uFlashDestination), uFileSize);
 8038e62:	f7ff fe6d 	bl	8038b40 <FLASH_If_Erase_Size>
 8038e66:	4604      	mov	r4, r0
  }
  else while (1);
  /* NOTE : delay inserted for Ymodem protocol*/
  HAL_Delay(1000);
 8038e68:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8038e6c:	f001 f86e 	bl	8039f4c <HAL_Delay>
  return ret;
}
 8038e70:	4620      	mov	r0, r4
 8038e72:	bd10      	pop	{r4, pc}
 8038e74:	20000244 	.word	0x20000244
 8038e78:	2000023c 	.word	0x2000023c
 8038e7c:	20000240 	.word	0x20000240

08038e80 <Ymodem_DataPktRxCpltCallback>:
  * @param  pData Pointer to the buffer.
  * @param  uSize Packet dimension (Bytes).
  * @retval None
  */
HAL_StatusTypeDef Ymodem_DataPktRxCpltCallback(uint8_t *pData, uint32_t uFlashDestination, uint32_t uSize)
{
 8038e80:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef e_ret_status = HAL_ERROR;

  m_uPacketsReceived++;
 8038e82:	4c17      	ldr	r4, [pc, #92]	; (8038ee0 <Ymodem_DataPktRxCpltCallback+0x60>)

  /*Increase the number of received packets*/
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 8038e84:	4e17      	ldr	r6, [pc, #92]	; (8038ee4 <Ymodem_DataPktRxCpltCallback+0x64>)
  m_uPacketsReceived++;
 8038e86:	6823      	ldr	r3, [r4, #0]
{
 8038e88:	4605      	mov	r5, r0
 8038e8a:	4608      	mov	r0, r1
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 8038e8c:	6831      	ldr	r1, [r6, #0]
  m_uPacketsReceived++;
 8038e8e:	3301      	adds	r3, #1
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 8038e90:	428b      	cmp	r3, r1
  m_uPacketsReceived++;
 8038e92:	6023      	str	r3, [r4, #0]
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 8038e94:	d109      	bne.n	8038eaa <Ymodem_DataPktRxCpltCallback+0x2a>
  {
    /*Extracting actual payload from last packet*/
    if (0 == (m_uFileSizeYmodem % PACKET_1K_SIZE))
 8038e96:	4b14      	ldr	r3, [pc, #80]	; (8038ee8 <Ymodem_DataPktRxCpltCallback+0x68>)
 8038e98:	681a      	ldr	r2, [r3, #0]
    {
      /* The last packet is not full, drop the extra bytes */
      uSize = m_uFileSizeYmodem - ((uint32_t)(m_uFileSizeYmodem / PACKET_1K_SIZE) * PACKET_1K_SIZE);
    }

    m_uPacketsReceived = 0U;
 8038e9a:	2300      	movs	r3, #0
    if (0 == (m_uFileSizeYmodem % PACKET_1K_SIZE))
 8038e9c:	f3c2 0209 	ubfx	r2, r2, #0, #10
      uSize = PACKET_1K_SIZE;
 8038ea0:	2a00      	cmp	r2, #0
 8038ea2:	bf08      	it	eq
 8038ea4:	f44f 6280 	moveq.w	r2, #1024	; 0x400
    m_uPacketsReceived = 0U;
 8038ea8:	6023      	str	r3, [r4, #0]
  }
  if ((uFlashDestination >= 0x8000000) && (uFlashDestination < 0x8080000))
 8038eaa:	f100 4378 	add.w	r3, r0, #4160749568	; 0xf8000000
 8038eae:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8038eb2:	d20f      	bcs.n	8038ed4 <Ymodem_DataPktRxCpltCallback+0x54>
  {
    /*Adjust dimension to 64-bit length */
    if (uSize % FLASH_IF_MIN_WRITE_LEN != 0U)
 8038eb4:	0753      	lsls	r3, r2, #29
    {
      uSize += (FLASH_IF_MIN_WRITE_LEN - (uSize % FLASH_IF_MIN_WRITE_LEN));
 8038eb6:	bf1c      	itt	ne
 8038eb8:	f022 0207 	bicne.w	r2, r2, #7
 8038ebc:	3208      	addne	r2, #8
    }

    /* Write Data in Flash - size has to be 64-bit aligned */
    if (FLASH_If_Write((void *)uFlashDestination, pData, uSize) == HAL_OK)
 8038ebe:	4629      	mov	r1, r5
 8038ec0:	f7ff febc 	bl	8038c3c <FLASH_If_Write>
 8038ec4:	b128      	cbz	r0, 8038ed2 <Ymodem_DataPktRxCpltCallback+0x52>
  }
  if (e_ret_status == HAL_ERROR)
  {

    /*Reset of the ymodem variables */
    m_uFileSizeYmodem = 0U;
 8038ec6:	2300      	movs	r3, #0
      e_ret_status = HAL_ERROR;
 8038ec8:	2001      	movs	r0, #1
    m_uFileSizeYmodem = 0U;
 8038eca:	4a07      	ldr	r2, [pc, #28]	; (8038ee8 <Ymodem_DataPktRxCpltCallback+0x68>)
    m_uPacketsReceived = 0U;
 8038ecc:	6023      	str	r3, [r4, #0]
    m_uFileSizeYmodem = 0U;
 8038ece:	6013      	str	r3, [r2, #0]
    m_uNbrBlocksYmodem = 0U;
 8038ed0:	6033      	str	r3, [r6, #0]
  }
  return e_ret_status;
}
 8038ed2:	bd70      	pop	{r4, r5, r6, pc}
    memcpy((void *)uFlashDestination, pData, uSize);
 8038ed4:	4629      	mov	r1, r5
 8038ed6:	f003 fbf4 	bl	803c6c2 <memcpy>
    e_ret_status = HAL_OK;
 8038eda:	2000      	movs	r0, #0
 8038edc:	e7f9      	b.n	8038ed2 <Ymodem_DataPktRxCpltCallback+0x52>
 8038ede:	bf00      	nop
 8038ee0:	20000244 	.word	0x20000244
 8038ee4:	20000240 	.word	0x20000240
 8038ee8:	2000023c 	.word	0x2000023c

08038eec <_write>:
  return ch;
}
#elif defined(__GNUC__)
/* Redirects printf to TFM_DRIVER_STDIO in case of GNUARM */
int _write(int fd, char *str, int len)
{
 8038eec:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8038eee:	460e      	mov	r6, r1
 8038ef0:	4615      	mov	r5, r2
  int i;

  for (i = 0; i < len; i++)
 8038ef2:	460c      	mov	r4, r1
 8038ef4:	1ba3      	subs	r3, r4, r6
 8038ef6:	429d      	cmp	r5, r3
 8038ef8:	dc02      	bgt.n	8038f00 <_write+0x14>
    uart_putc(str[i]);
  }

  /* Return the number of characters written */
  return len;
}
 8038efa:	4628      	mov	r0, r5
 8038efc:	b002      	add	sp, #8
 8038efe:	bd70      	pop	{r4, r5, r6, pc}
    uart_putc(str[i]);
 8038f00:	f814 3b01 	ldrb.w	r3, [r4], #1
  COM_Transmit(&c, 1, 1000U);
 8038f04:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8038f08:	2101      	movs	r1, #1
 8038f0a:	f10d 0007 	add.w	r0, sp, #7
 8038f0e:	f88d 3007 	strb.w	r3, [sp, #7]
 8038f12:	f7ff fd4b 	bl	80389ac <COM_Transmit>
 8038f16:	e7ed      	b.n	8038ef4 <_write+0x8>

08038f18 <FW_APP_PrintMainMenu>:
  * @brief  Display the TEST Main Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
void FW_APP_PrintMainMenu(void)
{
 8038f18:	b508      	push	{r3, lr}
  printf("\r\n=================== Main Menu ============================\r\n\n");
 8038f1a:	480a      	ldr	r0, [pc, #40]	; (8038f44 <FW_APP_PrintMainMenu+0x2c>)
 8038f1c:	f003 fc58 	bl	803c7d0 <puts>
  
  printf("  Do stuff for testing bli bla blub --------------------- 0\r\n\n");
 8038f20:	4809      	ldr	r0, [pc, #36]	; (8038f48 <FW_APP_PrintMainMenu+0x30>)
 8038f22:	f003 fc55 	bl	803c7d0 <puts>

  printf("  Download a new Fw Image ------------------------------- 1\r\n\n");
 8038f26:	4809      	ldr	r0, [pc, #36]	; (8038f4c <FW_APP_PrintMainMenu+0x34>)
 8038f28:	f003 fc52 	bl	803c7d0 <puts>
  printf("  Test Protections -------------------------------------- 2\r\n\n");
 8038f2c:	4808      	ldr	r0, [pc, #32]	; (8038f50 <FW_APP_PrintMainMenu+0x38>)
 8038f2e:	f003 fc4f 	bl	803c7d0 <puts>
  printf("  Test TFM ---------------------------------------------- 3\r\n\n");
 8038f32:	4808      	ldr	r0, [pc, #32]	; (8038f54 <FW_APP_PrintMainMenu+0x3c>)
 8038f34:	f003 fc4c 	bl	803c7d0 <puts>
  printf("  Selection :\r\n\n");
}
 8038f38:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("  Selection :\r\n\n");
 8038f3c:	4806      	ldr	r0, [pc, #24]	; (8038f58 <FW_APP_PrintMainMenu+0x40>)
 8038f3e:	f003 bc47 	b.w	803c7d0 <puts>
 8038f42:	bf00      	nop
 8038f44:	0803ddfd 	.word	0x0803ddfd
 8038f48:	0803de3c 	.word	0x0803de3c
 8038f4c:	0803de7a 	.word	0x0803de7a
 8038f50:	0803deb8 	.word	0x0803deb8
 8038f54:	0803def6 	.word	0x0803def6
 8038f58:	0803df34 	.word	0x0803df34

08038f5c <Custom_Stuff_Run>:

void Custom_Stuff_Run(){
 8038f5c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}

  printf("cool, but you can't return..\r\n\n");
 8038f60:	481a      	ldr	r0, [pc, #104]	; (8038fcc <Custom_Stuff_Run+0x70>)
 8038f62:	f003 fc35 	bl	803c7d0 <puts>

  HAL_Delay(5000);
 8038f66:	f241 3088 	movw	r0, #5000	; 0x1388
 8038f6a:	f000 ffef 	bl	8039f4c <HAL_Delay>
  printf("jk just press x\r\n\n");
 8038f6e:	4818      	ldr	r0, [pc, #96]	; (8038fd0 <Custom_Stuff_Run+0x74>)
 8038f70:	f003 fc2e 	bl	803c7d0 <puts>
      {
        case 'x' :
          exit = 1U;
          break;
        default:
          printf("Invalid Number ! press x to return \r");
 8038f74:	4f17      	ldr	r7, [pc, #92]	; (8038fd4 <Custom_Stuff_Run+0x78>)
          break;
      }
      
  printf("jk just press x\r\n\n");
 8038f76:	4e16      	ldr	r6, [pc, #88]	; (8038fd0 <Custom_Stuff_Run+0x74>)
  HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_5); 
 8038f78:	4d17      	ldr	r5, [pc, #92]	; (8038fd8 <Custom_Stuff_Run+0x7c>)
    key = 0U;
 8038f7a:	f04f 0800 	mov.w	r8, #0
 8038f7e:	f88d 8007 	strb.w	r8, [sp, #7]
    COM_Flush();
 8038f82:	f7ff fd23 	bl	80389cc <COM_Flush>
    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
 8038f86:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8038f8a:	2101      	movs	r1, #1
 8038f8c:	f10d 0007 	add.w	r0, sp, #7
 8038f90:	f7ff fd14 	bl	80389bc <COM_Receive>
 8038f94:	4604      	mov	r4, r0
 8038f96:	2800      	cmp	r0, #0
 8038f98:	d1f1      	bne.n	8038f7e <Custom_Stuff_Run+0x22>
      switch (key)
 8038f9a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8038f9e:	2b78      	cmp	r3, #120	; 0x78
 8038fa0:	d011      	beq.n	8038fc6 <Custom_Stuff_Run+0x6a>
          printf("Invalid Number ! press x to return \r");
 8038fa2:	4638      	mov	r0, r7
 8038fa4:	f003 fba0 	bl	803c6e8 <iprintf>
  printf("jk just press x\r\n\n");
 8038fa8:	4630      	mov	r0, r6
 8038faa:	f003 fc11 	bl	803c7d0 <puts>
  HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_5); 
 8038fae:	4628      	mov	r0, r5
 8038fb0:	2120      	movs	r1, #32
 8038fb2:	f001 fb47 	bl	803a644 <HAL_GPIO_TogglePin>
    HAL_Delay(100); //delay 100ms
 8038fb6:	2064      	movs	r0, #100	; 0x64
 8038fb8:	f000 ffc8 	bl	8039f4c <HAL_Delay>
  while (exit == 0U)
 8038fbc:	2c00      	cmp	r4, #0
 8038fbe:	d0dc      	beq.n	8038f7a <Custom_Stuff_Run+0x1e>
    }

  }
}
 8038fc0:	b002      	add	sp, #8
 8038fc2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          exit = 1U;
 8038fc6:	2401      	movs	r4, #1
 8038fc8:	e7ee      	b.n	8038fa8 <Custom_Stuff_Run+0x4c>
 8038fca:	bf00      	nop
 8038fcc:	0803dda7 	.word	0x0803dda7
 8038fd0:	0803ddc6 	.word	0x0803ddc6
 8038fd4:	0803ddd8 	.word	0x0803ddd8
 8038fd8:	42020c00 	.word	0x42020c00

08038fdc <FW_APP_Run>:
  * @param  None.
  * @retval None.
  */
void FW_APP_Run(void)
{
  uint8_t key = 0U;
 8038fdc:	2300      	movs	r3, #0
{
 8038fde:	b507      	push	{r0, r1, r2, lr}
  uint8_t key = 0U;
 8038fe0:	ac02      	add	r4, sp, #8
 8038fe2:	f804 3d01 	strb.w	r3, [r4, #-1]!

  /*##1- Print Main Menu message*/
  FW_APP_PrintMainMenu();
 8038fe6:	f7ff ff97 	bl	8038f18 <FW_APP_PrintMainMenu>
        break;
      case '3' :
        tfm_app_menu();
        break;
      default:
        printf("Invalid Number !\r");
 8038fea:	4d13      	ldr	r5, [pc, #76]	; (8039038 <FW_APP_Run+0x5c>)
  COM_Flush();
 8038fec:	f7ff fcee 	bl	80389cc <COM_Flush>
  if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
 8038ff0:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8038ff4:	2101      	movs	r1, #1
 8038ff6:	4620      	mov	r0, r4
 8038ff8:	f7ff fce0 	bl	80389bc <COM_Receive>
 8038ffc:	2800      	cmp	r0, #0
 8038ffe:	d1f5      	bne.n	8038fec <FW_APP_Run+0x10>
    switch (key)
 8039000:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8039004:	3b30      	subs	r3, #48	; 0x30
 8039006:	2b03      	cmp	r3, #3
 8039008:	d811      	bhi.n	803902e <FW_APP_Run+0x52>
 803900a:	e8df f003 	tbb	[pc, r3]
 803900e:	0702      	.short	0x0702
 8039010:	0d0a      	.short	0x0d0a
        Custom_Stuff_Run();
 8039012:	f7ff ffa3 	bl	8038f5c <Custom_Stuff_Run>
        break;
    }

    /*Print Main Menu message*/
    FW_APP_PrintMainMenu();
 8039016:	f7ff ff7f 	bl	8038f18 <FW_APP_PrintMainMenu>
 803901a:	e7e7      	b.n	8038fec <FW_APP_Run+0x10>
        FW_UPDATE_Run();
 803901c:	f7ff fe96 	bl	8038d4c <FW_UPDATE_Run>
        break;
 8039020:	e7f9      	b.n	8039016 <FW_APP_Run+0x3a>
        TEST_PROTECTIONS_Run();
 8039022:	f000 f9db 	bl	80393dc <TEST_PROTECTIONS_Run>
        break;
 8039026:	e7f6      	b.n	8039016 <FW_APP_Run+0x3a>
        tfm_app_menu();
 8039028:	f000 fbce 	bl	80397c8 <tfm_app_menu>
        break;
 803902c:	e7f3      	b.n	8039016 <FW_APP_Run+0x3a>
        printf("Invalid Number !\r");
 803902e:	4628      	mov	r0, r5
 8039030:	f003 fb5a 	bl	803c6e8 <iprintf>
        break;
 8039034:	e7ef      	b.n	8039016 <FW_APP_Run+0x3a>
 8039036:	bf00      	nop
 8039038:	0803dd95 	.word	0x0803dd95

0803903c <main>:
{
 803903c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  pUserAppId = (uint8_t *)&UserAppId;
 803903e:	4b17      	ldr	r3, [pc, #92]	; (803909c <main+0x60>)
 8039040:	4c17      	ldr	r4, [pc, #92]	; (80390a0 <main+0x64>)
 8039042:	6023      	str	r3, [r4, #0]
  HAL_Init();
 8039044:	f000 ff5e 	bl	8039f04 <HAL_Init>
 GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; // digital Output
 8039048:	2220      	movs	r2, #32
 803904a:	2301      	movs	r3, #1
 803904c:	e9cd 2301 	strd	r2, r3, [sp, #4]
 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8039050:	2300      	movs	r3, #0
 HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8039052:	a901      	add	r1, sp, #4
 8039054:	4813      	ldr	r0, [pc, #76]	; (80390a4 <main+0x68>)
 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8039056:	9304      	str	r3, [sp, #16]
 HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8039058:	f001 fa2c 	bl	803a4b4 <HAL_GPIO_Init>
  COM_Init();
 803905c:	f7ff fc30 	bl	80388c0 <COM_Init>
  if (TestNumber & TEST_PROTECTION_MASK)
 8039060:	4b11      	ldr	r3, [pc, #68]	; (80390a8 <main+0x6c>)
 8039062:	681a      	ldr	r2, [r3, #0]
 8039064:	4b11      	ldr	r3, [pc, #68]	; (80390ac <main+0x70>)
 8039066:	421a      	tst	r2, r3
 8039068:	d001      	beq.n	803906e <main+0x32>
    TEST_PROTECTIONS_Run_SecUserMem();
 803906a:	f000 f8d9 	bl	8039220 <TEST_PROTECTIONS_Run_SecUserMem>
  printf("\r\n======================================================================");
 803906e:	4810      	ldr	r0, [pc, #64]	; (80390b0 <main+0x74>)
 8039070:	f003 fb3a 	bl	803c6e8 <iprintf>
  printf("\r\n=              (C) COPYRIGHT 2019 STMicroelectronics                 =");
 8039074:	480f      	ldr	r0, [pc, #60]	; (80390b4 <main+0x78>)
 8039076:	f003 fb37 	bl	803c6e8 <iprintf>
  printf("\r\n=                                                                    =");
 803907a:	480f      	ldr	r0, [pc, #60]	; (80390b8 <main+0x7c>)
 803907c:	f003 fb34 	bl	803c6e8 <iprintf>
  printf("\r\n=                          User App #%c                               =", *pUserAppId);
 8039080:	6823      	ldr	r3, [r4, #0]
 8039082:	480e      	ldr	r0, [pc, #56]	; (80390bc <main+0x80>)
 8039084:	7819      	ldrb	r1, [r3, #0]
 8039086:	f003 fb2f 	bl	803c6e8 <iprintf>
  printf("\r\n======================================================================");
 803908a:	4809      	ldr	r0, [pc, #36]	; (80390b0 <main+0x74>)
 803908c:	f003 fb2c 	bl	803c6e8 <iprintf>
  printf("\r\n\r\n");
 8039090:	480b      	ldr	r0, [pc, #44]	; (80390c0 <main+0x84>)
 8039092:	f003 fb9d 	bl	803c7d0 <puts>
  FW_APP_Run();
 8039096:	f7ff ffa1 	bl	8038fdc <FW_APP_Run>
 803909a:	bf00      	nop
 803909c:	0803df44 	.word	0x0803df44
 80390a0:	20000684 	.word	0x20000684
 80390a4:	42020c00 	.word	0x42020c00
 80390a8:	20000000 	.word	0x20000000
 80390ac:	dead0000 	.word	0xdead0000
 80390b0:	0803df45 	.word	0x0803df45
 80390b4:	0803df8e 	.word	0x0803df8e
 80390b8:	0803dfd7 	.word	0x0803dfd7
 80390bc:	0803e020 	.word	0x0803e020
 80390c0:	0803e06a 	.word	0x0803e06a

080390c4 <mpu_armv8m_region_enable>:
  uint32_t ctrl_before;
  uint32_t base_cfg;
  uint32_t limit_cfg;

  /*FIXME : Add complete error checking*/
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 80390c4:	684a      	ldr	r2, [r1, #4]
{
 80390c6:	b530      	push	{r4, r5, lr}
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 80390c8:	f012 051f 	ands.w	r5, r2, #31
 80390cc:	d128      	bne.n	8039120 <mpu_armv8m_region_enable+0x5c>
  MPU_Type *mpu = (MPU_Type *)dev->base;
 80390ce:	6804      	ldr	r4, [r0, #0]
   */

  ctrl_before = mpu->CTRL;
  mpu->CTRL = 0;

  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 80390d0:	780b      	ldrb	r3, [r1, #0]
  ctrl_before = mpu->CTRL;
 80390d2:	6860      	ldr	r0, [r4, #4]
  mpu->CTRL = 0;
 80390d4:	6065      	str	r5, [r4, #4]
  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 80390d6:	60a3      	str	r3, [r4, #8]

  /* This 0s the lower bits of the base address */
  base_cfg = region_cfg->region_base & MPU_RBAR_BASE_Msk;
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 80390d8:	7c0b      	ldrb	r3, [r1, #16]
  base_cfg = region_cfg->region_base & MPU_RBAR_BASE_Msk;
 80390da:	f022 021f 	bic.w	r2, r2, #31
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 80390de:	f003 0301 	and.w	r3, r3, #1
 80390e2:	4313      	orrs	r3, r2
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
 80390e4:	7c8a      	ldrb	r2, [r1, #18]
 80390e6:	00d2      	lsls	r2, r2, #3
 80390e8:	f002 0218 	and.w	r2, r2, #24
 80390ec:	431a      	orrs	r2, r3
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
 80390ee:	7c4b      	ldrb	r3, [r1, #17]
 80390f0:	005b      	lsls	r3, r3, #1
 80390f2:	f003 0306 	and.w	r3, r3, #6
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 80390f6:	4313      	orrs	r3, r2

  mpu->RBAR = base_cfg;
 80390f8:	60e3      	str	r3, [r4, #12]

  /*This 0s the lower bits of base address but they are treated as 1 */
  limit_cfg = (region_cfg->region_limit - 1) & MPU_RLAR_LIMIT_Msk;
 80390fa:	688b      	ldr	r3, [r1, #8]
 80390fc:	3b01      	subs	r3, #1
 80390fe:	f023 021f 	bic.w	r2, r3, #31

  limit_cfg |= (region_cfg->region_attridx << MPU_RLAR_AttrIndx_Pos) &
 8039102:	68cb      	ldr	r3, [r1, #12]
 8039104:	005b      	lsls	r3, r3, #1
 8039106:	f003 030e 	and.w	r3, r3, #14
 803910a:	4313      	orrs	r3, r2
               MPU_RLAR_AttrIndx_Msk;

  limit_cfg |= MPU_RLAR_EN_Msk;
 803910c:	f043 0301 	orr.w	r3, r3, #1

  mpu->RLAR = limit_cfg;
 8039110:	6123      	str	r3, [r4, #16]

  /*Restore main MPU control*/
  mpu->CTRL = ctrl_before;
 8039112:	6060      	str	r0, [r4, #4]
 8039114:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8039118:	f3bf 8f6f 	isb	sy

  /* Enable MPU before the next instruction */
  __DSB();
  __ISB();

  return ret_val;
 803911c:	4628      	mov	r0, r5
}
 803911e:	bd30      	pop	{r4, r5, pc}
    return MPU_ARMV8M_ERROR;
 8039120:	2001      	movs	r0, #1
 8039122:	e7fc      	b.n	803911e <mpu_armv8m_region_enable+0x5a>

08039124 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 8039124:	4770      	bx	lr

08039126 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8039126:	e7fe      	b.n	8039126 <HardFault_Handler>

08039128 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8039128:	e7fe      	b.n	8039128 <MemManage_Handler>

0803912a <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 803912a:	e7fe      	b.n	803912a <BusFault_Handler>

0803912c <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 803912c:	e7fe      	b.n	803912c <UsageFault_Handler>

0803912e <DebugMon_Handler>:
 803912e:	4770      	bx	lr

08039130 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
 8039130:	f000 befa 	b.w	8039f28 <HAL_IncTick>

08039134 <FLASH_IRQHandler>:
  * @param  None
  * @retval None
  */
void FLASH_IRQHandler(void)
{
  HAL_FLASH_IRQHandler();
 8039134:	f001 b848 	b.w	803a1c8 <HAL_FLASH_IRQHandler>

08039138 <SystemInit>:

void SystemInit(void)
{
#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
extern uint32_t __Vectors;
  SCB->VTOR = (uint32_t) &__Vectors;
 8039138:	4b04      	ldr	r3, [pc, #16]	; (803914c <SystemInit+0x14>)
 803913a:	4a05      	ldr	r2, [pc, #20]	; (8039150 <SystemInit+0x18>)
 803913c:	609a      	str	r2, [r3, #8]
#endif
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 803913e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8039142:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8039146:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif
}
 803914a:	4770      	bx	lr
 803914c:	e000ed00 	.word	0xe000ed00
 8039150:	08038400 	.word	0x08038400

08039154 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
  uint32_t tmp, msirange, pllvco, pllsource, pllm, pllr;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 8039154:	4a21      	ldr	r2, [pc, #132]	; (80391dc <SystemCoreClockUpdate+0x88>)
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];
 8039156:	4922      	ldr	r1, [pc, #136]	; (80391e0 <SystemCoreClockUpdate+0x8c>)
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 8039158:	6813      	ldr	r3, [r2, #0]
{
 803915a:	b510      	push	{r4, lr}
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 803915c:	071b      	lsls	r3, r3, #28
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 803915e:	bf55      	itete	pl
 8039160:	f8d2 3094 	ldrpl.w	r3, [r2, #148]	; 0x94
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 8039164:	6813      	ldrmi	r3, [r2, #0]
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 8039166:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 803916a:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
  msirange = MSIRangeTable[msirange];
 803916e:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8039172:	6891      	ldr	r1, [r2, #8]
 8039174:	481b      	ldr	r0, [pc, #108]	; (80391e4 <SystemCoreClockUpdate+0x90>)
 8039176:	f001 010c 	and.w	r1, r1, #12
 803917a:	2908      	cmp	r1, #8
 803917c:	d003      	beq.n	8039186 <SystemCoreClockUpdate+0x32>
 803917e:	290c      	cmp	r1, #12
 8039180:	d00c      	beq.n	803919c <SystemCoreClockUpdate+0x48>
 8039182:	2904      	cmp	r1, #4
 8039184:	d127      	bne.n	80391d6 <SystemCoreClockUpdate+0x82>
    case 0x00:  /* MSI used as system clock source */
      SystemCoreClock = msirange;
      break;

    case 0x04:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
 8039186:	4b18      	ldr	r3, [pc, #96]	; (80391e8 <SystemCoreClockUpdate+0x94>)
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
      SystemCoreClock = pllvco/pllr;
 8039188:	6003      	str	r3, [r0, #0]
      SystemCoreClock = msirange;
      break;
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
 803918a:	6893      	ldr	r3, [r2, #8]
 803918c:	4a17      	ldr	r2, [pc, #92]	; (80391ec <SystemCoreClockUpdate+0x98>)
 803918e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8039192:	5cd2      	ldrb	r2, [r2, r3]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 8039194:	6803      	ldr	r3, [r0, #0]
 8039196:	40d3      	lsrs	r3, r2
 8039198:	6003      	str	r3, [r0, #0]
}
 803919a:	bd10      	pop	{r4, pc}
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 803919c:	68d1      	ldr	r1, [r2, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 803919e:	68d3      	ldr	r3, [r2, #12]
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80391a0:	f001 0103 	and.w	r1, r1, #3
      switch (pllsource)
 80391a4:	3902      	subs	r1, #2
 80391a6:	2901      	cmp	r1, #1
          pllvco = (HSE_VALUE / pllm);
 80391a8:	bf98      	it	ls
 80391aa:	490f      	ldrls	r1, [pc, #60]	; (80391e8 <SystemCoreClockUpdate+0x94>)
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 80391ac:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80391b0:	f103 0301 	add.w	r3, r3, #1
          pllvco = (HSE_VALUE / pllm);
 80391b4:	bf94      	ite	ls
 80391b6:	fbb1 f3f3 	udivls	r3, r1, r3
          pllvco = (msirange / pllm);
 80391ba:	fbb4 f3f3 	udivhi	r3, r4, r3
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 80391be:	68d4      	ldr	r4, [r2, #12]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 80391c0:	68d1      	ldr	r1, [r2, #12]
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 80391c2:	f3c4 2406 	ubfx	r4, r4, #8, #7
 80391c6:	4363      	muls	r3, r4
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 80391c8:	f3c1 6141 	ubfx	r1, r1, #25, #2
 80391cc:	3101      	adds	r1, #1
 80391ce:	0049      	lsls	r1, r1, #1
      SystemCoreClock = pllvco/pllr;
 80391d0:	fbb3 f3f1 	udiv	r3, r3, r1
 80391d4:	e7d8      	b.n	8039188 <SystemCoreClockUpdate+0x34>
      SystemCoreClock = msirange;
 80391d6:	6004      	str	r4, [r0, #0]
      break;
 80391d8:	e7d7      	b.n	803918a <SystemCoreClockUpdate+0x36>
 80391da:	bf00      	nop
 80391dc:	40021000 	.word	0x40021000
 80391e0:	0803e088 	.word	0x0803e088
 80391e4:	20000100 	.word	0x20000100
 80391e8:	00f42400 	.word	0x00f42400
 80391ec:	0803e06e 	.word	0x0803e06e

080391f0 <TEST_PROTECTIONS_PrintTestingMenu>:
  * @brief  Display the TEST Main Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
static void TEST_PROTECTIONS_PrintTestingMenu(void)
{
 80391f0:	b508      	push	{r3, lr}
  printf("\r\n=================== Test Menu ============================\r\n\n");
 80391f2:	4807      	ldr	r0, [pc, #28]	; (8039210 <TEST_PROTECTIONS_PrintTestingMenu+0x20>)
 80391f4:	f003 faec 	bl	803c7d0 <puts>
  printf("  Test Protection : NonSecure try to access to Secure --- 1\r\n\n");
 80391f8:	4806      	ldr	r0, [pc, #24]	; (8039214 <TEST_PROTECTIONS_PrintTestingMenu+0x24>)
 80391fa:	f003 fae9 	bl	803c7d0 <puts>
  printf("  RDP Regression ---------------------------------------- 2\r\n\n");
 80391fe:	4806      	ldr	r0, [pc, #24]	; (8039218 <TEST_PROTECTIONS_PrintTestingMenu+0x28>)
 8039200:	f003 fae6 	bl	803c7d0 <puts>
  printf("  Previous Menu ----------------------------------------- x\r\n\n");
}
 8039204:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("  Previous Menu ----------------------------------------- x\r\n\n");
 8039208:	4804      	ldr	r0, [pc, #16]	; (803921c <TEST_PROTECTIONS_PrintTestingMenu+0x2c>)
 803920a:	f003 bae1 	b.w	803c7d0 <puts>
 803920e:	bf00      	nop
 8039210:	0803e0c8 	.word	0x0803e0c8
 8039214:	0803e107 	.word	0x0803e107
 8039218:	0803e145 	.word	0x0803e145
 803921c:	0803e183 	.word	0x0803e183

08039220 <TEST_PROTECTIONS_Run_SecUserMem>:
  uint32_t page_error = 0U;
 8039220:	2300      	movs	r3, #0
{
 8039222:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if ((TestNumber & TEST_PROTECTION_MASK) == 0)
 8039226:	4d5f      	ldr	r5, [pc, #380]	; (80393a4 <TEST_PROTECTIONS_Run_SecUserMem+0x184>)
{
 8039228:	b089      	sub	sp, #36	; 0x24
  if ((TestNumber & TEST_PROTECTION_MASK) == 0)
 803922a:	682a      	ldr	r2, [r5, #0]
  uint32_t page_error = 0U;
 803922c:	9301      	str	r3, [sp, #4]
  if ((TestNumber & TEST_PROTECTION_MASK) == 0)
 803922e:	4b5e      	ldr	r3, [pc, #376]	; (80393a8 <TEST_PROTECTIONS_Run_SecUserMem+0x188>)
           aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg, (int)aProtectTests[test_idx].address);
 8039230:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 80393d8 <TEST_PROTECTIONS_Run_SecUserMem+0x1b8>
  if ((TestNumber & TEST_PROTECTION_MASK) == 0)
 8039234:	4213      	tst	r3, r2
      if (on)
      {
        __HAL_RCC_RNG_CLK_ENABLE();
      }
      else
        __HAL_RCC_RNG_CLK_DISABLE();
 8039236:	4f5d      	ldr	r7, [pc, #372]	; (80393ac <TEST_PROTECTIONS_Run_SecUserMem+0x18c>)
    TestNumber = TEST_PROTECTION_MASK;
 8039238:	bf08      	it	eq
 803923a:	602b      	streq	r3, [r5, #0]
    HAL_Delay(100);
 803923c:	2064      	movs	r0, #100	; 0x64
 803923e:	f000 fe85 	bl	8039f4c <HAL_Delay>
    test_idx = TestNumber & 0xffff;
 8039242:	882e      	ldrh	r6, [r5, #0]
    if (test_idx > (sizeof(aProtectTests) / sizeof(TestProtection_t) -1))
 8039244:	2e08      	cmp	r6, #8
 8039246:	d902      	bls.n	803924e <TEST_PROTECTIONS_Run_SecUserMem+0x2e>
    TestNumber = 0;            /* no more test in progress */
 8039248:	2300      	movs	r3, #0
 803924a:	602b      	str	r3, [r5, #0]
 803924c:	e045      	b.n	80392da <TEST_PROTECTIONS_Run_SecUserMem+0xba>
           aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg, (int)aProtectTests[test_idx].address);
 803924e:	f04f 0a28 	mov.w	sl, #40	; 0x28
    printf("\r\n= [TEST] %s @ %s %08x", \
 8039252:	2014      	movs	r0, #20
    TestNumber = TEST_PROTECTION_MASK | ((test_idx + 1) & 0xffff);
 8039254:	1c73      	adds	r3, r6, #1
 8039256:	f043 435e 	orr.w	r3, r3, #3724541952	; 0xde000000
 803925a:	f443 032d 	orr.w	r3, r3, #11337728	; 0xad0000
 803925e:	602b      	str	r3, [r5, #0]
           aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg, (int)aProtectTests[test_idx].address);
 8039260:	fb0a f306 	mul.w	r3, sl, r6
 8039264:	eb09 0203 	add.w	r2, r9, r3
 8039268:	f892 b024 	ldrb.w	fp, [r2, #36]	; 0x24
 803926c:	f103 0804 	add.w	r8, r3, #4
 8039270:	f859 4003 	ldr.w	r4, [r9, r3]
    printf("\r\n= [TEST] %s @ %s %08x", \
 8039274:	494e      	ldr	r1, [pc, #312]	; (80393b0 <TEST_PROTECTIONS_Run_SecUserMem+0x190>)
           aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg, (int)aProtectTests[test_idx].address);
 8039276:	44c8      	add	r8, r9
    printf("\r\n= [TEST] %s @ %s %08x", \
 8039278:	4623      	mov	r3, r4
 803927a:	fb00 110b 	mla	r1, r0, fp, r1
 803927e:	4642      	mov	r2, r8
 8039280:	484c      	ldr	r0, [pc, #304]	; (80393b4 <TEST_PROTECTIONS_Run_SecUserMem+0x194>)
 8039282:	f003 fa31 	bl	803c6e8 <iprintf>
    switch (aProtectTests[test_idx].type)
 8039286:	f1bb 0f07 	cmp.w	fp, #7
 803928a:	d8d7      	bhi.n	803923c <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
 803928c:	e8df f00b 	tbb	[pc, fp]
 8039290:	4a362804 	.word	0x4a362804
 8039294:	7f58564d 	.word	0x7f58564d
        HAL_FLASH_Unlock();
 8039298:	f000 fff0 	bl	803a27c <HAL_FLASH_Unlock>
        HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, aProtectTests[test_idx].address, pattern);
 803929c:	2200      	movs	r2, #0
 803929e:	4621      	mov	r1, r4
 80392a0:	2300      	movs	r3, #0
 80392a2:	2001      	movs	r0, #1
 80392a4:	f001 f83a 	bl	803a31c <HAL_FLASH_Program>
        HAL_FLASH_Lock();
 80392a8:	f000 fffa 	bl	803a2a0 <HAL_FLASH_Lock>
        flashErrCode = HAL_FLASH_GetError();
 80392ac:	f001 f804 	bl	803a2b8 <HAL_FLASH_GetError>
 80392b0:	4604      	mov	r4, r0
        printf("\r\nflash error code: %x",(int)flashErrCode);
 80392b2:	4601      	mov	r1, r0
 80392b4:	4840      	ldr	r0, [pc, #256]	; (80393b8 <TEST_PROTECTIONS_Run_SecUserMem+0x198>)
 80392b6:	f003 fa17 	bl	803c6e8 <iprintf>
          status = TEST_ERROR;
 80392ba:	f014 0f10 	tst.w	r4, #16
        if (0 == strncmp("OBs @", (const char *)aProtectTests[test_idx].msg, 5))
 80392be:	f04f 0205 	mov.w	r2, #5
 80392c2:	4641      	mov	r1, r8
 80392c4:	483d      	ldr	r0, [pc, #244]	; (80393bc <TEST_PROTECTIONS_Run_SecUserMem+0x19c>)
          status = TEST_ERROR;
 80392c6:	bf14      	ite	ne
 80392c8:	2600      	movne	r6, #0
 80392ca:	2602      	moveq	r6, #2
        if (0 == strncmp("OBs @", (const char *)aProtectTests[test_idx].msg, 5))
 80392cc:	f003 fb34 	bl	803c938 <strncmp>
 80392d0:	2800      	cmp	r0, #0
 80392d2:	d157      	bne.n	8039384 <TEST_PROTECTIONS_Run_SecUserMem+0x164>
    printf("\r\n TEST_PROTECTIONS_Run_SecUserMem : Failed");
 80392d4:	483a      	ldr	r0, [pc, #232]	; (80393c0 <TEST_PROTECTIONS_Run_SecUserMem+0x1a0>)
 80392d6:	f003 fa07 	bl	803c6e8 <iprintf>
}
 80392da:	b009      	add	sp, #36	; 0x24
 80392dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        tmp = *(uint8_t *)(aProtectTests[test_idx].address);
 80392e0:	7823      	ldrb	r3, [r4, #0]
        HAL_Delay(1);        /* ensure Flag is set */
 80392e2:	2001      	movs	r0, #1
        tmp = *(uint8_t *)(aProtectTests[test_idx].address);
 80392e4:	f88d 3003 	strb.w	r3, [sp, #3]
        HAL_Delay(1);        /* ensure Flag is set */
 80392e8:	f000 fe30 	bl	8039f4c <HAL_Delay>
        if (0 == strncmp("Isolated", (const char *)aProtectTests[test_idx].msg, 8))
 80392ec:	2208      	movs	r2, #8
 80392ee:	4641      	mov	r1, r8
 80392f0:	4834      	ldr	r0, [pc, #208]	; (80393c4 <TEST_PROTECTIONS_Run_SecUserMem+0x1a4>)
 80392f2:	f003 fb21 	bl	803c938 <strncmp>
 80392f6:	2800      	cmp	r0, #0
 80392f8:	d1a0      	bne.n	803923c <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
 80392fa:	e7eb      	b.n	80392d4 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        HAL_FLASH_Unlock();
 80392fc:	f000 ffbe 	bl	803a27c <HAL_FLASH_Unlock>
        p_erase_init.TypeErase   = FLASH_TYPEERASE_PAGES;
 8039300:	2301      	movs	r3, #1
 8039302:	2202      	movs	r2, #2
        HAL_FLASHEx_Erase(&p_erase_init, &page_error);
 8039304:	a901      	add	r1, sp, #4
        p_erase_init.Page        = (aProtectTests[test_idx].address) / 0x800;
 8039306:	0ae4      	lsrs	r4, r4, #11
        HAL_FLASHEx_Erase(&p_erase_init, &page_error);
 8039308:	a804      	add	r0, sp, #16
        p_erase_init.TypeErase   = FLASH_TYPEERASE_PAGES;
 803930a:	e9cd 2304 	strd	r2, r3, [sp, #16]
        p_erase_init.NbPages     = 1;
 803930e:	e9cd 4306 	strd	r4, r3, [sp, #24]
        HAL_FLASHEx_Erase(&p_erase_init, &page_error);
 8039312:	f001 f881 	bl	803a418 <HAL_FLASHEx_Erase>
        HAL_FLASH_Lock();
 8039316:	f000 ffc3 	bl	803a2a0 <HAL_FLASH_Lock>
        if ((HAL_FLASH_GetError() & HAL_FLASH_ERROR_WRP) == 0U)
 803931a:	f000 ffcd 	bl	803a2b8 <HAL_FLASH_GetError>
 803931e:	06c3      	lsls	r3, r0, #27
 8039320:	d48c      	bmi.n	803923c <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
 8039322:	e7d7      	b.n	80392d4 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        *(uint32_t *)aProtectTests[test_idx].address = 0x00000000;
 8039324:	2300      	movs	r3, #0
 8039326:	6023      	str	r3, [r4, #0]
 8039328:	e7d4      	b.n	80392d4 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        tmp = *(uint8_t *)aProtectTests[test_idx].address;
 803932a:	7823      	ldrb	r3, [r4, #0]
        printf(" value : %d ", tmp);
 803932c:	4826      	ldr	r0, [pc, #152]	; (80393c8 <TEST_PROTECTIONS_Run_SecUserMem+0x1a8>)
        tmp = *(uint8_t *)aProtectTests[test_idx].address;
 803932e:	f88d 3003 	strb.w	r3, [sp, #3]
        printf(" value : %d ", tmp);
 8039332:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8039336:	f003 f9d7 	bl	803c6e8 <iprintf>
 803933a:	e7cb      	b.n	80392d4 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        func();
 803933c:	47a0      	blx	r4
 803933e:	e7c9      	b.n	80392d4 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        set_periph(aProtectTests[test_idx].periph, 1);
 8039340:	fb0a 9606 	mla	r6, sl, r6, r9
 8039344:	f896 6025 	ldrb.w	r6, [r6, #37]	; 0x25
  switch (periph)
 8039348:	b946      	cbnz	r6, 803935c <TEST_PROTECTIONS_Run_SecUserMem+0x13c>
        __HAL_RCC_RNG_CLK_ENABLE();
 803934a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 803934c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8039350:	64fb      	str	r3, [r7, #76]	; 0x4c
 8039352:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8039354:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8039358:	9303      	str	r3, [sp, #12]
 803935a:	9b03      	ldr	r3, [sp, #12]
          status = TEST_ERROR;
 803935c:	230a      	movs	r3, #10
          tmp_reg = *((__IO uint32_t *)aProtectTests[test_idx].address);
 803935e:	6822      	ldr	r2, [r4, #0]
 8039360:	9202      	str	r2, [sp, #8]
          if (tmp_reg != 0)
 8039362:	9a02      	ldr	r2, [sp, #8]
 8039364:	b90a      	cbnz	r2, 803936a <TEST_PROTECTIONS_Run_SecUserMem+0x14a>
        for (i = 0; i < 10; i++)
 8039366:	3b01      	subs	r3, #1
 8039368:	d1f9      	bne.n	803935e <TEST_PROTECTIONS_Run_SecUserMem+0x13e>
        if (tmp_reg != 0)
 803936a:	9b02      	ldr	r3, [sp, #8]
 803936c:	b1b3      	cbz	r3, 803939c <TEST_PROTECTIONS_Run_SecUserMem+0x17c>
          printf(" value : %x ",(int)tmp_reg);
 803936e:	9902      	ldr	r1, [sp, #8]
 8039370:	4816      	ldr	r0, [pc, #88]	; (80393cc <TEST_PROTECTIONS_Run_SecUserMem+0x1ac>)
 8039372:	f003 f9b9 	bl	803c6e8 <iprintf>
  switch (periph)
 8039376:	2e00      	cmp	r6, #0
 8039378:	d1ac      	bne.n	80392d4 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
          status = TEST_ERROR;
 803937a:	2602      	movs	r6, #2
        __HAL_RCC_RNG_CLK_DISABLE();
 803937c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 803937e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8039382:	64fb      	str	r3, [r7, #76]	; 0x4c
  } while (status == TEST_IN_PROGRESS) ;
 8039384:	2e00      	cmp	r6, #0
 8039386:	f43f af59 	beq.w	803923c <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
  if (status == TEST_ERROR)
 803938a:	b11e      	cbz	r6, 8039394 <TEST_PROTECTIONS_Run_SecUserMem+0x174>
 803938c:	e7a2      	b.n	80392d4 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        printf("\r\n TEST_PROTECTIONS_Run_SecUserMem : Passed");
 803938e:	4810      	ldr	r0, [pc, #64]	; (80393d0 <TEST_PROTECTIONS_Run_SecUserMem+0x1b0>)
 8039390:	f003 f9aa 	bl	803c6e8 <iprintf>
    printf("\b\b\b\b\b\b\b\b");
 8039394:	480f      	ldr	r0, [pc, #60]	; (80393d4 <TEST_PROTECTIONS_Run_SecUserMem+0x1b4>)
 8039396:	f003 f9a7 	bl	803c6e8 <iprintf>
 803939a:	e755      	b.n	8039248 <TEST_PROTECTIONS_Run_SecUserMem+0x28>
  switch (periph)
 803939c:	2e00      	cmp	r6, #0
 803939e:	f47f af4d 	bne.w	803923c <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
 80393a2:	e7eb      	b.n	803937c <TEST_PROTECTIONS_Run_SecUserMem+0x15c>
 80393a4:	20000000 	.word	0x20000000
 80393a8:	dead0000 	.word	0xdead0000
 80393ac:	40021000 	.word	0x40021000
 80393b0:	0803e454 	.word	0x0803e454
 80393b4:	0803e233 	.word	0x0803e233
 80393b8:	0803e24b 	.word	0x0803e24b
 80393bc:	0803e262 	.word	0x0803e262
 80393c0:	0803e2b7 	.word	0x0803e2b7
 80393c4:	0803e268 	.word	0x0803e268
 80393c8:	0803e271 	.word	0x0803e271
 80393cc:	0803e27e 	.word	0x0803e27e
 80393d0:	0803e28b 	.word	0x0803e28b
 80393d4:	0803e2e3 	.word	0x0803e2e3
 80393d8:	0803e2ec 	.word	0x0803e2ec

080393dc <TEST_PROTECTIONS_Run>:
{
 80393dc:	b570      	push	{r4, r5, r6, lr}
  uint8_t key = 0U;
 80393de:	2400      	movs	r4, #0
{
 80393e0:	b088      	sub	sp, #32
  uint8_t key = 0U;
 80393e2:	ad08      	add	r5, sp, #32
 80393e4:	f805 4d19 	strb.w	r4, [r5, #-25]!
  TEST_PROTECTIONS_PrintTestingMenu();
 80393e8:	f7ff ff02 	bl	80391f0 <TEST_PROTECTIONS_PrintTestingMenu>
          printf("Invalid Number !\r");
 80393ec:	4e26      	ldr	r6, [pc, #152]	; (8039488 <TEST_PROTECTIONS_Run+0xac>)
    key = 0U;
 80393ee:	f88d 4007 	strb.w	r4, [sp, #7]
    COM_Flush();
 80393f2:	f7ff faeb 	bl	80389cc <COM_Flush>
    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
 80393f6:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 80393fa:	2101      	movs	r1, #1
 80393fc:	4628      	mov	r0, r5
 80393fe:	f7ff fadd 	bl	80389bc <COM_Receive>
 8039402:	2800      	cmp	r0, #0
 8039404:	d1f3      	bne.n	80393ee <TEST_PROTECTIONS_Run+0x12>
      switch (key)
 8039406:	f89d 3007 	ldrb.w	r3, [sp, #7]
 803940a:	2b32      	cmp	r3, #50	; 0x32
 803940c:	d008      	beq.n	8039420 <TEST_PROTECTIONS_Run+0x44>
 803940e:	2b78      	cmp	r3, #120	; 0x78
 8039410:	d031      	beq.n	8039476 <TEST_PROTECTIONS_Run+0x9a>
 8039412:	2b31      	cmp	r3, #49	; 0x31
 8039414:	d133      	bne.n	803947e <TEST_PROTECTIONS_Run+0xa2>
          TEST_PROTECTIONS_Run_SecUserMem();
 8039416:	f7ff ff03 	bl	8039220 <TEST_PROTECTIONS_Run_SecUserMem>
      TEST_PROTECTIONS_PrintTestingMenu();
 803941a:	f7ff fee9 	bl	80391f0 <TEST_PROTECTIONS_PrintTestingMenu>
 803941e:	e7e6      	b.n	80393ee <TEST_PROTECTIONS_Run+0x12>
  region_cfg.region_nr = 2U;
 8039420:	2302      	movs	r3, #2
 8039422:	4a1a      	ldr	r2, [pc, #104]	; (803948c <TEST_PROTECTIONS_Run+0xb0>)
  region_cfg.region_limit = NS_DATA_LIMIT;
 8039424:	491a      	ldr	r1, [pc, #104]	; (8039490 <TEST_PROTECTIONS_Run+0xb4>)
  region_cfg.region_nr = 2U;
 8039426:	e9cd 2302 	strd	r2, r3, [sp, #8]
  region_cfg.region_limit = NS_DATA_LIMIT;
 803942a:	4a1a      	ldr	r2, [pc, #104]	; (8039494 <TEST_PROTECTIONS_Run+0xb8>)
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 803942c:	f88d 001d 	strb.w	r0, [sp, #29]
  region_cfg.region_limit = NS_DATA_LIMIT;
 8039430:	e9cd 1204 	strd	r1, r2, [sp, #16]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 8039434:	f88d 001e 	strb.w	r0, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_OK;
 8039438:	f88d 001c 	strb.w	r0, [sp, #28]
  mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg);
 803943c:	a903      	add	r1, sp, #12
 803943e:	a802      	add	r0, sp, #8
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 8039440:	9306      	str	r3, [sp, #24]
  mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg);
 8039442:	f7ff fe3f 	bl	80390c4 <mpu_armv8m_region_enable>
  __ASM volatile ("cpsid i" : : : "memory");
 8039446:	b672      	cpsid	i
    *pt = WHILE_1_OPCODE;
 8039448:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 803944c:	f24e 72fe 	movw	r2, #59390	; 0xe7fe
 8039450:	801a      	strh	r2, [r3, #0]
  __ASM volatile ("dsb 0xF":::"memory");
 8039452:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8039456:	f3bf 8f6f 	isb	sy
    printf("\r\n Device ready for regression : \r\n");
 803945a:	480f      	ldr	r0, [pc, #60]	; (8039498 <TEST_PROTECTIONS_Run+0xbc>)
 803945c:	f003 f9b8 	bl	803c7d0 <puts>
    printf("\r\n - Connect STM32CubeProgrammer mode=HotPlug");
 8039460:	480e      	ldr	r0, [pc, #56]	; (803949c <TEST_PROTECTIONS_Run+0xc0>)
 8039462:	f003 f941 	bl	803c6e8 <iprintf>
    printf("\r\n - Perform RDP Regression ");
 8039466:	480e      	ldr	r0, [pc, #56]	; (80394a0 <TEST_PROTECTIONS_Run+0xc4>)
 8039468:	f003 f93e 	bl	803c6e8 <iprintf>
    printf("\r\n ");
 803946c:	480d      	ldr	r0, [pc, #52]	; (80394a4 <TEST_PROTECTIONS_Run+0xc8>)
 803946e:	f003 f93b 	bl	803c6e8 <iprintf>
    nsfptr();
 8039472:	4b0d      	ldr	r3, [pc, #52]	; (80394a8 <TEST_PROTECTIONS_Run+0xcc>)
 8039474:	4798      	blx	r3
      TEST_PROTECTIONS_PrintTestingMenu();
 8039476:	f7ff febb 	bl	80391f0 <TEST_PROTECTIONS_PrintTestingMenu>
}
 803947a:	b008      	add	sp, #32
 803947c:	bd70      	pop	{r4, r5, r6, pc}
          printf("Invalid Number !\r");
 803947e:	4630      	mov	r0, r6
 8039480:	f003 f932 	bl	803c6e8 <iprintf>
          break;
 8039484:	e7c9      	b.n	803941a <TEST_PROTECTIONS_Run+0x3e>
 8039486:	bf00      	nop
 8039488:	0803dd95 	.word	0x0803dd95
 803948c:	e000ed90 	.word	0xe000ed90
 8039490:	20000020 	.word	0x20000020
 8039494:	2002ffff 	.word	0x2002ffff
 8039498:	0803e1c1 	.word	0x0803e1c1
 803949c:	0803e1e4 	.word	0x0803e1e4
 80394a0:	0803e212 	.word	0x0803e212
 80394a4:	0803e22f 	.word	0x0803e22f
 80394a8:	20000001 	.word	0x20000001

080394ac <tfm_app_print_menu>:
  * @brief  Display the TEST TFM App Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
static void tfm_app_print_menu(void)
{
 80394ac:	b508      	push	{r3, lr}
  printf("\r\n======================= TFM Examples Menu ===========================\r\n\n");
 80394ae:	4816      	ldr	r0, [pc, #88]	; (8039508 <tfm_app_print_menu+0x5c>)
 80394b0:	f003 f98e 	bl	803c7d0 <puts>
  printf("  TFM - Test All                                   --------------------- 0\r\n\n");
 80394b4:	4815      	ldr	r0, [pc, #84]	; (803950c <tfm_app_print_menu+0x60>)
 80394b6:	f003 f98b 	bl	803c7d0 <puts>
  printf("  TFM - Test AES-GCM                               --------------------- 1\r\n\n");
 80394ba:	4815      	ldr	r0, [pc, #84]	; (8039510 <tfm_app_print_menu+0x64>)
 80394bc:	f003 f988 	bl	803c7d0 <puts>
  printf("  TFM - Test AES-CBC                               --------------------- 2\r\n\n");
 80394c0:	4814      	ldr	r0, [pc, #80]	; (8039514 <tfm_app_print_menu+0x68>)
 80394c2:	f003 f985 	bl	803c7d0 <puts>
  printf("  TFM - Test SST set UID                           --------------------- 3\r\n\n");
 80394c6:	4814      	ldr	r0, [pc, #80]	; (8039518 <tfm_app_print_menu+0x6c>)
 80394c8:	f003 f982 	bl	803c7d0 <puts>
  printf("  TFM - Test SST read / check UID                  --------------------- 4\r\n\n");
 80394cc:	4813      	ldr	r0, [pc, #76]	; (803951c <tfm_app_print_menu+0x70>)
 80394ce:	f003 f97f 	bl	803c7d0 <puts>
  printf("  TFM - Test SST remove UID                        --------------------- 5\r\n\n");
 80394d2:	4813      	ldr	r0, [pc, #76]	; (8039520 <tfm_app_print_menu+0x74>)
 80394d4:	f003 f97c 	bl	803c7d0 <puts>
  printf("  TFM - Test EAT                                   --------------------- 6\r\n\n");
 80394d8:	4812      	ldr	r0, [pc, #72]	; (8039524 <tfm_app_print_menu+0x78>)
 80394da:	f003 f979 	bl	803c7d0 <puts>
  printf("  TFM - Test ITS set UID                           --------------------- 7\r\n\n");
 80394de:	4812      	ldr	r0, [pc, #72]	; (8039528 <tfm_app_print_menu+0x7c>)
 80394e0:	f003 f976 	bl	803c7d0 <puts>
  printf("  TFM - Test ITS read / check UID                  --------------------- 8\r\n\n");
 80394e4:	4811      	ldr	r0, [pc, #68]	; (803952c <tfm_app_print_menu+0x80>)
 80394e6:	f003 f973 	bl	803c7d0 <puts>
  printf("  TFM - Test ITS remove UID                        --------------------- 9\r\n\n");
 80394ea:	4811      	ldr	r0, [pc, #68]	; (8039530 <tfm_app_print_menu+0x84>)
 80394ec:	f003 f970 	bl	803c7d0 <puts>
  printf("  TFM - Test SHA224                                --------------------- a\r\n\n");
 80394f0:	4810      	ldr	r0, [pc, #64]	; (8039534 <tfm_app_print_menu+0x88>)
 80394f2:	f003 f96d 	bl	803c7d0 <puts>
  printf("  TFM - Test SHA256                                --------------------- b\r\n\n");
 80394f6:	4810      	ldr	r0, [pc, #64]	; (8039538 <tfm_app_print_menu+0x8c>)
 80394f8:	f003 f96a 	bl	803c7d0 <puts>
  printf("  Exit TFM Examples Menu                           --------------------- x\r\n\n");
}
 80394fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("  Exit TFM Examples Menu                           --------------------- x\r\n\n");
 8039500:	480e      	ldr	r0, [pc, #56]	; (803953c <tfm_app_print_menu+0x90>)
 8039502:	f003 b965 	b.w	803c7d0 <puts>
 8039506:	bf00      	nop
 8039508:	0803e633 	.word	0x0803e633
 803950c:	0803e67d 	.word	0x0803e67d
 8039510:	0803e6ca 	.word	0x0803e6ca
 8039514:	0803e717 	.word	0x0803e717
 8039518:	0803e764 	.word	0x0803e764
 803951c:	0803e7b1 	.word	0x0803e7b1
 8039520:	0803e7fe 	.word	0x0803e7fe
 8039524:	0803e84b 	.word	0x0803e84b
 8039528:	0803e898 	.word	0x0803e898
 803952c:	0803e8e5 	.word	0x0803e8e5
 8039530:	0803e932 	.word	0x0803e932
 8039534:	0803e97f 	.word	0x0803e97f
 8039538:	0803e9cc 	.word	0x0803e9cc
 803953c:	0803ea19 	.word	0x0803ea19

08039540 <tfm_sst_set_uid.isra.0>:
/**
  * @brief  Write in SST a TEST UID
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_sst_set_uid(struct test_result_t *ret)
 8039540:	b5f0      	push	{r4, r5, r6, r7, lr}
 8039542:	b08b      	sub	sp, #44	; 0x2c
{
  psa_ps_status_t status;
  const psa_ps_uid_t uid = TEST_UID;
  const psa_ps_create_flags_t flags = PSA_PS_FLAG_NONE;
  const uint32_t write_len = TEST_DATA_SIZE;
  const uint8_t write_data[] = TEST_DATA;
 8039544:	ac03      	add	r4, sp, #12
static void tfm_sst_set_uid(struct test_result_t *ret)
 8039546:	4606      	mov	r6, r0
 8039548:	4623      	mov	r3, r4
  const uint8_t write_data[] = TEST_DATA;
 803954a:	4a0d      	ldr	r2, [pc, #52]	; (8039580 <tfm_sst_set_uid.isra.0+0x40>)
 803954c:	f102 0718 	add.w	r7, r2, #24
 8039550:	4625      	mov	r5, r4
 8039552:	6810      	ldr	r0, [r2, #0]
 8039554:	6851      	ldr	r1, [r2, #4]
 8039556:	3208      	adds	r2, #8
 8039558:	c503      	stmia	r5!, {r0, r1}
 803955a:	42ba      	cmp	r2, r7
 803955c:	462c      	mov	r4, r5
 803955e:	d1f7      	bne.n	8039550 <tfm_sst_set_uid.isra.0+0x10>
 8039560:	8812      	ldrh	r2, [r2, #0]
  /* Set a UIDtime */
  status = psa_ps_set(uid, write_len, write_data, flags);
 8039562:	2100      	movs	r1, #0
  const uint8_t write_data[] = TEST_DATA;
 8039564:	802a      	strh	r2, [r5, #0]
  status = psa_ps_set(uid, write_len, write_data, flags);
 8039566:	2200      	movs	r2, #0
 8039568:	2002      	movs	r0, #2
 803956a:	9200      	str	r2, [sp, #0]
 803956c:	2219      	movs	r2, #25
 803956e:	f002 fc07 	bl	803bd80 <psa_ps_set>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 8039572:	3000      	adds	r0, #0
 8039574:	bf18      	it	ne
 8039576:	2001      	movne	r0, #1
 8039578:	7030      	strb	r0, [r6, #0]
  return;
}
 803957a:	b00b      	add	sp, #44	; 0x2c
 803957c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 803957e:	bf00      	nop
 8039580:	0803ead5 	.word	0x0803ead5

08039584 <tfm_sst_read_uid.isra.1>:
/**
  * @brief  Read ITS TEST UID and compare its value
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_sst_read_uid(struct test_result_t *ret)
 8039584:	b5f0      	push	{r4, r5, r6, r7, lr}
 8039586:	b097      	sub	sp, #92	; 0x5c
{
  psa_ps_status_t status;
  const psa_ps_uid_t uid = TEST_UID;
  uint8_t read_data[] = TEST_READ_DATA ;
 8039588:	aa0a      	add	r2, sp, #40	; 0x28
static void tfm_sst_read_uid(struct test_result_t *ret)
 803958a:	4605      	mov	r5, r0
 803958c:	4616      	mov	r6, r2
  uint8_t read_data[] = TEST_READ_DATA ;
 803958e:	4b19      	ldr	r3, [pc, #100]	; (80395f4 <tfm_sst_read_uid.isra.1+0x70>)
 8039590:	f103 0728 	add.w	r7, r3, #40	; 0x28
 8039594:	4614      	mov	r4, r2
 8039596:	6818      	ldr	r0, [r3, #0]
 8039598:	6859      	ldr	r1, [r3, #4]
 803959a:	3308      	adds	r3, #8
 803959c:	c403      	stmia	r4!, {r0, r1}
 803959e:	42bb      	cmp	r3, r7
 80395a0:	4622      	mov	r2, r4
 80395a2:	d1f7      	bne.n	8039594 <tfm_sst_read_uid.isra.1+0x10>
  uint8_t expected_data[] = TEST_DATA;
 80395a4:	aa03      	add	r2, sp, #12
 80395a6:	4617      	mov	r7, r2
  uint8_t read_data[] = TEST_READ_DATA ;
 80395a8:	6818      	ldr	r0, [r3, #0]
 80395aa:	791b      	ldrb	r3, [r3, #4]
 80395ac:	6020      	str	r0, [r4, #0]
 80395ae:	7123      	strb	r3, [r4, #4]
  uint8_t expected_data[] = TEST_DATA;
 80395b0:	4b11      	ldr	r3, [pc, #68]	; (80395f8 <tfm_sst_read_uid.isra.1+0x74>)
 80395b2:	f103 0c18 	add.w	ip, r3, #24
 80395b6:	4614      	mov	r4, r2
 80395b8:	6818      	ldr	r0, [r3, #0]
 80395ba:	6859      	ldr	r1, [r3, #4]
 80395bc:	3308      	adds	r3, #8
 80395be:	c403      	stmia	r4!, {r0, r1}
 80395c0:	4563      	cmp	r3, ip
 80395c2:	4622      	mov	r2, r4
 80395c4:	d1f7      	bne.n	80395b6 <tfm_sst_read_uid.isra.1+0x32>
 80395c6:	881b      	ldrh	r3, [r3, #0]
  /* read UID */
  status = psa_ps_get(uid, 0, TEST_DATA_SIZE, read_data);
 80395c8:	2200      	movs	r2, #0
  uint8_t expected_data[] = TEST_DATA;
 80395ca:	8023      	strh	r3, [r4, #0]
  status = psa_ps_get(uid, 0, TEST_DATA_SIZE, read_data);
 80395cc:	2002      	movs	r0, #2
 80395ce:	9600      	str	r6, [sp, #0]
 80395d0:	2319      	movs	r3, #25
 80395d2:	2100      	movs	r1, #0
 80395d4:	f002 fbff 	bl	803bdd6 <psa_ps_get>
  if ((status == PSA_SUCCESS) && (!memcmp(read_data, expected_data, TEST_DATA_SIZE)))
 80395d8:	b940      	cbnz	r0, 80395ec <tfm_sst_read_uid.isra.1+0x68>
 80395da:	2219      	movs	r2, #25
 80395dc:	4639      	mov	r1, r7
 80395de:	4630      	mov	r0, r6
 80395e0:	f003 f860 	bl	803c6a4 <memcmp>
 80395e4:	b910      	cbnz	r0, 80395ec <tfm_sst_read_uid.isra.1+0x68>
  {
    ret->val = TEST_PASSED;
 80395e6:	7028      	strb	r0, [r5, #0]
  else
  {
    ret->val = TEST_FAILED;
  }
  return;
}
 80395e8:	b017      	add	sp, #92	; 0x5c
 80395ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret->val = TEST_FAILED;
 80395ec:	2301      	movs	r3, #1
 80395ee:	702b      	strb	r3, [r5, #0]
 80395f0:	e7fa      	b.n	80395e8 <tfm_sst_read_uid.isra.1+0x64>
 80395f2:	bf00      	nop
 80395f4:	0803eaa8 	.word	0x0803eaa8
 80395f8:	0803ead5 	.word	0x0803ead5

080395fc <tfm_its_set_uid.isra.3>:
/**
  * @brief  Write in ITS a TEST UID
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_its_set_uid(struct test_result_t *ret)
 80395fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80395fe:	b08b      	sub	sp, #44	; 0x2c
{
  psa_ps_status_t status;
  const psa_ps_uid_t uid = TEST_UID;
  const psa_ps_create_flags_t flags = PSA_PS_FLAG_NONE;
  const uint32_t write_len = TEST_DATA_SIZE;
  const uint8_t write_data[] = TEST_DATA;
 8039600:	ac03      	add	r4, sp, #12
static void tfm_its_set_uid(struct test_result_t *ret)
 8039602:	4606      	mov	r6, r0
 8039604:	4623      	mov	r3, r4
  const uint8_t write_data[] = TEST_DATA;
 8039606:	4a0d      	ldr	r2, [pc, #52]	; (803963c <tfm_its_set_uid.isra.3+0x40>)
 8039608:	f102 0718 	add.w	r7, r2, #24
 803960c:	4625      	mov	r5, r4
 803960e:	6810      	ldr	r0, [r2, #0]
 8039610:	6851      	ldr	r1, [r2, #4]
 8039612:	3208      	adds	r2, #8
 8039614:	c503      	stmia	r5!, {r0, r1}
 8039616:	42ba      	cmp	r2, r7
 8039618:	462c      	mov	r4, r5
 803961a:	d1f7      	bne.n	803960c <tfm_its_set_uid.isra.3+0x10>
 803961c:	8812      	ldrh	r2, [r2, #0]
  /* Set a UIDtime */
  status = psa_its_set(uid, write_len, write_data, flags);
 803961e:	2100      	movs	r1, #0
  const uint8_t write_data[] = TEST_DATA;
 8039620:	802a      	strh	r2, [r5, #0]
  status = psa_its_set(uid, write_len, write_data, flags);
 8039622:	2200      	movs	r2, #0
 8039624:	2002      	movs	r0, #2
 8039626:	9200      	str	r2, [sp, #0]
 8039628:	2219      	movs	r2, #25
 803962a:	f002 fafe 	bl	803bc2a <psa_its_set>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 803962e:	3000      	adds	r0, #0
 8039630:	bf18      	it	ne
 8039632:	2001      	movne	r0, #1
 8039634:	7030      	strb	r0, [r6, #0]
  return;
}
 8039636:	b00b      	add	sp, #44	; 0x2c
 8039638:	bdf0      	pop	{r4, r5, r6, r7, pc}
 803963a:	bf00      	nop
 803963c:	0803ead5 	.word	0x0803ead5

08039640 <tfm_its_read_uid.isra.4>:
/**
  * @brief  Read TEST UID and compare its value
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_its_read_uid(struct test_result_t *ret)
 8039640:	b5f0      	push	{r4, r5, r6, r7, lr}
 8039642:	b097      	sub	sp, #92	; 0x5c
{
  psa_ps_status_t status;
  const psa_ps_uid_t uid = TEST_UID;
  size_t data_len;
  uint8_t read_data[] = TEST_READ_DATA ;
 8039644:	aa0a      	add	r2, sp, #40	; 0x28
static void tfm_its_read_uid(struct test_result_t *ret)
 8039646:	4605      	mov	r5, r0
 8039648:	4616      	mov	r6, r2
  uint8_t read_data[] = TEST_READ_DATA ;
 803964a:	4b1b      	ldr	r3, [pc, #108]	; (80396b8 <tfm_its_read_uid.isra.4+0x78>)
 803964c:	f103 0728 	add.w	r7, r3, #40	; 0x28
 8039650:	4614      	mov	r4, r2
 8039652:	6818      	ldr	r0, [r3, #0]
 8039654:	6859      	ldr	r1, [r3, #4]
 8039656:	3308      	adds	r3, #8
 8039658:	c403      	stmia	r4!, {r0, r1}
 803965a:	42bb      	cmp	r3, r7
 803965c:	4622      	mov	r2, r4
 803965e:	d1f7      	bne.n	8039650 <tfm_its_read_uid.isra.4+0x10>
  uint8_t expected_data[] = TEST_DATA;
 8039660:	aa03      	add	r2, sp, #12
 8039662:	4617      	mov	r7, r2
  uint8_t read_data[] = TEST_READ_DATA ;
 8039664:	6818      	ldr	r0, [r3, #0]
 8039666:	791b      	ldrb	r3, [r3, #4]
 8039668:	6020      	str	r0, [r4, #0]
 803966a:	7123      	strb	r3, [r4, #4]
  uint8_t expected_data[] = TEST_DATA;
 803966c:	4b13      	ldr	r3, [pc, #76]	; (80396bc <tfm_its_read_uid.isra.4+0x7c>)
 803966e:	f103 0c18 	add.w	ip, r3, #24
 8039672:	4614      	mov	r4, r2
 8039674:	6818      	ldr	r0, [r3, #0]
 8039676:	6859      	ldr	r1, [r3, #4]
 8039678:	3308      	adds	r3, #8
 803967a:	c403      	stmia	r4!, {r0, r1}
 803967c:	4563      	cmp	r3, ip
 803967e:	4622      	mov	r2, r4
 8039680:	d1f7      	bne.n	8039672 <tfm_its_read_uid.isra.4+0x32>
 8039682:	881b      	ldrh	r3, [r3, #0]
  /* read UID */
  status = psa_its_get(uid, 0, TEST_DATA_SIZE, read_data, &data_len);
 8039684:	2200      	movs	r2, #0
  uint8_t expected_data[] = TEST_DATA;
 8039686:	8023      	strh	r3, [r4, #0]
  status = psa_its_get(uid, 0, TEST_DATA_SIZE, read_data, &data_len);
 8039688:	ab02      	add	r3, sp, #8
 803968a:	e9cd 6300 	strd	r6, r3, [sp]
 803968e:	2002      	movs	r0, #2
 8039690:	2319      	movs	r3, #25
 8039692:	2100      	movs	r1, #0
 8039694:	f002 faf2 	bl	803bc7c <psa_its_get>
  if ((status == PSA_SUCCESS) && (data_len == TEST_DATA_SIZE)
 8039698:	b950      	cbnz	r0, 80396b0 <tfm_its_read_uid.isra.4+0x70>
 803969a:	9a02      	ldr	r2, [sp, #8]
 803969c:	2a19      	cmp	r2, #25
 803969e:	d107      	bne.n	80396b0 <tfm_its_read_uid.isra.4+0x70>
      && (!memcmp(read_data, expected_data, TEST_DATA_SIZE)))
 80396a0:	4639      	mov	r1, r7
 80396a2:	4630      	mov	r0, r6
 80396a4:	f002 fffe 	bl	803c6a4 <memcmp>
 80396a8:	b910      	cbnz	r0, 80396b0 <tfm_its_read_uid.isra.4+0x70>
  {
    ret->val = TEST_PASSED;
 80396aa:	7028      	strb	r0, [r5, #0]
  else
  {
    ret->val = TEST_FAILED;
  }
  return;
}
 80396ac:	b017      	add	sp, #92	; 0x5c
 80396ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret->val = TEST_FAILED;
 80396b0:	2301      	movs	r3, #1
 80396b2:	702b      	strb	r3, [r5, #0]
 80396b4:	e7fa      	b.n	80396ac <tfm_its_read_uid.isra.4+0x6c>
 80396b6:	bf00      	nop
 80396b8:	0803eaa8 	.word	0x0803eaa8
 80396bc:	0803ead5 	.word	0x0803ead5

080396c0 <dump_eat_token>:
void dump_eat_token(struct q_useful_buf_c *token)
{
 80396c0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int32_t len = token->len;
  int32_t n_item_per_line;
  int32_t i, index = 0;
  uint8_t *byte = (uint8_t *)token->ptr;
 80396c4:	e9d0 8700 	ldrd	r8, r7, [r0]
  int32_t i, index = 0;
 80396c8:	2400      	movs	r4, #0
  while (index < len)
  {
    n_item_per_line = (len-index) >= 20 ? 20 : (len-index);
    for (i = 0; i < n_item_per_line; i++)
    {
      printf("%2.2x", byte[index + i]);
 80396ca:	f8df 9044 	ldr.w	r9, [pc, #68]	; 8039710 <dump_eat_token+0x50>
    }
    printf("\r\n");
 80396ce:	f8df a03c 	ldr.w	sl, [pc, #60]	; 803970c <dump_eat_token+0x4c>
  while (index < len)
 80396d2:	42bc      	cmp	r4, r7
 80396d4:	db04      	blt.n	80396e0 <dump_eat_token+0x20>
    index += n_item_per_line;

  }
  printf("\r\n");

}
 80396d6:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  printf("\r\n");
 80396da:	480c      	ldr	r0, [pc, #48]	; (803970c <dump_eat_token+0x4c>)
 80396dc:	f003 b878 	b.w	803c7d0 <puts>
    n_item_per_line = (len-index) >= 20 ? 20 : (len-index);
 80396e0:	1b3d      	subs	r5, r7, r4
 80396e2:	2d14      	cmp	r5, #20
 80396e4:	eb08 0604 	add.w	r6, r8, r4
 80396e8:	bfa8      	it	ge
 80396ea:	2514      	movge	r5, #20
 80396ec:	46b3      	mov	fp, r6
    for (i = 0; i < n_item_per_line; i++)
 80396ee:	eba6 030b 	sub.w	r3, r6, fp
 80396f2:	429d      	cmp	r5, r3
 80396f4:	dc04      	bgt.n	8039700 <dump_eat_token+0x40>
    printf("\r\n");
 80396f6:	4650      	mov	r0, sl
 80396f8:	f003 f86a 	bl	803c7d0 <puts>
    index += n_item_per_line;
 80396fc:	442c      	add	r4, r5
 80396fe:	e7e8      	b.n	80396d2 <dump_eat_token+0x12>
      printf("%2.2x", byte[index + i]);
 8039700:	f816 1b01 	ldrb.w	r1, [r6], #1
 8039704:	4648      	mov	r0, r9
 8039706:	f002 ffef 	bl	803c6e8 <iprintf>
 803970a:	e7f0      	b.n	80396ee <dump_eat_token+0x2e>
 803970c:	0803e06c 	.word	0x0803e06c
 8039710:	0803e4f4 	.word	0x0803e4f4

08039714 <tfm_eat_test_circuit_sig.isra.6.constprop.7>:
  * @brief  request eat short cicuit, check result and
  * display response result buffer.
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_eat_test_circuit_sig(uint32_t encode_options, struct test_result_t *ret)
 8039714:	b5f0      	push	{r4, r5, r6, r7, lr}
  Q_USEFUL_BUF_MAKE_STACK_UB(token_storage, ATTEST_TOKEN_MAX_SIZE);
  struct q_useful_buf_c completed_token;
  struct q_useful_buf_c tmp;

  /* -- Make a token with all the claims -- */
  tmp = TOKEN_TEST_VALUE_NONCE;
 8039716:	2440      	movs	r4, #64	; 0x40
static void tfm_eat_test_circuit_sig(uint32_t encode_options, struct test_result_t *ret)
 8039718:	f5ad 7d31 	sub.w	sp, sp, #708	; 0x2c4
  tmp = TOKEN_TEST_VALUE_NONCE;
 803971c:	ab10      	add	r3, sp, #64	; 0x40
 803971e:	4622      	mov	r2, r4
 8039720:	2100      	movs	r1, #0
static void tfm_eat_test_circuit_sig(uint32_t encode_options, struct test_result_t *ret)
 8039722:	4606      	mov	r6, r0
  tmp = TOKEN_TEST_VALUE_NONCE;
 8039724:	4618      	mov	r0, r3
 8039726:	f002 ffd7 	bl	803c6d8 <memset>
 803972a:	e9cd 0406 	strd	r0, r4, [sp, #24]
  printf("token request value :\r\n");
 803972e:	4823      	ldr	r0, [pc, #140]	; (80397bc <tfm_eat_test_circuit_sig.isra.6.constprop.7+0xa8>)
 8039730:	f003 f84e 	bl	803c7d0 <puts>
  dump_eat_token(&tmp);
 8039734:	a806      	add	r0, sp, #24
 8039736:	f7ff ffc3 	bl	80396c0 <dump_eat_token>
 803973a:	e9dd 5406 	ldrd	r5, r4, [sp, #24]
  enum psa_attest_err_t return_value;
  uint32_t completed_token_len;
  struct q_useful_buf_c        actual_nonce;
  Q_USEFUL_BUF_MAKE_STACK_UB(actual_nonce_storage, 64);

  if (nonce.len == 64 && q_useful_buf_is_value(nonce, 0))
 803973e:	2c40      	cmp	r4, #64	; 0x40
 8039740:	d11c      	bne.n	803977c <tfm_eat_test_circuit_sig.isra.6.constprop.7+0x68>
 8039742:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
 8039746:	ab0a      	add	r3, sp, #40	; 0x28
}

static inline size_t q_useful_buf_is_value(const struct q_useful_buf_c buf,
                                           uint8_t uValue)
{
    return UsefulBuf_IsValue(buf, uValue);
 8039748:	2200      	movs	r2, #0
 803974a:	e893 0003 	ldmia.w	r3, {r0, r1}
 803974e:	f001 fef1 	bl	803b534 <UsefulBuf_IsValue>
 8039752:	b198      	cbz	r0, 803977c <tfm_eat_test_circuit_sig.isra.6.constprop.7+0x68>
 8039754:	e9cd 540e 	strd	r5, r4, [sp, #56]	; 0x38
 8039758:	af20      	add	r7, sp, #128	; 0x80
 803975a:	ab0e      	add	r3, sp, #56	; 0x38
}


static inline UsefulBufC UsefulBuf_Copy(UsefulBuf Dest, const UsefulBufC Src)
{
   return UsefulBuf_CopyOffset(Dest, 0, Src);
 803975c:	e893 0003 	ldmia.w	r3, {r0, r1}
 8039760:	e9cd 740c 	strd	r7, r4, [sp, #48]	; 0x30
 8039764:	e88d 0003 	stmia.w	sp, {r0, r1}
 8039768:	aa0c      	add	r2, sp, #48	; 0x30
 803976a:	2300      	movs	r3, #0
 803976c:	ca06      	ldmia	r2, {r1, r2}
 803976e:	a808      	add	r0, sp, #32
 8039770:	f001 fec3 	bl	803b4fa <UsefulBuf_CopyOffset>
    return UsefulBuf_Copy(dest, src);
 8039774:	e9dd 5408 	ldrd	r5, r4, [sp, #32]
  {
    /* Go into special option-packed nonce mode */
    actual_nonce = q_useful_buf_copy(actual_nonce_storage, nonce);
    /* Use memcpy as it always works and avoids type punning */
    memcpy((uint8_t *)actual_nonce_storage.ptr,
 8039778:	2300      	movs	r3, #0
 803977a:	603b      	str	r3, [r7, #0]
  else
  {
    actual_nonce = nonce;
  }

  completed_token_len = (uint32_t)buffer.len;
 803977c:	f44f 7300 	mov.w	r3, #512	; 0x200
  return_value = psa_initial_attest_get_token(actual_nonce.ptr,
 8039780:	af30      	add	r7, sp, #192	; 0xc0
  completed_token_len = (uint32_t)buffer.len;
 8039782:	9303      	str	r3, [sp, #12]
  return_value = psa_initial_attest_get_token(actual_nonce.ptr,
 8039784:	4621      	mov	r1, r4
 8039786:	ab03      	add	r3, sp, #12
 8039788:	463a      	mov	r2, r7
 803978a:	4628      	mov	r0, r5
 803978c:	f002 fa28 	bl	803bbe0 <psa_initial_attest_get_token>
                                              (uint32_t)actual_nonce.len,
                                              buffer.ptr,
                                              &completed_token_len);

  *completed_token = (struct q_useful_buf_c)
 8039790:	9b03      	ldr	r3, [sp, #12]
  if (status == PSA_ATTEST_ERR_SUCCESS)
 8039792:	4601      	mov	r1, r0
  *completed_token = (struct q_useful_buf_c)
 8039794:	e9cd 7304 	strd	r7, r3, [sp, #16]
  if (status == PSA_ATTEST_ERR_SUCCESS)
 8039798:	b948      	cbnz	r0, 80397ae <tfm_eat_test_circuit_sig.isra.6.constprop.7+0x9a>
    ret->val = TEST_PASSED;
 803979a:	7030      	strb	r0, [r6, #0]
    printf("token response value :\r\n");
 803979c:	4808      	ldr	r0, [pc, #32]	; (80397c0 <tfm_eat_test_circuit_sig.isra.6.constprop.7+0xac>)
 803979e:	f003 f817 	bl	803c7d0 <puts>
    dump_eat_token(&completed_token);
 80397a2:	a804      	add	r0, sp, #16
 80397a4:	f7ff ff8c 	bl	80396c0 <dump_eat_token>
}
 80397a8:	f50d 7d31 	add.w	sp, sp, #708	; 0x2c4
 80397ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    printf("failed status %d\r\n", status);
 80397ae:	4805      	ldr	r0, [pc, #20]	; (80397c4 <tfm_eat_test_circuit_sig.isra.6.constprop.7+0xb0>)
 80397b0:	f002 ff9a 	bl	803c6e8 <iprintf>
    ret->val = TEST_FAILED;
 80397b4:	2301      	movs	r3, #1
 80397b6:	7033      	strb	r3, [r6, #0]
 80397b8:	e7f6      	b.n	80397a8 <tfm_eat_test_circuit_sig.isra.6.constprop.7+0x94>
 80397ba:	bf00      	nop
 80397bc:	0803ea66 	.word	0x0803ea66
 80397c0:	0803ea7d 	.word	0x0803ea7d
 80397c4:	0803ea95 	.word	0x0803ea95

080397c8 <tfm_app_menu>:
  uint8_t key = 0;
 80397c8:	2300      	movs	r3, #0
{
 80397ca:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80397ce:	b087      	sub	sp, #28
  uint8_t key = 0;
 80397d0:	f88d 3007 	strb.w	r3, [sp, #7]
  tfm_app_print_menu();
 80397d4:	f7ff fe6a 	bl	80394ac <tfm_app_print_menu>
          printf("EAT normal circuit sig test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80397d8:	4db2      	ldr	r5, [pc, #712]	; (8039aa4 <tfm_app_menu+0x2dc>)
 80397da:	4eb3      	ldr	r6, [pc, #716]	; (8039aa8 <tfm_app_menu+0x2e0>)
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_GCM, &ret);
 80397dc:	f8df 9310 	ldr.w	r9, [pc, #784]	; 8039af0 <tfm_app_menu+0x328>
    key = 0U;
 80397e0:	2400      	movs	r4, #0
 80397e2:	f88d 4007 	strb.w	r4, [sp, #7]
    COM_Flush();
 80397e6:	f7ff f8f1 	bl	80389cc <COM_Flush>
    if (COM_Receive(&key, 1U, COM_UART_TIMEOUT_MAX) == HAL_OK)
 80397ea:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80397ee:	2101      	movs	r1, #1
 80397f0:	f10d 0007 	add.w	r0, sp, #7
 80397f4:	f7ff f8e2 	bl	80389bc <COM_Receive>
 80397f8:	2800      	cmp	r0, #0
 80397fa:	d1f2      	bne.n	80397e2 <tfm_app_menu+0x1a>
      switch (key)
 80397fc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8039800:	2b36      	cmp	r3, #54	; 0x36
 8039802:	f000 8191 	beq.w	8039b28 <tfm_app_menu+0x360>
 8039806:	d824      	bhi.n	8039852 <tfm_app_menu+0x8a>
 8039808:	2b32      	cmp	r3, #50	; 0x32
 803980a:	f000 813a 	beq.w	8039a82 <tfm_app_menu+0x2ba>
 803980e:	d808      	bhi.n	8039822 <tfm_app_menu+0x5a>
 8039810:	2b30      	cmp	r3, #48	; 0x30
 8039812:	d045      	beq.n	80398a0 <tfm_app_menu+0xd8>
 8039814:	2b31      	cmp	r3, #49	; 0x31
 8039816:	f000 8122 	beq.w	8039a5e <tfm_app_menu+0x296>
          printf("Invalid Number !\r");
 803981a:	48a4      	ldr	r0, [pc, #656]	; (8039aac <tfm_app_menu+0x2e4>)
 803981c:	f002 ff64 	bl	803c6e8 <iprintf>
 8039820:	e11a      	b.n	8039a58 <tfm_app_menu+0x290>
      switch (key)
 8039822:	2b34      	cmp	r3, #52	; 0x34
 8039824:	f04f 0301 	mov.w	r3, #1
 8039828:	f000 8171 	beq.w	8039b0e <tfm_app_menu+0x346>
 803982c:	f240 8162 	bls.w	8039af4 <tfm_app_menu+0x32c>
  status = psa_ps_remove(uid);
 8039830:	2002      	movs	r0, #2
 8039832:	2100      	movs	r1, #0
          ret.val = TEST_FAILED;
 8039834:	f88d 3008 	strb.w	r3, [sp, #8]
  status = psa_ps_remove(uid);
 8039838:	f002 faf9 	bl	803be2e <psa_ps_remove>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 803983c:	2800      	cmp	r0, #0
 803983e:	bf12      	itee	ne
 8039840:	2301      	movne	r3, #1
 8039842:	2300      	moveq	r3, #0
          printf("SST remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039844:	4629      	moveq	r1, r5
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 8039846:	f88d 3008 	strb.w	r3, [sp, #8]
          printf("SST remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 803984a:	bf18      	it	ne
 803984c:	4631      	movne	r1, r6
 803984e:	4898      	ldr	r0, [pc, #608]	; (8039ab0 <tfm_app_menu+0x2e8>)
 8039850:	e114      	b.n	8039a7c <tfm_app_menu+0x2b4>
      switch (key)
 8039852:	2b39      	cmp	r3, #57	; 0x39
 8039854:	f000 817d 	beq.w	8039b52 <tfm_app_menu+0x38a>
 8039858:	d80b      	bhi.n	8039872 <tfm_app_menu+0xaa>
 803985a:	2b37      	cmp	r3, #55	; 0x37
 803985c:	f000 8172 	beq.w	8039b44 <tfm_app_menu+0x37c>
 8039860:	2b38      	cmp	r3, #56	; 0x38
 8039862:	d1da      	bne.n	803981a <tfm_app_menu+0x52>
          ret.val = TEST_FAILED;
 8039864:	2301      	movs	r3, #1
 8039866:	a806      	add	r0, sp, #24
 8039868:	f800 3d10 	strb.w	r3, [r0, #-16]!
          tfm_its_read_uid(&ret);
 803986c:	f7ff fee8 	bl	8039640 <tfm_its_read_uid.isra.4>
 8039870:	e152      	b.n	8039b18 <tfm_app_menu+0x350>
      switch (key)
 8039872:	2b62      	cmp	r3, #98	; 0x62
 8039874:	f000 8175 	beq.w	8039b62 <tfm_app_menu+0x39a>
 8039878:	2b78      	cmp	r3, #120	; 0x78
 803987a:	f000 8181 	beq.w	8039b80 <tfm_app_menu+0x3b8>
 803987e:	2b61      	cmp	r3, #97	; 0x61
 8039880:	d1cb      	bne.n	803981a <tfm_app_menu+0x52>
          ret.val = TEST_FAILED;
 8039882:	2301      	movs	r3, #1
 8039884:	a906      	add	r1, sp, #24
 8039886:	f801 3d10 	strb.w	r3, [r1, #-16]!
          psa_hash_test(PSA_ALG_SHA_224, &ret);
 803988a:	488a      	ldr	r0, [pc, #552]	; (8039ab4 <tfm_app_menu+0x2ec>)
 803988c:	f002 fcd8 	bl	803c240 <psa_hash_test>
          printf("SHA224 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039890:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039894:	4888      	ldr	r0, [pc, #544]	; (8039ab8 <tfm_app_menu+0x2f0>)
 8039896:	2900      	cmp	r1, #0
 8039898:	bf0c      	ite	eq
 803989a:	4629      	moveq	r1, r5
 803989c:	4631      	movne	r1, r6
 803989e:	e0ed      	b.n	8039a7c <tfm_app_menu+0x2b4>
          ret.val = TEST_FAILED;
 80398a0:	f04f 0801 	mov.w	r8, #1
 80398a4:	af06      	add	r7, sp, #24
 80398a6:	f807 8d10 	strb.w	r8, [r7, #-16]!
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_GCM, &ret);
 80398aa:	463a      	mov	r2, r7
 80398ac:	4649      	mov	r1, r9
 80398ae:	4883      	ldr	r0, [pc, #524]	; (8039abc <tfm_app_menu+0x2f4>)
 80398b0:	f002 fd6a 	bl	803c388 <psa_aead_test>
          printf("AES GCM test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80398b4:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80398b8:	4881      	ldr	r0, [pc, #516]	; (8039ac0 <tfm_app_menu+0x2f8>)
 80398ba:	2900      	cmp	r1, #0
 80398bc:	bf0c      	ite	eq
 80398be:	4629      	moveq	r1, r5
 80398c0:	4631      	movne	r1, r6
 80398c2:	f002 ff11 	bl	803c6e8 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80398c6:	f89d 4008 	ldrb.w	r4, [sp, #8]
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
 80398ca:	463a      	mov	r2, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80398cc:	fab4 f484 	clz	r4, r4
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
 80398d0:	497c      	ldr	r1, [pc, #496]	; (8039ac4 <tfm_app_menu+0x2fc>)
 80398d2:	487a      	ldr	r0, [pc, #488]	; (8039abc <tfm_app_menu+0x2f4>)
          ret.val = TEST_FAILED;
 80398d4:	f88d 8008 	strb.w	r8, [sp, #8]
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
 80398d8:	f002 face 	bl	803be78 <psa_cipher_test>
          printf("AES CBC test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80398dc:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80398e0:	4879      	ldr	r0, [pc, #484]	; (8039ac8 <tfm_app_menu+0x300>)
 80398e2:	2900      	cmp	r1, #0
 80398e4:	bf0c      	ite	eq
 80398e6:	4629      	moveq	r1, r5
 80398e8:	4631      	movne	r1, r6
 80398ea:	f002 fefd 	bl	803c6e8 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80398ee:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80398f2:	0964      	lsrs	r4, r4, #5
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80398f4:	2b00      	cmp	r3, #0
 80398f6:	bf08      	it	eq
 80398f8:	3401      	addeq	r4, #1
          tfm_sst_set_uid(&ret);
 80398fa:	4638      	mov	r0, r7
 80398fc:	f7ff fe20 	bl	8039540 <tfm_sst_set_uid.isra.0>
          printf("SST set UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039900:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039904:	4871      	ldr	r0, [pc, #452]	; (8039acc <tfm_app_menu+0x304>)
 8039906:	2900      	cmp	r1, #0
 8039908:	bf0c      	ite	eq
 803990a:	4629      	moveq	r1, r5
 803990c:	4631      	movne	r1, r6
 803990e:	f002 feeb 	bl	803c6e8 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039912:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tfm_sst_read_uid(&ret);
 8039916:	4638      	mov	r0, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039918:	2b00      	cmp	r3, #0
 803991a:	bf08      	it	eq
 803991c:	3401      	addeq	r4, #1
          tfm_sst_read_uid(&ret);
 803991e:	f7ff fe31 	bl	8039584 <tfm_sst_read_uid.isra.1>
          printf("SST read / check UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039922:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039926:	486a      	ldr	r0, [pc, #424]	; (8039ad0 <tfm_app_menu+0x308>)
 8039928:	2900      	cmp	r1, #0
 803992a:	bf0c      	ite	eq
 803992c:	4629      	moveq	r1, r5
 803992e:	4631      	movne	r1, r6
 8039930:	f002 feda 	bl	803c6e8 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039934:	f89d 3008 	ldrb.w	r3, [sp, #8]
  status = psa_ps_remove(uid);
 8039938:	2100      	movs	r1, #0
 803993a:	2002      	movs	r0, #2
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 803993c:	2b00      	cmp	r3, #0
 803993e:	bf08      	it	eq
 8039940:	3401      	addeq	r4, #1
  status = psa_ps_remove(uid);
 8039942:	f002 fa74 	bl	803be2e <psa_ps_remove>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 8039946:	2800      	cmp	r0, #0
 8039948:	bf13      	iteet	ne
 803994a:	4643      	movne	r3, r8
 803994c:	2300      	moveq	r3, #0
          printf("SST remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 803994e:	4629      	moveq	r1, r5
 8039950:	4631      	movne	r1, r6
 8039952:	4857      	ldr	r0, [pc, #348]	; (8039ab0 <tfm_app_menu+0x2e8>)
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 8039954:	f88d 3008 	strb.w	r3, [sp, #8]
          printf("SST remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039958:	f002 fec6 	bl	803c6e8 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 803995c:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tfm_eat_test_circuit_sig(TOKEN_OPT_NORMAL_CIRCUIT_SIGN, &ret);
 8039960:	4638      	mov	r0, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039962:	2b00      	cmp	r3, #0
 8039964:	bf08      	it	eq
 8039966:	3401      	addeq	r4, #1
          ret.val = TEST_FAILED;
 8039968:	f88d 8008 	strb.w	r8, [sp, #8]
          tfm_eat_test_circuit_sig(TOKEN_OPT_NORMAL_CIRCUIT_SIGN, &ret);
 803996c:	f7ff fed2 	bl	8039714 <tfm_eat_test_circuit_sig.isra.6.constprop.7>
          printf("EAT normal circuit sig test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039970:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039974:	4857      	ldr	r0, [pc, #348]	; (8039ad4 <tfm_app_menu+0x30c>)
 8039976:	2900      	cmp	r1, #0
 8039978:	bf0c      	ite	eq
 803997a:	4629      	moveq	r1, r5
 803997c:	4631      	movne	r1, r6
 803997e:	f002 feb3 	bl	803c6e8 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039982:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tfm_its_set_uid(&ret);
 8039986:	4638      	mov	r0, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039988:	2b00      	cmp	r3, #0
 803998a:	bf08      	it	eq
 803998c:	3401      	addeq	r4, #1
          tfm_its_set_uid(&ret);
 803998e:	f7ff fe35 	bl	80395fc <tfm_its_set_uid.isra.3>
          printf("ITS set UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039992:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039996:	4850      	ldr	r0, [pc, #320]	; (8039ad8 <tfm_app_menu+0x310>)
 8039998:	2900      	cmp	r1, #0
 803999a:	bf0c      	ite	eq
 803999c:	4629      	moveq	r1, r5
 803999e:	4631      	movne	r1, r6
 80399a0:	f002 fea2 	bl	803c6e8 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80399a4:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tfm_its_read_uid(&ret);
 80399a8:	4638      	mov	r0, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80399aa:	2b00      	cmp	r3, #0
 80399ac:	bf08      	it	eq
 80399ae:	3401      	addeq	r4, #1
          tfm_its_read_uid(&ret);
 80399b0:	f7ff fe46 	bl	8039640 <tfm_its_read_uid.isra.4>
          printf("ITS read / check UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80399b4:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80399b8:	4848      	ldr	r0, [pc, #288]	; (8039adc <tfm_app_menu+0x314>)
 80399ba:	2900      	cmp	r1, #0
 80399bc:	bf0c      	ite	eq
 80399be:	4629      	moveq	r1, r5
 80399c0:	4631      	movne	r1, r6
 80399c2:	f002 fe91 	bl	803c6e8 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80399c6:	f89d 3008 	ldrb.w	r3, [sp, #8]
  status = psa_its_remove(uid);
 80399ca:	2100      	movs	r1, #0
 80399cc:	2002      	movs	r0, #2
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80399ce:	2b00      	cmp	r3, #0
 80399d0:	bf08      	it	eq
 80399d2:	3401      	addeq	r4, #1
  status = psa_its_remove(uid);
 80399d4:	f002 f984 	bl	803bce0 <psa_its_remove>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 80399d8:	2800      	cmp	r0, #0
 80399da:	bf13      	iteet	ne
 80399dc:	4643      	movne	r3, r8
 80399de:	2300      	moveq	r3, #0
          printf("ITS remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80399e0:	4629      	moveq	r1, r5
 80399e2:	4631      	movne	r1, r6
 80399e4:	483e      	ldr	r0, [pc, #248]	; (8039ae0 <tfm_app_menu+0x318>)
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 80399e6:	f88d 3008 	strb.w	r3, [sp, #8]
          printf("ITS remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80399ea:	f002 fe7d 	bl	803c6e8 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80399ee:	f89d 3008 	ldrb.w	r3, [sp, #8]
          psa_hash_test(PSA_ALG_SHA_224, &ret);
 80399f2:	4639      	mov	r1, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80399f4:	2b00      	cmp	r3, #0
 80399f6:	bf08      	it	eq
 80399f8:	3401      	addeq	r4, #1
          psa_hash_test(PSA_ALG_SHA_224, &ret);
 80399fa:	482e      	ldr	r0, [pc, #184]	; (8039ab4 <tfm_app_menu+0x2ec>)
          ret.val = TEST_FAILED;
 80399fc:	f88d 8008 	strb.w	r8, [sp, #8]
          psa_hash_test(PSA_ALG_SHA_224, &ret);
 8039a00:	f002 fc1e 	bl	803c240 <psa_hash_test>
          printf("SHA224 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039a04:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039a08:	482b      	ldr	r0, [pc, #172]	; (8039ab8 <tfm_app_menu+0x2f0>)
 8039a0a:	2900      	cmp	r1, #0
 8039a0c:	bf0c      	ite	eq
 8039a0e:	4629      	moveq	r1, r5
 8039a10:	4631      	movne	r1, r6
 8039a12:	f002 fe69 	bl	803c6e8 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039a16:	f89d 1008 	ldrb.w	r1, [sp, #8]
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039a1a:	b2e4      	uxtb	r4, r4
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039a1c:	2900      	cmp	r1, #0
 8039a1e:	bf08      	it	eq
 8039a20:	3401      	addeq	r4, #1
          psa_hash_test(PSA_ALG_SHA_256, &ret);
 8039a22:	4830      	ldr	r0, [pc, #192]	; (8039ae4 <tfm_app_menu+0x31c>)
 8039a24:	4639      	mov	r1, r7
          ret.val = TEST_FAILED;
 8039a26:	f88d 8008 	strb.w	r8, [sp, #8]
          psa_hash_test(PSA_ALG_SHA_256, &ret);
 8039a2a:	f002 fc09 	bl	803c240 <psa_hash_test>
          printf("SHA256 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039a2e:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039a32:	482d      	ldr	r0, [pc, #180]	; (8039ae8 <tfm_app_menu+0x320>)
 8039a34:	2900      	cmp	r1, #0
 8039a36:	bf0c      	ite	eq
 8039a38:	4629      	moveq	r1, r5
 8039a3a:	4631      	movne	r1, r6
 8039a3c:	f002 fe54 	bl	803c6e8 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039a40:	f89d 1008 	ldrb.w	r1, [sp, #8]
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039a44:	b2e4      	uxtb	r4, r4
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039a46:	2900      	cmp	r1, #0
 8039a48:	bf14      	ite	ne
 8039a4a:	4621      	movne	r1, r4
 8039a4c:	1c61      	addeq	r1, r4, #1
          printf("CUMULATIVE RESULT: %d/%d success\r\n", tests_success, tests_executed);
 8039a4e:	220b      	movs	r2, #11
 8039a50:	b2c9      	uxtb	r1, r1
 8039a52:	4826      	ldr	r0, [pc, #152]	; (8039aec <tfm_app_menu+0x324>)
 8039a54:	f002 fe48 	bl	803c6e8 <iprintf>
          tfm_app_print_menu();
 8039a58:	f7ff fd28 	bl	80394ac <tfm_app_print_menu>
          break;
 8039a5c:	e6c0      	b.n	80397e0 <tfm_app_menu+0x18>
          ret.val = TEST_FAILED;
 8039a5e:	2301      	movs	r3, #1
 8039a60:	aa06      	add	r2, sp, #24
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_GCM, &ret);
 8039a62:	4649      	mov	r1, r9
 8039a64:	4815      	ldr	r0, [pc, #84]	; (8039abc <tfm_app_menu+0x2f4>)
          ret.val = TEST_FAILED;
 8039a66:	f802 3d10 	strb.w	r3, [r2, #-16]!
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_GCM, &ret);
 8039a6a:	f002 fc8d 	bl	803c388 <psa_aead_test>
          printf("AES GCM test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039a6e:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039a72:	4813      	ldr	r0, [pc, #76]	; (8039ac0 <tfm_app_menu+0x2f8>)
 8039a74:	2900      	cmp	r1, #0
 8039a76:	bf0c      	ite	eq
 8039a78:	4629      	moveq	r1, r5
 8039a7a:	4631      	movne	r1, r6
          printf("SHA256 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039a7c:	f002 fe34 	bl	803c6e8 <iprintf>
 8039a80:	e7ea      	b.n	8039a58 <tfm_app_menu+0x290>
          ret.val = TEST_FAILED;
 8039a82:	2301      	movs	r3, #1
 8039a84:	aa06      	add	r2, sp, #24
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
 8039a86:	490f      	ldr	r1, [pc, #60]	; (8039ac4 <tfm_app_menu+0x2fc>)
 8039a88:	480c      	ldr	r0, [pc, #48]	; (8039abc <tfm_app_menu+0x2f4>)
          ret.val = TEST_FAILED;
 8039a8a:	f802 3d10 	strb.w	r3, [r2, #-16]!
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
 8039a8e:	f002 f9f3 	bl	803be78 <psa_cipher_test>
          printf("AES CBC test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039a92:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039a96:	480c      	ldr	r0, [pc, #48]	; (8039ac8 <tfm_app_menu+0x300>)
 8039a98:	2900      	cmp	r1, #0
 8039a9a:	bf0c      	ite	eq
 8039a9c:	4629      	moveq	r1, r5
 8039a9e:	4631      	movne	r1, r6
 8039aa0:	e7ec      	b.n	8039a7c <tfm_app_menu+0x2b4>
 8039aa2:	bf00      	nop
 8039aa4:	0803e4fa 	.word	0x0803e4fa
 8039aa8:	0803e506 	.word	0x0803e506
 8039aac:	0803dd95 	.word	0x0803dd95
 8039ab0:	0803e566 	.word	0x0803e566
 8039ab4:	01000008 	.word	0x01000008
 8039ab8:	0803e5ee 	.word	0x0803e5ee
 8039abc:	40000001 	.word	0x40000001
 8039ac0:	0803e50d 	.word	0x0803e50d
 8039ac4:	04600100 	.word	0x04600100
 8039ac8:	0803e51f 	.word	0x0803e51f
 8039acc:	0803e531 	.word	0x0803e531
 8039ad0:	0803e547 	.word	0x0803e547
 8039ad4:	0803e57f 	.word	0x0803e57f
 8039ad8:	0803e5a0 	.word	0x0803e5a0
 8039adc:	0803e5b6 	.word	0x0803e5b6
 8039ae0:	0803e5d5 	.word	0x0803e5d5
 8039ae4:	01000009 	.word	0x01000009
 8039ae8:	0803e5ff 	.word	0x0803e5ff
 8039aec:	0803e610 	.word	0x0803e610
 8039af0:	06001002 	.word	0x06001002
          ret.val = TEST_FAILED;
 8039af4:	a806      	add	r0, sp, #24
 8039af6:	f800 3d10 	strb.w	r3, [r0, #-16]!
          tfm_sst_set_uid(&ret);
 8039afa:	f7ff fd21 	bl	8039540 <tfm_sst_set_uid.isra.0>
          printf("SST set UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039afe:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039b02:	4821      	ldr	r0, [pc, #132]	; (8039b88 <tfm_app_menu+0x3c0>)
 8039b04:	2900      	cmp	r1, #0
 8039b06:	bf0c      	ite	eq
 8039b08:	4629      	moveq	r1, r5
 8039b0a:	4631      	movne	r1, r6
 8039b0c:	e7b6      	b.n	8039a7c <tfm_app_menu+0x2b4>
          ret.val = TEST_FAILED;
 8039b0e:	a806      	add	r0, sp, #24
 8039b10:	f800 3d10 	strb.w	r3, [r0, #-16]!
          tfm_sst_read_uid(&ret);
 8039b14:	f7ff fd36 	bl	8039584 <tfm_sst_read_uid.isra.1>
          printf("SST read / check UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039b18:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039b1c:	481b      	ldr	r0, [pc, #108]	; (8039b8c <tfm_app_menu+0x3c4>)
 8039b1e:	2900      	cmp	r1, #0
 8039b20:	bf0c      	ite	eq
 8039b22:	4629      	moveq	r1, r5
 8039b24:	4631      	movne	r1, r6
 8039b26:	e7a9      	b.n	8039a7c <tfm_app_menu+0x2b4>
          ret.val = TEST_FAILED;
 8039b28:	2301      	movs	r3, #1
 8039b2a:	a806      	add	r0, sp, #24
 8039b2c:	f800 3d10 	strb.w	r3, [r0, #-16]!
          tfm_eat_test_circuit_sig(TOKEN_OPT_NORMAL_CIRCUIT_SIGN, &ret);
 8039b30:	f7ff fdf0 	bl	8039714 <tfm_eat_test_circuit_sig.isra.6.constprop.7>
          printf("EAT normal circuit sig test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039b34:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039b38:	4815      	ldr	r0, [pc, #84]	; (8039b90 <tfm_app_menu+0x3c8>)
 8039b3a:	2900      	cmp	r1, #0
 8039b3c:	bf0c      	ite	eq
 8039b3e:	4629      	moveq	r1, r5
 8039b40:	4631      	movne	r1, r6
 8039b42:	e79b      	b.n	8039a7c <tfm_app_menu+0x2b4>
          ret.val = TEST_FAILED;
 8039b44:	2301      	movs	r3, #1
 8039b46:	a806      	add	r0, sp, #24
 8039b48:	f800 3d10 	strb.w	r3, [r0, #-16]!
          tfm_its_set_uid(&ret);
 8039b4c:	f7ff fd56 	bl	80395fc <tfm_its_set_uid.isra.3>
 8039b50:	e7d5      	b.n	8039afe <tfm_app_menu+0x336>
          ret.val = TEST_FAILED;
 8039b52:	2301      	movs	r3, #1
  status = psa_its_remove(uid);
 8039b54:	2100      	movs	r1, #0
 8039b56:	2002      	movs	r0, #2
          ret.val = TEST_FAILED;
 8039b58:	f88d 3008 	strb.w	r3, [sp, #8]
  status = psa_its_remove(uid);
 8039b5c:	f002 f8c0 	bl	803bce0 <psa_its_remove>
 8039b60:	e66c      	b.n	803983c <tfm_app_menu+0x74>
          ret.val = TEST_FAILED;
 8039b62:	2301      	movs	r3, #1
 8039b64:	a906      	add	r1, sp, #24
 8039b66:	f801 3d10 	strb.w	r3, [r1, #-16]!
          psa_hash_test(PSA_ALG_SHA_256, &ret);
 8039b6a:	480a      	ldr	r0, [pc, #40]	; (8039b94 <tfm_app_menu+0x3cc>)
 8039b6c:	f002 fb68 	bl	803c240 <psa_hash_test>
          printf("SHA256 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039b70:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039b74:	4808      	ldr	r0, [pc, #32]	; (8039b98 <tfm_app_menu+0x3d0>)
 8039b76:	2900      	cmp	r1, #0
 8039b78:	bf0c      	ite	eq
 8039b7a:	4629      	moveq	r1, r5
 8039b7c:	4631      	movne	r1, r6
 8039b7e:	e77d      	b.n	8039a7c <tfm_app_menu+0x2b4>
}
 8039b80:	b007      	add	sp, #28
 8039b82:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8039b86:	bf00      	nop
 8039b88:	0803e531 	.word	0x0803e531
 8039b8c:	0803e547 	.word	0x0803e547
 8039b90:	0803e57f 	.word	0x0803e57f
 8039b94:	01000009 	.word	0x01000009
 8039b98:	0803e5ff 	.word	0x0803e5ff

08039b9c <tfm_ns_interface_dispatch>:
  * \brief NS world, NS lock based dispatcher
  */
int32_t tfm_ns_interface_dispatch(veneer_fn fn,
                                  uint32_t arg0, uint32_t arg1,
                                  uint32_t arg2, uint32_t arg3)
{
 8039b9c:	b570      	push	{r4, r5, r6, lr}
 8039b9e:	4606      	mov	r6, r0
 8039ba0:	4608      	mov	r0, r1
 8039ba2:	4611      	mov	r1, r2
 8039ba4:	461a      	mov	r2, r3
__STATIC_FORCEINLINE uint8_t __LDREXB(volatile uint8_t *addr)
{
    uint32_t result;

#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
 8039ba6:	4c08      	ldr	r4, [pc, #32]	; (8039bc8 <tfm_ns_interface_dispatch+0x2c>)
 8039ba8:	e8d4 3f4f 	ldrexb	r3, [r4]
    newValue = __LDREXB(valuePtr) + delta;
 8039bac:	3301      	adds	r3, #1
 8039bae:	b2db      	uxtb	r3, r3
 */
__STATIC_FORCEINLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
{
   uint32_t result;

   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
 8039bb0:	e8c4 3f45 	strexb	r5, r3, [r4]
  } while (__STREXB(newValue, valuePtr));
 8039bb4:	2d00      	cmp	r5, #0
 8039bb6:	d1f7      	bne.n	8039ba8 <tfm_ns_interface_dispatch+0xc>
  uint32_t ret;
  /*  We're only supporting a single user of RNG */
  if (core_util_atomic_incr_u8(&users, 1) > 1)
 8039bb8:	2b01      	cmp	r3, #1
 8039bba:	d900      	bls.n	8039bbe <tfm_ns_interface_dispatch+0x22>
 8039bbc:	e7fe      	b.n	8039bbc <tfm_ns_interface_dispatch+0x20>
  {
    while (1);
  }
  ret = (uint32_t)fn(arg0, arg1, arg2, arg3);
 8039bbe:	9b04      	ldr	r3, [sp, #16]
 8039bc0:	47b0      	blx	r6
  users = 0;
 8039bc2:	7025      	strb	r5, [r4, #0]
  return ret;
}
 8039bc4:	bd70      	pop	{r4, r5, r6, pc}
 8039bc6:	bf00      	nop
 8039bc8:	20000248 	.word	0x20000248

08039bcc <Ymodem_Init>:
  * @param None.
  * @retval None.
  */
void Ymodem_Init(void)
{
  __HAL_RCC_CRC_CLK_ENABLE();
 8039bcc:	4b11      	ldr	r3, [pc, #68]	; (8039c14 <Ymodem_Init+0x48>)
{
 8039bce:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_CRC_CLK_ENABLE();
 8039bd0:	6c9a      	ldr	r2, [r3, #72]	; 0x48
  /*-1- Configure the CRC peripheral */
  CrcHandle.Instance = CRC;

  /* The CRC-16-CCIT polynomial is used */
  CrcHandle.Init.DefaultPolynomialUse    = DEFAULT_POLYNOMIAL_DISABLE;
  CrcHandle.Init.GeneratingPolynomial    = 0x1021U;
 8039bd2:	4811      	ldr	r0, [pc, #68]	; (8039c18 <Ymodem_Init+0x4c>)
  __HAL_RCC_CRC_CLK_ENABLE();
 8039bd4:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8039bd8:	649a      	str	r2, [r3, #72]	; 0x48
 8039bda:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
 8039bdc:	f241 0221 	movw	r2, #4129	; 0x1021
  __HAL_RCC_CRC_CLK_ENABLE();
 8039be0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8039be4:	9301      	str	r3, [sp, #4]
 8039be6:	9b01      	ldr	r3, [sp, #4]
  CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
 8039be8:	2308      	movs	r3, #8
 8039bea:	e9c0 2302 	strd	r2, r3, [r0, #8]
  CrcHandle.Instance = CRC;
 8039bee:	4b0b      	ldr	r3, [pc, #44]	; (8039c1c <Ymodem_Init+0x50>)
 8039bf0:	6003      	str	r3, [r0, #0]
 8039bf2:	f240 1301 	movw	r3, #257	; 0x101
 8039bf6:	8083      	strh	r3, [r0, #4]

  /* The zero init value is used */
  CrcHandle.Init.DefaultInitValueUse     = DEFAULT_INIT_VALUE_DISABLE;
  CrcHandle.Init.InitValue               = 0U;
 8039bf8:	2300      	movs	r3, #0

  /* The input data are not inverted */
  CrcHandle.Init.InputDataInversionMode  = CRC_INPUTDATA_INVERSION_NONE;
 8039bfa:	e9c0 3304 	strd	r3, r3, [r0, #16]

  /* The output data are not inverted */
  CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 8039bfe:	6183      	str	r3, [r0, #24]

  /* The input data are 32-bit long words */
  CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT_BYTES;
 8039c00:	2301      	movs	r3, #1
 8039c02:	6203      	str	r3, [r0, #32]

  if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
 8039c04:	f000 fa5e 	bl	803a0c4 <HAL_CRC_Init>
 8039c08:	b100      	cbz	r0, 8039c0c <Ymodem_Init+0x40>
 8039c0a:	e7fe      	b.n	8039c0a <Ymodem_Init+0x3e>
  {
    /* Initialization Error */
    while (1);
  }
}
 8039c0c:	b003      	add	sp, #12
 8039c0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8039c12:	bf00      	nop
 8039c14:	40021000 	.word	0x40021000
 8039c18:	2000024c 	.word	0x2000024c
 8039c1c:	40023000 	.word	0x40023000

08039c20 <Ymodem_Receive>:
  * @param  puSize The uSize of the file.
  * @param  uFlashDestination where the file has to be downloaded.
  * @retval COM_StatusTypeDef result of reception/programming
  */
COM_StatusTypeDef Ymodem_Receive(uint32_t *puSize, uint32_t uFlashDestination)
{
 8039c20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t ramsource, filesize;
  uint8_t *file_ptr;
  uint8_t file_size[FILE_SIZE_LENGTH + 1U], tmp;
  uint32_t packets_received;
  COM_StatusTypeDef e_result = COM_OK;
  uint32_t cause = 0;
 8039c24:	2500      	movs	r5, #0
{
 8039c26:	4681      	mov	r9, r0
 8039c28:	468a      	mov	sl, r1
  uint32_t i, packet_length, session_done = 0U, file_done, errors = 0U, session_begin = 0U;
 8039c2a:	46ab      	mov	fp, r5
    *pData = char1;
 8039c2c:	4f9a      	ldr	r7, [pc, #616]	; (8039e98 <Ymodem_Receive+0x278>)
{
 8039c2e:	b08b      	sub	sp, #44	; 0x2c
 8039c30:	2600      	movs	r6, #0
 8039c32:	e0e2      	b.n	8039dfa <Ymodem_Receive+0x1da>
    switch (char1)
 8039c34:	2a61      	cmp	r2, #97	; 0x61
 8039c36:	d003      	beq.n	8039c40 <Ymodem_Receive+0x20>
 8039c38:	2a72      	cmp	r2, #114	; 0x72
 8039c3a:	d053      	beq.n	8039ce4 <Ymodem_Receive+0xc4>
 8039c3c:	2a41      	cmp	r2, #65	; 0x41
 8039c3e:	d163      	bne.n	8039d08 <Ymodem_Receive+0xe8>
        status = HAL_BUSY;
 8039c40:	2302      	movs	r3, #2
  uint32_t packet_size = 0U;
 8039c42:	2400      	movs	r4, #0
 8039c44:	e001      	b.n	8039c4a <Ymodem_Receive+0x2a>
        packet_size = PACKET_1K_SIZE;
 8039c46:	f44f 6480 	mov.w	r4, #1024	; 0x400
    *pData = char1;
 8039c4a:	f89d 200f 	ldrb.w	r2, [sp, #15]
    if (packet_size >= PACKET_SIZE)
 8039c4e:	2c7f      	cmp	r4, #127	; 0x7f
    *pData = char1;
 8039c50:	703a      	strb	r2, [r7, #0]
    if (packet_size >= PACKET_SIZE)
 8039c52:	d95d      	bls.n	8039d10 <Ymodem_Receive+0xf0>
      status = COM_Receive(&pData[PACKET_NUMBER_INDEX], packet_size + PACKET_OVERHEAD_SIZE, uTimeout);
 8039c54:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8039c58:	1d21      	adds	r1, r4, #4
 8039c5a:	4890      	ldr	r0, [pc, #576]	; (8039e9c <Ymodem_Receive+0x27c>)
 8039c5c:	f7fe feae 	bl	80389bc <COM_Receive>
      if (status == HAL_OK)
 8039c60:	4603      	mov	r3, r0
 8039c62:	2800      	cmp	r0, #0
 8039c64:	d155      	bne.n	8039d12 <Ymodem_Receive+0xf2>
        if (pData[PACKET_NUMBER_INDEX] != ((pData[PACKET_CNUMBER_INDEX]) ^ NEGATIVE_BYTE))
 8039c66:	78fb      	ldrb	r3, [r7, #3]
 8039c68:	78ba      	ldrb	r2, [r7, #2]
 8039c6a:	43db      	mvns	r3, r3
 8039c6c:	b2db      	uxtb	r3, r3
 8039c6e:	429a      	cmp	r2, r3
 8039c70:	d152      	bne.n	8039d18 <Ymodem_Receive+0xf8>
          crc = pData[ packet_size + PACKET_DATA_INDEX ] << 8U;
 8039c72:	193a      	adds	r2, r7, r4
 8039c74:	7911      	ldrb	r1, [r2, #4]
          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
 8039c76:	7953      	ldrb	r3, [r2, #5]
          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
 8039c78:	4889      	ldr	r0, [pc, #548]	; (8039ea0 <Ymodem_Receive+0x280>)
          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
 8039c7a:	eb03 2301 	add.w	r3, r3, r1, lsl #8
          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
 8039c7e:	4622      	mov	r2, r4
 8039c80:	4988      	ldr	r1, [pc, #544]	; (8039ea4 <Ymodem_Receive+0x284>)
          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
 8039c82:	9301      	str	r3, [sp, #4]
          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
 8039c84:	f000 fa58 	bl	803a138 <HAL_CRC_Calculate>
 8039c88:	9b01      	ldr	r3, [sp, #4]
 8039c8a:	4283      	cmp	r3, r0
 8039c8c:	d144      	bne.n	8039d18 <Ymodem_Receive+0xf8>
              *puSize = filesize;
              file_done = 1U;
              break;
            default:
              /* Normal packet */
              if (m_aPacketData[PACKET_NUMBER_INDEX] != (packets_received & 0xff))
 8039c8e:	78ba      	ldrb	r2, [r7, #2]
 8039c90:	b2f3      	uxtb	r3, r6
 8039c92:	429a      	cmp	r2, r3
 8039c94:	f040 80b1 	bne.w	8039dfa <Ymodem_Receive+0x1da>
              {
                /*             Serial_PutByte(NAK);*/
              }
              else
              {
                if (packets_received == 0U)
 8039c98:	2e00      	cmp	r6, #0
 8039c9a:	f040 80ce 	bne.w	8039e3a <Ymodem_Receive+0x21a>
                {
                  /* File name packet */
                  if (m_aPacketData[PACKET_DATA_INDEX] != 0U)
 8039c9e:	793b      	ldrb	r3, [r7, #4]
 8039ca0:	2b00      	cmp	r3, #0
 8039ca2:	f040 8091 	bne.w	8039dc8 <Ymodem_Receive+0x1a8>

                  }
                  /* File header packet is empty, end session */
                  else
                  {
                    Serial_PutByte(ACK);
 8039ca6:	2006      	movs	r0, #6
 8039ca8:	f7fe feec 	bl	8038a84 <Serial_PutByte>
 8039cac:	4634      	mov	r4, r6
                    file_done = 1;
                    session_done = 1;
                    cause = 3;
 8039cae:	2503      	movs	r5, #3
    }
  }
#if defined(__ARMCC_VERSION)
  printf("e_result = %x , %u\n", e_result, cause);
#else
  printf("e_result = %x , %lu\n", e_result, cause);
 8039cb0:	462a      	mov	r2, r5
 8039cb2:	4621      	mov	r1, r4
 8039cb4:	487c      	ldr	r0, [pc, #496]	; (8039ea8 <Ymodem_Receive+0x288>)
 8039cb6:	f002 fd17 	bl	803c6e8 <iprintf>
#endif /* __ARMCC_VERSION */
  return e_result;
}
 8039cba:	4620      	mov	r0, r4
 8039cbc:	b00b      	add	sp, #44	; 0x2c
 8039cbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((COM_Receive(&char1, 1U, uTimeout) == HAL_OK) && (char1 == CA))
 8039cc2:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8039cc6:	2101      	movs	r1, #1
 8039cc8:	f10d 000f 	add.w	r0, sp, #15
 8039ccc:	f7fe fe76 	bl	80389bc <COM_Receive>
 8039cd0:	4603      	mov	r3, r0
 8039cd2:	b9d8      	cbnz	r0, 8039d0c <Ymodem_Receive+0xec>
 8039cd4:	f89d 200f 	ldrb.w	r2, [sp, #15]
          packet_size = 2U;
 8039cd8:	2a18      	cmp	r2, #24
 8039cda:	bf16      	itet	ne
 8039cdc:	2400      	movne	r4, #0
 8039cde:	2402      	moveq	r4, #2
 8039ce0:	2301      	movne	r3, #1
 8039ce2:	e7b2      	b.n	8039c4a <Ymodem_Receive+0x2a>
 8039ce4:	9001      	str	r0, [sp, #4]
        COM_Receive(&char1, 1U, uTimeout);                /* Ymodem starup sequence : rb ==> 0x72 + 0x62 + 0x0D */
 8039ce6:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8039cea:	2101      	movs	r1, #1
 8039cec:	f10d 000f 	add.w	r0, sp, #15
 8039cf0:	f7fe fe64 	bl	80389bc <COM_Receive>
        COM_Receive(&char1, 1U, uTimeout);
 8039cf4:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8039cf8:	2101      	movs	r1, #1
 8039cfa:	f10d 000f 	add.w	r0, sp, #15
 8039cfe:	f7fe fe5d 	bl	80389bc <COM_Receive>
        packet_size = 3U;
 8039d02:	2403      	movs	r4, #3
 8039d04:	9b01      	ldr	r3, [sp, #4]
 8039d06:	e7a0      	b.n	8039c4a <Ymodem_Receive+0x2a>
        status = HAL_ERROR;
 8039d08:	2301      	movs	r3, #1
 8039d0a:	e79a      	b.n	8039c42 <Ymodem_Receive+0x22>
          status = HAL_ERROR;
 8039d0c:	2301      	movs	r3, #1
 8039d0e:	e79c      	b.n	8039c4a <Ymodem_Receive+0x2a>
      switch (ReceivePacket(m_aPacketData, &packet_length, DOWNLOAD_TIMEOUT))
 8039d10:	b193      	cbz	r3, 8039d38 <Ymodem_Receive+0x118>
 8039d12:	2b02      	cmp	r3, #2
 8039d14:	f000 80b0 	beq.w	8039e78 <Ymodem_Receive+0x258>
          if (session_begin > 0U)
 8039d18:	f1bb 0f00 	cmp.w	fp, #0
 8039d1c:	d001      	beq.n	8039d22 <Ymodem_Receive+0x102>
            errors ++;
 8039d1e:	f108 0801 	add.w	r8, r8, #1
          if (errors > MAX_ERRORS)
 8039d22:	f1b8 0f05 	cmp.w	r8, #5
 8039d26:	f240 80af 	bls.w	8039e88 <Ymodem_Receive+0x268>
            Serial_PutByte(CA);
 8039d2a:	2018      	movs	r0, #24
 8039d2c:	f7fe feaa 	bl	8038a84 <Serial_PutByte>
            Serial_PutByte(CA);
 8039d30:	2018      	movs	r0, #24
 8039d32:	f7fe fea7 	bl	8038a84 <Serial_PutByte>
 8039d36:	e062      	b.n	8039dfe <Ymodem_Receive+0x1de>
          switch (packet_length)
 8039d38:	2c02      	cmp	r4, #2
 8039d3a:	d00a      	beq.n	8039d52 <Ymodem_Receive+0x132>
 8039d3c:	2c03      	cmp	r4, #3
 8039d3e:	d05c      	beq.n	8039dfa <Ymodem_Receive+0x1da>
 8039d40:	2c00      	cmp	r4, #0
 8039d42:	d1a4      	bne.n	8039c8e <Ymodem_Receive+0x6e>
              Serial_PutByte(ACK);
 8039d44:	2006      	movs	r0, #6
 8039d46:	f7fe fe9d 	bl	8038a84 <Serial_PutByte>
              *puSize = filesize;
 8039d4a:	9b04      	ldr	r3, [sp, #16]
 8039d4c:	f8c9 3000 	str.w	r3, [r9]
 8039d50:	e76e      	b.n	8039c30 <Ymodem_Receive+0x10>
              Serial_PutByte(ACK);
 8039d52:	2006      	movs	r0, #6
 8039d54:	f7fe fe96 	bl	8038a84 <Serial_PutByte>
          switch (packet_length)
 8039d58:	2402      	movs	r4, #2
 8039d5a:	e7a9      	b.n	8039cb0 <Ymodem_Receive+0x90>
                      m_aFileName[i++] = *file_ptr++;
 8039d5c:	5483      	strb	r3, [r0, r2]
 8039d5e:	3201      	adds	r2, #1
                    while ((*file_ptr != 0U) && (i < FILE_NAME_LENGTH))
 8039d60:	f811 3b01 	ldrb.w	r3, [r1], #1
 8039d64:	b10b      	cbz	r3, 8039d6a <Ymodem_Receive+0x14a>
 8039d66:	2a40      	cmp	r2, #64	; 0x40
 8039d68:	d1f8      	bne.n	8039d5c <Ymodem_Receive+0x13c>
                    m_aFileName[i++] = '\0';
 8039d6a:	2300      	movs	r3, #0
 8039d6c:	5483      	strb	r3, [r0, r2]
 8039d6e:	a805      	add	r0, sp, #20
                    while ((*file_ptr != ' ') && (i < FILE_SIZE_LENGTH))
 8039d70:	5cca      	ldrb	r2, [r1, r3]
 8039d72:	2a20      	cmp	r2, #32
 8039d74:	d001      	beq.n	8039d7a <Ymodem_Receive+0x15a>
 8039d76:	2b10      	cmp	r3, #16
 8039d78:	d12a      	bne.n	8039dd0 <Ymodem_Receive+0x1b0>
                    file_size[i++] = '\0';
 8039d7a:	2400      	movs	r4, #0
 8039d7c:	aa0a      	add	r2, sp, #40	; 0x28
 8039d7e:	4413      	add	r3, r2
                    Str2Int(file_size, &filesize);
 8039d80:	a904      	add	r1, sp, #16
                    file_size[i++] = '\0';
 8039d82:	f803 4c14 	strb.w	r4, [r3, #-20]
                    Str2Int(file_size, &filesize);
 8039d86:	f7fe fe2f 	bl	80389e8 <Str2Int>
                    if ((uint32_t)filesize > *puSize)
 8039d8a:	9904      	ldr	r1, [sp, #16]
 8039d8c:	f8d9 3000 	ldr.w	r3, [r9]
 8039d90:	428b      	cmp	r3, r1
 8039d92:	d206      	bcs.n	8039da2 <Ymodem_Receive+0x182>
                      tmp = CA;
 8039d94:	2318      	movs	r3, #24
                      *puSize = 0;
 8039d96:	f8c9 4000 	str.w	r4, [r9]
                      cause = 1;
 8039d9a:	2501      	movs	r5, #1
                      e_result = COM_ABORT;
 8039d9c:	2402      	movs	r4, #2
                      tmp = CA;
 8039d9e:	f88d 300e 	strb.w	r3, [sp, #14]
                    if ((*puSize) && (Ymodem_HeaderPktRxCpltCallback(uFlashDestination, (uint32_t) filesize) == HAL_OK))
 8039da2:	f8d9 3000 	ldr.w	r3, [r9]
 8039da6:	b1b3      	cbz	r3, 8039dd6 <Ymodem_Receive+0x1b6>
 8039da8:	4650      	mov	r0, sl
 8039daa:	f7ff f849 	bl	8038e40 <Ymodem_HeaderPktRxCpltCallback>
 8039dae:	b990      	cbnz	r0, 8039dd6 <Ymodem_Receive+0x1b6>
                      Serial_PutByte(ACK);
 8039db0:	2006      	movs	r0, #6
 8039db2:	f7fe fe67 	bl	8038a84 <Serial_PutByte>
                      COM_Flush();
 8039db6:	f7fe fe09 	bl	80389cc <COM_Flush>
                      Serial_PutByte(CRC16);
 8039dba:	2043      	movs	r0, #67	; 0x43
 8039dbc:	f7fe fe62 	bl	8038a84 <Serial_PutByte>
                packets_received ++;
 8039dc0:	3601      	adds	r6, #1
                session_begin = 1U;
 8039dc2:	f04f 0b01 	mov.w	fp, #1
 8039dc6:	e015      	b.n	8039df4 <Ymodem_Receive+0x1d4>
 8039dc8:	4632      	mov	r2, r6
                    file_ptr = m_aPacketData + PACKET_DATA_INDEX;
 8039dca:	4936      	ldr	r1, [pc, #216]	; (8039ea4 <Ymodem_Receive+0x284>)
 8039dcc:	4837      	ldr	r0, [pc, #220]	; (8039eac <Ymodem_Receive+0x28c>)
 8039dce:	e7c7      	b.n	8039d60 <Ymodem_Receive+0x140>
                      file_size[i++] = *file_ptr++;
 8039dd0:	54c2      	strb	r2, [r0, r3]
 8039dd2:	3301      	adds	r3, #1
 8039dd4:	e7cc      	b.n	8039d70 <Ymodem_Receive+0x150>
                      COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 8039dd6:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8039dda:	2101      	movs	r1, #1
 8039ddc:	f10d 000e 	add.w	r0, sp, #14
 8039de0:	f7fe fde4 	bl	80389ac <COM_Transmit>
                      COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 8039de4:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8039de8:	2101      	movs	r1, #1
 8039dea:	f10d 000e 	add.w	r0, sp, #14
 8039dee:	f7fe fddd 	bl	80389ac <COM_Transmit>
                      cause = 2;
 8039df2:	2502      	movs	r5, #2
    while ((file_done == 0U) && (e_result == COM_OK))
 8039df4:	2c00      	cmp	r4, #0
 8039df6:	f47f af5b 	bne.w	8039cb0 <Ymodem_Receive+0x90>
 8039dfa:	f04f 0800 	mov.w	r8, #0
  status = (HAL_StatusTypeDef)COM_Receive(&char1, 1, uTimeout);
 8039dfe:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8039e02:	2101      	movs	r1, #1
 8039e04:	f10d 000f 	add.w	r0, sp, #15
 8039e08:	f7fe fdd8 	bl	80389bc <COM_Receive>
 8039e0c:	4603      	mov	r3, r0
 8039e0e:	4604      	mov	r4, r0
  if (status == HAL_OK)
 8039e10:	2800      	cmp	r0, #0
 8039e12:	f47f af7e 	bne.w	8039d12 <Ymodem_Receive+0xf2>
    switch (char1)
 8039e16:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8039e1a:	2a18      	cmp	r2, #24
 8039e1c:	f43f af51 	beq.w	8039cc2 <Ymodem_Receive+0xa2>
 8039e20:	f63f af08 	bhi.w	8039c34 <Ymodem_Receive+0x14>
 8039e24:	2a02      	cmp	r2, #2
 8039e26:	f43f af0e 	beq.w	8039c46 <Ymodem_Receive+0x26>
 8039e2a:	2a04      	cmp	r2, #4
 8039e2c:	f43f af09 	beq.w	8039c42 <Ymodem_Receive+0x22>
 8039e30:	2a01      	cmp	r2, #1
 8039e32:	f47f af69 	bne.w	8039d08 <Ymodem_Receive+0xe8>
        packet_size = PACKET_SIZE;
 8039e36:	2480      	movs	r4, #128	; 0x80
 8039e38:	e707      	b.n	8039c4a <Ymodem_Receive+0x2a>
                  if ((*puSize) && (Ymodem_DataPktRxCpltCallback((uint8_t *)
 8039e3a:	f8d9 3000 	ldr.w	r3, [r9]
 8039e3e:	b15b      	cbz	r3, 8039e58 <Ymodem_Receive+0x238>
 8039e40:	4622      	mov	r2, r4
 8039e42:	4651      	mov	r1, sl
 8039e44:	4817      	ldr	r0, [pc, #92]	; (8039ea4 <Ymodem_Receive+0x284>)
 8039e46:	f7ff f81b 	bl	8038e80 <Ymodem_DataPktRxCpltCallback>
 8039e4a:	b928      	cbnz	r0, 8039e58 <Ymodem_Receive+0x238>
                    Serial_PutByte(ACK);
 8039e4c:	2006      	movs	r0, #6
                    uFlashDestination += (packet_length);
 8039e4e:	44a2      	add	sl, r4
                    Serial_PutByte(ACK);
 8039e50:	f7fe fe18 	bl	8038a84 <Serial_PutByte>
                    COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 8039e54:	2400      	movs	r4, #0
 8039e56:	e7b3      	b.n	8039dc0 <Ymodem_Receive+0x1a0>
                    COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 8039e58:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8039e5c:	2101      	movs	r1, #1
 8039e5e:	f10d 000e 	add.w	r0, sp, #14
 8039e62:	f7fe fda3 	bl	80389ac <COM_Transmit>
                    COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 8039e66:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8039e6a:	2101      	movs	r1, #1
 8039e6c:	f10d 000e 	add.w	r0, sp, #14
 8039e70:	f7fe fd9c 	bl	80389ac <COM_Transmit>
                    cause = 4;
 8039e74:	2504      	movs	r5, #4
 8039e76:	e7ed      	b.n	8039e54 <Ymodem_Receive+0x234>
          Serial_PutByte(CA);
 8039e78:	2018      	movs	r0, #24
 8039e7a:	f7fe fe03 	bl	8038a84 <Serial_PutByte>
          Serial_PutByte(CA);
 8039e7e:	2018      	movs	r0, #24
 8039e80:	f7fe fe00 	bl	8038a84 <Serial_PutByte>
          cause  = 5;
 8039e84:	2505      	movs	r5, #5
          break;
 8039e86:	e767      	b.n	8039d58 <Ymodem_Receive+0x138>
            Serial_PutByte(CRC16); /* Ask for a packet */
 8039e88:	2043      	movs	r0, #67	; 0x43
 8039e8a:	f7fe fdfb 	bl	8038a84 <Serial_PutByte>
            printf("\b.");         /* Replace C char by . on display console */
 8039e8e:	4808      	ldr	r0, [pc, #32]	; (8039eb0 <Ymodem_Receive+0x290>)
 8039e90:	f002 fc2a 	bl	803c6e8 <iprintf>
 8039e94:	e7b3      	b.n	8039dfe <Ymodem_Receive+0x1de>
 8039e96:	bf00      	nop
 8039e98:	20000270 	.word	0x20000270
 8039e9c:	20000272 	.word	0x20000272
 8039ea0:	2000024c 	.word	0x2000024c
 8039ea4:	20000274 	.word	0x20000274
 8039ea8:	0803eaf2 	.word	0x0803eaf2
 8039eac:	20000688 	.word	0x20000688
 8039eb0:	0803eaef 	.word	0x0803eaef

08039eb4 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 8039eb4:	4770      	bx	lr
	...

08039eb8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8039eb8:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  if (uwTickFreq != 0U)
 8039eba:	4b0f      	ldr	r3, [pc, #60]	; (8039ef8 <HAL_InitTick+0x40>)
{
 8039ebc:	4605      	mov	r5, r0
  if (uwTickFreq != 0U)
 8039ebe:	6818      	ldr	r0, [r3, #0]
 8039ec0:	b908      	cbnz	r0, 8039ec6 <HAL_InitTick+0xe>
      status = HAL_ERROR;
    }
  }
  else
  {
    status = HAL_ERROR;
 8039ec2:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 8039ec4:	bd38      	pop	{r3, r4, r5, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) == 0U)
 8039ec6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8039eca:	fbb3 f3f0 	udiv	r3, r3, r0
 8039ece:	4a0b      	ldr	r2, [pc, #44]	; (8039efc <HAL_InitTick+0x44>)
 8039ed0:	6810      	ldr	r0, [r2, #0]
 8039ed2:	fbb0 f0f3 	udiv	r0, r0, r3
 8039ed6:	f000 f891 	bl	8039ffc <HAL_SYSTICK_Config>
 8039eda:	4604      	mov	r4, r0
 8039edc:	2800      	cmp	r0, #0
 8039ede:	d1f0      	bne.n	8039ec2 <HAL_InitTick+0xa>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8039ee0:	2d07      	cmp	r5, #7
 8039ee2:	d8ee      	bhi.n	8039ec2 <HAL_InitTick+0xa>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8039ee4:	4602      	mov	r2, r0
 8039ee6:	4629      	mov	r1, r5
 8039ee8:	f04f 30ff 	mov.w	r0, #4294967295
 8039eec:	f000 f852 	bl	8039f94 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8039ef0:	4b03      	ldr	r3, [pc, #12]	; (8039f00 <HAL_InitTick+0x48>)
 8039ef2:	4620      	mov	r0, r4
 8039ef4:	601d      	str	r5, [r3, #0]
 8039ef6:	e7e5      	b.n	8039ec4 <HAL_InitTick+0xc>
 8039ef8:	20000104 	.word	0x20000104
 8039efc:	20000100 	.word	0x20000100
 8039f00:	20000108 	.word	0x20000108

08039f04 <HAL_Init>:
{
 8039f04:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 8039f06:	2004      	movs	r0, #4
 8039f08:	f000 f832 	bl	8039f70 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
 8039f0c:	f7ff f922 	bl	8039154 <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8039f10:	2007      	movs	r0, #7
 8039f12:	f7ff ffd1 	bl	8039eb8 <HAL_InitTick>
 8039f16:	4604      	mov	r4, r0
 8039f18:	b918      	cbnz	r0, 8039f22 <HAL_Init+0x1e>
    HAL_MspInit();
 8039f1a:	f7ff ffcb 	bl	8039eb4 <HAL_MspInit>
}
 8039f1e:	4620      	mov	r0, r4
 8039f20:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 8039f22:	2401      	movs	r4, #1
 8039f24:	e7fb      	b.n	8039f1e <HAL_Init+0x1a>
	...

08039f28 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8039f28:	4a03      	ldr	r2, [pc, #12]	; (8039f38 <HAL_IncTick+0x10>)
 8039f2a:	4904      	ldr	r1, [pc, #16]	; (8039f3c <HAL_IncTick+0x14>)
 8039f2c:	6813      	ldr	r3, [r2, #0]
 8039f2e:	6809      	ldr	r1, [r1, #0]
 8039f30:	440b      	add	r3, r1
 8039f32:	6013      	str	r3, [r2, #0]
}
 8039f34:	4770      	bx	lr
 8039f36:	bf00      	nop
 8039f38:	200006cc 	.word	0x200006cc
 8039f3c:	20000104 	.word	0x20000104

08039f40 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8039f40:	4b01      	ldr	r3, [pc, #4]	; (8039f48 <HAL_GetTick+0x8>)
 8039f42:	6818      	ldr	r0, [r3, #0]
}
 8039f44:	4770      	bx	lr
 8039f46:	bf00      	nop
 8039f48:	200006cc 	.word	0x200006cc

08039f4c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8039f4c:	b538      	push	{r3, r4, r5, lr}
 8039f4e:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8039f50:	f7ff fff6 	bl	8039f40 <HAL_GetTick>
 8039f54:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 8039f56:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 8039f58:	bf1e      	ittt	ne
 8039f5a:	4b04      	ldrne	r3, [pc, #16]	; (8039f6c <HAL_Delay+0x20>)
 8039f5c:	681b      	ldrne	r3, [r3, #0]
 8039f5e:	18e4      	addne	r4, r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 8039f60:	f7ff ffee 	bl	8039f40 <HAL_GetTick>
 8039f64:	1b40      	subs	r0, r0, r5
 8039f66:	42a0      	cmp	r0, r4
 8039f68:	d3fa      	bcc.n	8039f60 <HAL_Delay+0x14>
  {
  }
}
 8039f6a:	bd38      	pop	{r3, r4, r5, pc}
 8039f6c:	20000104 	.word	0x20000104

08039f70 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8039f70:	4a07      	ldr	r2, [pc, #28]	; (8039f90 <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priority group */
 8039f72:	0200      	lsls	r0, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8039f74:	68d3      	ldr	r3, [r2, #12]
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priority group */
 8039f76:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8039f7a:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8039f7e:	041b      	lsls	r3, r3, #16
 8039f80:	0c1b      	lsrs	r3, r3, #16
 8039f82:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8039f86:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 8039f8a:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8039f8c:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8039f8e:	4770      	bx	lr
 8039f90:	e000ed00 	.word	0xe000ed00

08039f94 <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8039f94:	4b17      	ldr	r3, [pc, #92]	; (8039ff4 <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 7
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8039f96:	b570      	push	{r4, r5, r6, lr}
 8039f98:	68dc      	ldr	r4, [r3, #12]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8039f9a:	f04f 36ff 	mov.w	r6, #4294967295
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8039f9e:	f3c4 2402 	ubfx	r4, r4, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8039fa2:	f1c4 0507 	rsb	r5, r4, #7
 8039fa6:	2d03      	cmp	r5, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8039fa8:	f104 0303 	add.w	r3, r4, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8039fac:	bf28      	it	cs
 8039fae:	2503      	movcs	r5, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8039fb0:	2b06      	cmp	r3, #6
 8039fb2:	bf98      	it	ls
 8039fb4:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8039fb6:	fa06 f305 	lsl.w	r3, r6, r5
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8039fba:	bf88      	it	hi
 8039fbc:	3c04      	subhi	r4, #4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8039fbe:	ea21 0303 	bic.w	r3, r1, r3
 8039fc2:	40a3      	lsls	r3, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8039fc4:	fa06 f404 	lsl.w	r4, r6, r4
 8039fc8:	ea22 0404 	bic.w	r4, r2, r4
  if ((int32_t)(IRQn) >= 0)
 8039fcc:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8039fce:	ea43 0304 	orr.w	r3, r3, r4
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039fd2:	bfa8      	it	ge
 8039fd4:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 8039fd8:	ea4f 1343 	mov.w	r3, r3, lsl #5
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039fdc:	bfb8      	it	lt
 8039fde:	4a06      	ldrlt	r2, [pc, #24]	; (8039ff8 <HAL_NVIC_SetPriority+0x64>)
 8039fe0:	b2db      	uxtb	r3, r3
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039fe2:	bfab      	itete	ge
 8039fe4:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039fe8:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039fec:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039ff0:	5413      	strblt	r3, [r2, r0]
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8039ff2:	bd70      	pop	{r4, r5, r6, pc}
 8039ff4:	e000ed00 	.word	0xe000ed00
 8039ff8:	e000ed14 	.word	0xe000ed14

08039ffc <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8039ffc:	3801      	subs	r0, #1
 8039ffe:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 803a002:	d20a      	bcs.n	803a01a <HAL_SYSTICK_Config+0x1e>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 803a004:	21e0      	movs	r1, #224	; 0xe0
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 803a006:	4b06      	ldr	r3, [pc, #24]	; (803a020 <HAL_SYSTICK_Config+0x24>)
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 803a008:	4a06      	ldr	r2, [pc, #24]	; (803a024 <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 803a00a:	6058      	str	r0, [r3, #4]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 803a00c:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 803a010:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 803a012:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 803a014:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 803a016:	601a      	str	r2, [r3, #0]
 803a018:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 803a01a:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
  return SysTick_Config(TicksNumb);
}
 803a01c:	4770      	bx	lr
 803a01e:	bf00      	nop
 803a020:	e000e010 	.word	0xe000e010
 803a024:	e000ed00 	.word	0xe000ed00

0803a028 <CRC_Handle_8>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 803a028:	460b      	mov	r3, r1
 803a02a:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint16_t *pReg;

  /* Processing time optimization: 4 bytes are entered in a row with a single word write,
   * last bytes must be carefully fed to the CRC calculator to ensure a correct type
   * handling by the peripheral */
  for (i = 0U; i < (BufferLength / 4U); i++)
 803a02c:	0896      	lsrs	r6, r2, #2
 803a02e:	6805      	ldr	r5, [r0, #0]
 803a030:	eb01 0786 	add.w	r7, r1, r6, lsl #2
 803a034:	42bb      	cmp	r3, r7
 803a036:	d108      	bne.n	803a04a <CRC_Handle_8+0x22>
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
                         (uint32_t)pBuffer[(4U * i) + 3U];
  }
  /* last bytes specific handling */
  if ((BufferLength % 4U) != 0U)
 803a038:	f012 0203 	ands.w	r2, r2, #3
 803a03c:	d01e      	beq.n	803a07c <CRC_Handle_8+0x54>
  {
    if ((BufferLength % 4U) == 1U)
 803a03e:	2a01      	cmp	r2, #1
 803a040:	d114      	bne.n	803a06c <CRC_Handle_8+0x44>
    {
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];         /* Derogation MisraC2012 R.11.5 */
 803a042:	f811 3026 	ldrb.w	r3, [r1, r6, lsl #2]
    {
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
      pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                    /* Derogation MisraC2012 R.11.5 */
      *pReg = data;

      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 803a046:	702b      	strb	r3, [r5, #0]
 803a048:	e018      	b.n	803a07c <CRC_Handle_8+0x54>
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 803a04a:	785c      	ldrb	r4, [r3, #1]
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 803a04c:	f893 c000 	ldrb.w	ip, [r3]
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 803a050:	0424      	lsls	r4, r4, #16
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 803a052:	ea44 640c 	orr.w	r4, r4, ip, lsl #24
                         (uint32_t)pBuffer[(4U * i) + 3U];
 803a056:	f893 c003 	ldrb.w	ip, [r3, #3]
 803a05a:	3304      	adds	r3, #4
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 803a05c:	ea44 040c 	orr.w	r4, r4, ip
 803a060:	f813 cc02 	ldrb.w	ip, [r3, #-2]
 803a064:	ea44 240c 	orr.w	r4, r4, ip, lsl #8
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 803a068:	602c      	str	r4, [r5, #0]
 803a06a:	e7e3      	b.n	803a034 <CRC_Handle_8+0xc>
    if ((BufferLength % 4U) == 2U)
 803a06c:	2a02      	cmp	r2, #2
 803a06e:	d108      	bne.n	803a082 <CRC_Handle_8+0x5a>
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 803a070:	f811 2026 	ldrb.w	r2, [r1, r6, lsl #2]
 803a074:	785b      	ldrb	r3, [r3, #1]
 803a076:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
      *pReg = data;
 803a07a:	802b      	strh	r3, [r5, #0]
    }
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 803a07c:	6803      	ldr	r3, [r0, #0]
 803a07e:	6818      	ldr	r0, [r3, #0]
}
 803a080:	bdf0      	pop	{r4, r5, r6, r7, pc}
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 803a082:	785a      	ldrb	r2, [r3, #1]
 803a084:	f811 1026 	ldrb.w	r1, [r1, r6, lsl #2]
 803a088:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
      *pReg = data;
 803a08c:	802a      	strh	r2, [r5, #0]
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 803a08e:	789b      	ldrb	r3, [r3, #2]
 803a090:	e7d9      	b.n	803a046 <CRC_Handle_8+0x1e>

0803a092 <CRC_Handle_16>:
  __IO uint16_t *pReg;

  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure
   * a correct type handling by the peripheral */
  for (i = 0U; i < (BufferLength / 2U); i++)
 803a092:	2300      	movs	r3, #0
 803a094:	6800      	ldr	r0, [r0, #0]
{
 803a096:	b570      	push	{r4, r5, r6, lr}
  for (i = 0U; i < (BufferLength / 2U); i++)
 803a098:	0855      	lsrs	r5, r2, #1
 803a09a:	429d      	cmp	r5, r3
 803a09c:	d106      	bne.n	803a0ac <CRC_Handle_16+0x1a>
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
  }
  if ((BufferLength % 2U) != 0U)
 803a09e:	07d3      	lsls	r3, r2, #31
  {
    pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                 /* Derogation MisraC2012 R.11.5 */
    *pReg = pBuffer[2U * i];
 803a0a0:	bf44      	itt	mi
 803a0a2:	f831 3025 	ldrhmi.w	r3, [r1, r5, lsl #2]
 803a0a6:	8003      	strhmi	r3, [r0, #0]
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 803a0a8:	6800      	ldr	r0, [r0, #0]
}
 803a0aa:	bd70      	pop	{r4, r5, r6, pc}
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 803a0ac:	eb01 0483 	add.w	r4, r1, r3, lsl #2
 803a0b0:	f831 6023 	ldrh.w	r6, [r1, r3, lsl #2]
 803a0b4:	8864      	ldrh	r4, [r4, #2]
  for (i = 0U; i < (BufferLength / 2U); i++)
 803a0b6:	3301      	adds	r3, #1
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 803a0b8:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
 803a0bc:	6004      	str	r4, [r0, #0]
 803a0be:	e7ec      	b.n	803a09a <CRC_Handle_16+0x8>

0803a0c0 <HAL_CRC_MspInit>:
}
 803a0c0:	4770      	bx	lr
	...

0803a0c4 <HAL_CRC_Init>:
{
 803a0c4:	b510      	push	{r4, lr}
  if (hcrc == NULL)
 803a0c6:	4604      	mov	r4, r0
 803a0c8:	b908      	cbnz	r0, 803a0ce <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 803a0ca:	2001      	movs	r0, #1
}
 803a0cc:	bd10      	pop	{r4, pc}
  if (hcrc->State == HAL_CRC_STATE_RESET)
 803a0ce:	7f43      	ldrb	r3, [r0, #29]
 803a0d0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 803a0d4:	b913      	cbnz	r3, 803a0dc <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 803a0d6:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 803a0d8:	f7ff fff2 	bl	803a0c0 <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY;
 803a0dc:	2302      	movs	r3, #2
 803a0de:	7763      	strb	r3, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 803a0e0:	7923      	ldrb	r3, [r4, #4]
 803a0e2:	b9e3      	cbnz	r3, 803a11e <HAL_CRC_Init+0x5a>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 803a0e4:	6823      	ldr	r3, [r4, #0]
 803a0e6:	4a13      	ldr	r2, [pc, #76]	; (803a134 <HAL_CRC_Init+0x70>)
 803a0e8:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 803a0ea:	689a      	ldr	r2, [r3, #8]
 803a0ec:	f022 0218 	bic.w	r2, r2, #24
 803a0f0:	609a      	str	r2, [r3, #8]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 803a0f2:	7962      	ldrb	r2, [r4, #5]
 803a0f4:	6823      	ldr	r3, [r4, #0]
 803a0f6:	b9d2      	cbnz	r2, 803a12e <HAL_CRC_Init+0x6a>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 803a0f8:	f04f 32ff 	mov.w	r2, #4294967295
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 803a0fc:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 803a0fe:	689a      	ldr	r2, [r3, #8]
 803a100:	6961      	ldr	r1, [r4, #20]
 803a102:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 803a106:	430a      	orrs	r2, r1
 803a108:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 803a10a:	689a      	ldr	r2, [r3, #8]
 803a10c:	69a1      	ldr	r1, [r4, #24]
 803a10e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 803a112:	430a      	orrs	r2, r1
 803a114:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 803a116:	2301      	movs	r3, #1
  return HAL_OK;
 803a118:	2000      	movs	r0, #0
  hcrc->State = HAL_CRC_STATE_READY;
 803a11a:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 803a11c:	e7d6      	b.n	803a0cc <HAL_CRC_Init+0x8>
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 803a11e:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 803a122:	4620      	mov	r0, r4
 803a124:	f000 f82c 	bl	803a180 <HAL_CRCEx_Polynomial_Set>
 803a128:	2800      	cmp	r0, #0
 803a12a:	d0e2      	beq.n	803a0f2 <HAL_CRC_Init+0x2e>
 803a12c:	e7cd      	b.n	803a0ca <HAL_CRC_Init+0x6>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 803a12e:	6922      	ldr	r2, [r4, #16]
 803a130:	e7e4      	b.n	803a0fc <HAL_CRC_Init+0x38>
 803a132:	bf00      	nop
 803a134:	04c11db7 	.word	0x04c11db7

0803a138 <HAL_CRC_Calculate>:
{
 803a138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  hcrc->State = HAL_CRC_STATE_BUSY;
 803a13a:	2502      	movs	r5, #2
 803a13c:	7745      	strb	r5, [r0, #29]
  __HAL_CRC_DR_RESET(hcrc);
 803a13e:	6805      	ldr	r5, [r0, #0]
{
 803a140:	4604      	mov	r4, r0
  __HAL_CRC_DR_RESET(hcrc);
 803a142:	68af      	ldr	r7, [r5, #8]
 803a144:	f047 0701 	orr.w	r7, r7, #1
 803a148:	60af      	str	r7, [r5, #8]
  switch (hcrc->InputDataFormat)
 803a14a:	6a07      	ldr	r7, [r0, #32]
 803a14c:	2f02      	cmp	r7, #2
 803a14e:	d012      	beq.n	803a176 <HAL_CRC_Calculate+0x3e>
 803a150:	2f03      	cmp	r7, #3
 803a152:	d004      	beq.n	803a15e <HAL_CRC_Calculate+0x26>
 803a154:	2f01      	cmp	r7, #1
 803a156:	d111      	bne.n	803a17c <HAL_CRC_Calculate+0x44>
      temp = CRC_Handle_8(hcrc, (uint8_t *)pBuffer, BufferLength);
 803a158:	f7ff ff66 	bl	803a028 <CRC_Handle_8>
      break;
 803a15c:	e004      	b.n	803a168 <HAL_CRC_Calculate+0x30>
 803a15e:	eb01 0682 	add.w	r6, r1, r2, lsl #2
      for (index = 0U; index < BufferLength; index++)
 803a162:	42b1      	cmp	r1, r6
 803a164:	d103      	bne.n	803a16e <HAL_CRC_Calculate+0x36>
      temp = hcrc->Instance->DR;
 803a166:	6828      	ldr	r0, [r5, #0]
  hcrc->State = HAL_CRC_STATE_READY;
 803a168:	2301      	movs	r3, #1
 803a16a:	7763      	strb	r3, [r4, #29]
}
 803a16c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        hcrc->Instance->DR = pBuffer[index];
 803a16e:	f851 3b04 	ldr.w	r3, [r1], #4
 803a172:	602b      	str	r3, [r5, #0]
 803a174:	e7f5      	b.n	803a162 <HAL_CRC_Calculate+0x2a>
      temp = CRC_Handle_16(hcrc, (uint16_t *)(void *)pBuffer, BufferLength);    /* Derogation MisraC2012 R.11.5 */
 803a176:	f7ff ff8c 	bl	803a092 <CRC_Handle_16>
      break;
 803a17a:	e7f5      	b.n	803a168 <HAL_CRC_Calculate+0x30>
  uint32_t temp = 0U;  /* CRC output (read from hcrc->Instance->DR register) */
 803a17c:	2000      	movs	r0, #0
 803a17e:	e7f3      	b.n	803a168 <HAL_CRC_Calculate+0x30>

0803a180 <HAL_CRCEx_Polynomial_Set>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 803a180:	231f      	movs	r3, #31
{
 803a182:	b510      	push	{r4, lr}
   * definition. HAL_ERROR is reported if Pol degree is
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 803a184:	f113 33ff 	adds.w	r3, r3, #4294967295
 803a188:	d306      	bcc.n	803a198 <HAL_CRCEx_Polynomial_Set+0x18>
 803a18a:	fa21 f403 	lsr.w	r4, r1, r3
 803a18e:	07e4      	lsls	r4, r4, #31
 803a190:	d5f8      	bpl.n	803a184 <HAL_CRCEx_Polynomial_Set+0x4>
  {
  }

  switch (PolyLength)
 803a192:	2a08      	cmp	r2, #8
 803a194:	d014      	beq.n	803a1c0 <HAL_CRCEx_Polynomial_Set+0x40>
 803a196:	d802      	bhi.n	803a19e <HAL_CRCEx_Polynomial_Set+0x1e>
 803a198:	b13a      	cbz	r2, 803a1aa <HAL_CRCEx_Polynomial_Set+0x2a>

    case CRC_POLYLENGTH_32B:
      /* no polynomial definition vs. polynomial length issue possible */
      break;
    default:
      status =  HAL_ERROR;
 803a19a:	2001      	movs	r0, #1

    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
  }
  /* Return function status */
  return status;
 803a19c:	e00d      	b.n	803a1ba <HAL_CRCEx_Polynomial_Set+0x3a>
  switch (PolyLength)
 803a19e:	2a10      	cmp	r2, #16
 803a1a0:	d00c      	beq.n	803a1bc <HAL_CRCEx_Polynomial_Set+0x3c>
 803a1a2:	2a18      	cmp	r2, #24
 803a1a4:	d1f9      	bne.n	803a19a <HAL_CRCEx_Polynomial_Set+0x1a>
      if (msb >= HAL_CRC_LENGTH_7B)
 803a1a6:	2b06      	cmp	r3, #6
      if (msb >= HAL_CRC_LENGTH_16B)
 803a1a8:	d8f7      	bhi.n	803a19a <HAL_CRCEx_Polynomial_Set+0x1a>
    WRITE_REG(hcrc->Instance->POL, Pol);
 803a1aa:	6800      	ldr	r0, [r0, #0]
 803a1ac:	6141      	str	r1, [r0, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 803a1ae:	6883      	ldr	r3, [r0, #8]
 803a1b0:	f023 0318 	bic.w	r3, r3, #24
 803a1b4:	431a      	orrs	r2, r3
 803a1b6:	6082      	str	r2, [r0, #8]
 803a1b8:	2000      	movs	r0, #0
}
 803a1ba:	bd10      	pop	{r4, pc}
      if (msb >= HAL_CRC_LENGTH_8B)
 803a1bc:	2b07      	cmp	r3, #7
 803a1be:	e7f3      	b.n	803a1a8 <HAL_CRCEx_Polynomial_Set+0x28>
      if (msb >= HAL_CRC_LENGTH_16B)
 803a1c0:	2b0f      	cmp	r3, #15
 803a1c2:	e7f1      	b.n	803a1a8 <HAL_CRCEx_Polynomial_Set+0x28>

0803a1c4 <HAL_FLASH_EndOfOperationCallback>:
  UNUSED(ReturnValue);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
   */
}
 803a1c4:	4770      	bx	lr

0803a1c6 <HAL_FLASH_OperationErrorCallback>:
 803a1c6:	4770      	bx	lr

0803a1c8 <HAL_FLASH_IRQHandler>:
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
 803a1c8:	4a29      	ldr	r2, [pc, #164]	; (803a270 <HAL_FLASH_IRQHandler+0xa8>)
{
 803a1ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  type = (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK));
 803a1ce:	4c29      	ldr	r4, [pc, #164]	; (803a274 <HAL_FLASH_IRQHandler+0xac>)
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
 803a1d0:	6813      	ldr	r3, [r2, #0]
  type = (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK));
 803a1d2:	68a5      	ldr	r5, [r4, #8]
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
 803a1d4:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
  type = (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK));
 803a1d8:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
 803a1dc:	f023 0305 	bic.w	r3, r3, #5
 803a1e0:	049b      	lsls	r3, r3, #18
  if(type == FLASH_TYPEERASE_PAGES)
 803a1e2:	2d02      	cmp	r5, #2
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
 803a1e4:	ea4f 4393 	mov.w	r3, r3, lsr #18
 803a1e8:	4690      	mov	r8, r2
  if(type == FLASH_TYPEERASE_PAGES)
 803a1ea:	d12f      	bne.n	803a24c <HAL_FLASH_IRQHandler+0x84>
    param = pFlash.Page;
 803a1ec:	6967      	ldr	r7, [r4, #20]
  CLEAR_BIT((*reg), type);
 803a1ee:	4e22      	ldr	r6, [pc, #136]	; (803a278 <HAL_FLASH_IRQHandler+0xb0>)
 803a1f0:	6832      	ldr	r2, [r6, #0]
 803a1f2:	ea22 0205 	bic.w	r2, r2, r5
 803a1f6:	6032      	str	r2, [r6, #0]
  if(error != 0U)
 803a1f8:	b14b      	cbz	r3, 803a20e <HAL_FLASH_IRQHandler+0x46>
    pFlash.ErrorCode |= error;
 803a1fa:	6862      	ldr	r2, [r4, #4]
    HAL_FLASH_OperationErrorCallback(param);
 803a1fc:	4638      	mov	r0, r7
    pFlash.ErrorCode |= error;
 803a1fe:	431a      	orrs	r2, r3
 803a200:	6062      	str	r2, [r4, #4]
    (*reg_sr) = error;
 803a202:	f8c8 3000 	str.w	r3, [r8]
    pFlash.ProcedureOnGoing = 0U;
 803a206:	2300      	movs	r3, #0
 803a208:	60a3      	str	r3, [r4, #8]
    HAL_FLASH_OperationErrorCallback(param);
 803a20a:	f7ff ffdc 	bl	803a1c6 <HAL_FLASH_OperationErrorCallback>
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
 803a20e:	f8d8 3000 	ldr.w	r3, [r8]
 803a212:	07db      	lsls	r3, r3, #31
 803a214:	d511      	bpl.n	803a23a <HAL_FLASH_IRQHandler+0x72>
    (*reg_sr) = FLASH_FLAG_EOP;
 803a216:	2301      	movs	r3, #1
    if(type == FLASH_TYPEERASE_PAGES)
 803a218:	2d02      	cmp	r5, #2
    (*reg_sr) = FLASH_FLAG_EOP;
 803a21a:	f8c8 3000 	str.w	r3, [r8]
    if(type == FLASH_TYPEERASE_PAGES)
 803a21e:	d124      	bne.n	803a26a <HAL_FLASH_IRQHandler+0xa2>
      pFlash.NbPagesToErase--;
 803a220:	69a3      	ldr	r3, [r4, #24]
 803a222:	3b01      	subs	r3, #1
 803a224:	61a3      	str	r3, [r4, #24]
      if(pFlash.NbPagesToErase != 0U)
 803a226:	b1e3      	cbz	r3, 803a262 <HAL_FLASH_IRQHandler+0x9a>
        pFlash.Page++;
 803a228:	6960      	ldr	r0, [r4, #20]
        FLASH_PageErase(pFlash.Page, pFlash.Bank);
 803a22a:	6921      	ldr	r1, [r4, #16]
        pFlash.Page++;
 803a22c:	3001      	adds	r0, #1
 803a22e:	6160      	str	r0, [r4, #20]
        FLASH_PageErase(pFlash.Page, pFlash.Bank);
 803a230:	f000 f8ce 	bl	803a3d0 <FLASH_PageErase>
    HAL_FLASH_EndOfOperationCallback(param);
 803a234:	4638      	mov	r0, r7
 803a236:	f7ff ffc5 	bl	803a1c4 <HAL_FLASH_EndOfOperationCallback>
  if(pFlash.ProcedureOnGoing == 0U)
 803a23a:	68a2      	ldr	r2, [r4, #8]
 803a23c:	b922      	cbnz	r2, 803a248 <HAL_FLASH_IRQHandler+0x80>
    (*reg) &= ~(FLASH_IT_EOP | FLASH_IT_OPERR);
 803a23e:	6833      	ldr	r3, [r6, #0]
 803a240:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 803a244:	6033      	str	r3, [r6, #0]
    __HAL_UNLOCK(&pFlash);
 803a246:	7022      	strb	r2, [r4, #0]
}
 803a248:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if(type == FLASH_TYPEERASE_MASSERASE)
 803a24c:	f248 0204 	movw	r2, #32772	; 0x8004
 803a250:	4295      	cmp	r5, r2
 803a252:	d101      	bne.n	803a258 <HAL_FLASH_IRQHandler+0x90>
    param = pFlash.Bank;
 803a254:	6927      	ldr	r7, [r4, #16]
 803a256:	e7ca      	b.n	803a1ee <HAL_FLASH_IRQHandler+0x26>
  else if(type == FLASH_TYPEPROGRAM_DOUBLEWORD)
 803a258:	2d01      	cmp	r5, #1
    param = pFlash.Address;
 803a25a:	bf0c      	ite	eq
 803a25c:	68e7      	ldreq	r7, [r4, #12]
  uint32_t param = 0U;
 803a25e:	2700      	movne	r7, #0
 803a260:	e7c5      	b.n	803a1ee <HAL_FLASH_IRQHandler+0x26>
        pFlash.ProcedureOnGoing = 0U;
 803a262:	60a3      	str	r3, [r4, #8]
        param = 0xFFFFFFFFU;
 803a264:	f04f 37ff 	mov.w	r7, #4294967295
 803a268:	e7e4      	b.n	803a234 <HAL_FLASH_IRQHandler+0x6c>
      pFlash.ProcedureOnGoing = 0U;
 803a26a:	2300      	movs	r3, #0
 803a26c:	60a3      	str	r3, [r4, #8]
 803a26e:	e7e1      	b.n	803a234 <HAL_FLASH_IRQHandler+0x6c>
 803a270:	40022020 	.word	0x40022020
 803a274:	2000010c 	.word	0x2000010c
 803a278:	40022028 	.word	0x40022028

0803a27c <HAL_FLASH_Unlock>:
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  HAL_StatusTypeDef status = HAL_OK;

  if(READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 803a27c:	4b06      	ldr	r3, [pc, #24]	; (803a298 <HAL_FLASH_Unlock+0x1c>)
 803a27e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 803a280:	2a00      	cmp	r2, #0
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY1);
 803a282:	bfbf      	itttt	lt
 803a284:	4a05      	ldrlt	r2, [pc, #20]	; (803a29c <HAL_FLASH_Unlock+0x20>)
 803a286:	609a      	strlt	r2, [r3, #8]
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY2);
 803a288:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
 803a28c:	609a      	strlt	r2, [r3, #8]

    /* verify Flash is unlocked */
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 803a28e:	bfba      	itte	lt
 803a290:	6a98      	ldrlt	r0, [r3, #40]	; 0x28
  HAL_StatusTypeDef status = HAL_OK;
 803a292:	0fc0      	lsrlt	r0, r0, #31
 803a294:	2000      	movge	r0, #0
    }
  }
#endif

  return status;
}
 803a296:	4770      	bx	lr
 803a298:	40022000 	.word	0x40022000
 803a29c:	45670123 	.word	0x45670123

0803a2a0 <HAL_FLASH_Lock>:
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
  HAL_StatusTypeDef status = HAL_ERROR;

  /* Set the LOCK Bit to lock the FLASH Registers access */
  SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
 803a2a0:	4b04      	ldr	r3, [pc, #16]	; (803a2b4 <HAL_FLASH_Lock+0x14>)
 803a2a2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 803a2a4:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 803a2a8:	629a      	str	r2, [r3, #40]	; 0x28

  /* verify Flash is locked */
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 803a2aa:	6a98      	ldr	r0, [r3, #40]	; 0x28
    }
  }
#endif

  return status;
}
 803a2ac:	43c0      	mvns	r0, r0
 803a2ae:	0fc0      	lsrs	r0, r0, #31
 803a2b0:	4770      	bx	lr
 803a2b2:	bf00      	nop
 803a2b4:	40022000 	.word	0x40022000

0803a2b8 <HAL_FLASH_GetError>:
  *            @arg HAL_FLASH_ERROR_OPTW: FLASH Option modification error
  */
uint32_t HAL_FLASH_GetError(void)
{
   return pFlash.ErrorCode;
}
 803a2b8:	4b01      	ldr	r3, [pc, #4]	; (803a2c0 <HAL_FLASH_GetError+0x8>)
 803a2ba:	6858      	ldr	r0, [r3, #4]
 803a2bc:	4770      	bx	lr
 803a2be:	bf00      	nop
 803a2c0:	2000010c 	.word	0x2000010c

0803a2c4 <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
 803a2c4:	b570      	push	{r4, r5, r6, lr}
 803a2c6:	4604      	mov	r4, r0
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */

  uint32_t timeout = HAL_GetTick() + Timeout;
 803a2c8:	f7ff fe3a 	bl	8039f40 <HAL_GetTick>
  uint32_t error;
  __IO uint32_t *reg_sr;

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 803a2cc:	4d10      	ldr	r5, [pc, #64]	; (803a310 <FLASH_WaitForLastOperation+0x4c>)
  uint32_t timeout = HAL_GetTick() + Timeout;
 803a2ce:	1906      	adds	r6, r0, r4
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 803a2d0:	6a2b      	ldr	r3, [r5, #32]
 803a2d2:	03db      	lsls	r3, r3, #15
 803a2d4:	d40c      	bmi.n	803a2f0 <FLASH_WaitForLastOperation+0x2c>
  
  /* Access to SECSR or NSSR registers depends on operation type */
  reg_sr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECSR) : &(FLASH_NS->NSSR);

  /* Check FLASH operation error flags */
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 803a2d6:	f242 02fa 	movw	r2, #8442	; 0x20fa
 803a2da:	490e      	ldr	r1, [pc, #56]	; (803a314 <FLASH_WaitForLastOperation+0x50>)
 803a2dc:	6808      	ldr	r0, [r1, #0]
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
#endif /* __ARM_FEATURE_CMSE */ 

  if(error != 0u)
 803a2de:	4002      	ands	r2, r0
 803a2e0:	d00e      	beq.n	803a300 <FLASH_WaitForLastOperation+0x3c>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= error;
 803a2e2:	480d      	ldr	r0, [pc, #52]	; (803a318 <FLASH_WaitForLastOperation+0x54>)
 803a2e4:	6843      	ldr	r3, [r0, #4]
 803a2e6:	4313      	orrs	r3, r2
 803a2e8:	6043      	str	r3, [r0, #4]
    {
      FLASH->NSSR = FLASH_FLAG_OPTWERR;
    }
#endif /* __ARM_FEATURE_CMSE */

    return HAL_ERROR;
 803a2ea:	2001      	movs	r0, #1
    (*reg_sr) = error;
 803a2ec:	600a      	str	r2, [r1, #0]
    (*reg_sr) = FLASH_FLAG_EOP;
  }

  /* If there is an error flag set */
  return HAL_OK;
}
 803a2ee:	bd70      	pop	{r4, r5, r6, pc}
    if(Timeout != HAL_MAX_DELAY)
 803a2f0:	1c62      	adds	r2, r4, #1
 803a2f2:	d0ed      	beq.n	803a2d0 <FLASH_WaitForLastOperation+0xc>
      if(HAL_GetTick() >= timeout)
 803a2f4:	f7ff fe24 	bl	8039f40 <HAL_GetTick>
 803a2f8:	42b0      	cmp	r0, r6
 803a2fa:	d3e9      	bcc.n	803a2d0 <FLASH_WaitForLastOperation+0xc>
        return HAL_TIMEOUT;
 803a2fc:	2003      	movs	r0, #3
 803a2fe:	e7f6      	b.n	803a2ee <FLASH_WaitForLastOperation+0x2a>
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
 803a300:	6808      	ldr	r0, [r1, #0]
 803a302:	f010 0001 	ands.w	r0, r0, #1
 803a306:	d0f2      	beq.n	803a2ee <FLASH_WaitForLastOperation+0x2a>
    (*reg_sr) = FLASH_FLAG_EOP;
 803a308:	2301      	movs	r3, #1
 803a30a:	4610      	mov	r0, r2
 803a30c:	600b      	str	r3, [r1, #0]
 803a30e:	e7ee      	b.n	803a2ee <FLASH_WaitForLastOperation+0x2a>
 803a310:	40022000 	.word	0x40022000
 803a314:	40022020 	.word	0x40022020
 803a318:	2000010c 	.word	0x2000010c

0803a31c <HAL_FLASH_Program>:
{
 803a31c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 803a320:	4c18      	ldr	r4, [pc, #96]	; (803a384 <HAL_FLASH_Program+0x68>)
{
 803a322:	461f      	mov	r7, r3
  __HAL_LOCK(&pFlash);
 803a324:	7823      	ldrb	r3, [r4, #0]
{
 803a326:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 803a328:	2b01      	cmp	r3, #1
{
 803a32a:	460e      	mov	r6, r1
 803a32c:	4690      	mov	r8, r2
  __HAL_LOCK(&pFlash);
 803a32e:	d027      	beq.n	803a380 <HAL_FLASH_Program+0x64>
 803a330:	2301      	movs	r3, #1
 803a332:	7023      	strb	r3, [r4, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 803a334:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 803a336:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 803a33a:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 803a33c:	f7ff ffc2 	bl	803a2c4 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 803a340:	b9d0      	cbnz	r0, 803a378 <HAL_FLASH_Program+0x5c>
    pFlash.ProcedureOnGoing = TypeProgram;
 803a342:	60a5      	str	r5, [r4, #8]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a344:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a348:	b672      	cpsid	i
  /* Disable interrupts to avoid any interruption during the double word programming */
  primask_bit = __get_PRIMASK();
  __disable_irq();

  /* Set PG bit */
  SET_BIT((*reg), FLASH_NSCR_NSPG);
 803a34a:	4d0f      	ldr	r5, [pc, #60]	; (803a388 <HAL_FLASH_Program+0x6c>)
 803a34c:	6828      	ldr	r0, [r5, #0]
 803a34e:	f040 0001 	orr.w	r0, r0, #1
 803a352:	6028      	str	r0, [r5, #0]

  /* Program first word */
  *(uint32_t*)Address = (uint32_t)Data;
 803a354:	f8c6 8000 	str.w	r8, [r6]
  __ASM volatile ("isb 0xF":::"memory");
 803a358:	f3bf 8f6f 	isb	sy
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(uint32_t*)(Address+4U) = (uint32_t)(Data >> 32U);
 803a35c:	6077      	str	r7, [r6, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a35e:	f381 8810 	msr	PRIMASK, r1
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 803a362:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 803a366:	f7ff ffad 	bl	803a2c4 <FLASH_WaitForLastOperation>
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 803a36a:	68a2      	ldr	r2, [r4, #8]
 803a36c:	682b      	ldr	r3, [r5, #0]
 803a36e:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 803a372:	ea23 0302 	bic.w	r3, r3, r2
 803a376:	602b      	str	r3, [r5, #0]
  __HAL_UNLOCK(&pFlash);
 803a378:	2300      	movs	r3, #0
 803a37a:	7023      	strb	r3, [r4, #0]
}
 803a37c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  __HAL_LOCK(&pFlash);
 803a380:	2002      	movs	r0, #2
 803a382:	e7fb      	b.n	803a37c <HAL_FLASH_Program+0x60>
 803a384:	2000010c 	.word	0x2000010c
 803a388:	40022028 	.word	0x40022028

0803a38c <FLASH_MassErase>:
#endif
  
  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);

  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) != 0U)
 803a38c:	4b0e      	ldr	r3, [pc, #56]	; (803a3c8 <FLASH_MassErase+0x3c>)
 803a38e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 803a390:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 803a394:	4b0d      	ldr	r3, [pc, #52]	; (803a3cc <FLASH_MassErase+0x40>)
 803a396:	d010      	beq.n	803a3ba <FLASH_MassErase+0x2e>
  {
    /* Check the parameters */
    assert_param(IS_FLASH_BANK(Banks));

    /* Set the Mass Erase Bit for the bank 1 if requested */
    if((Banks & FLASH_BANK_1) != 0U)
 803a398:	07c1      	lsls	r1, r0, #31
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER1);
 803a39a:	bf42      	ittt	mi
 803a39c:	681a      	ldrmi	r2, [r3, #0]
 803a39e:	f042 0204 	orrmi.w	r2, r2, #4
 803a3a2:	601a      	strmi	r2, [r3, #0]
    }

    /* Set the Mass Erase Bit for the bank 2 if requested */
    if((Banks & FLASH_BANK_2) != 0U)
 803a3a4:	0782      	lsls	r2, r0, #30
 803a3a6:	d503      	bpl.n	803a3b0 <FLASH_MassErase+0x24>
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER2);
 803a3a8:	681a      	ldr	r2, [r3, #0]
 803a3aa:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    }
  }
  else
  {
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
 803a3ae:	601a      	str	r2, [r3, #0]
  }

  /* Proceed to erase all sectors */
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 803a3b0:	681a      	ldr	r2, [r3, #0]
 803a3b2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 803a3b6:	601a      	str	r2, [r3, #0]

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
#endif
}
 803a3b8:	4770      	bx	lr
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
 803a3ba:	681a      	ldr	r2, [r3, #0]
 803a3bc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 803a3c0:	f042 0204 	orr.w	r2, r2, #4
 803a3c4:	e7f3      	b.n	803a3ae <FLASH_MassErase+0x22>
 803a3c6:	bf00      	nop
 803a3c8:	40022000 	.word	0x40022000
 803a3cc:	40022028 	.word	0x40022028

0803a3d0 <FLASH_PageErase>:
#endif

  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);

  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
 803a3d0:	4b0f      	ldr	r3, [pc, #60]	; (803a410 <FLASH_PageErase+0x40>)
 803a3d2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 803a3d4:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 803a3d8:	4b0e      	ldr	r3, [pc, #56]	; (803a414 <FLASH_PageErase+0x44>)
 803a3da:	d112      	bne.n	803a402 <FLASH_PageErase+0x32>
  {
    CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 803a3dc:	6819      	ldr	r1, [r3, #0]
  {
    assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

    if((Banks & FLASH_BANK_1) != 0U)
    {
      CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 803a3de:	f421 6100 	bic.w	r1, r1, #2048	; 0x800
    }
    else
    {
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
 803a3e2:	6019      	str	r1, [r3, #0]
    }
  }

  /* Proceed to erase the page */
  MODIFY_REG((*reg), (FLASH_NSCR_NSPNB | FLASH_NSCR_NSPER), ((Page << FLASH_NSCR_NSPNB_Pos) | FLASH_NSCR_NSPER));
 803a3e4:	681a      	ldr	r2, [r3, #0]
 803a3e6:	f422 727e 	bic.w	r2, r2, #1016	; 0x3f8
 803a3ea:	f022 0202 	bic.w	r2, r2, #2
 803a3ee:	f042 0202 	orr.w	r2, r2, #2
 803a3f2:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
 803a3f6:	6018      	str	r0, [r3, #0]
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 803a3f8:	681a      	ldr	r2, [r3, #0]
 803a3fa:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 803a3fe:	601a      	str	r2, [r3, #0]

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
#endif
}
 803a400:	4770      	bx	lr
    if((Banks & FLASH_BANK_1) != 0U)
 803a402:	f011 0f01 	tst.w	r1, #1
      CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 803a406:	6819      	ldr	r1, [r3, #0]
    if((Banks & FLASH_BANK_1) != 0U)
 803a408:	d1e9      	bne.n	803a3de <FLASH_PageErase+0xe>
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
 803a40a:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 803a40e:	e7e8      	b.n	803a3e2 <FLASH_PageErase+0x12>
 803a410:	40022000 	.word	0x40022000
 803a414:	40022028 	.word	0x40022028

0803a418 <HAL_FLASHEx_Erase>:
{
 803a418:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 803a41c:	4c23      	ldr	r4, [pc, #140]	; (803a4ac <HAL_FLASHEx_Erase+0x94>)
{
 803a41e:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 803a420:	7823      	ldrb	r3, [r4, #0]
{
 803a422:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 803a424:	2b01      	cmp	r3, #1
 803a426:	d03e      	beq.n	803a4a6 <HAL_FLASHEx_Erase+0x8e>
 803a428:	2301      	movs	r3, #1
 803a42a:	7023      	strb	r3, [r4, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 803a42c:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 803a42e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 803a432:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 803a434:	f7ff ff46 	bl	803a2c4 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 803a438:	4606      	mov	r6, r0
 803a43a:	b9b8      	cbnz	r0, 803a46c <HAL_FLASHEx_Erase+0x54>
    if ((pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
 803a43c:	f248 0204 	movw	r2, #32772	; 0x8004
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 803a440:	682b      	ldr	r3, [r5, #0]
 803a442:	60a3      	str	r3, [r4, #8]
    if ((pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
 803a444:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 803a448:	4293      	cmp	r3, r2
 803a44a:	d114      	bne.n	803a476 <HAL_FLASHEx_Erase+0x5e>
      FLASH_MassErase(pEraseInit->Banks);
 803a44c:	6868      	ldr	r0, [r5, #4]
 803a44e:	f7ff ff9d 	bl	803a38c <FLASH_MassErase>
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 803a452:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 803a456:	f7ff ff35 	bl	803a2c4 <FLASH_WaitForLastOperation>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 803a45a:	4606      	mov	r6, r0
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 803a45c:	4914      	ldr	r1, [pc, #80]	; (803a4b0 <HAL_FLASHEx_Erase+0x98>)
 803a45e:	68a2      	ldr	r2, [r4, #8]
 803a460:	680b      	ldr	r3, [r1, #0]
 803a462:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 803a466:	ea23 0302 	bic.w	r3, r3, r2
 803a46a:	600b      	str	r3, [r1, #0]
  __HAL_UNLOCK(&pFlash);
 803a46c:	2300      	movs	r3, #0
 803a46e:	7023      	strb	r3, [r4, #0]
}
 803a470:	4630      	mov	r0, r6
 803a472:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *PageError = 0xFFFFFFFFU;
 803a476:	f04f 33ff 	mov.w	r3, #4294967295
 803a47a:	f8c8 3000 	str.w	r3, [r8]
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 803a47e:	68af      	ldr	r7, [r5, #8]
 803a480:	e9d5 3202 	ldrd	r3, r2, [r5, #8]
 803a484:	4413      	add	r3, r2
 803a486:	42bb      	cmp	r3, r7
 803a488:	d9e8      	bls.n	803a45c <HAL_FLASHEx_Erase+0x44>
        FLASH_PageErase(page_index, pEraseInit->Banks);
 803a48a:	4638      	mov	r0, r7
 803a48c:	6869      	ldr	r1, [r5, #4]
 803a48e:	f7ff ff9f 	bl	803a3d0 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 803a492:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 803a496:	f7ff ff15 	bl	803a2c4 <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 803a49a:	b110      	cbz	r0, 803a4a2 <HAL_FLASHEx_Erase+0x8a>
          *PageError = page_index;
 803a49c:	f8c8 7000 	str.w	r7, [r8]
 803a4a0:	e7db      	b.n	803a45a <HAL_FLASHEx_Erase+0x42>
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 803a4a2:	3701      	adds	r7, #1
 803a4a4:	e7ec      	b.n	803a480 <HAL_FLASHEx_Erase+0x68>
  __HAL_LOCK(&pFlash);
 803a4a6:	2602      	movs	r6, #2
 803a4a8:	e7e2      	b.n	803a470 <HAL_FLASHEx_Erase+0x58>
 803a4aa:	bf00      	nop
 803a4ac:	2000010c 	.word	0x2000010c
 803a4b0:	40022028 	.word	0x40022028

0803a4b4 <HAL_GPIO_Init>:
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0U;
 803a4b4:	2300      	movs	r3, #0
{
 803a4b6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
        EXTI->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 803a4ba:	4a5f      	ldr	r2, [pc, #380]	; (803a638 <HAL_GPIO_Init+0x184>)
  while (((GPIO_Init->Pin) >> position) != 0U)
 803a4bc:	f8d1 8000 	ldr.w	r8, [r1]
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 803a4c0:	f8df 917c 	ldr.w	r9, [pc, #380]	; 803a640 <HAL_GPIO_Init+0x18c>
  while (((GPIO_Init->Pin) >> position) != 0U)
 803a4c4:	fa38 f403 	lsrs.w	r4, r8, r3
 803a4c8:	d101      	bne.n	803a4ce <HAL_GPIO_Init+0x1a>
      }
    }

    position++;
  }
}
 803a4ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 803a4ce:	f04f 0c01 	mov.w	ip, #1
 803a4d2:	fa0c fc03 	lsl.w	ip, ip, r3
    if(iocurrent != 0U)
 803a4d6:	ea1c 0608 	ands.w	r6, ip, r8
 803a4da:	f000 809f 	beq.w	803a61c <HAL_GPIO_Init+0x168>
 803a4de:	2503      	movs	r5, #3
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 803a4e0:	684c      	ldr	r4, [r1, #4]
 803a4e2:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 803a4e6:	f024 0a10 	bic.w	sl, r4, #16
 803a4ea:	f10a 37ff 	add.w	r7, sl, #4294967295
 803a4ee:	fa05 f50e 	lsl.w	r5, r5, lr
 803a4f2:	2f01      	cmp	r7, #1
 803a4f4:	ea6f 0505 	mvn.w	r5, r5
 803a4f8:	d811      	bhi.n	803a51e <HAL_GPIO_Init+0x6a>
        temp = GPIOx->OSPEEDR;
 803a4fa:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 803a4fc:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
 803a500:	68cf      	ldr	r7, [r1, #12]
 803a502:	fa07 f70e 	lsl.w	r7, r7, lr
 803a506:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->OSPEEDR = temp;
 803a50a:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 803a50c:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 803a50e:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 803a512:	f3c4 1700 	ubfx	r7, r4, #4, #1
 803a516:	409f      	lsls	r7, r3
 803a518:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->OTYPER = temp;
 803a51c:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 803a51e:	68c7      	ldr	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 803a520:	f1ba 0f02 	cmp.w	sl, #2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 803a524:	ea07 0c05 	and.w	ip, r7, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 803a528:	688f      	ldr	r7, [r1, #8]
 803a52a:	fa07 f70e 	lsl.w	r7, r7, lr
 803a52e:	ea47 070c 	orr.w	r7, r7, ip
      GPIOx->PUPDR = temp;
 803a532:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 803a534:	d116      	bne.n	803a564 <HAL_GPIO_Init+0xb0>
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 803a536:	f04f 0c0f 	mov.w	ip, #15
        temp = GPIOx->AFR[position >> 3U];
 803a53a:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 803a53e:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 803a542:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 803a546:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 803a54a:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 803a54e:	fa0c fc0b 	lsl.w	ip, ip, fp
 803a552:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 803a556:	690f      	ldr	r7, [r1, #16]
 803a558:	fa07 f70b 	lsl.w	r7, r7, fp
 803a55c:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->AFR[position >> 3U] = temp;
 803a560:	f8ca 7020 	str.w	r7, [sl, #32]
      temp = GPIOx->MODER;
 803a564:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 803a566:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 803a568:	f004 0703 	and.w	r7, r4, #3
 803a56c:	fa07 fe0e 	lsl.w	lr, r7, lr
 803a570:	ea4e 0505 	orr.w	r5, lr, r5
      GPIOx->MODER = temp;
 803a574:	6005      	str	r5, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 803a576:	00e5      	lsls	r5, r4, #3
 803a578:	d550      	bpl.n	803a61c <HAL_GPIO_Init+0x168>
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 803a57a:	f04f 0c0f 	mov.w	ip, #15
 803a57e:	f023 0703 	bic.w	r7, r3, #3
 803a582:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 803a586:	f507 373d 	add.w	r7, r7, #193536	; 0x2f400
 803a58a:	f003 0e03 	and.w	lr, r3, #3
        temp = EXTI->EXTICR[position >> 2U];
 803a58e:	6e3d      	ldr	r5, [r7, #96]	; 0x60
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 803a590:	ea4f 0ece 	mov.w	lr, lr, lsl #3
 803a594:	fa0c fc0e 	lsl.w	ip, ip, lr
 803a598:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 803a59c:	4d27      	ldr	r5, [pc, #156]	; (803a63c <HAL_GPIO_Init+0x188>)
 803a59e:	42a8      	cmp	r0, r5
 803a5a0:	d03e      	beq.n	803a620 <HAL_GPIO_Init+0x16c>
 803a5a2:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 803a5a6:	42a8      	cmp	r0, r5
 803a5a8:	d03c      	beq.n	803a624 <HAL_GPIO_Init+0x170>
 803a5aa:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 803a5ae:	42a8      	cmp	r0, r5
 803a5b0:	d03a      	beq.n	803a628 <HAL_GPIO_Init+0x174>
 803a5b2:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 803a5b6:	42a8      	cmp	r0, r5
 803a5b8:	d038      	beq.n	803a62c <HAL_GPIO_Init+0x178>
 803a5ba:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 803a5be:	42a8      	cmp	r0, r5
 803a5c0:	d036      	beq.n	803a630 <HAL_GPIO_Init+0x17c>
 803a5c2:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 803a5c6:	42a8      	cmp	r0, r5
 803a5c8:	d034      	beq.n	803a634 <HAL_GPIO_Init+0x180>
 803a5ca:	4548      	cmp	r0, r9
 803a5cc:	bf14      	ite	ne
 803a5ce:	2507      	movne	r5, #7
 803a5d0:	2506      	moveq	r5, #6
 803a5d2:	fa05 f50e 	lsl.w	r5, r5, lr
 803a5d6:	ea45 050c 	orr.w	r5, r5, ip
        EXTI->EXTICR[position >> 2U] = temp;
 803a5da:	663d      	str	r5, [r7, #96]	; 0x60
        temp &= ~(iocurrent);
 803a5dc:	43f7      	mvns	r7, r6
        temp = EXTI->IMR1;
 803a5de:	f8d2 5080 	ldr.w	r5, [r2, #128]	; 0x80
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 803a5e2:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~(iocurrent);
 803a5e6:	bf0c      	ite	eq
 803a5e8:	403d      	andeq	r5, r7
          temp |= iocurrent;
 803a5ea:	4335      	orrne	r5, r6
        EXTI->IMR1 = temp;
 803a5ec:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
        temp = EXTI->EMR1;
 803a5f0:	f8d2 5084 	ldr.w	r5, [r2, #132]	; 0x84
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 803a5f4:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~(iocurrent);
 803a5f8:	bf0c      	ite	eq
 803a5fa:	403d      	andeq	r5, r7
          temp |= iocurrent;
 803a5fc:	4335      	orrne	r5, r6
        EXTI->EMR1 = temp;
 803a5fe:	f8c2 5084 	str.w	r5, [r2, #132]	; 0x84
        temp = EXTI->RTSR1;
 803a602:	6815      	ldr	r5, [r2, #0]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 803a604:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~(iocurrent);
 803a608:	bf0c      	ite	eq
 803a60a:	403d      	andeq	r5, r7
          temp |= iocurrent;
 803a60c:	4335      	orrne	r5, r6
        EXTI->RTSR1 = temp;
 803a60e:	6015      	str	r5, [r2, #0]
        temp = EXTI->FTSR1;
 803a610:	6855      	ldr	r5, [r2, #4]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 803a612:	02a4      	lsls	r4, r4, #10
        temp &= ~(iocurrent);
 803a614:	bf54      	ite	pl
 803a616:	403d      	andpl	r5, r7
          temp |= iocurrent;
 803a618:	4335      	orrmi	r5, r6
        EXTI->FTSR1 = temp;
 803a61a:	6055      	str	r5, [r2, #4]
    position++;
 803a61c:	3301      	adds	r3, #1
 803a61e:	e751      	b.n	803a4c4 <HAL_GPIO_Init+0x10>
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 803a620:	2500      	movs	r5, #0
 803a622:	e7d6      	b.n	803a5d2 <HAL_GPIO_Init+0x11e>
 803a624:	2501      	movs	r5, #1
 803a626:	e7d4      	b.n	803a5d2 <HAL_GPIO_Init+0x11e>
 803a628:	2502      	movs	r5, #2
 803a62a:	e7d2      	b.n	803a5d2 <HAL_GPIO_Init+0x11e>
 803a62c:	2503      	movs	r5, #3
 803a62e:	e7d0      	b.n	803a5d2 <HAL_GPIO_Init+0x11e>
 803a630:	2504      	movs	r5, #4
 803a632:	e7ce      	b.n	803a5d2 <HAL_GPIO_Init+0x11e>
 803a634:	2505      	movs	r5, #5
 803a636:	e7cc      	b.n	803a5d2 <HAL_GPIO_Init+0x11e>
 803a638:	4002f400 	.word	0x4002f400
 803a63c:	42020000 	.word	0x42020000
 803a640:	42021800 	.word	0x42021800

0803a644 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != 0U)
 803a644:	6943      	ldr	r3, [r0, #20]
 803a646:	420b      	tst	r3, r1
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 803a648:	bf14      	ite	ne
 803a64a:	6281      	strne	r1, [r0, #40]	; 0x28
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 803a64c:	6181      	streq	r1, [r0, #24]
  }
}
 803a64e:	4770      	bx	lr

0803a650 <HAL_PWREx_EnableVddIO2>:
  * @note  Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply is present.
  * @retval None
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_IOSV);
 803a650:	4a02      	ldr	r2, [pc, #8]	; (803a65c <HAL_PWREx_EnableVddIO2+0xc>)
 803a652:	6853      	ldr	r3, [r2, #4]
 803a654:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 803a658:	6053      	str	r3, [r2, #4]
}
 803a65a:	4770      	bx	lr
 803a65c:	40007000 	.word	0x40007000

0803a660 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t msirange = 0U, sysclockfreq = 0U;
  uint32_t pllvco, pllsource, pllr, pllm;    /* no init needed */
  uint32_t sysclk_source, pll_oscsource;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 803a660:	4b23      	ldr	r3, [pc, #140]	; (803a6f0 <HAL_RCC_GetSysClockFreq+0x90>)
 803a662:	689a      	ldr	r2, [r3, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 803a664:	68d9      	ldr	r1, [r3, #12]

  if ((sysclk_source == RCC_CFGR_SWS_MSI) ||
 803a666:	f012 020c 	ands.w	r2, r2, #12
 803a66a:	d005      	beq.n	803a678 <HAL_RCC_GetSysClockFreq+0x18>
 803a66c:	2a0c      	cmp	r2, #12
 803a66e:	d115      	bne.n	803a69c <HAL_RCC_GetSysClockFreq+0x3c>
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 803a670:	f001 0103 	and.w	r1, r1, #3
      ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 803a674:	2901      	cmp	r1, #1
 803a676:	d118      	bne.n	803a6aa <HAL_RCC_GetSysClockFreq+0x4a>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 803a678:	6819      	ldr	r1, [r3, #0]
    {
      /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
    }
    /*MSI frequency range in Hz*/
    msirange = MSIRangeTable[msirange];
 803a67a:	481e      	ldr	r0, [pc, #120]	; (803a6f4 <HAL_RCC_GetSysClockFreq+0x94>)
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 803a67c:	0709      	lsls	r1, r1, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 803a67e:	bf55      	itete	pl
 803a680:	f8d3 1094 	ldrpl.w	r1, [r3, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 803a684:	6819      	ldrmi	r1, [r3, #0]
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 803a686:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 803a68a:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
    msirange = MSIRangeTable[msirange];
 803a68e:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]

    if (sysclk_source == RCC_CFGR_SWS_MSI)
 803a692:	b112      	cbz	r2, 803a69a <HAL_RCC_GetSysClockFreq+0x3a>
  else
  {
    /* unexpected case: sysclockfreq at 0 */
  }

  if (sysclk_source == RCC_CFGR_SWS_PLL)
 803a694:	2a0c      	cmp	r2, #12
 803a696:	d009      	beq.n	803a6ac <HAL_RCC_GetSysClockFreq+0x4c>
 803a698:	2000      	movs	r0, #0
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
    sysclockfreq = pllvco / pllr;
  }

  return sysclockfreq;
}
 803a69a:	4770      	bx	lr
  else if (sysclk_source == RCC_CFGR_SWS_HSI)
 803a69c:	2a04      	cmp	r2, #4
 803a69e:	d024      	beq.n	803a6ea <HAL_RCC_GetSysClockFreq+0x8a>
  else if (sysclk_source == RCC_CFGR_SWS_HSE)
 803a6a0:	2a08      	cmp	r2, #8
 803a6a2:	4815      	ldr	r0, [pc, #84]	; (803a6f8 <HAL_RCC_GetSysClockFreq+0x98>)
 803a6a4:	bf18      	it	ne
 803a6a6:	2000      	movne	r0, #0
 803a6a8:	4770      	bx	lr
  uint32_t msirange = 0U, sysclockfreq = 0U;
 803a6aa:	2000      	movs	r0, #0
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 803a6ac:	68d9      	ldr	r1, [r3, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 803a6ae:	68da      	ldr	r2, [r3, #12]
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 803a6b0:	f001 0103 	and.w	r1, r1, #3
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 803a6b4:	f3c2 1203 	ubfx	r2, r2, #4, #4
    switch (pllsource)
 803a6b8:	2902      	cmp	r1, #2
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 803a6ba:	f102 0201 	add.w	r2, r2, #1
    switch (pllsource)
 803a6be:	d005      	beq.n	803a6cc <HAL_RCC_GetSysClockFreq+0x6c>
 803a6c0:	2903      	cmp	r1, #3
 803a6c2:	d003      	beq.n	803a6cc <HAL_RCC_GetSysClockFreq+0x6c>
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 803a6c4:	68d9      	ldr	r1, [r3, #12]
 803a6c6:	f3c1 2106 	ubfx	r1, r1, #8, #7
 803a6ca:	e003      	b.n	803a6d4 <HAL_RCC_GetSysClockFreq+0x74>
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 803a6cc:	68d9      	ldr	r1, [r3, #12]
 803a6ce:	480a      	ldr	r0, [pc, #40]	; (803a6f8 <HAL_RCC_GetSysClockFreq+0x98>)
 803a6d0:	f3c1 2106 	ubfx	r1, r1, #8, #7
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 803a6d4:	fbb0 f0f2 	udiv	r0, r0, r2
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 803a6d8:	68db      	ldr	r3, [r3, #12]
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 803a6da:	4348      	muls	r0, r1
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 803a6dc:	f3c3 6341 	ubfx	r3, r3, #25, #2
 803a6e0:	3301      	adds	r3, #1
 803a6e2:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco / pllr;
 803a6e4:	fbb0 f0f3 	udiv	r0, r0, r3
 803a6e8:	4770      	bx	lr
 803a6ea:	4803      	ldr	r0, [pc, #12]	; (803a6f8 <HAL_RCC_GetSysClockFreq+0x98>)
 803a6ec:	4770      	bx	lr
 803a6ee:	bf00      	nop
 803a6f0:	40021000 	.word	0x40021000
 803a6f4:	0803e088 	.word	0x0803e088
 803a6f8:	00f42400 	.word	0x00f42400

0803a6fc <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 803a6fc:	b508      	push	{r3, lr}
  SystemCoreClockUpdate();
 803a6fe:	f7fe fd29 	bl	8039154 <SystemCoreClockUpdate>
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 803a702:	4b05      	ldr	r3, [pc, #20]	; (803a718 <HAL_RCC_GetPCLK1Freq+0x1c>)
 803a704:	4a05      	ldr	r2, [pc, #20]	; (803a71c <HAL_RCC_GetPCLK1Freq+0x20>)
 803a706:	689b      	ldr	r3, [r3, #8]
 803a708:	f3c3 2302 	ubfx	r3, r3, #8, #3
 803a70c:	5cd3      	ldrb	r3, [r2, r3]
 803a70e:	4a04      	ldr	r2, [pc, #16]	; (803a720 <HAL_RCC_GetPCLK1Freq+0x24>)
 803a710:	6810      	ldr	r0, [r2, #0]
}
 803a712:	40d8      	lsrs	r0, r3
 803a714:	bd08      	pop	{r3, pc}
 803a716:	bf00      	nop
 803a718:	40021000 	.word	0x40021000
 803a71c:	0803e07e 	.word	0x0803e07e
 803a720:	20000100 	.word	0x20000100

0803a724 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 803a724:	b508      	push	{r3, lr}
  SystemCoreClockUpdate();
 803a726:	f7fe fd15 	bl	8039154 <SystemCoreClockUpdate>
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 803a72a:	4b05      	ldr	r3, [pc, #20]	; (803a740 <HAL_RCC_GetPCLK2Freq+0x1c>)
 803a72c:	4a05      	ldr	r2, [pc, #20]	; (803a744 <HAL_RCC_GetPCLK2Freq+0x20>)
 803a72e:	689b      	ldr	r3, [r3, #8]
 803a730:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 803a734:	5cd3      	ldrb	r3, [r2, r3]
 803a736:	4a04      	ldr	r2, [pc, #16]	; (803a748 <HAL_RCC_GetPCLK2Freq+0x24>)
 803a738:	6810      	ldr	r0, [r2, #0]
}
 803a73a:	40d8      	lsrs	r0, r3
 803a73c:	bd08      	pop	{r3, pc}
 803a73e:	bf00      	nop
 803a740:	40021000 	.word	0x40021000
 803a744:	0803e07e 	.word	0x0803e07e
 803a748:	20000100 	.word	0x20000100
 803a74c:	00000000 	.word	0x00000000

0803a750 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 803a750:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
 803a754:	4604      	mov	r4, r0
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 803a756:	6803      	ldr	r3, [r0, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 803a758:	69c1      	ldr	r1, [r0, #28]
 803a75a:	6882      	ldr	r2, [r0, #8]
 803a75c:	6900      	ldr	r0, [r0, #16]
  tmpreg |= (uint32_t)huart->FifoMode;
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 803a75e:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 803a760:	4302      	orrs	r2, r0
 803a762:	6960      	ldr	r0, [r4, #20]
 803a764:	4302      	orrs	r2, r0
  tmpreg |= (uint32_t)huart->FifoMode;
 803a766:	6e60      	ldr	r0, [r4, #100]	; 0x64
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 803a768:	430a      	orrs	r2, r1
  tmpreg |= (uint32_t)huart->FifoMode;
 803a76a:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 803a76c:	48ad      	ldr	r0, [pc, #692]	; (803aa24 <UART_SetConfig+0x2d4>)
 803a76e:	4028      	ands	r0, r5
 803a770:	4302      	orrs	r2, r0
 803a772:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 803a774:	685a      	ldr	r2, [r3, #4]
 803a776:	68e0      	ldr	r0, [r4, #12]
 803a778:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 803a77c:	4302      	orrs	r2, r0
 803a77e:	605a      	str	r2, [r3, #4]
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 803a780:	4aa9      	ldr	r2, [pc, #676]	; (803aa28 <UART_SetConfig+0x2d8>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 803a782:	69a0      	ldr	r0, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 803a784:	4293      	cmp	r3, r2
  {
    tmpreg |= huart->Init.OneBitSampling;
 803a786:	bf1c      	itt	ne
 803a788:	6a22      	ldrne	r2, [r4, #32]
 803a78a:	4310      	orrne	r0, r2
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 803a78c:	689a      	ldr	r2, [r3, #8]
 803a78e:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 803a792:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 803a796:	4302      	orrs	r2, r0
 803a798:	609a      	str	r2, [r3, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 803a79a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 803a79c:	6a60      	ldr	r0, [r4, #36]	; 0x24
 803a79e:	f022 020f 	bic.w	r2, r2, #15
 803a7a2:	4302      	orrs	r2, r0
 803a7a4:	62da      	str	r2, [r3, #44]	; 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 803a7a6:	4aa1      	ldr	r2, [pc, #644]	; (803aa2c <UART_SetConfig+0x2dc>)
 803a7a8:	4293      	cmp	r3, r2
 803a7aa:	d118      	bne.n	803a7de <UART_SetConfig+0x8e>
 803a7ac:	4ba0      	ldr	r3, [pc, #640]	; (803aa30 <UART_SetConfig+0x2e0>)
 803a7ae:	4aa1      	ldr	r2, [pc, #644]	; (803aa34 <UART_SetConfig+0x2e4>)
 803a7b0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 803a7b4:	f003 0303 	and.w	r3, r3, #3
        }
      } /*   if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) || (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (lpuart_ker_ck_pres != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803a7b8:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 803a7bc:	5cd3      	ldrb	r3, [r2, r3]
 803a7be:	f040 8498 	bne.w	803b0f2 <UART_SetConfig+0x9a2>
  {
    switch (clocksource)
 803a7c2:	2b08      	cmp	r3, #8
 803a7c4:	f200 82a7 	bhi.w	803ad16 <UART_SetConfig+0x5c6>
 803a7c8:	e8df f013 	tbh	[pc, r3, lsl #1]
 803a7cc:	02550461 	.word	0x02550461
 803a7d0:	02a503b9 	.word	0x02a503b9
 803a7d4:	02a50429 	.word	0x02a50429
 803a7d8:	02a502a5 	.word	0x02a502a5
 803a7dc:	0430      	.short	0x0430
  UART_GETCLOCKSOURCE(huart, clocksource);
 803a7de:	4a96      	ldr	r2, [pc, #600]	; (803aa38 <UART_SetConfig+0x2e8>)
 803a7e0:	4293      	cmp	r3, r2
 803a7e2:	d106      	bne.n	803a7f2 <UART_SetConfig+0xa2>
 803a7e4:	4b92      	ldr	r3, [pc, #584]	; (803aa30 <UART_SetConfig+0x2e0>)
 803a7e6:	4a95      	ldr	r2, [pc, #596]	; (803aa3c <UART_SetConfig+0x2ec>)
 803a7e8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 803a7ec:	f003 030c 	and.w	r3, r3, #12
 803a7f0:	e7e2      	b.n	803a7b8 <UART_SetConfig+0x68>
 803a7f2:	4a93      	ldr	r2, [pc, #588]	; (803aa40 <UART_SetConfig+0x2f0>)
 803a7f4:	4293      	cmp	r3, r2
 803a7f6:	d144      	bne.n	803a882 <UART_SetConfig+0x132>
 803a7f8:	f502 32e4 	add.w	r2, r2, #116736	; 0x1c800
 803a7fc:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 803a800:	f002 0230 	and.w	r2, r2, #48	; 0x30
 803a804:	2a10      	cmp	r2, #16
 803a806:	f000 8402 	beq.w	803b00e <UART_SetConfig+0x8be>
 803a80a:	d82a      	bhi.n	803a862 <UART_SetConfig+0x112>
 803a80c:	bb7a      	cbnz	r2, 803a86e <UART_SetConfig+0x11e>
  if (UART_INSTANCE_LOWPOWER(huart))
 803a80e:	4a86      	ldr	r2, [pc, #536]	; (803aa28 <UART_SetConfig+0x2d8>)
 803a810:	4293      	cmp	r3, r2
 803a812:	f040 8438 	bne.w	803b086 <UART_SetConfig+0x936>
        lpuart_ker_ck_pres = (HAL_RCC_GetPCLK1Freq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803a816:	f7ff ff71 	bl	803a6fc <HAL_RCC_GetPCLK1Freq>
 803a81a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803a81c:	2b00      	cmp	r3, #0
 803a81e:	d06c      	beq.n	803a8fa <UART_SetConfig+0x1aa>
 803a820:	2b01      	cmp	r3, #1
 803a822:	d06c      	beq.n	803a8fe <UART_SetConfig+0x1ae>
 803a824:	2b02      	cmp	r3, #2
 803a826:	d06c      	beq.n	803a902 <UART_SetConfig+0x1b2>
 803a828:	2b03      	cmp	r3, #3
 803a82a:	d06c      	beq.n	803a906 <UART_SetConfig+0x1b6>
 803a82c:	2b04      	cmp	r3, #4
 803a82e:	d06c      	beq.n	803a90a <UART_SetConfig+0x1ba>
 803a830:	2b05      	cmp	r3, #5
 803a832:	d06c      	beq.n	803a90e <UART_SetConfig+0x1be>
 803a834:	2b06      	cmp	r3, #6
 803a836:	d06c      	beq.n	803a912 <UART_SetConfig+0x1c2>
 803a838:	2b07      	cmp	r3, #7
 803a83a:	d06c      	beq.n	803a916 <UART_SetConfig+0x1c6>
 803a83c:	2b08      	cmp	r3, #8
 803a83e:	d06c      	beq.n	803a91a <UART_SetConfig+0x1ca>
 803a840:	2b09      	cmp	r3, #9
 803a842:	d06c      	beq.n	803a91e <UART_SetConfig+0x1ce>
 803a844:	2b0a      	cmp	r3, #10
 803a846:	d06c      	beq.n	803a922 <UART_SetConfig+0x1d2>
 803a848:	2b0b      	cmp	r3, #11
 803a84a:	bf14      	ite	ne
 803a84c:	2301      	movne	r3, #1
 803a84e:	f44f 7380 	moveq.w	r3, #256	; 0x100
 803a852:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 803a856:	2100      	movs	r1, #0
    if (lpuart_ker_ck_pres != 0U)
 803a858:	2800      	cmp	r0, #0
 803a85a:	f040 8083 	bne.w	803a964 <UART_SetConfig+0x214>
 803a85e:	4602      	mov	r2, r0
 803a860:	e087      	b.n	803a972 <UART_SetConfig+0x222>
  UART_GETCLOCKSOURCE(huart, clocksource);
 803a862:	2a20      	cmp	r2, #32
 803a864:	f000 8363 	beq.w	803af2e <UART_SetConfig+0x7de>
 803a868:	2a30      	cmp	r2, #48	; 0x30
 803a86a:	f000 83a5 	beq.w	803afb8 <UART_SetConfig+0x868>
  if (UART_INSTANCE_LOWPOWER(huart))
 803a86e:	4a6e      	ldr	r2, [pc, #440]	; (803aa28 <UART_SetConfig+0x2d8>)
 803a870:	4293      	cmp	r3, r2
 803a872:	d07d      	beq.n	803a970 <UART_SetConfig+0x220>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803a874:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 803a878:	f000 824d 	beq.w	803ad16 <UART_SetConfig+0x5c6>
        break;
      case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
        break;
      default:
        ret = HAL_ERROR;
 803a87c:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 803a87e:	2300      	movs	r3, #0
 803a880:	e2db      	b.n	803ae3a <UART_SetConfig+0x6ea>
  UART_GETCLOCKSOURCE(huart, clocksource);
 803a882:	4a70      	ldr	r2, [pc, #448]	; (803aa44 <UART_SetConfig+0x2f4>)
 803a884:	4293      	cmp	r3, r2
 803a886:	d10e      	bne.n	803a8a6 <UART_SetConfig+0x156>
 803a888:	f502 32e2 	add.w	r2, r2, #115712	; 0x1c400
 803a88c:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 803a890:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 803a894:	2a40      	cmp	r2, #64	; 0x40
 803a896:	f000 83ba 	beq.w	803b00e <UART_SetConfig+0x8be>
 803a89a:	d9b7      	bls.n	803a80c <UART_SetConfig+0xbc>
 803a89c:	2a80      	cmp	r2, #128	; 0x80
 803a89e:	f000 8346 	beq.w	803af2e <UART_SetConfig+0x7de>
 803a8a2:	2ac0      	cmp	r2, #192	; 0xc0
 803a8a4:	e7e1      	b.n	803a86a <UART_SetConfig+0x11a>
 803a8a6:	4a68      	ldr	r2, [pc, #416]	; (803aa48 <UART_SetConfig+0x2f8>)
 803a8a8:	4293      	cmp	r3, r2
 803a8aa:	d111      	bne.n	803a8d0 <UART_SetConfig+0x180>
 803a8ac:	f502 32e0 	add.w	r2, r2, #114688	; 0x1c000
 803a8b0:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 803a8b4:	f402 7240 	and.w	r2, r2, #768	; 0x300
 803a8b8:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 803a8bc:	f000 83a7 	beq.w	803b00e <UART_SetConfig+0x8be>
 803a8c0:	d9a4      	bls.n	803a80c <UART_SetConfig+0xbc>
 803a8c2:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 803a8c6:	f000 8332 	beq.w	803af2e <UART_SetConfig+0x7de>
 803a8ca:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 803a8ce:	e7cc      	b.n	803a86a <UART_SetConfig+0x11a>
 803a8d0:	4a55      	ldr	r2, [pc, #340]	; (803aa28 <UART_SetConfig+0x2d8>)
 803a8d2:	4293      	cmp	r3, r2
 803a8d4:	d1ce      	bne.n	803a874 <UART_SetConfig+0x124>
 803a8d6:	f502 32c8 	add.w	r2, r2, #102400	; 0x19000
 803a8da:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 803a8de:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 803a8e2:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 803a8e6:	f000 8392 	beq.w	803b00e <UART_SetConfig+0x8be>
 803a8ea:	d98f      	bls.n	803a80c <UART_SetConfig+0xbc>
 803a8ec:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 803a8f0:	f000 831d 	beq.w	803af2e <UART_SetConfig+0x7de>
 803a8f4:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 803a8f8:	e7b7      	b.n	803a86a <UART_SetConfig+0x11a>
        lpuart_ker_ck_pres = (HAL_RCC_GetPCLK1Freq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803a8fa:	2301      	movs	r3, #1
 803a8fc:	e7a9      	b.n	803a852 <UART_SetConfig+0x102>
 803a8fe:	2302      	movs	r3, #2
 803a900:	e7a7      	b.n	803a852 <UART_SetConfig+0x102>
 803a902:	2304      	movs	r3, #4
 803a904:	e7a5      	b.n	803a852 <UART_SetConfig+0x102>
 803a906:	2306      	movs	r3, #6
 803a908:	e7a3      	b.n	803a852 <UART_SetConfig+0x102>
 803a90a:	2308      	movs	r3, #8
 803a90c:	e7a1      	b.n	803a852 <UART_SetConfig+0x102>
 803a90e:	230a      	movs	r3, #10
 803a910:	e79f      	b.n	803a852 <UART_SetConfig+0x102>
 803a912:	230c      	movs	r3, #12
 803a914:	e79d      	b.n	803a852 <UART_SetConfig+0x102>
 803a916:	2310      	movs	r3, #16
 803a918:	e79b      	b.n	803a852 <UART_SetConfig+0x102>
 803a91a:	2320      	movs	r3, #32
 803a91c:	e799      	b.n	803a852 <UART_SetConfig+0x102>
 803a91e:	2340      	movs	r3, #64	; 0x40
 803a920:	e797      	b.n	803a852 <UART_SetConfig+0x102>
 803a922:	2380      	movs	r3, #128	; 0x80
 803a924:	e795      	b.n	803a852 <UART_SetConfig+0x102>
        lpuart_ker_ck_pres = ((uint32_t)HSI_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803a926:	2800      	cmp	r0, #0
 803a928:	d063      	beq.n	803a9f2 <UART_SetConfig+0x2a2>
 803a92a:	2801      	cmp	r0, #1
 803a92c:	d064      	beq.n	803a9f8 <UART_SetConfig+0x2a8>
 803a92e:	2802      	cmp	r0, #2
 803a930:	d065      	beq.n	803a9fe <UART_SetConfig+0x2ae>
 803a932:	2803      	cmp	r0, #3
 803a934:	f04f 0102 	mov.w	r1, #2
 803a938:	d064      	beq.n	803aa04 <UART_SetConfig+0x2b4>
 803a93a:	2804      	cmp	r0, #4
 803a93c:	d064      	beq.n	803aa08 <UART_SetConfig+0x2b8>
 803a93e:	2805      	cmp	r0, #5
 803a940:	d064      	beq.n	803aa0c <UART_SetConfig+0x2bc>
 803a942:	2806      	cmp	r0, #6
 803a944:	d064      	beq.n	803aa10 <UART_SetConfig+0x2c0>
 803a946:	2807      	cmp	r0, #7
 803a948:	d064      	beq.n	803aa14 <UART_SetConfig+0x2c4>
 803a94a:	2808      	cmp	r0, #8
 803a94c:	d064      	beq.n	803aa18 <UART_SetConfig+0x2c8>
 803a94e:	2809      	cmp	r0, #9
 803a950:	d064      	beq.n	803aa1c <UART_SetConfig+0x2cc>
 803a952:	280a      	cmp	r0, #10
 803a954:	d064      	beq.n	803aa20 <UART_SetConfig+0x2d0>
 803a956:	f24f 4224 	movw	r2, #62500	; 0xf424
 803a95a:	4b3c      	ldr	r3, [pc, #240]	; (803aa4c <UART_SetConfig+0x2fc>)
 803a95c:	280b      	cmp	r0, #11
 803a95e:	bf14      	ite	ne
 803a960:	4618      	movne	r0, r3
 803a962:	4610      	moveq	r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 803a964:	6862      	ldr	r2, [r4, #4]
 803a966:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 803a96a:	4283      	cmp	r3, r0
 803a96c:	f240 80a5 	bls.w	803aaba <UART_SetConfig+0x36a>
        ret = HAL_ERROR;
 803a970:	2201      	movs	r2, #1
      ret = HAL_ERROR;
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 803a972:	2300      	movs	r3, #0
 803a974:	f04f 1101 	mov.w	r1, #65537	; 0x10001
  huart->NbRxDataToProcess = 1;

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 803a978:	6723      	str	r3, [r4, #112]	; 0x70
  huart->NbTxDataToProcess = 1;
 803a97a:	e9c4 131a 	strd	r1, r3, [r4, #104]	; 0x68
  huart->TxISR = NULL;

  return ret;
}
 803a97e:	4610      	mov	r0, r2
 803a980:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
        lpuart_ker_ck_pres = (HAL_RCC_GetSysClockFreq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803a984:	f7ff fe6c 	bl	803a660 <HAL_RCC_GetSysClockFreq>
 803a988:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803a98a:	b1e3      	cbz	r3, 803a9c6 <UART_SetConfig+0x276>
 803a98c:	2b01      	cmp	r3, #1
 803a98e:	d01c      	beq.n	803a9ca <UART_SetConfig+0x27a>
 803a990:	2b02      	cmp	r3, #2
 803a992:	d01c      	beq.n	803a9ce <UART_SetConfig+0x27e>
 803a994:	2b03      	cmp	r3, #3
 803a996:	d01c      	beq.n	803a9d2 <UART_SetConfig+0x282>
 803a998:	2b04      	cmp	r3, #4
 803a99a:	d01c      	beq.n	803a9d6 <UART_SetConfig+0x286>
 803a99c:	2b05      	cmp	r3, #5
 803a99e:	d01c      	beq.n	803a9da <UART_SetConfig+0x28a>
 803a9a0:	2b06      	cmp	r3, #6
 803a9a2:	d01c      	beq.n	803a9de <UART_SetConfig+0x28e>
 803a9a4:	2b07      	cmp	r3, #7
 803a9a6:	d01c      	beq.n	803a9e2 <UART_SetConfig+0x292>
 803a9a8:	2b08      	cmp	r3, #8
 803a9aa:	d01c      	beq.n	803a9e6 <UART_SetConfig+0x296>
 803a9ac:	2b09      	cmp	r3, #9
 803a9ae:	d01c      	beq.n	803a9ea <UART_SetConfig+0x29a>
 803a9b0:	2b0a      	cmp	r3, #10
 803a9b2:	d01c      	beq.n	803a9ee <UART_SetConfig+0x29e>
 803a9b4:	2b0b      	cmp	r3, #11
 803a9b6:	bf14      	ite	ne
 803a9b8:	2301      	movne	r3, #1
 803a9ba:	f44f 7380 	moveq.w	r3, #256	; 0x100
 803a9be:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 803a9c2:	2104      	movs	r1, #4
 803a9c4:	e748      	b.n	803a858 <UART_SetConfig+0x108>
        lpuart_ker_ck_pres = (HAL_RCC_GetSysClockFreq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803a9c6:	2301      	movs	r3, #1
 803a9c8:	e7f9      	b.n	803a9be <UART_SetConfig+0x26e>
 803a9ca:	2302      	movs	r3, #2
 803a9cc:	e7f7      	b.n	803a9be <UART_SetConfig+0x26e>
 803a9ce:	2304      	movs	r3, #4
 803a9d0:	e7f5      	b.n	803a9be <UART_SetConfig+0x26e>
 803a9d2:	2306      	movs	r3, #6
 803a9d4:	e7f3      	b.n	803a9be <UART_SetConfig+0x26e>
 803a9d6:	2308      	movs	r3, #8
 803a9d8:	e7f1      	b.n	803a9be <UART_SetConfig+0x26e>
 803a9da:	230a      	movs	r3, #10
 803a9dc:	e7ef      	b.n	803a9be <UART_SetConfig+0x26e>
 803a9de:	230c      	movs	r3, #12
 803a9e0:	e7ed      	b.n	803a9be <UART_SetConfig+0x26e>
 803a9e2:	2310      	movs	r3, #16
 803a9e4:	e7eb      	b.n	803a9be <UART_SetConfig+0x26e>
 803a9e6:	2320      	movs	r3, #32
 803a9e8:	e7e9      	b.n	803a9be <UART_SetConfig+0x26e>
 803a9ea:	2340      	movs	r3, #64	; 0x40
 803a9ec:	e7e7      	b.n	803a9be <UART_SetConfig+0x26e>
 803a9ee:	2380      	movs	r3, #128	; 0x80
 803a9f0:	e7e5      	b.n	803a9be <UART_SetConfig+0x26e>
 803a9f2:	2102      	movs	r1, #2
        lpuart_ker_ck_pres = ((uint32_t)HSI_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803a9f4:	4815      	ldr	r0, [pc, #84]	; (803aa4c <UART_SetConfig+0x2fc>)
 803a9f6:	e7b5      	b.n	803a964 <UART_SetConfig+0x214>
 803a9f8:	2102      	movs	r1, #2
 803a9fa:	4815      	ldr	r0, [pc, #84]	; (803aa50 <UART_SetConfig+0x300>)
 803a9fc:	e7b2      	b.n	803a964 <UART_SetConfig+0x214>
 803a9fe:	4601      	mov	r1, r0
 803aa00:	4814      	ldr	r0, [pc, #80]	; (803aa54 <UART_SetConfig+0x304>)
 803aa02:	e7af      	b.n	803a964 <UART_SetConfig+0x214>
 803aa04:	4814      	ldr	r0, [pc, #80]	; (803aa58 <UART_SetConfig+0x308>)
 803aa06:	e7ad      	b.n	803a964 <UART_SetConfig+0x214>
 803aa08:	4814      	ldr	r0, [pc, #80]	; (803aa5c <UART_SetConfig+0x30c>)
 803aa0a:	e7ab      	b.n	803a964 <UART_SetConfig+0x214>
 803aa0c:	4814      	ldr	r0, [pc, #80]	; (803aa60 <UART_SetConfig+0x310>)
 803aa0e:	e7a9      	b.n	803a964 <UART_SetConfig+0x214>
 803aa10:	4814      	ldr	r0, [pc, #80]	; (803aa64 <UART_SetConfig+0x314>)
 803aa12:	e7a7      	b.n	803a964 <UART_SetConfig+0x214>
 803aa14:	4814      	ldr	r0, [pc, #80]	; (803aa68 <UART_SetConfig+0x318>)
 803aa16:	e7a5      	b.n	803a964 <UART_SetConfig+0x214>
 803aa18:	4814      	ldr	r0, [pc, #80]	; (803aa6c <UART_SetConfig+0x31c>)
 803aa1a:	e7a3      	b.n	803a964 <UART_SetConfig+0x214>
 803aa1c:	4814      	ldr	r0, [pc, #80]	; (803aa70 <UART_SetConfig+0x320>)
 803aa1e:	e7a1      	b.n	803a964 <UART_SetConfig+0x214>
 803aa20:	4814      	ldr	r0, [pc, #80]	; (803aa74 <UART_SetConfig+0x324>)
 803aa22:	e79f      	b.n	803a964 <UART_SetConfig+0x214>
 803aa24:	cfff69f3 	.word	0xcfff69f3
 803aa28:	40008000 	.word	0x40008000
 803aa2c:	40013800 	.word	0x40013800
 803aa30:	40021000 	.word	0x40021000
 803aa34:	0803eb07 	.word	0x0803eb07
 803aa38:	40004400 	.word	0x40004400
 803aa3c:	0803eb0b 	.word	0x0803eb0b
 803aa40:	40004800 	.word	0x40004800
 803aa44:	40004c00 	.word	0x40004c00
 803aa48:	40005000 	.word	0x40005000
 803aa4c:	00f42400 	.word	0x00f42400
 803aa50:	007a1200 	.word	0x007a1200
 803aa54:	003d0900 	.word	0x003d0900
 803aa58:	0028b0aa 	.word	0x0028b0aa
 803aa5c:	001e8480 	.word	0x001e8480
 803aa60:	00186a00 	.word	0x00186a00
 803aa64:	00145855 	.word	0x00145855
 803aa68:	000f4240 	.word	0x000f4240
 803aa6c:	0007a120 	.word	0x0007a120
 803aa70:	0003d090 	.word	0x0003d090
 803aa74:	0001e848 	.word	0x0001e848
        lpuart_ker_ck_pres = ((uint32_t)LSE_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803aa78:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 803aa7c:	e772      	b.n	803a964 <UART_SetConfig+0x214>
 803aa7e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 803aa82:	e76f      	b.n	803a964 <UART_SetConfig+0x214>
 803aa84:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 803aa88:	e76c      	b.n	803a964 <UART_SetConfig+0x214>
 803aa8a:	f241 5055 	movw	r0, #5461	; 0x1555
 803aa8e:	e769      	b.n	803a964 <UART_SetConfig+0x214>
 803aa90:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 803aa94:	e766      	b.n	803a964 <UART_SetConfig+0x214>
 803aa96:	f640 40cc 	movw	r0, #3276	; 0xccc
 803aa9a:	e763      	b.n	803a964 <UART_SetConfig+0x214>
 803aa9c:	f640 20aa 	movw	r0, #2730	; 0xaaa
 803aaa0:	e760      	b.n	803a964 <UART_SetConfig+0x214>
 803aaa2:	f44f 6000 	mov.w	r0, #2048	; 0x800
 803aaa6:	e75d      	b.n	803a964 <UART_SetConfig+0x214>
 803aaa8:	f44f 6080 	mov.w	r0, #1024	; 0x400
 803aaac:	e75a      	b.n	803a964 <UART_SetConfig+0x214>
 803aaae:	f44f 7000 	mov.w	r0, #512	; 0x200
 803aab2:	e757      	b.n	803a964 <UART_SetConfig+0x214>
 803aab4:	f44f 7080 	mov.w	r0, #256	; 0x100
 803aab8:	e754      	b.n	803a964 <UART_SetConfig+0x214>
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 803aaba:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
 803aabe:	f63f af57 	bhi.w	803a970 <UART_SetConfig+0x220>
        switch (clocksource)
 803aac2:	2908      	cmp	r1, #8
 803aac4:	f200 80d4 	bhi.w	803ac70 <UART_SetConfig+0x520>
 803aac8:	e8df f001 	tbb	[pc, r1]
 803aacc:	d2444105 	.word	0xd2444105
 803aad0:	d2d2d280 	.word	0xd2d2d280
 803aad4:	99          	.byte	0x99
 803aad5:	00          	.byte	0x00
            pclk = HAL_RCC_GetPCLK1Freq();
 803aad6:	f7ff fe11 	bl	803a6fc <HAL_RCC_GetPCLK1Freq>
            usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803aada:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803aadc:	2b00      	cmp	r3, #0
 803aade:	f000 808c 	beq.w	803abfa <UART_SetConfig+0x4aa>
 803aae2:	2b01      	cmp	r3, #1
 803aae4:	d075      	beq.n	803abd2 <UART_SetConfig+0x482>
 803aae6:	2b02      	cmp	r3, #2
 803aae8:	d075      	beq.n	803abd6 <UART_SetConfig+0x486>
 803aaea:	2b03      	cmp	r3, #3
 803aaec:	d075      	beq.n	803abda <UART_SetConfig+0x48a>
 803aaee:	2b04      	cmp	r3, #4
 803aaf0:	d075      	beq.n	803abde <UART_SetConfig+0x48e>
 803aaf2:	2b05      	cmp	r3, #5
 803aaf4:	d075      	beq.n	803abe2 <UART_SetConfig+0x492>
 803aaf6:	2b06      	cmp	r3, #6
 803aaf8:	d075      	beq.n	803abe6 <UART_SetConfig+0x496>
 803aafa:	2b07      	cmp	r3, #7
 803aafc:	d075      	beq.n	803abea <UART_SetConfig+0x49a>
 803aafe:	2b08      	cmp	r3, #8
 803ab00:	d075      	beq.n	803abee <UART_SetConfig+0x49e>
 803ab02:	2b09      	cmp	r3, #9
 803ab04:	d075      	beq.n	803abf2 <UART_SetConfig+0x4a2>
 803ab06:	2b0a      	cmp	r3, #10
 803ab08:	d075      	beq.n	803abf6 <UART_SetConfig+0x4a6>
 803ab0a:	2b0b      	cmp	r3, #11
 803ab0c:	d175      	bne.n	803abfa <UART_SetConfig+0x4aa>
 803ab0e:	f44f 7280 	mov.w	r2, #256	; 0x100
 803ab12:	2300      	movs	r3, #0
 803ab14:	2100      	movs	r1, #0
 803ab16:	f002 fe03 	bl	803d720 <__aeabi_uldivmod>
 803ab1a:	6865      	ldr	r5, [r4, #4]
 803ab1c:	020f      	lsls	r7, r1, #8
 803ab1e:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 803ab22:	0206      	lsls	r6, r0, #8
 803ab24:	0868      	lsrs	r0, r5, #1
 803ab26:	eb16 0b00 	adds.w	fp, r6, r0
 803ab2a:	f147 0c00 	adc.w	ip, r7, #0
 803ab2e:	462a      	mov	r2, r5
 803ab30:	2300      	movs	r3, #0
 803ab32:	4658      	mov	r0, fp
 803ab34:	4661      	mov	r1, ip
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ab36:	f002 fdf3 	bl	803d720 <__aeabi_uldivmod>
            break;
 803ab3a:	2200      	movs	r2, #0
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 803ab3c:	4b96      	ldr	r3, [pc, #600]	; (803ad98 <UART_SetConfig+0x648>)
 803ab3e:	f5a0 7140 	sub.w	r1, r0, #768	; 0x300
 803ab42:	4299      	cmp	r1, r3
 803ab44:	f63f af14 	bhi.w	803a970 <UART_SetConfig+0x220>
          huart->Instance->BRR = usartdiv;
 803ab48:	6823      	ldr	r3, [r4, #0]
 803ab4a:	60d8      	str	r0, [r3, #12]
 803ab4c:	e711      	b.n	803a972 <UART_SetConfig+0x222>
            pclk = HAL_RCC_GetPCLK2Freq();
 803ab4e:	f7ff fde9 	bl	803a724 <HAL_RCC_GetPCLK2Freq>
 803ab52:	e7c2      	b.n	803aada <UART_SetConfig+0x38a>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ab54:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803ab56:	2b00      	cmp	r3, #0
 803ab58:	d036      	beq.n	803abc8 <UART_SetConfig+0x478>
 803ab5a:	2b01      	cmp	r3, #1
 803ab5c:	d016      	beq.n	803ab8c <UART_SetConfig+0x43c>
 803ab5e:	2b02      	cmp	r3, #2
 803ab60:	d016      	beq.n	803ab90 <UART_SetConfig+0x440>
 803ab62:	2b03      	cmp	r3, #3
 803ab64:	d016      	beq.n	803ab94 <UART_SetConfig+0x444>
 803ab66:	2b04      	cmp	r3, #4
 803ab68:	d01e      	beq.n	803aba8 <UART_SetConfig+0x458>
 803ab6a:	2b05      	cmp	r3, #5
 803ab6c:	d01e      	beq.n	803abac <UART_SetConfig+0x45c>
 803ab6e:	2b06      	cmp	r3, #6
 803ab70:	d01e      	beq.n	803abb0 <UART_SetConfig+0x460>
 803ab72:	2b07      	cmp	r3, #7
 803ab74:	d020      	beq.n	803abb8 <UART_SetConfig+0x468>
 803ab76:	2b08      	cmp	r3, #8
 803ab78:	d020      	beq.n	803abbc <UART_SetConfig+0x46c>
 803ab7a:	2b09      	cmp	r3, #9
 803ab7c:	d020      	beq.n	803abc0 <UART_SetConfig+0x470>
 803ab7e:	2b0a      	cmp	r3, #10
 803ab80:	d020      	beq.n	803abc4 <UART_SetConfig+0x474>
 803ab82:	2b0b      	cmp	r3, #11
 803ab84:	d120      	bne.n	803abc8 <UART_SetConfig+0x478>
 803ab86:	4e85      	ldr	r6, [pc, #532]	; (803ad9c <UART_SetConfig+0x64c>)
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ab88:	2700      	movs	r7, #0
 803ab8a:	e006      	b.n	803ab9a <UART_SetConfig+0x44a>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ab8c:	4e84      	ldr	r6, [pc, #528]	; (803ada0 <UART_SetConfig+0x650>)
 803ab8e:	e7fb      	b.n	803ab88 <UART_SetConfig+0x438>
 803ab90:	4e84      	ldr	r6, [pc, #528]	; (803ada4 <UART_SetConfig+0x654>)
 803ab92:	e7f9      	b.n	803ab88 <UART_SetConfig+0x438>
 803ab94:	a77c      	add	r7, pc, #496	; (adr r7, 803ad88 <UART_SetConfig+0x638>)
 803ab96:	e9d7 6700 	ldrd	r6, r7, [r7]
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ab9a:	0855      	lsrs	r5, r2, #1
 803ab9c:	1970      	adds	r0, r6, r5
 803ab9e:	f04f 0300 	mov.w	r3, #0
 803aba2:	f147 0100 	adc.w	r1, r7, #0
 803aba6:	e7c6      	b.n	803ab36 <UART_SetConfig+0x3e6>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803aba8:	4e7f      	ldr	r6, [pc, #508]	; (803ada8 <UART_SetConfig+0x658>)
 803abaa:	e7ed      	b.n	803ab88 <UART_SetConfig+0x438>
 803abac:	4e7f      	ldr	r6, [pc, #508]	; (803adac <UART_SetConfig+0x65c>)
 803abae:	e7eb      	b.n	803ab88 <UART_SetConfig+0x438>
 803abb0:	a777      	add	r7, pc, #476	; (adr r7, 803ad90 <UART_SetConfig+0x640>)
 803abb2:	e9d7 6700 	ldrd	r6, r7, [r7]
 803abb6:	e7f0      	b.n	803ab9a <UART_SetConfig+0x44a>
 803abb8:	4e7d      	ldr	r6, [pc, #500]	; (803adb0 <UART_SetConfig+0x660>)
 803abba:	e7e5      	b.n	803ab88 <UART_SetConfig+0x438>
 803abbc:	4e7d      	ldr	r6, [pc, #500]	; (803adb4 <UART_SetConfig+0x664>)
 803abbe:	e7e3      	b.n	803ab88 <UART_SetConfig+0x438>
 803abc0:	4e7d      	ldr	r6, [pc, #500]	; (803adb8 <UART_SetConfig+0x668>)
 803abc2:	e7e1      	b.n	803ab88 <UART_SetConfig+0x438>
 803abc4:	4e7d      	ldr	r6, [pc, #500]	; (803adbc <UART_SetConfig+0x66c>)
 803abc6:	e7df      	b.n	803ab88 <UART_SetConfig+0x438>
 803abc8:	4e7d      	ldr	r6, [pc, #500]	; (803adc0 <UART_SetConfig+0x670>)
 803abca:	e7dd      	b.n	803ab88 <UART_SetConfig+0x438>
            pclk = HAL_RCC_GetSysClockFreq();
 803abcc:	f7ff fd48 	bl	803a660 <HAL_RCC_GetSysClockFreq>
 803abd0:	e783      	b.n	803aada <UART_SetConfig+0x38a>
            usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803abd2:	2202      	movs	r2, #2
 803abd4:	e79d      	b.n	803ab12 <UART_SetConfig+0x3c2>
 803abd6:	2204      	movs	r2, #4
 803abd8:	e79b      	b.n	803ab12 <UART_SetConfig+0x3c2>
 803abda:	2206      	movs	r2, #6
 803abdc:	e799      	b.n	803ab12 <UART_SetConfig+0x3c2>
 803abde:	2208      	movs	r2, #8
 803abe0:	e797      	b.n	803ab12 <UART_SetConfig+0x3c2>
 803abe2:	220a      	movs	r2, #10
 803abe4:	e795      	b.n	803ab12 <UART_SetConfig+0x3c2>
 803abe6:	220c      	movs	r2, #12
 803abe8:	e793      	b.n	803ab12 <UART_SetConfig+0x3c2>
 803abea:	2210      	movs	r2, #16
 803abec:	e791      	b.n	803ab12 <UART_SetConfig+0x3c2>
 803abee:	2220      	movs	r2, #32
 803abf0:	e78f      	b.n	803ab12 <UART_SetConfig+0x3c2>
 803abf2:	2240      	movs	r2, #64	; 0x40
 803abf4:	e78d      	b.n	803ab12 <UART_SetConfig+0x3c2>
 803abf6:	2280      	movs	r2, #128	; 0x80
 803abf8:	e78b      	b.n	803ab12 <UART_SetConfig+0x3c2>
 803abfa:	2201      	movs	r2, #1
 803abfc:	e789      	b.n	803ab12 <UART_SetConfig+0x3c2>
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803abfe:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803ac00:	b39b      	cbz	r3, 803ac6a <UART_SetConfig+0x51a>
 803ac02:	2b01      	cmp	r3, #1
 803ac04:	d016      	beq.n	803ac34 <UART_SetConfig+0x4e4>
 803ac06:	2b02      	cmp	r3, #2
 803ac08:	d017      	beq.n	803ac3a <UART_SetConfig+0x4ea>
 803ac0a:	2b03      	cmp	r3, #3
 803ac0c:	d018      	beq.n	803ac40 <UART_SetConfig+0x4f0>
 803ac0e:	2b04      	cmp	r3, #4
 803ac10:	d018      	beq.n	803ac44 <UART_SetConfig+0x4f4>
 803ac12:	2b05      	cmp	r3, #5
 803ac14:	d019      	beq.n	803ac4a <UART_SetConfig+0x4fa>
 803ac16:	2b06      	cmp	r3, #6
 803ac18:	d019      	beq.n	803ac4e <UART_SetConfig+0x4fe>
 803ac1a:	2b07      	cmp	r3, #7
 803ac1c:	d019      	beq.n	803ac52 <UART_SetConfig+0x502>
 803ac1e:	2b08      	cmp	r3, #8
 803ac20:	d01a      	beq.n	803ac58 <UART_SetConfig+0x508>
 803ac22:	2b09      	cmp	r3, #9
 803ac24:	d01b      	beq.n	803ac5e <UART_SetConfig+0x50e>
 803ac26:	2b0a      	cmp	r3, #10
 803ac28:	d01c      	beq.n	803ac64 <UART_SetConfig+0x514>
 803ac2a:	2b0b      	cmp	r3, #11
 803ac2c:	d11d      	bne.n	803ac6a <UART_SetConfig+0x51a>
 803ac2e:	f44f 4600 	mov.w	r6, #32768	; 0x8000
 803ac32:	e7a9      	b.n	803ab88 <UART_SetConfig+0x438>
 803ac34:	f44f 0680 	mov.w	r6, #4194304	; 0x400000
 803ac38:	e7a6      	b.n	803ab88 <UART_SetConfig+0x438>
 803ac3a:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
 803ac3e:	e7a3      	b.n	803ab88 <UART_SetConfig+0x438>
 803ac40:	4e60      	ldr	r6, [pc, #384]	; (803adc4 <UART_SetConfig+0x674>)
 803ac42:	e7a1      	b.n	803ab88 <UART_SetConfig+0x438>
 803ac44:	f44f 1680 	mov.w	r6, #1048576	; 0x100000
 803ac48:	e79e      	b.n	803ab88 <UART_SetConfig+0x438>
 803ac4a:	4e5f      	ldr	r6, [pc, #380]	; (803adc8 <UART_SetConfig+0x678>)
 803ac4c:	e79c      	b.n	803ab88 <UART_SetConfig+0x438>
 803ac4e:	4e5f      	ldr	r6, [pc, #380]	; (803adcc <UART_SetConfig+0x67c>)
 803ac50:	e79a      	b.n	803ab88 <UART_SetConfig+0x438>
 803ac52:	f44f 2600 	mov.w	r6, #524288	; 0x80000
 803ac56:	e797      	b.n	803ab88 <UART_SetConfig+0x438>
 803ac58:	f44f 2680 	mov.w	r6, #262144	; 0x40000
 803ac5c:	e794      	b.n	803ab88 <UART_SetConfig+0x438>
 803ac5e:	f44f 3600 	mov.w	r6, #131072	; 0x20000
 803ac62:	e791      	b.n	803ab88 <UART_SetConfig+0x438>
 803ac64:	f44f 3680 	mov.w	r6, #65536	; 0x10000
 803ac68:	e78e      	b.n	803ab88 <UART_SetConfig+0x438>
 803ac6a:	f44f 0600 	mov.w	r6, #8388608	; 0x800000
 803ac6e:	e78b      	b.n	803ab88 <UART_SetConfig+0x438>
            ret = HAL_ERROR;
 803ac70:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 803ac72:	2000      	movs	r0, #0
 803ac74:	e762      	b.n	803ab3c <UART_SetConfig+0x3ec>
        pclk = HAL_RCC_GetPCLK2Freq();
 803ac76:	f7ff fd55 	bl	803a724 <HAL_RCC_GetPCLK2Freq>
 803ac7a:	e20a      	b.n	803b092 <UART_SetConfig+0x942>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ac7c:	484f      	ldr	r0, [pc, #316]	; (803adbc <UART_SetConfig+0x66c>)
 803ac7e:	e185      	b.n	803af8c <UART_SetConfig+0x83c>
 803ac80:	4846      	ldr	r0, [pc, #280]	; (803ad9c <UART_SetConfig+0x64c>)
 803ac82:	e183      	b.n	803af8c <UART_SetConfig+0x83c>
 803ac84:	4852      	ldr	r0, [pc, #328]	; (803add0 <UART_SetConfig+0x680>)
 803ac86:	e181      	b.n	803af8c <UART_SetConfig+0x83c>
 803ac88:	4852      	ldr	r0, [pc, #328]	; (803add4 <UART_SetConfig+0x684>)
 803ac8a:	e17f      	b.n	803af8c <UART_SetConfig+0x83c>
 803ac8c:	4852      	ldr	r0, [pc, #328]	; (803add8 <UART_SetConfig+0x688>)
 803ac8e:	e17d      	b.n	803af8c <UART_SetConfig+0x83c>
 803ac90:	4852      	ldr	r0, [pc, #328]	; (803addc <UART_SetConfig+0x68c>)
 803ac92:	e17b      	b.n	803af8c <UART_SetConfig+0x83c>
 803ac94:	4852      	ldr	r0, [pc, #328]	; (803ade0 <UART_SetConfig+0x690>)
 803ac96:	e179      	b.n	803af8c <UART_SetConfig+0x83c>
 803ac98:	4852      	ldr	r0, [pc, #328]	; (803ade4 <UART_SetConfig+0x694>)
 803ac9a:	e177      	b.n	803af8c <UART_SetConfig+0x83c>
 803ac9c:	4852      	ldr	r0, [pc, #328]	; (803ade8 <UART_SetConfig+0x698>)
 803ac9e:	e175      	b.n	803af8c <UART_SetConfig+0x83c>
 803aca0:	4852      	ldr	r0, [pc, #328]	; (803adec <UART_SetConfig+0x69c>)
 803aca2:	e173      	b.n	803af8c <UART_SetConfig+0x83c>
 803aca4:	4852      	ldr	r0, [pc, #328]	; (803adf0 <UART_SetConfig+0x6a0>)
 803aca6:	e171      	b.n	803af8c <UART_SetConfig+0x83c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803aca8:	2201      	movs	r2, #1
 803acaa:	e219      	b.n	803b0e0 <UART_SetConfig+0x990>
 803acac:	2202      	movs	r2, #2
 803acae:	e217      	b.n	803b0e0 <UART_SetConfig+0x990>
 803acb0:	2204      	movs	r2, #4
 803acb2:	e215      	b.n	803b0e0 <UART_SetConfig+0x990>
 803acb4:	2206      	movs	r2, #6
 803acb6:	e213      	b.n	803b0e0 <UART_SetConfig+0x990>
 803acb8:	2208      	movs	r2, #8
 803acba:	e211      	b.n	803b0e0 <UART_SetConfig+0x990>
 803acbc:	220a      	movs	r2, #10
 803acbe:	e20f      	b.n	803b0e0 <UART_SetConfig+0x990>
 803acc0:	220c      	movs	r2, #12
 803acc2:	e20d      	b.n	803b0e0 <UART_SetConfig+0x990>
 803acc4:	2210      	movs	r2, #16
 803acc6:	e20b      	b.n	803b0e0 <UART_SetConfig+0x990>
 803acc8:	2220      	movs	r2, #32
 803acca:	e209      	b.n	803b0e0 <UART_SetConfig+0x990>
 803accc:	2240      	movs	r2, #64	; 0x40
 803acce:	e207      	b.n	803b0e0 <UART_SetConfig+0x990>
 803acd0:	2280      	movs	r2, #128	; 0x80
 803acd2:	e205      	b.n	803b0e0 <UART_SetConfig+0x990>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803acd4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 803acd8:	e1cf      	b.n	803b07a <UART_SetConfig+0x92a>
 803acda:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 803acde:	e1cc      	b.n	803b07a <UART_SetConfig+0x92a>
 803ace0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 803ace4:	e1c9      	b.n	803b07a <UART_SetConfig+0x92a>
 803ace6:	f642 23aa 	movw	r3, #10922	; 0x2aaa
 803acea:	e1c6      	b.n	803b07a <UART_SetConfig+0x92a>
 803acec:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 803acf0:	e1c3      	b.n	803b07a <UART_SetConfig+0x92a>
 803acf2:	f641 1398 	movw	r3, #6552	; 0x1998
 803acf6:	e1c0      	b.n	803b07a <UART_SetConfig+0x92a>
 803acf8:	f241 5354 	movw	r3, #5460	; 0x1554
 803acfc:	e1bd      	b.n	803b07a <UART_SetConfig+0x92a>
 803acfe:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 803ad02:	e1ba      	b.n	803b07a <UART_SetConfig+0x92a>
 803ad04:	f44f 6300 	mov.w	r3, #2048	; 0x800
 803ad08:	e1b7      	b.n	803b07a <UART_SetConfig+0x92a>
 803ad0a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 803ad0e:	e1b4      	b.n	803b07a <UART_SetConfig+0x92a>
 803ad10:	f44f 7300 	mov.w	r3, #512	; 0x200
 803ad14:	e1b1      	b.n	803b07a <UART_SetConfig+0x92a>
        ret = HAL_ERROR;
 803ad16:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 803ad18:	2300      	movs	r3, #0
 803ad1a:	e13e      	b.n	803af9a <UART_SetConfig+0x84a>
        pclk = HAL_RCC_GetPCLK1Freq();
 803ad1c:	f7ff fcee 	bl	803a6fc <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ad20:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803ad22:	2b00      	cmp	r3, #0
 803ad24:	f000 80ac 	beq.w	803ae80 <UART_SetConfig+0x730>
 803ad28:	2b01      	cmp	r3, #1
 803ad2a:	f000 80ab 	beq.w	803ae84 <UART_SetConfig+0x734>
 803ad2e:	2b02      	cmp	r3, #2
 803ad30:	f000 80aa 	beq.w	803ae88 <UART_SetConfig+0x738>
 803ad34:	2b03      	cmp	r3, #3
 803ad36:	f000 80a9 	beq.w	803ae8c <UART_SetConfig+0x73c>
 803ad3a:	2b04      	cmp	r3, #4
 803ad3c:	f000 80a8 	beq.w	803ae90 <UART_SetConfig+0x740>
 803ad40:	2b05      	cmp	r3, #5
 803ad42:	f000 80a7 	beq.w	803ae94 <UART_SetConfig+0x744>
 803ad46:	2b06      	cmp	r3, #6
 803ad48:	f000 80a6 	beq.w	803ae98 <UART_SetConfig+0x748>
 803ad4c:	2b07      	cmp	r3, #7
 803ad4e:	f000 80a5 	beq.w	803ae9c <UART_SetConfig+0x74c>
 803ad52:	2b08      	cmp	r3, #8
 803ad54:	f000 80a4 	beq.w	803aea0 <UART_SetConfig+0x750>
 803ad58:	2b09      	cmp	r3, #9
 803ad5a:	f000 80a3 	beq.w	803aea4 <UART_SetConfig+0x754>
 803ad5e:	2b0a      	cmp	r3, #10
 803ad60:	f000 80a2 	beq.w	803aea8 <UART_SetConfig+0x758>
 803ad64:	2b0b      	cmp	r3, #11
 803ad66:	bf14      	ite	ne
 803ad68:	2301      	movne	r3, #1
 803ad6a:	f44f 7380 	moveq.w	r3, #256	; 0x100
 803ad6e:	fbb0 f3f3 	udiv	r3, r0, r3
 803ad72:	6862      	ldr	r2, [r4, #4]
 803ad74:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 803ad78:	fbb3 f3f2 	udiv	r3, r3, r2
 803ad7c:	e05b      	b.n	803ae36 <UART_SetConfig+0x6e6>
        pclk = HAL_RCC_GetPCLK2Freq();
 803ad7e:	f7ff fcd1 	bl	803a724 <HAL_RCC_GetPCLK2Freq>
 803ad82:	e7cd      	b.n	803ad20 <UART_SetConfig+0x5d0>
 803ad84:	f3af 8000 	nop.w
 803ad88:	28b0aa00 	.word	0x28b0aa00
 803ad8c:	00000000 	.word	0x00000000
 803ad90:	14585500 	.word	0x14585500
 803ad94:	00000000 	.word	0x00000000
 803ad98:	000ffcff 	.word	0x000ffcff
 803ad9c:	00f42400 	.word	0x00f42400
 803ada0:	7a120000 	.word	0x7a120000
 803ada4:	3d090000 	.word	0x3d090000
 803ada8:	1e848000 	.word	0x1e848000
 803adac:	186a0000 	.word	0x186a0000
 803adb0:	0f424000 	.word	0x0f424000
 803adb4:	07a12000 	.word	0x07a12000
 803adb8:	03d09000 	.word	0x03d09000
 803adbc:	01e84800 	.word	0x01e84800
 803adc0:	f4240000 	.word	0xf4240000
 803adc4:	00155500 	.word	0x00155500
 803adc8:	000ccc00 	.word	0x000ccc00
 803adcc:	000aaa00 	.word	0x000aaa00
 803add0:	007a1200 	.word	0x007a1200
 803add4:	00516154 	.word	0x00516154
 803add8:	003d0900 	.word	0x003d0900
 803addc:	0030d400 	.word	0x0030d400
 803ade0:	0028b0aa 	.word	0x0028b0aa
 803ade4:	001e8480 	.word	0x001e8480
 803ade8:	000f4240 	.word	0x000f4240
 803adec:	0007a120 	.word	0x0007a120
 803adf0:	0003d090 	.word	0x0003d090
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803adf4:	b358      	cbz	r0, 803ae4e <UART_SetConfig+0x6fe>
 803adf6:	2801      	cmp	r0, #1
 803adf8:	d02b      	beq.n	803ae52 <UART_SetConfig+0x702>
 803adfa:	2802      	cmp	r0, #2
 803adfc:	d02b      	beq.n	803ae56 <UART_SetConfig+0x706>
 803adfe:	2803      	cmp	r0, #3
 803ae00:	d02b      	beq.n	803ae5a <UART_SetConfig+0x70a>
 803ae02:	2804      	cmp	r0, #4
 803ae04:	d02b      	beq.n	803ae5e <UART_SetConfig+0x70e>
 803ae06:	2805      	cmp	r0, #5
 803ae08:	d02b      	beq.n	803ae62 <UART_SetConfig+0x712>
 803ae0a:	2806      	cmp	r0, #6
 803ae0c:	d02b      	beq.n	803ae66 <UART_SetConfig+0x716>
 803ae0e:	2807      	cmp	r0, #7
 803ae10:	d02b      	beq.n	803ae6a <UART_SetConfig+0x71a>
 803ae12:	2808      	cmp	r0, #8
 803ae14:	d02b      	beq.n	803ae6e <UART_SetConfig+0x71e>
 803ae16:	2809      	cmp	r0, #9
 803ae18:	d02b      	beq.n	803ae72 <UART_SetConfig+0x722>
 803ae1a:	280a      	cmp	r0, #10
 803ae1c:	d02b      	beq.n	803ae76 <UART_SetConfig+0x726>
 803ae1e:	f24f 4224 	movw	r2, #62500	; 0xf424
 803ae22:	4bc0      	ldr	r3, [pc, #768]	; (803b124 <UART_SetConfig+0x9d4>)
 803ae24:	280b      	cmp	r0, #11
 803ae26:	bf14      	ite	ne
 803ae28:	4618      	movne	r0, r3
 803ae2a:	4610      	moveq	r0, r2
 803ae2c:	6863      	ldr	r3, [r4, #4]
 803ae2e:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 803ae32:	fbb0 f3f3 	udiv	r3, r0, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 803ae36:	2200      	movs	r2, #0
 803ae38:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 803ae3a:	f64f 71ef 	movw	r1, #65519	; 0xffef
 803ae3e:	f1a3 0010 	sub.w	r0, r3, #16
 803ae42:	4288      	cmp	r0, r1
 803ae44:	f63f ad94 	bhi.w	803a970 <UART_SetConfig+0x220>
      huart->Instance->BRR = usartdiv;
 803ae48:	6821      	ldr	r1, [r4, #0]
 803ae4a:	60cb      	str	r3, [r1, #12]
 803ae4c:	e591      	b.n	803a972 <UART_SetConfig+0x222>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ae4e:	48b5      	ldr	r0, [pc, #724]	; (803b124 <UART_SetConfig+0x9d4>)
 803ae50:	e7ec      	b.n	803ae2c <UART_SetConfig+0x6dc>
 803ae52:	48b5      	ldr	r0, [pc, #724]	; (803b128 <UART_SetConfig+0x9d8>)
 803ae54:	e7ea      	b.n	803ae2c <UART_SetConfig+0x6dc>
 803ae56:	48b5      	ldr	r0, [pc, #724]	; (803b12c <UART_SetConfig+0x9dc>)
 803ae58:	e7e8      	b.n	803ae2c <UART_SetConfig+0x6dc>
 803ae5a:	48b5      	ldr	r0, [pc, #724]	; (803b130 <UART_SetConfig+0x9e0>)
 803ae5c:	e7e6      	b.n	803ae2c <UART_SetConfig+0x6dc>
 803ae5e:	48b5      	ldr	r0, [pc, #724]	; (803b134 <UART_SetConfig+0x9e4>)
 803ae60:	e7e4      	b.n	803ae2c <UART_SetConfig+0x6dc>
 803ae62:	48b5      	ldr	r0, [pc, #724]	; (803b138 <UART_SetConfig+0x9e8>)
 803ae64:	e7e2      	b.n	803ae2c <UART_SetConfig+0x6dc>
 803ae66:	48b5      	ldr	r0, [pc, #724]	; (803b13c <UART_SetConfig+0x9ec>)
 803ae68:	e7e0      	b.n	803ae2c <UART_SetConfig+0x6dc>
 803ae6a:	48b5      	ldr	r0, [pc, #724]	; (803b140 <UART_SetConfig+0x9f0>)
 803ae6c:	e7de      	b.n	803ae2c <UART_SetConfig+0x6dc>
 803ae6e:	48b5      	ldr	r0, [pc, #724]	; (803b144 <UART_SetConfig+0x9f4>)
 803ae70:	e7dc      	b.n	803ae2c <UART_SetConfig+0x6dc>
 803ae72:	48b5      	ldr	r0, [pc, #724]	; (803b148 <UART_SetConfig+0x9f8>)
 803ae74:	e7da      	b.n	803ae2c <UART_SetConfig+0x6dc>
 803ae76:	48b5      	ldr	r0, [pc, #724]	; (803b14c <UART_SetConfig+0x9fc>)
 803ae78:	e7d8      	b.n	803ae2c <UART_SetConfig+0x6dc>
        pclk = HAL_RCC_GetSysClockFreq();
 803ae7a:	f7ff fbf1 	bl	803a660 <HAL_RCC_GetSysClockFreq>
 803ae7e:	e74f      	b.n	803ad20 <UART_SetConfig+0x5d0>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ae80:	2301      	movs	r3, #1
 803ae82:	e774      	b.n	803ad6e <UART_SetConfig+0x61e>
 803ae84:	2302      	movs	r3, #2
 803ae86:	e772      	b.n	803ad6e <UART_SetConfig+0x61e>
 803ae88:	2304      	movs	r3, #4
 803ae8a:	e770      	b.n	803ad6e <UART_SetConfig+0x61e>
 803ae8c:	2306      	movs	r3, #6
 803ae8e:	e76e      	b.n	803ad6e <UART_SetConfig+0x61e>
 803ae90:	2308      	movs	r3, #8
 803ae92:	e76c      	b.n	803ad6e <UART_SetConfig+0x61e>
 803ae94:	230a      	movs	r3, #10
 803ae96:	e76a      	b.n	803ad6e <UART_SetConfig+0x61e>
 803ae98:	230c      	movs	r3, #12
 803ae9a:	e768      	b.n	803ad6e <UART_SetConfig+0x61e>
 803ae9c:	2310      	movs	r3, #16
 803ae9e:	e766      	b.n	803ad6e <UART_SetConfig+0x61e>
 803aea0:	2320      	movs	r3, #32
 803aea2:	e764      	b.n	803ad6e <UART_SetConfig+0x61e>
 803aea4:	2340      	movs	r3, #64	; 0x40
 803aea6:	e762      	b.n	803ad6e <UART_SetConfig+0x61e>
 803aea8:	2380      	movs	r3, #128	; 0x80
 803aeaa:	e760      	b.n	803ad6e <UART_SetConfig+0x61e>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803aeac:	b1f0      	cbz	r0, 803aeec <UART_SetConfig+0x79c>
 803aeae:	2801      	cmp	r0, #1
 803aeb0:	d01f      	beq.n	803aef2 <UART_SetConfig+0x7a2>
 803aeb2:	2802      	cmp	r0, #2
 803aeb4:	d020      	beq.n	803aef8 <UART_SetConfig+0x7a8>
 803aeb6:	2803      	cmp	r0, #3
 803aeb8:	d021      	beq.n	803aefe <UART_SetConfig+0x7ae>
 803aeba:	2804      	cmp	r0, #4
 803aebc:	d022      	beq.n	803af04 <UART_SetConfig+0x7b4>
 803aebe:	2805      	cmp	r0, #5
 803aec0:	d023      	beq.n	803af0a <UART_SetConfig+0x7ba>
 803aec2:	2806      	cmp	r0, #6
 803aec4:	d024      	beq.n	803af10 <UART_SetConfig+0x7c0>
 803aec6:	2807      	cmp	r0, #7
 803aec8:	d025      	beq.n	803af16 <UART_SetConfig+0x7c6>
 803aeca:	2808      	cmp	r0, #8
 803aecc:	d026      	beq.n	803af1c <UART_SetConfig+0x7cc>
 803aece:	2809      	cmp	r0, #9
 803aed0:	d027      	beq.n	803af22 <UART_SetConfig+0x7d2>
 803aed2:	280a      	cmp	r0, #10
 803aed4:	d028      	beq.n	803af28 <UART_SetConfig+0x7d8>
 803aed6:	280b      	cmp	r0, #11
 803aed8:	bf14      	ite	ne
 803aeda:	f44f 4300 	movne.w	r3, #32768	; 0x8000
 803aede:	2380      	moveq	r3, #128	; 0x80
 803aee0:	6860      	ldr	r0, [r4, #4]
 803aee2:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 803aee6:	fbb3 f3f0 	udiv	r3, r3, r0
 803aeea:	e7a4      	b.n	803ae36 <UART_SetConfig+0x6e6>
 803aeec:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 803aef0:	e7f6      	b.n	803aee0 <UART_SetConfig+0x790>
 803aef2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 803aef6:	e7f3      	b.n	803aee0 <UART_SetConfig+0x790>
 803aef8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 803aefc:	e7f0      	b.n	803aee0 <UART_SetConfig+0x790>
 803aefe:	f241 5355 	movw	r3, #5461	; 0x1555
 803af02:	e7ed      	b.n	803aee0 <UART_SetConfig+0x790>
 803af04:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 803af08:	e7ea      	b.n	803aee0 <UART_SetConfig+0x790>
 803af0a:	f640 43cc 	movw	r3, #3276	; 0xccc
 803af0e:	e7e7      	b.n	803aee0 <UART_SetConfig+0x790>
 803af10:	f640 23aa 	movw	r3, #2730	; 0xaaa
 803af14:	e7e4      	b.n	803aee0 <UART_SetConfig+0x790>
 803af16:	f44f 6300 	mov.w	r3, #2048	; 0x800
 803af1a:	e7e1      	b.n	803aee0 <UART_SetConfig+0x790>
 803af1c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 803af20:	e7de      	b.n	803aee0 <UART_SetConfig+0x790>
 803af22:	f44f 7300 	mov.w	r3, #512	; 0x200
 803af26:	e7db      	b.n	803aee0 <UART_SetConfig+0x790>
 803af28:	f44f 7380 	mov.w	r3, #256	; 0x100
 803af2c:	e7d8      	b.n	803aee0 <UART_SetConfig+0x790>
  if (UART_INSTANCE_LOWPOWER(huart))
 803af2e:	4a88      	ldr	r2, [pc, #544]	; (803b150 <UART_SetConfig+0xa00>)
 803af30:	4293      	cmp	r3, r2
 803af32:	f43f acf8 	beq.w	803a926 <UART_SetConfig+0x1d6>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803af36:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 803af3a:	f47f af5b 	bne.w	803adf4 <UART_SetConfig+0x6a4>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803af3e:	2800      	cmp	r0, #0
 803af40:	f43f ae9c 	beq.w	803ac7c <UART_SetConfig+0x52c>
 803af44:	2801      	cmp	r0, #1
 803af46:	f43f ae9b 	beq.w	803ac80 <UART_SetConfig+0x530>
 803af4a:	2802      	cmp	r0, #2
 803af4c:	f43f ae9a 	beq.w	803ac84 <UART_SetConfig+0x534>
 803af50:	2803      	cmp	r0, #3
 803af52:	f43f ae99 	beq.w	803ac88 <UART_SetConfig+0x538>
 803af56:	2804      	cmp	r0, #4
 803af58:	f43f ae98 	beq.w	803ac8c <UART_SetConfig+0x53c>
 803af5c:	2805      	cmp	r0, #5
 803af5e:	f43f ae97 	beq.w	803ac90 <UART_SetConfig+0x540>
 803af62:	2806      	cmp	r0, #6
 803af64:	f43f ae96 	beq.w	803ac94 <UART_SetConfig+0x544>
 803af68:	2807      	cmp	r0, #7
 803af6a:	f43f ae95 	beq.w	803ac98 <UART_SetConfig+0x548>
 803af6e:	2808      	cmp	r0, #8
 803af70:	f43f ae94 	beq.w	803ac9c <UART_SetConfig+0x54c>
 803af74:	2809      	cmp	r0, #9
 803af76:	f43f ae93 	beq.w	803aca0 <UART_SetConfig+0x550>
 803af7a:	280a      	cmp	r0, #10
 803af7c:	f43f ae92 	beq.w	803aca4 <UART_SetConfig+0x554>
 803af80:	4b74      	ldr	r3, [pc, #464]	; (803b154 <UART_SetConfig+0xa04>)
 803af82:	4a72      	ldr	r2, [pc, #456]	; (803b14c <UART_SetConfig+0x9fc>)
 803af84:	280b      	cmp	r0, #11
 803af86:	bf14      	ite	ne
 803af88:	4618      	movne	r0, r3
 803af8a:	4610      	moveq	r0, r2
 803af8c:	6863      	ldr	r3, [r4, #4]
 803af8e:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 803af92:	fbb0 f3f3 	udiv	r3, r0, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 803af96:	2200      	movs	r2, #0
 803af98:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 803af9a:	f64f 71ef 	movw	r1, #65519	; 0xffef
 803af9e:	f1a3 0010 	sub.w	r0, r3, #16
 803afa2:	4288      	cmp	r0, r1
 803afa4:	f63f ace4 	bhi.w	803a970 <UART_SetConfig+0x220>
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 803afa8:	f023 010f 	bic.w	r1, r3, #15
      huart->Instance->BRR = brrtemp;
 803afac:	6820      	ldr	r0, [r4, #0]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 803afae:	f3c3 0342 	ubfx	r3, r3, #1, #3
      huart->Instance->BRR = brrtemp;
 803afb2:	430b      	orrs	r3, r1
 803afb4:	60c3      	str	r3, [r0, #12]
 803afb6:	e4dc      	b.n	803a972 <UART_SetConfig+0x222>
  if (UART_INSTANCE_LOWPOWER(huart))
 803afb8:	4a65      	ldr	r2, [pc, #404]	; (803b150 <UART_SetConfig+0xa00>)
 803afba:	4293      	cmp	r3, r2
 803afbc:	d132      	bne.n	803b024 <UART_SetConfig+0x8d4>
        lpuart_ker_ck_pres = ((uint32_t)LSE_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803afbe:	2108      	movs	r1, #8
 803afc0:	2800      	cmp	r0, #0
 803afc2:	f43f ad59 	beq.w	803aa78 <UART_SetConfig+0x328>
 803afc6:	2801      	cmp	r0, #1
 803afc8:	f43f ad59 	beq.w	803aa7e <UART_SetConfig+0x32e>
 803afcc:	2802      	cmp	r0, #2
 803afce:	f43f ad59 	beq.w	803aa84 <UART_SetConfig+0x334>
 803afd2:	2803      	cmp	r0, #3
 803afd4:	f43f ad59 	beq.w	803aa8a <UART_SetConfig+0x33a>
 803afd8:	2804      	cmp	r0, #4
 803afda:	f43f ad59 	beq.w	803aa90 <UART_SetConfig+0x340>
 803afde:	2805      	cmp	r0, #5
 803afe0:	f43f ad59 	beq.w	803aa96 <UART_SetConfig+0x346>
 803afe4:	2806      	cmp	r0, #6
 803afe6:	f43f ad59 	beq.w	803aa9c <UART_SetConfig+0x34c>
 803afea:	2807      	cmp	r0, #7
 803afec:	f43f ad59 	beq.w	803aaa2 <UART_SetConfig+0x352>
 803aff0:	2808      	cmp	r0, #8
 803aff2:	f43f ad59 	beq.w	803aaa8 <UART_SetConfig+0x358>
 803aff6:	2809      	cmp	r0, #9
 803aff8:	f43f ad59 	beq.w	803aaae <UART_SetConfig+0x35e>
 803affc:	280a      	cmp	r0, #10
 803affe:	f43f ad59 	beq.w	803aab4 <UART_SetConfig+0x364>
 803b002:	280b      	cmp	r0, #11
 803b004:	bf0c      	ite	eq
 803b006:	2080      	moveq	r0, #128	; 0x80
 803b008:	f44f 4000 	movne.w	r0, #32768	; 0x8000
 803b00c:	e4aa      	b.n	803a964 <UART_SetConfig+0x214>
  if (UART_INSTANCE_LOWPOWER(huart))
 803b00e:	4a50      	ldr	r2, [pc, #320]	; (803b150 <UART_SetConfig+0xa00>)
 803b010:	4293      	cmp	r3, r2
 803b012:	f43f acb7 	beq.w	803a984 <UART_SetConfig+0x234>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803b016:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 803b01a:	f47f af2e 	bne.w	803ae7a <UART_SetConfig+0x72a>
        pclk = HAL_RCC_GetSysClockFreq();
 803b01e:	f7ff fb1f 	bl	803a660 <HAL_RCC_GetSysClockFreq>
 803b022:	e036      	b.n	803b092 <UART_SetConfig+0x942>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803b024:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 803b028:	f47f af40 	bne.w	803aeac <UART_SetConfig+0x75c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803b02c:	2800      	cmp	r0, #0
 803b02e:	f43f ae51 	beq.w	803acd4 <UART_SetConfig+0x584>
 803b032:	2801      	cmp	r0, #1
 803b034:	f43f ae51 	beq.w	803acda <UART_SetConfig+0x58a>
 803b038:	2802      	cmp	r0, #2
 803b03a:	f43f ae51 	beq.w	803ace0 <UART_SetConfig+0x590>
 803b03e:	2803      	cmp	r0, #3
 803b040:	f43f ae51 	beq.w	803ace6 <UART_SetConfig+0x596>
 803b044:	2804      	cmp	r0, #4
 803b046:	f43f ae51 	beq.w	803acec <UART_SetConfig+0x59c>
 803b04a:	2805      	cmp	r0, #5
 803b04c:	f43f ae51 	beq.w	803acf2 <UART_SetConfig+0x5a2>
 803b050:	2806      	cmp	r0, #6
 803b052:	f43f ae51 	beq.w	803acf8 <UART_SetConfig+0x5a8>
 803b056:	2807      	cmp	r0, #7
 803b058:	f43f ae51 	beq.w	803acfe <UART_SetConfig+0x5ae>
 803b05c:	2808      	cmp	r0, #8
 803b05e:	f43f ae51 	beq.w	803ad04 <UART_SetConfig+0x5b4>
 803b062:	2809      	cmp	r0, #9
 803b064:	f43f ae51 	beq.w	803ad0a <UART_SetConfig+0x5ba>
 803b068:	280a      	cmp	r0, #10
 803b06a:	f43f ae51 	beq.w	803ad10 <UART_SetConfig+0x5c0>
 803b06e:	280b      	cmp	r0, #11
 803b070:	bf14      	ite	ne
 803b072:	f44f 3380 	movne.w	r3, #65536	; 0x10000
 803b076:	f44f 7380 	moveq.w	r3, #256	; 0x100
 803b07a:	6860      	ldr	r0, [r4, #4]
 803b07c:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 803b080:	fbb3 f3f0 	udiv	r3, r3, r0
 803b084:	e787      	b.n	803af96 <UART_SetConfig+0x846>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803b086:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 803b08a:	f47f ae47 	bne.w	803ad1c <UART_SetConfig+0x5cc>
        pclk = HAL_RCC_GetPCLK1Freq();
 803b08e:	f7ff fb35 	bl	803a6fc <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803b092:	6a61      	ldr	r1, [r4, #36]	; 0x24
 803b094:	2900      	cmp	r1, #0
 803b096:	f43f ae07 	beq.w	803aca8 <UART_SetConfig+0x558>
 803b09a:	2901      	cmp	r1, #1
 803b09c:	f43f ae06 	beq.w	803acac <UART_SetConfig+0x55c>
 803b0a0:	2902      	cmp	r1, #2
 803b0a2:	f43f ae05 	beq.w	803acb0 <UART_SetConfig+0x560>
 803b0a6:	2903      	cmp	r1, #3
 803b0a8:	f43f ae04 	beq.w	803acb4 <UART_SetConfig+0x564>
 803b0ac:	2904      	cmp	r1, #4
 803b0ae:	f43f ae03 	beq.w	803acb8 <UART_SetConfig+0x568>
 803b0b2:	2905      	cmp	r1, #5
 803b0b4:	f43f ae02 	beq.w	803acbc <UART_SetConfig+0x56c>
 803b0b8:	2906      	cmp	r1, #6
 803b0ba:	f43f ae01 	beq.w	803acc0 <UART_SetConfig+0x570>
 803b0be:	2907      	cmp	r1, #7
 803b0c0:	f43f ae00 	beq.w	803acc4 <UART_SetConfig+0x574>
 803b0c4:	2908      	cmp	r1, #8
 803b0c6:	f43f adff 	beq.w	803acc8 <UART_SetConfig+0x578>
 803b0ca:	2909      	cmp	r1, #9
 803b0cc:	f43f adfe 	beq.w	803accc <UART_SetConfig+0x57c>
 803b0d0:	290a      	cmp	r1, #10
 803b0d2:	f43f adfd 	beq.w	803acd0 <UART_SetConfig+0x580>
 803b0d6:	290b      	cmp	r1, #11
 803b0d8:	bf14      	ite	ne
 803b0da:	2201      	movne	r2, #1
 803b0dc:	f44f 7280 	moveq.w	r2, #256	; 0x100
 803b0e0:	fbb0 f2f2 	udiv	r2, r0, r2
 803b0e4:	6861      	ldr	r1, [r4, #4]
 803b0e6:	084b      	lsrs	r3, r1, #1
 803b0e8:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 803b0ec:	fbb3 f3f1 	udiv	r3, r3, r1
 803b0f0:	e751      	b.n	803af96 <UART_SetConfig+0x846>
    switch (clocksource)
 803b0f2:	2b08      	cmp	r3, #8
 803b0f4:	f63f ac3c 	bhi.w	803a970 <UART_SetConfig+0x220>
 803b0f8:	a201      	add	r2, pc, #4	; (adr r2, 803b100 <UART_SetConfig+0x9b0>)
 803b0fa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 803b0fe:	bf00      	nop
 803b100:	0803ad1d 	.word	0x0803ad1d
 803b104:	0803ad7f 	.word	0x0803ad7f
 803b108:	0803adf5 	.word	0x0803adf5
 803b10c:	0803a971 	.word	0x0803a971
 803b110:	0803ae7b 	.word	0x0803ae7b
 803b114:	0803a971 	.word	0x0803a971
 803b118:	0803a971 	.word	0x0803a971
 803b11c:	0803a971 	.word	0x0803a971
 803b120:	0803aead 	.word	0x0803aead
 803b124:	00f42400 	.word	0x00f42400
 803b128:	007a1200 	.word	0x007a1200
 803b12c:	003d0900 	.word	0x003d0900
 803b130:	0028b0aa 	.word	0x0028b0aa
 803b134:	001e8480 	.word	0x001e8480
 803b138:	00186a00 	.word	0x00186a00
 803b13c:	00145855 	.word	0x00145855
 803b140:	000f4240 	.word	0x000f4240
 803b144:	0007a120 	.word	0x0007a120
 803b148:	0003d090 	.word	0x0003d090
 803b14c:	0001e848 	.word	0x0001e848
 803b150:	40008000 	.word	0x40008000
 803b154:	01e84800 	.word	0x01e84800

0803b158 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 803b158:	6a83      	ldr	r3, [r0, #40]	; 0x28
{
 803b15a:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 803b15c:	07da      	lsls	r2, r3, #31
 803b15e:	d506      	bpl.n	803b16e <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 803b160:	6801      	ldr	r1, [r0, #0]
 803b162:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 803b164:	684a      	ldr	r2, [r1, #4]
 803b166:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 803b16a:	4322      	orrs	r2, r4
 803b16c:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 803b16e:	079c      	lsls	r4, r3, #30
 803b170:	d506      	bpl.n	803b180 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 803b172:	6801      	ldr	r1, [r0, #0]
 803b174:	6b04      	ldr	r4, [r0, #48]	; 0x30
 803b176:	684a      	ldr	r2, [r1, #4]
 803b178:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 803b17c:	4322      	orrs	r2, r4
 803b17e:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 803b180:	0759      	lsls	r1, r3, #29
 803b182:	d506      	bpl.n	803b192 <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 803b184:	6801      	ldr	r1, [r0, #0]
 803b186:	6b44      	ldr	r4, [r0, #52]	; 0x34
 803b188:	684a      	ldr	r2, [r1, #4]
 803b18a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 803b18e:	4322      	orrs	r2, r4
 803b190:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 803b192:	071a      	lsls	r2, r3, #28
 803b194:	d506      	bpl.n	803b1a4 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 803b196:	6801      	ldr	r1, [r0, #0]
 803b198:	6b84      	ldr	r4, [r0, #56]	; 0x38
 803b19a:	684a      	ldr	r2, [r1, #4]
 803b19c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 803b1a0:	4322      	orrs	r2, r4
 803b1a2:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 803b1a4:	06dc      	lsls	r4, r3, #27
 803b1a6:	d506      	bpl.n	803b1b6 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 803b1a8:	6801      	ldr	r1, [r0, #0]
 803b1aa:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 803b1ac:	688a      	ldr	r2, [r1, #8]
 803b1ae:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 803b1b2:	4322      	orrs	r2, r4
 803b1b4:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 803b1b6:	0699      	lsls	r1, r3, #26
 803b1b8:	d506      	bpl.n	803b1c8 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 803b1ba:	6801      	ldr	r1, [r0, #0]
 803b1bc:	6c04      	ldr	r4, [r0, #64]	; 0x40
 803b1be:	688a      	ldr	r2, [r1, #8]
 803b1c0:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 803b1c4:	4322      	orrs	r2, r4
 803b1c6:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 803b1c8:	065a      	lsls	r2, r3, #25
 803b1ca:	d510      	bpl.n	803b1ee <UART_AdvFeatureConfig+0x96>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 803b1cc:	6801      	ldr	r1, [r0, #0]
 803b1ce:	6c44      	ldr	r4, [r0, #68]	; 0x44
 803b1d0:	684a      	ldr	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 803b1d2:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 803b1d6:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 803b1da:	ea42 0204 	orr.w	r2, r2, r4
 803b1de:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 803b1e0:	d105      	bne.n	803b1ee <UART_AdvFeatureConfig+0x96>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 803b1e2:	684a      	ldr	r2, [r1, #4]
 803b1e4:	6c84      	ldr	r4, [r0, #72]	; 0x48
 803b1e6:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 803b1ea:	4322      	orrs	r2, r4
 803b1ec:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 803b1ee:	061b      	lsls	r3, r3, #24
 803b1f0:	d506      	bpl.n	803b200 <UART_AdvFeatureConfig+0xa8>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 803b1f2:	6802      	ldr	r2, [r0, #0]
 803b1f4:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 803b1f6:	6853      	ldr	r3, [r2, #4]
 803b1f8:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 803b1fc:	430b      	orrs	r3, r1
 803b1fe:	6053      	str	r3, [r2, #4]
  }
}
 803b200:	bd10      	pop	{r4, pc}

0803b202 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 803b202:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 803b206:	4604      	mov	r4, r0
 803b208:	460f      	mov	r7, r1
 803b20a:	4616      	mov	r6, r2
 803b20c:	4698      	mov	r8, r3
 803b20e:	9d06      	ldr	r5, [sp, #24]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 803b210:	6821      	ldr	r1, [r4, #0]
 803b212:	69ca      	ldr	r2, [r1, #28]
 803b214:	ea37 0302 	bics.w	r3, r7, r2
 803b218:	bf0c      	ite	eq
 803b21a:	2201      	moveq	r2, #1
 803b21c:	2200      	movne	r2, #0
 803b21e:	42b2      	cmp	r2, r6
 803b220:	d001      	beq.n	803b226 <UART_WaitOnFlagUntilTimeout+0x24>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 803b222:	2000      	movs	r0, #0
 803b224:	e01a      	b.n	803b25c <UART_WaitOnFlagUntilTimeout+0x5a>
    if (Timeout != HAL_MAX_DELAY)
 803b226:	1c68      	adds	r0, r5, #1
 803b228:	d0f3      	beq.n	803b212 <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 803b22a:	f7fe fe89 	bl	8039f40 <HAL_GetTick>
 803b22e:	eba0 0008 	sub.w	r0, r0, r8
 803b232:	42a8      	cmp	r0, r5
 803b234:	6820      	ldr	r0, [r4, #0]
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 803b236:	6803      	ldr	r3, [r0, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 803b238:	d800      	bhi.n	803b23c <UART_WaitOnFlagUntilTimeout+0x3a>
 803b23a:	b98d      	cbnz	r5, 803b260 <UART_WaitOnFlagUntilTimeout+0x5e>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 803b23c:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 803b240:	6003      	str	r3, [r0, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 803b242:	6883      	ldr	r3, [r0, #8]
 803b244:	f023 0301 	bic.w	r3, r3, #1
 803b248:	6083      	str	r3, [r0, #8]
        huart->gState = HAL_UART_STATE_READY;
 803b24a:	2320      	movs	r3, #32
 803b24c:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
        huart->RxState = HAL_UART_STATE_READY;
 803b250:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          __HAL_UNLOCK(huart);
 803b254:	2300      	movs	r3, #0
          return HAL_TIMEOUT;
 803b256:	2003      	movs	r0, #3
          __HAL_UNLOCK(huart);
 803b258:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
}
 803b25c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 803b260:	075a      	lsls	r2, r3, #29
 803b262:	d5d5      	bpl.n	803b210 <UART_WaitOnFlagUntilTimeout+0xe>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 803b264:	69c3      	ldr	r3, [r0, #28]
 803b266:	051b      	lsls	r3, r3, #20
 803b268:	d5d2      	bpl.n	803b210 <UART_WaitOnFlagUntilTimeout+0xe>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 803b26a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 803b26e:	6203      	str	r3, [r0, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 803b270:	6803      	ldr	r3, [r0, #0]
 803b272:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 803b276:	6003      	str	r3, [r0, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 803b278:	6883      	ldr	r3, [r0, #8]
 803b27a:	f023 0301 	bic.w	r3, r3, #1
 803b27e:	6083      	str	r3, [r0, #8]
          huart->gState = HAL_UART_STATE_READY;
 803b280:	2320      	movs	r3, #32
 803b282:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
          huart->RxState = HAL_UART_STATE_READY;
 803b286:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 803b28a:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 803b28e:	e7e1      	b.n	803b254 <UART_WaitOnFlagUntilTimeout+0x52>

0803b290 <HAL_UART_Transmit>:
{
 803b290:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 803b294:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
 803b296:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
{
 803b29a:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
 803b29c:	2b20      	cmp	r3, #32
{
 803b29e:	460e      	mov	r6, r1
 803b2a0:	4691      	mov	r9, r2
  if (huart->gState == HAL_UART_STATE_READY)
 803b2a2:	d14f      	bne.n	803b344 <HAL_UART_Transmit+0xb4>
    if ((pData == NULL) || (Size == 0U))
 803b2a4:	2900      	cmp	r1, #0
 803b2a6:	d04b      	beq.n	803b340 <HAL_UART_Transmit+0xb0>
 803b2a8:	2a00      	cmp	r2, #0
 803b2aa:	d049      	beq.n	803b340 <HAL_UART_Transmit+0xb0>
    __HAL_LOCK(huart);
 803b2ac:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 803b2b0:	2b01      	cmp	r3, #1
 803b2b2:	d047      	beq.n	803b344 <HAL_UART_Transmit+0xb4>
 803b2b4:	2301      	movs	r3, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 803b2b6:	2500      	movs	r5, #0
    __HAL_LOCK(huart);
 803b2b8:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 803b2bc:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 803b2be:	f8c0 5088 	str.w	r5, [r0, #136]	; 0x88
    huart->gState = HAL_UART_STATE_BUSY_TX;
 803b2c2:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    tickstart = HAL_GetTick();
 803b2c6:	f7fe fe3b 	bl	8039f40 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 803b2ca:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 803b2cc:	4607      	mov	r7, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 803b2ce:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->TxXferSize  = Size;
 803b2d2:	f8a4 9054 	strh.w	r9, [r4, #84]	; 0x54
    huart->TxXferCount = Size;
 803b2d6:	f8a4 9056 	strh.w	r9, [r4, #86]	; 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 803b2da:	d103      	bne.n	803b2e4 <HAL_UART_Transmit+0x54>
 803b2dc:	6923      	ldr	r3, [r4, #16]
 803b2de:	b90b      	cbnz	r3, 803b2e4 <HAL_UART_Transmit+0x54>
 803b2e0:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 803b2e2:	461e      	mov	r6, r3
    __HAL_UNLOCK(huart);
 803b2e4:	2300      	movs	r3, #0
 803b2e6:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
    while (huart->TxXferCount > 0U)
 803b2ea:	f8b4 2056 	ldrh.w	r2, [r4, #86]	; 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 803b2ee:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
 803b2f2:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 803b2f4:	463b      	mov	r3, r7
    while (huart->TxXferCount > 0U)
 803b2f6:	b942      	cbnz	r2, 803b30a <HAL_UART_Transmit+0x7a>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 803b2f8:	2140      	movs	r1, #64	; 0x40
 803b2fa:	4620      	mov	r0, r4
 803b2fc:	f7ff ff81 	bl	803b202 <UART_WaitOnFlagUntilTimeout>
 803b300:	b948      	cbnz	r0, 803b316 <HAL_UART_Transmit+0x86>
    huart->gState = HAL_UART_STATE_READY;
 803b302:	2320      	movs	r3, #32
 803b304:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    return HAL_OK;
 803b308:	e006      	b.n	803b318 <HAL_UART_Transmit+0x88>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 803b30a:	2200      	movs	r2, #0
 803b30c:	2180      	movs	r1, #128	; 0x80
 803b30e:	4620      	mov	r0, r4
 803b310:	f7ff ff77 	bl	803b202 <UART_WaitOnFlagUntilTimeout>
 803b314:	b118      	cbz	r0, 803b31e <HAL_UART_Transmit+0x8e>
        return HAL_TIMEOUT;
 803b316:	2003      	movs	r0, #3
}
 803b318:	b003      	add	sp, #12
 803b31a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 803b31e:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
 803b320:	b95e      	cbnz	r6, 803b33a <HAL_UART_Transmit+0xaa>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 803b322:	f835 3b02 	ldrh.w	r3, [r5], #2
 803b326:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 803b32a:	6293      	str	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 803b32c:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
 803b330:	3b01      	subs	r3, #1
 803b332:	b29b      	uxth	r3, r3
 803b334:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
 803b338:	e7d7      	b.n	803b2ea <HAL_UART_Transmit+0x5a>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 803b33a:	f816 3b01 	ldrb.w	r3, [r6], #1
 803b33e:	e7f4      	b.n	803b32a <HAL_UART_Transmit+0x9a>
      return  HAL_ERROR;
 803b340:	2001      	movs	r0, #1
 803b342:	e7e9      	b.n	803b318 <HAL_UART_Transmit+0x88>
    return HAL_BUSY;
 803b344:	2002      	movs	r0, #2
 803b346:	e7e7      	b.n	803b318 <HAL_UART_Transmit+0x88>

0803b348 <HAL_UART_Receive>:
{
 803b348:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 803b34c:	4699      	mov	r9, r3
  if (huart->RxState == HAL_UART_STATE_READY)
 803b34e:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 803b352:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_READY)
 803b354:	2b20      	cmp	r3, #32
{
 803b356:	460d      	mov	r5, r1
 803b358:	4616      	mov	r6, r2
  if (huart->RxState == HAL_UART_STATE_READY)
 803b35a:	d167      	bne.n	803b42c <HAL_UART_Receive+0xe4>
    if ((pData == NULL) || (Size == 0U))
 803b35c:	2900      	cmp	r1, #0
 803b35e:	d063      	beq.n	803b428 <HAL_UART_Receive+0xe0>
 803b360:	2a00      	cmp	r2, #0
 803b362:	d061      	beq.n	803b428 <HAL_UART_Receive+0xe0>
    __HAL_LOCK(huart);
 803b364:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 803b368:	2b01      	cmp	r3, #1
 803b36a:	d05f      	beq.n	803b42c <HAL_UART_Receive+0xe4>
 803b36c:	2301      	movs	r3, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 803b36e:	2700      	movs	r7, #0
    __HAL_LOCK(huart);
 803b370:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 803b374:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 803b376:	f8c0 7088 	str.w	r7, [r0, #136]	; 0x88
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 803b37a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    tickstart = HAL_GetTick();
 803b37e:	f7fe fddf 	bl	8039f40 <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
 803b382:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 803b384:	4680      	mov	r8, r0
    UART_MASK_COMPUTATION(huart);
 803b386:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->RxXferSize  = Size;
 803b38a:	f8a4 605c 	strh.w	r6, [r4, #92]	; 0x5c
    huart->RxXferCount = Size;
 803b38e:	f8a4 605e 	strh.w	r6, [r4, #94]	; 0x5e
    UART_MASK_COMPUTATION(huart);
 803b392:	d11d      	bne.n	803b3d0 <HAL_UART_Receive+0x88>
 803b394:	6922      	ldr	r2, [r4, #16]
 803b396:	b9ca      	cbnz	r2, 803b3cc <HAL_UART_Receive+0x84>
 803b398:	f240 12ff 	movw	r2, #511	; 0x1ff
 803b39c:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 803b3a0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    uhMask = huart->Mask;
 803b3a4:	f8b4 7060 	ldrh.w	r7, [r4, #96]	; 0x60
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 803b3a8:	d123      	bne.n	803b3f2 <HAL_UART_Receive+0xaa>
 803b3aa:	6923      	ldr	r3, [r4, #16]
 803b3ac:	bb0b      	cbnz	r3, 803b3f2 <HAL_UART_Receive+0xaa>
 803b3ae:	462e      	mov	r6, r5
      pdata8bits  = NULL;
 803b3b0:	461d      	mov	r5, r3
    __HAL_UNLOCK(huart);
 803b3b2:	2300      	movs	r3, #0
 803b3b4:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
    while (huart->RxXferCount > 0U)
 803b3b8:	f8b4 005e 	ldrh.w	r0, [r4, #94]	; 0x5e
 803b3bc:	b280      	uxth	r0, r0
 803b3be:	b9d0      	cbnz	r0, 803b3f6 <HAL_UART_Receive+0xae>
    huart->RxState = HAL_UART_STATE_READY;
 803b3c0:	2320      	movs	r3, #32
 803b3c2:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
}
 803b3c6:	b003      	add	sp, #12
 803b3c8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    UART_MASK_COMPUTATION(huart);
 803b3cc:	22ff      	movs	r2, #255	; 0xff
 803b3ce:	e7e5      	b.n	803b39c <HAL_UART_Receive+0x54>
 803b3d0:	b923      	cbnz	r3, 803b3dc <HAL_UART_Receive+0x94>
 803b3d2:	6922      	ldr	r2, [r4, #16]
 803b3d4:	2a00      	cmp	r2, #0
 803b3d6:	d0f9      	beq.n	803b3cc <HAL_UART_Receive+0x84>
 803b3d8:	227f      	movs	r2, #127	; 0x7f
 803b3da:	e7df      	b.n	803b39c <HAL_UART_Receive+0x54>
 803b3dc:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 803b3e0:	d104      	bne.n	803b3ec <HAL_UART_Receive+0xa4>
 803b3e2:	6922      	ldr	r2, [r4, #16]
 803b3e4:	2a00      	cmp	r2, #0
 803b3e6:	d0f7      	beq.n	803b3d8 <HAL_UART_Receive+0x90>
 803b3e8:	223f      	movs	r2, #63	; 0x3f
 803b3ea:	e7d7      	b.n	803b39c <HAL_UART_Receive+0x54>
 803b3ec:	f8a4 7060 	strh.w	r7, [r4, #96]	; 0x60
 803b3f0:	e7d6      	b.n	803b3a0 <HAL_UART_Receive+0x58>
      pdata16bits = NULL;
 803b3f2:	2600      	movs	r6, #0
 803b3f4:	e7dd      	b.n	803b3b2 <HAL_UART_Receive+0x6a>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 803b3f6:	f8cd 9000 	str.w	r9, [sp]
 803b3fa:	4643      	mov	r3, r8
 803b3fc:	2200      	movs	r2, #0
 803b3fe:	2120      	movs	r1, #32
 803b400:	4620      	mov	r0, r4
 803b402:	f7ff fefe 	bl	803b202 <UART_WaitOnFlagUntilTimeout>
 803b406:	b998      	cbnz	r0, 803b430 <HAL_UART_Receive+0xe8>
 803b408:	6823      	ldr	r3, [r4, #0]
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 803b40a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 803b40c:	403b      	ands	r3, r7
      if (pdata8bits == NULL)
 803b40e:	b945      	cbnz	r5, 803b422 <HAL_UART_Receive+0xda>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 803b410:	f826 3b02 	strh.w	r3, [r6], #2
      huart->RxXferCount--;
 803b414:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 803b418:	3b01      	subs	r3, #1
 803b41a:	b29b      	uxth	r3, r3
 803b41c:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
 803b420:	e7ca      	b.n	803b3b8 <HAL_UART_Receive+0x70>
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 803b422:	f805 3b01 	strb.w	r3, [r5], #1
 803b426:	e7f5      	b.n	803b414 <HAL_UART_Receive+0xcc>
      return  HAL_ERROR;
 803b428:	2001      	movs	r0, #1
 803b42a:	e7cc      	b.n	803b3c6 <HAL_UART_Receive+0x7e>
    return HAL_BUSY;
 803b42c:	2002      	movs	r0, #2
 803b42e:	e7ca      	b.n	803b3c6 <HAL_UART_Receive+0x7e>
        return HAL_TIMEOUT;
 803b430:	2003      	movs	r0, #3
 803b432:	e7c8      	b.n	803b3c6 <HAL_UART_Receive+0x7e>

0803b434 <UART_CheckIdleState>:
{
 803b434:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 803b436:	2600      	movs	r6, #0
{
 803b438:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 803b43a:	f8c0 6088 	str.w	r6, [r0, #136]	; 0x88
  tickstart = HAL_GetTick();
 803b43e:	f7fe fd7f 	bl	8039f40 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 803b442:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 803b444:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 803b446:	681b      	ldr	r3, [r3, #0]
 803b448:	071a      	lsls	r2, r3, #28
 803b44a:	d417      	bmi.n	803b47c <UART_CheckIdleState+0x48>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 803b44c:	6823      	ldr	r3, [r4, #0]
 803b44e:	681b      	ldr	r3, [r3, #0]
 803b450:	075b      	lsls	r3, r3, #29
 803b452:	d50a      	bpl.n	803b46a <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 803b454:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 803b458:	2200      	movs	r2, #0
 803b45a:	9300      	str	r3, [sp, #0]
 803b45c:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 803b460:	462b      	mov	r3, r5
 803b462:	4620      	mov	r0, r4
 803b464:	f7ff fecd 	bl	803b202 <UART_WaitOnFlagUntilTimeout>
 803b468:	b9a0      	cbnz	r0, 803b494 <UART_CheckIdleState+0x60>
  huart->gState = HAL_UART_STATE_READY;
 803b46a:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
 803b46c:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 803b46e:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  __HAL_UNLOCK(huart);
 803b472:	f884 007c 	strb.w	r0, [r4, #124]	; 0x7c
  huart->RxState = HAL_UART_STATE_READY;
 803b476:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  return HAL_OK;
 803b47a:	e00c      	b.n	803b496 <UART_CheckIdleState+0x62>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 803b47c:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 803b480:	4632      	mov	r2, r6
 803b482:	9300      	str	r3, [sp, #0]
 803b484:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 803b488:	4603      	mov	r3, r0
 803b48a:	4620      	mov	r0, r4
 803b48c:	f7ff feb9 	bl	803b202 <UART_WaitOnFlagUntilTimeout>
 803b490:	2800      	cmp	r0, #0
 803b492:	d0db      	beq.n	803b44c <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 803b494:	2003      	movs	r0, #3
}
 803b496:	b002      	add	sp, #8
 803b498:	bd70      	pop	{r4, r5, r6, pc}

0803b49a <HAL_UART_Init>:
{
 803b49a:	b510      	push	{r4, lr}
  if (huart == NULL)
 803b49c:	4604      	mov	r4, r0
 803b49e:	b350      	cbz	r0, 803b4f6 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 803b4a0:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 803b4a4:	b91b      	cbnz	r3, 803b4ae <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 803b4a6:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    HAL_UART_MspInit(huart);
 803b4aa:	f7fd fa31 	bl	8038910 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 803b4ae:	2324      	movs	r3, #36	; 0x24
  __HAL_UART_DISABLE(huart);
 803b4b0:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 803b4b2:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  __HAL_UART_DISABLE(huart);
 803b4b6:	6813      	ldr	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 803b4b8:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 803b4ba:	f023 0301 	bic.w	r3, r3, #1
 803b4be:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 803b4c0:	f7ff f946 	bl	803a750 <UART_SetConfig>
 803b4c4:	2801      	cmp	r0, #1
 803b4c6:	d016      	beq.n	803b4f6 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 803b4c8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 803b4ca:	b113      	cbz	r3, 803b4d2 <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 803b4cc:	4620      	mov	r0, r4
 803b4ce:	f7ff fe43 	bl	803b158 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 803b4d2:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 803b4d4:	4620      	mov	r0, r4
}
 803b4d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 803b4da:	685a      	ldr	r2, [r3, #4]
 803b4dc:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 803b4e0:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 803b4e2:	689a      	ldr	r2, [r3, #8]
 803b4e4:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 803b4e8:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 803b4ea:	681a      	ldr	r2, [r3, #0]
 803b4ec:	f042 0201 	orr.w	r2, r2, #1
 803b4f0:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 803b4f2:	f7ff bf9f 	b.w	803b434 <UART_CheckIdleState>
}
 803b4f6:	2001      	movs	r0, #1
 803b4f8:	bd10      	pop	{r4, pc}

0803b4fa <UsefulBuf_CopyOffset>:

/*
 Public function -- see UsefulBuf.h
 */
UsefulBufC UsefulBuf_CopyOffset(UsefulBuf Dest, size_t uOffset, const UsefulBufC Src)
{
 803b4fa:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 803b4fc:	4605      	mov	r5, r0
 803b4fe:	a802      	add	r0, sp, #8
 803b500:	e900 0006 	stmdb	r0, {r1, r2}
 803b504:	9a01      	ldr	r2, [sp, #4]
 803b506:	461c      	mov	r4, r3
   // Do this with subtraction so it doesn't give erroneous result if uOffset + Src.len overflows
   if(uOffset > Dest.len || Src.len > Dest.len - uOffset) { // uOffset + Src.len > Dest.len
 803b508:	4293      	cmp	r3, r2
 803b50a:	d803      	bhi.n	803b514 <UsefulBuf_CopyOffset+0x1a>
 803b50c:	9e09      	ldr	r6, [sp, #36]	; 0x24
 803b50e:	1ad2      	subs	r2, r2, r3
 803b510:	42b2      	cmp	r2, r6
 803b512:	d205      	bcs.n	803b520 <UsefulBuf_CopyOffset+0x26>
      return NULLUsefulBufC;
 803b514:	2300      	movs	r3, #0
 803b516:	e9c5 3300 	strd	r3, r3, [r5]
   }

   memcpy((uint8_t *)Dest.ptr + uOffset, Src.ptr, Src.len);

   return (UsefulBufC){Dest.ptr, Src.len + uOffset};
}
 803b51a:	4628      	mov	r0, r5
 803b51c:	b003      	add	sp, #12
 803b51e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 803b520:	9f00      	ldr	r7, [sp, #0]
   memcpy((uint8_t *)Dest.ptr + uOffset, Src.ptr, Src.len);
 803b522:	4632      	mov	r2, r6
 803b524:	9908      	ldr	r1, [sp, #32]
 803b526:	18f8      	adds	r0, r7, r3
   return (UsefulBufC){Dest.ptr, Src.len + uOffset};
 803b528:	4434      	add	r4, r6
   memcpy((uint8_t *)Dest.ptr + uOffset, Src.ptr, Src.len);
 803b52a:	f001 f8ca 	bl	803c6c2 <memcpy>
   return (UsefulBufC){Dest.ptr, Src.len + uOffset};
 803b52e:	602f      	str	r7, [r5, #0]
 803b530:	606c      	str	r4, [r5, #4]
 803b532:	e7f2      	b.n	803b51a <UsefulBuf_CopyOffset+0x20>

0803b534 <UsefulBuf_IsValue>:

/*
 Public function -- see UsefulBuf.h
 */
size_t UsefulBuf_IsValue(const UsefulBufC UB, uint8_t uValue)
{
 803b534:	b537      	push	{r0, r1, r2, r4, r5, lr}
 803b536:	ab02      	add	r3, sp, #8
 803b538:	e903 0003 	stmdb	r3, {r0, r1}
 803b53c:	9801      	ldr	r0, [sp, #4]
   return UsefulBuf_IsEmptyC(UB) || UsefulBuf_IsNULLC(UB);
 803b53e:	b168      	cbz	r0, 803b55c <UsefulBuf_IsValue+0x28>
 803b540:	9b00      	ldr	r3, [sp, #0]
 803b542:	b17b      	cbz	r3, 803b564 <UsefulBuf_IsValue+0x30>
   if(UsefulBuf_IsNULLOrEmptyC(UB)) {
      /* Not a match */
      return 0;
   }

   const uint8_t * const pEnd = (uint8_t *)UB.ptr + UB.len;
 803b544:	1819      	adds	r1, r3, r0
 803b546:	4618      	mov	r0, r3
   for(const uint8_t *p = UB.ptr; p < pEnd; p++) {
 803b548:	4288      	cmp	r0, r1
 803b54a:	d302      	bcc.n	803b552 <UsefulBuf_IsValue+0x1e>
         return p - (uint8_t *)UB.ptr;
      }
   }

   /* Success. All bytes matched */
   return SIZE_MAX;
 803b54c:	f04f 30ff 	mov.w	r0, #4294967295
 803b550:	e004      	b.n	803b55c <UsefulBuf_IsValue+0x28>
      if(*p != uValue) {
 803b552:	7805      	ldrb	r5, [r0, #0]
 803b554:	1c44      	adds	r4, r0, #1
 803b556:	4295      	cmp	r5, r2
 803b558:	d002      	beq.n	803b560 <UsefulBuf_IsValue+0x2c>
         return p - (uint8_t *)UB.ptr;
 803b55a:	1ac0      	subs	r0, r0, r3
}
 803b55c:	b003      	add	sp, #12
 803b55e:	bd30      	pop	{r4, r5, pc}
 803b560:	4620      	mov	r0, r4
 803b562:	e7f1      	b.n	803b548 <UsefulBuf_IsValue+0x14>
      return 0;
 803b564:	4618      	mov	r0, r3
 803b566:	e7f9      	b.n	803b55c <UsefulBuf_IsValue+0x28>

0803b568 <psa_allocate_key>:
     */
    return PSA_SUCCESS;
}

psa_status_t psa_allocate_key(psa_key_handle_t *handle)
{
 803b568:	b530      	push	{r4, r5, lr}
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    const struct tfm_crypto_pack_iovec iov = {
 803b56a:	2434      	movs	r4, #52	; 0x34
{
 803b56c:	b095      	sub	sp, #84	; 0x54
    const struct tfm_crypto_pack_iovec iov = {
 803b56e:	ab07      	add	r3, sp, #28
{
 803b570:	4605      	mov	r5, r0
    const struct tfm_crypto_pack_iovec iov = {
 803b572:	4622      	mov	r2, r4
 803b574:	2100      	movs	r1, #0
 803b576:	4618      	mov	r0, r3
 803b578:	f001 f8ae 	bl	803c6d8 <memset>
        .sfn_id = TFM_CRYPTO_ALLOCATE_KEY_SID,
    };
    psa_invec in_vec[] = {
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };
    psa_outvec out_vec[] = {
 803b57c:	2302      	movs	r3, #2
    psa_invec in_vec[] = {
 803b57e:	e9cd 0403 	strd	r0, r4, [sp, #12]
        {.base = handle, .len = sizeof(psa_key_handle_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b582:	2101      	movs	r1, #1
 803b584:	2080      	movs	r0, #128	; 0x80
    psa_outvec out_vec[] = {
 803b586:	9505      	str	r5, [sp, #20]
 803b588:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b58a:	f000 fbc9 	bl	803bd20 <psa_connect>
 803b58e:	1e05      	subs	r5, r0, #0
 803b590:	dd0e      	ble.n	803b5b0 <psa_allocate_key+0x48>

    status = API_DISPATCH(tfm_crypto_allocate_key,
 803b592:	2301      	movs	r3, #1
 803b594:	aa05      	add	r2, sp, #20
 803b596:	9200      	str	r2, [sp, #0]
 803b598:	9301      	str	r3, [sp, #4]
 803b59a:	aa03      	add	r2, sp, #12
 803b59c:	2100      	movs	r1, #0
 803b59e:	f000 fbcd 	bl	803bd3c <psa_call>
 803b5a2:	4604      	mov	r4, r0
                          TFM_CRYPTO_ALLOCATE_KEY);

    PSA_CLOSE();
 803b5a4:	4628      	mov	r0, r5
 803b5a6:	f000 fbdd 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 803b5aa:	4620      	mov	r0, r4
 803b5ac:	b015      	add	sp, #84	; 0x54
 803b5ae:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b5b0:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b5b4:	e7f9      	b.n	803b5aa <psa_allocate_key+0x42>

0803b5b6 <psa_import_key>:

psa_status_t psa_import_key(psa_key_handle_t handle,
                            psa_key_type_t type,
                            const uint8_t *data,
                            size_t data_length)
{
 803b5b6:	b5f0      	push	{r4, r5, r6, r7, lr}
 803b5b8:	b095      	sub	sp, #84	; 0x54
 803b5ba:	4615      	mov	r5, r2
 803b5bc:	4607      	mov	r7, r0
 803b5be:	460e      	mov	r6, r1
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b5c0:	222e      	movs	r2, #46	; 0x2e
 803b5c2:	2100      	movs	r1, #0
 803b5c4:	f10d 0022 	add.w	r0, sp, #34	; 0x22
{
 803b5c8:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
 803b5ca:	f001 f885 	bl	803c6d8 <memset>
        .sfn_id = TFM_CRYPTO_IMPORT_KEY_SID,
        .key_handle = handle,
        .type = type,
    };
    psa_invec in_vec[] = {
 803b5ce:	ab07      	add	r3, sp, #28
    struct tfm_crypto_pack_iovec iov = {
 803b5d0:	2101      	movs	r1, #1
    psa_invec in_vec[] = {
 803b5d2:	9303      	str	r3, [sp, #12]
 803b5d4:	2334      	movs	r3, #52	; 0x34
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = data, .len = data_length}
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b5d6:	2080      	movs	r0, #128	; 0x80
    psa_invec in_vec[] = {
 803b5d8:	e9cd 3504 	strd	r3, r5, [sp, #16]
    struct tfm_crypto_pack_iovec iov = {
 803b5dc:	9107      	str	r1, [sp, #28]
 803b5de:	f8ad 7020 	strh.w	r7, [sp, #32]
 803b5e2:	9609      	str	r6, [sp, #36]	; 0x24
    psa_invec in_vec[] = {
 803b5e4:	9406      	str	r4, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b5e6:	f000 fb9b 	bl	803bd20 <psa_connect>
 803b5ea:	1e05      	subs	r5, r0, #0
 803b5ec:	dd0d      	ble.n	803b60a <psa_import_key+0x54>

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_import_key,
 803b5ee:	2100      	movs	r1, #0
 803b5f0:	2302      	movs	r3, #2
 803b5f2:	e9cd 1100 	strd	r1, r1, [sp]
 803b5f6:	aa03      	add	r2, sp, #12
 803b5f8:	f000 fba0 	bl	803bd3c <psa_call>
 803b5fc:	4604      	mov	r4, r0
                                    TFM_CRYPTO_IMPORT_KEY);

    PSA_CLOSE();
 803b5fe:	4628      	mov	r0, r5
 803b600:	f000 fbb0 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 803b604:	4620      	mov	r0, r4
 803b606:	b015      	add	sp, #84	; 0x54
 803b608:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b60a:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b60e:	e7f9      	b.n	803b604 <psa_import_key+0x4e>

0803b610 <psa_destroy_key>:

psa_status_t psa_destroy_key(psa_key_handle_t handle)
{
 803b610:	b530      	push	{r4, r5, lr}
 803b612:	b093      	sub	sp, #76	; 0x4c
 803b614:	4604      	mov	r4, r0
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b616:	222e      	movs	r2, #46	; 0x2e
 803b618:	2100      	movs	r1, #0
 803b61a:	f10d 001a 	add.w	r0, sp, #26
 803b61e:	f001 f85b 	bl	803c6d8 <memset>
 803b622:	2302      	movs	r3, #2
 803b624:	9305      	str	r3, [sp, #20]
        .sfn_id = TFM_CRYPTO_DESTROY_KEY_SID,
        .key_handle = handle,
    };
    psa_invec in_vec[] = {
 803b626:	ab05      	add	r3, sp, #20
 803b628:	9303      	str	r3, [sp, #12]
 803b62a:	2334      	movs	r3, #52	; 0x34
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b62c:	2101      	movs	r1, #1
 803b62e:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
 803b630:	f8ad 4018 	strh.w	r4, [sp, #24]
    psa_invec in_vec[] = {
 803b634:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
 803b636:	f000 fb73 	bl	803bd20 <psa_connect>
 803b63a:	1e05      	subs	r5, r0, #0
 803b63c:	dd0d      	ble.n	803b65a <psa_destroy_key+0x4a>

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_destroy_key,
 803b63e:	2100      	movs	r1, #0
 803b640:	2301      	movs	r3, #1
 803b642:	e9cd 1100 	strd	r1, r1, [sp]
 803b646:	aa03      	add	r2, sp, #12
 803b648:	f000 fb78 	bl	803bd3c <psa_call>
 803b64c:	4604      	mov	r4, r0
                                    TFM_CRYPTO_DESTROY_KEY);

    PSA_CLOSE();
 803b64e:	4628      	mov	r0, r5
 803b650:	f000 fb88 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 803b654:	4620      	mov	r0, r4
 803b656:	b013      	add	sp, #76	; 0x4c
 803b658:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b65a:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b65e:	e7f9      	b.n	803b654 <psa_destroy_key+0x44>

0803b660 <psa_get_key_information>:

psa_status_t psa_get_key_information(psa_key_handle_t handle,
                                     psa_key_type_t *type,
                                     size_t *bits)
{
 803b660:	b570      	push	{r4, r5, r6, lr}
 803b662:	b096      	sub	sp, #88	; 0x58
 803b664:	460d      	mov	r5, r1
 803b666:	4606      	mov	r6, r0
 803b668:	4614      	mov	r4, r2
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b66a:	2100      	movs	r1, #0
 803b66c:	222e      	movs	r2, #46	; 0x2e
 803b66e:	f10d 002a 	add.w	r0, sp, #42	; 0x2a
 803b672:	f001 f831 	bl	803c6d8 <memset>
 803b676:	2303      	movs	r3, #3
 803b678:	9309      	str	r3, [sp, #36]	; 0x24
        .sfn_id = TFM_CRYPTO_GET_KEY_INFORMATION_SID,
        .key_handle = handle,
    };
    psa_invec in_vec[] = {
 803b67a:	ab09      	add	r3, sp, #36	; 0x24
 803b67c:	9303      	str	r3, [sp, #12]
 803b67e:	2334      	movs	r3, #52	; 0x34
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };
    psa_outvec out_vec[] = {
 803b680:	e9cd 3504 	strd	r3, r5, [sp, #16]
 803b684:	2304      	movs	r3, #4
        {.base = type, .len = sizeof(psa_key_type_t)},
        {.base = bits, .len = sizeof(size_t)}
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b686:	2101      	movs	r1, #1
 803b688:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
 803b68a:	f8ad 6028 	strh.w	r6, [sp, #40]	; 0x28
    psa_outvec out_vec[] = {
 803b68e:	e9cd 3406 	strd	r3, r4, [sp, #24]
 803b692:	9308      	str	r3, [sp, #32]
    PSA_CONNECT(TFM_CRYPTO);
 803b694:	f000 fb44 	bl	803bd20 <psa_connect>
 803b698:	1e05      	subs	r5, r0, #0
 803b69a:	dd0f      	ble.n	803b6bc <psa_get_key_information+0x5c>

    status = API_DISPATCH(tfm_crypto_get_key_information,
 803b69c:	2302      	movs	r3, #2
 803b69e:	9301      	str	r3, [sp, #4]
 803b6a0:	ab05      	add	r3, sp, #20
 803b6a2:	9300      	str	r3, [sp, #0]
 803b6a4:	aa03      	add	r2, sp, #12
 803b6a6:	2301      	movs	r3, #1
 803b6a8:	2100      	movs	r1, #0
 803b6aa:	f000 fb47 	bl	803bd3c <psa_call>
 803b6ae:	4604      	mov	r4, r0
                          TFM_CRYPTO_GET_KEY_INFORMATION);

    PSA_CLOSE();
 803b6b0:	4628      	mov	r0, r5
 803b6b2:	f000 fb57 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 803b6b6:	4620      	mov	r0, r4
 803b6b8:	b016      	add	sp, #88	; 0x58
 803b6ba:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b6bc:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b6c0:	e7f9      	b.n	803b6b6 <psa_get_key_information+0x56>

0803b6c2 <psa_key_policy_set_usage>:
void psa_key_policy_set_usage(psa_key_policy_t *policy,
                              psa_key_usage_t usage,
                              psa_algorithm_t alg)
{
    policy->usage = usage;
    policy->alg = alg;
 803b6c2:	e9c0 1200 	strd	r1, r2, [r0]
}
 803b6c6:	4770      	bx	lr

0803b6c8 <psa_set_key_policy>:
    return policy->alg;
}

psa_status_t psa_set_key_policy(psa_key_handle_t handle,
                                const psa_key_policy_t *policy)
{
 803b6c8:	b530      	push	{r4, r5, lr}
 803b6ca:	b095      	sub	sp, #84	; 0x54
 803b6cc:	4605      	mov	r5, r0
 803b6ce:	460c      	mov	r4, r1
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b6d0:	222e      	movs	r2, #46	; 0x2e
 803b6d2:	2100      	movs	r1, #0
 803b6d4:	f10d 0022 	add.w	r0, sp, #34	; 0x22
 803b6d8:	f000 fffe 	bl	803c6d8 <memset>
 803b6dc:	2307      	movs	r3, #7
 803b6de:	9307      	str	r3, [sp, #28]
        .sfn_id = TFM_CRYPTO_SET_KEY_POLICY_SID,
        .key_handle = handle,
    };

    psa_invec in_vec[] = {
 803b6e0:	ab07      	add	r3, sp, #28
 803b6e2:	9303      	str	r3, [sp, #12]
 803b6e4:	2334      	movs	r3, #52	; 0x34
 803b6e6:	e9cd 3404 	strd	r3, r4, [sp, #16]
 803b6ea:	230c      	movs	r3, #12
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = policy, .len = sizeof(psa_key_policy_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b6ec:	2101      	movs	r1, #1
 803b6ee:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
 803b6f0:	f8ad 5020 	strh.w	r5, [sp, #32]
    psa_invec in_vec[] = {
 803b6f4:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b6f6:	f000 fb13 	bl	803bd20 <psa_connect>
 803b6fa:	1e05      	subs	r5, r0, #0
 803b6fc:	dd0d      	ble.n	803b71a <psa_set_key_policy+0x52>

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_set_key_policy,
 803b6fe:	2100      	movs	r1, #0
 803b700:	2302      	movs	r3, #2
 803b702:	e9cd 1100 	strd	r1, r1, [sp]
 803b706:	aa03      	add	r2, sp, #12
 803b708:	f000 fb18 	bl	803bd3c <psa_call>
 803b70c:	4604      	mov	r4, r0
                                    TFM_CRYPTO_SET_KEY_POLICY);

    PSA_CLOSE();
 803b70e:	4628      	mov	r0, r5
 803b710:	f000 fb28 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 803b714:	4620      	mov	r0, r4
 803b716:	b015      	add	sp, #84	; 0x54
 803b718:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b71a:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b71e:	e7f9      	b.n	803b714 <psa_set_key_policy+0x4c>

0803b720 <psa_cipher_set_iv>:
}

psa_status_t psa_cipher_set_iv(psa_cipher_operation_t *operation,
                               const unsigned char *iv,
                               size_t iv_length)
{
 803b720:	b570      	push	{r4, r5, r6, lr}
 803b722:	b096      	sub	sp, #88	; 0x58
 803b724:	4604      	mov	r4, r0
 803b726:	4615      	mov	r5, r2
 803b728:	460e      	mov	r6, r1
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b72a:	2230      	movs	r2, #48	; 0x30
 803b72c:	2100      	movs	r1, #0
 803b72e:	a80a      	add	r0, sp, #40	; 0x28
 803b730:	f000 ffd2 	bl	803c6d8 <memset>
 803b734:	230b      	movs	r3, #11
 803b736:	9309      	str	r3, [sp, #36]	; 0x24
 803b738:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b73a:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b73c:	930f      	str	r3, [sp, #60]	; 0x3c
    psa_invec in_vec[] = {
 803b73e:	ab09      	add	r3, sp, #36	; 0x24
 803b740:	9305      	str	r3, [sp, #20]
 803b742:	2334      	movs	r3, #52	; 0x34
 803b744:	e9cd 3606 	strd	r3, r6, [sp, #24]
    psa_outvec out_vec[] = {
 803b748:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b74a:	2080      	movs	r0, #128	; 0x80
    psa_invec in_vec[] = {
 803b74c:	9508      	str	r5, [sp, #32]
    psa_outvec out_vec[] = {
 803b74e:	9403      	str	r4, [sp, #12]
 803b750:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
 803b752:	f000 fae5 	bl	803bd20 <psa_connect>
 803b756:	1e05      	subs	r5, r0, #0
 803b758:	dd0f      	ble.n	803b77a <psa_cipher_set_iv+0x5a>

    status = API_DISPATCH(tfm_crypto_cipher_set_iv,
 803b75a:	2301      	movs	r3, #1
 803b75c:	9301      	str	r3, [sp, #4]
 803b75e:	ab03      	add	r3, sp, #12
 803b760:	9300      	str	r3, [sp, #0]
 803b762:	aa05      	add	r2, sp, #20
 803b764:	2302      	movs	r3, #2
 803b766:	2100      	movs	r1, #0
 803b768:	f000 fae8 	bl	803bd3c <psa_call>
 803b76c:	4604      	mov	r4, r0
                          TFM_CRYPTO_CIPHER_SET_IV);

    PSA_CLOSE();
 803b76e:	4628      	mov	r0, r5
 803b770:	f000 faf8 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 803b774:	4620      	mov	r0, r4
 803b776:	b016      	add	sp, #88	; 0x58
 803b778:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b77a:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b77e:	e7f9      	b.n	803b774 <psa_cipher_set_iv+0x54>

0803b780 <psa_cipher_encrypt_setup>:

psa_status_t psa_cipher_encrypt_setup(psa_cipher_operation_t *operation,
                                      psa_key_handle_t handle,
                                      psa_algorithm_t alg)
{
 803b780:	b570      	push	{r4, r5, r6, lr}
 803b782:	b094      	sub	sp, #80	; 0x50
 803b784:	4604      	mov	r4, r0
 803b786:	4615      	mov	r5, r2
 803b788:	460e      	mov	r6, r1
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b78a:	222e      	movs	r2, #46	; 0x2e
 803b78c:	2100      	movs	r1, #0
 803b78e:	f10d 0022 	add.w	r0, sp, #34	; 0x22
 803b792:	f000 ffa1 	bl	803c6d8 <memset>
 803b796:	230c      	movs	r3, #12
 803b798:	9307      	str	r3, [sp, #28]
 803b79a:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b79c:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b79e:	930d      	str	r3, [sp, #52]	; 0x34
    psa_invec in_vec[] = {
 803b7a0:	ab07      	add	r3, sp, #28
 803b7a2:	9303      	str	r3, [sp, #12]
 803b7a4:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
 803b7a6:	e9cd 3404 	strd	r3, r4, [sp, #16]
 803b7aa:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b7ac:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
 803b7ae:	950b      	str	r5, [sp, #44]	; 0x2c
 803b7b0:	f8ad 6020 	strh.w	r6, [sp, #32]
    psa_outvec out_vec[] = {
 803b7b4:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b7b6:	f000 fab3 	bl	803bd20 <psa_connect>
 803b7ba:	1e05      	subs	r5, r0, #0
 803b7bc:	dd0e      	ble.n	803b7dc <psa_cipher_encrypt_setup+0x5c>

    status = API_DISPATCH(tfm_crypto_cipher_encrypt_setup,
 803b7be:	2301      	movs	r3, #1
 803b7c0:	aa05      	add	r2, sp, #20
 803b7c2:	9200      	str	r2, [sp, #0]
 803b7c4:	9301      	str	r3, [sp, #4]
 803b7c6:	aa03      	add	r2, sp, #12
 803b7c8:	2100      	movs	r1, #0
 803b7ca:	f000 fab7 	bl	803bd3c <psa_call>
 803b7ce:	4604      	mov	r4, r0
                          TFM_CRYPTO_CIPHER_ENCRYPT_SETUP);

    PSA_CLOSE();
 803b7d0:	4628      	mov	r0, r5
 803b7d2:	f000 fac7 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 803b7d6:	4620      	mov	r0, r4
 803b7d8:	b014      	add	sp, #80	; 0x50
 803b7da:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b7dc:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b7e0:	e7f9      	b.n	803b7d6 <psa_cipher_encrypt_setup+0x56>

0803b7e2 <psa_cipher_decrypt_setup>:

psa_status_t psa_cipher_decrypt_setup(psa_cipher_operation_t *operation,
                                      psa_key_handle_t handle,
                                      psa_algorithm_t alg)
{
 803b7e2:	b570      	push	{r4, r5, r6, lr}
 803b7e4:	b094      	sub	sp, #80	; 0x50
 803b7e6:	4604      	mov	r4, r0
 803b7e8:	4615      	mov	r5, r2
 803b7ea:	460e      	mov	r6, r1
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b7ec:	222e      	movs	r2, #46	; 0x2e
 803b7ee:	2100      	movs	r1, #0
 803b7f0:	f10d 0022 	add.w	r0, sp, #34	; 0x22
 803b7f4:	f000 ff70 	bl	803c6d8 <memset>
 803b7f8:	230d      	movs	r3, #13
 803b7fa:	9307      	str	r3, [sp, #28]
 803b7fc:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b7fe:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b800:	930d      	str	r3, [sp, #52]	; 0x34
    psa_invec in_vec[] = {
 803b802:	ab07      	add	r3, sp, #28
 803b804:	9303      	str	r3, [sp, #12]
 803b806:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
 803b808:	e9cd 3404 	strd	r3, r4, [sp, #16]
 803b80c:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b80e:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
 803b810:	950b      	str	r5, [sp, #44]	; 0x2c
 803b812:	f8ad 6020 	strh.w	r6, [sp, #32]
    psa_outvec out_vec[] = {
 803b816:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b818:	f000 fa82 	bl	803bd20 <psa_connect>
 803b81c:	1e05      	subs	r5, r0, #0
 803b81e:	dd0e      	ble.n	803b83e <psa_cipher_decrypt_setup+0x5c>

    status = API_DISPATCH(tfm_crypto_cipher_decrypt_setup,
 803b820:	2301      	movs	r3, #1
 803b822:	aa05      	add	r2, sp, #20
 803b824:	9200      	str	r2, [sp, #0]
 803b826:	9301      	str	r3, [sp, #4]
 803b828:	aa03      	add	r2, sp, #12
 803b82a:	2100      	movs	r1, #0
 803b82c:	f000 fa86 	bl	803bd3c <psa_call>
 803b830:	4604      	mov	r4, r0
                          TFM_CRYPTO_CIPHER_DECRYPT_SETUP);

    PSA_CLOSE();
 803b832:	4628      	mov	r0, r5
 803b834:	f000 fa96 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 803b838:	4620      	mov	r0, r4
 803b83a:	b014      	add	sp, #80	; 0x50
 803b83c:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b83e:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b842:	e7f9      	b.n	803b838 <psa_cipher_decrypt_setup+0x56>

0803b844 <psa_cipher_update>:
                               const uint8_t *input,
                               size_t input_length,
                               unsigned char *output,
                               size_t output_size,
                               size_t *output_length)
{
 803b844:	b5f0      	push	{r4, r5, r6, r7, lr}
 803b846:	4616      	mov	r6, r2
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b848:	2230      	movs	r2, #48	; 0x30
{
 803b84a:	b099      	sub	sp, #100	; 0x64
 803b84c:	4604      	mov	r4, r0
 803b84e:	460f      	mov	r7, r1
    struct tfm_crypto_pack_iovec iov = {
 803b850:	eb0d 0002 	add.w	r0, sp, r2
 803b854:	2100      	movs	r1, #0
{
 803b856:	461d      	mov	r5, r3
    struct tfm_crypto_pack_iovec iov = {
 803b858:	f000 ff3e 	bl	803c6d8 <memset>
 803b85c:	230e      	movs	r3, #14
 803b85e:	930b      	str	r3, [sp, #44]	; 0x2c
 803b860:	6823      	ldr	r3, [r4, #0]
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
        {.base = output, .len = output_size}
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b862:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b864:	9311      	str	r3, [sp, #68]	; 0x44
    psa_invec in_vec[] = {
 803b866:	ab0b      	add	r3, sp, #44	; 0x2c
 803b868:	9303      	str	r3, [sp, #12]
 803b86a:	2334      	movs	r3, #52	; 0x34
 803b86c:	e9cd 3704 	strd	r3, r7, [sp, #16]
    psa_outvec out_vec[] = {
 803b870:	2304      	movs	r3, #4
 803b872:	e9cd 3508 	strd	r3, r5, [sp, #32]
 803b876:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    PSA_CONNECT(TFM_CRYPTO);
 803b878:	2080      	movs	r0, #128	; 0x80
    psa_outvec out_vec[] = {
 803b87a:	e9cd 6406 	strd	r6, r4, [sp, #24]
 803b87e:	930a      	str	r3, [sp, #40]	; 0x28
    PSA_CONNECT(TFM_CRYPTO);
 803b880:	f000 fa4e 	bl	803bd20 <psa_connect>
 803b884:	1e05      	subs	r5, r0, #0
 803b886:	dd11      	ble.n	803b8ac <psa_cipher_update+0x68>

    status = API_DISPATCH(tfm_crypto_cipher_update,
 803b888:	2302      	movs	r3, #2
 803b88a:	aa07      	add	r2, sp, #28
 803b88c:	9301      	str	r3, [sp, #4]
 803b88e:	9200      	str	r2, [sp, #0]
 803b890:	2100      	movs	r1, #0
 803b892:	aa03      	add	r2, sp, #12
 803b894:	f000 fa52 	bl	803bd3c <psa_call>
                          TFM_CRYPTO_CIPHER_UPDATE);

    *output_length = out_vec[1].len;
 803b898:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 803b89a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    status = API_DISPATCH(tfm_crypto_cipher_update,
 803b89c:	4604      	mov	r4, r0
    *output_length = out_vec[1].len;
 803b89e:	601a      	str	r2, [r3, #0]

    PSA_CLOSE();
 803b8a0:	4628      	mov	r0, r5
 803b8a2:	f000 fa5f 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 803b8a6:	4620      	mov	r0, r4
 803b8a8:	b019      	add	sp, #100	; 0x64
 803b8aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b8ac:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b8b0:	e7f9      	b.n	803b8a6 <psa_cipher_update+0x62>

0803b8b2 <psa_cipher_abort>:

psa_status_t psa_cipher_abort(psa_cipher_operation_t *operation)
{
 803b8b2:	b530      	push	{r4, r5, lr}
 803b8b4:	b095      	sub	sp, #84	; 0x54
 803b8b6:	4604      	mov	r4, r0
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b8b8:	2230      	movs	r2, #48	; 0x30
 803b8ba:	2100      	movs	r1, #0
 803b8bc:	a808      	add	r0, sp, #32
 803b8be:	f000 ff0b 	bl	803c6d8 <memset>
 803b8c2:	230f      	movs	r3, #15
 803b8c4:	9307      	str	r3, [sp, #28]
 803b8c6:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b8c8:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b8ca:	930d      	str	r3, [sp, #52]	; 0x34
    psa_invec in_vec[] = {
 803b8cc:	ab07      	add	r3, sp, #28
 803b8ce:	9303      	str	r3, [sp, #12]
 803b8d0:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
 803b8d2:	e9cd 3404 	strd	r3, r4, [sp, #16]
 803b8d6:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b8d8:	2080      	movs	r0, #128	; 0x80
    psa_outvec out_vec[] = {
 803b8da:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b8dc:	f000 fa20 	bl	803bd20 <psa_connect>
 803b8e0:	1e05      	subs	r5, r0, #0
 803b8e2:	dd0e      	ble.n	803b902 <psa_cipher_abort+0x50>

    status = API_DISPATCH(tfm_crypto_cipher_abort,
 803b8e4:	2301      	movs	r3, #1
 803b8e6:	aa05      	add	r2, sp, #20
 803b8e8:	9200      	str	r2, [sp, #0]
 803b8ea:	9301      	str	r3, [sp, #4]
 803b8ec:	aa03      	add	r2, sp, #12
 803b8ee:	2100      	movs	r1, #0
 803b8f0:	f000 fa24 	bl	803bd3c <psa_call>
 803b8f4:	4604      	mov	r4, r0
                          TFM_CRYPTO_CIPHER_ABORT);

    PSA_CLOSE();
 803b8f6:	4628      	mov	r0, r5
 803b8f8:	f000 fa34 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 803b8fc:	4620      	mov	r0, r4
 803b8fe:	b015      	add	sp, #84	; 0x54
 803b900:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b902:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b906:	e7f9      	b.n	803b8fc <psa_cipher_abort+0x4a>

0803b908 <psa_cipher_finish>:

psa_status_t psa_cipher_finish(psa_cipher_operation_t *operation,
                               uint8_t *output,
                               size_t output_size,
                               size_t *output_length)
{
 803b908:	b5f0      	push	{r4, r5, r6, r7, lr}
 803b90a:	b097      	sub	sp, #92	; 0x5c
 803b90c:	4604      	mov	r4, r0
 803b90e:	4615      	mov	r5, r2
 803b910:	460f      	mov	r7, r1
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b912:	2230      	movs	r2, #48	; 0x30
 803b914:	2100      	movs	r1, #0
 803b916:	a80a      	add	r0, sp, #40	; 0x28
{
 803b918:	461e      	mov	r6, r3
    struct tfm_crypto_pack_iovec iov = {
 803b91a:	f000 fedd 	bl	803c6d8 <memset>
 803b91e:	2310      	movs	r3, #16
 803b920:	9309      	str	r3, [sp, #36]	; 0x24
 803b922:	6823      	ldr	r3, [r4, #0]
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
        {.base = output, .len = output_size},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b924:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b926:	930f      	str	r3, [sp, #60]	; 0x3c
    psa_invec in_vec[] = {
 803b928:	ab09      	add	r3, sp, #36	; 0x24
 803b92a:	9303      	str	r3, [sp, #12]
 803b92c:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
 803b92e:	e9cd 3404 	strd	r3, r4, [sp, #16]
 803b932:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b934:	2080      	movs	r0, #128	; 0x80
    psa_outvec out_vec[] = {
 803b936:	9508      	str	r5, [sp, #32]
 803b938:	e9cd 3706 	strd	r3, r7, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b93c:	f000 f9f0 	bl	803bd20 <psa_connect>
 803b940:	1e05      	subs	r5, r0, #0
 803b942:	dd11      	ble.n	803b968 <psa_cipher_finish+0x60>

    status = API_DISPATCH(tfm_crypto_cipher_finish,
 803b944:	2302      	movs	r3, #2
 803b946:	9301      	str	r3, [sp, #4]
 803b948:	ab05      	add	r3, sp, #20
 803b94a:	9300      	str	r3, [sp, #0]
 803b94c:	aa03      	add	r2, sp, #12
 803b94e:	2301      	movs	r3, #1
 803b950:	2100      	movs	r1, #0
 803b952:	f000 f9f3 	bl	803bd3c <psa_call>
                          TFM_CRYPTO_CIPHER_FINISH);

    *output_length = out_vec[1].len;
 803b956:	9b08      	ldr	r3, [sp, #32]
    status = API_DISPATCH(tfm_crypto_cipher_finish,
 803b958:	4604      	mov	r4, r0
    *output_length = out_vec[1].len;
 803b95a:	6033      	str	r3, [r6, #0]

    PSA_CLOSE();
 803b95c:	4628      	mov	r0, r5
 803b95e:	f000 fa01 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 803b962:	4620      	mov	r0, r4
 803b964:	b017      	add	sp, #92	; 0x5c
 803b966:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b968:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b96c:	e7f9      	b.n	803b962 <psa_cipher_finish+0x5a>

0803b96e <psa_hash_setup>:

psa_status_t psa_hash_setup(psa_hash_operation_t *operation,
                            psa_algorithm_t alg)
{
 803b96e:	b530      	push	{r4, r5, lr}
 803b970:	b095      	sub	sp, #84	; 0x54
 803b972:	4604      	mov	r4, r0
 803b974:	460d      	mov	r5, r1
#if (TFM_CRYPTO_HASH_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b976:	2230      	movs	r2, #48	; 0x30
 803b978:	2100      	movs	r1, #0
 803b97a:	a808      	add	r0, sp, #32
 803b97c:	f000 feac 	bl	803c6d8 <memset>
 803b980:	2311      	movs	r3, #17
 803b982:	9307      	str	r3, [sp, #28]
 803b984:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b986:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b988:	930d      	str	r3, [sp, #52]	; 0x34
    psa_invec in_vec[] = {
 803b98a:	ab07      	add	r3, sp, #28
 803b98c:	9303      	str	r3, [sp, #12]
 803b98e:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
 803b990:	e9cd 3404 	strd	r3, r4, [sp, #16]
 803b994:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b996:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
 803b998:	950b      	str	r5, [sp, #44]	; 0x2c
    psa_outvec out_vec[] = {
 803b99a:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b99c:	f000 f9c0 	bl	803bd20 <psa_connect>
 803b9a0:	1e05      	subs	r5, r0, #0
 803b9a2:	dd0e      	ble.n	803b9c2 <psa_hash_setup+0x54>

    status = API_DISPATCH(tfm_crypto_hash_setup,
 803b9a4:	2301      	movs	r3, #1
 803b9a6:	aa05      	add	r2, sp, #20
 803b9a8:	9200      	str	r2, [sp, #0]
 803b9aa:	9301      	str	r3, [sp, #4]
 803b9ac:	aa03      	add	r2, sp, #12
 803b9ae:	2100      	movs	r1, #0
 803b9b0:	f000 f9c4 	bl	803bd3c <psa_call>
 803b9b4:	4604      	mov	r4, r0
                          TFM_CRYPTO_HASH_SETUP);

    PSA_CLOSE();
 803b9b6:	4628      	mov	r0, r5
 803b9b8:	f000 f9d4 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 803b9bc:	4620      	mov	r0, r4
 803b9be:	b015      	add	sp, #84	; 0x54
 803b9c0:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b9c2:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b9c6:	e7f9      	b.n	803b9bc <psa_hash_setup+0x4e>

0803b9c8 <psa_hash_update>:

psa_status_t psa_hash_update(psa_hash_operation_t *operation,
                             const uint8_t *input,
                             size_t input_length)
{
 803b9c8:	b570      	push	{r4, r5, r6, lr}
 803b9ca:	b096      	sub	sp, #88	; 0x58
 803b9cc:	4604      	mov	r4, r0
 803b9ce:	4615      	mov	r5, r2
 803b9d0:	460e      	mov	r6, r1
#if (TFM_CRYPTO_HASH_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b9d2:	2230      	movs	r2, #48	; 0x30
 803b9d4:	2100      	movs	r1, #0
 803b9d6:	a80a      	add	r0, sp, #40	; 0x28
 803b9d8:	f000 fe7e 	bl	803c6d8 <memset>
 803b9dc:	2312      	movs	r3, #18
 803b9de:	9309      	str	r3, [sp, #36]	; 0x24
 803b9e0:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b9e2:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b9e4:	930f      	str	r3, [sp, #60]	; 0x3c
    psa_invec in_vec[] = {
 803b9e6:	ab09      	add	r3, sp, #36	; 0x24
 803b9e8:	9305      	str	r3, [sp, #20]
 803b9ea:	2334      	movs	r3, #52	; 0x34
 803b9ec:	e9cd 3606 	strd	r3, r6, [sp, #24]
    psa_outvec out_vec[] = {
 803b9f0:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b9f2:	2080      	movs	r0, #128	; 0x80
    psa_invec in_vec[] = {
 803b9f4:	9508      	str	r5, [sp, #32]
    psa_outvec out_vec[] = {
 803b9f6:	9403      	str	r4, [sp, #12]
 803b9f8:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
 803b9fa:	f000 f991 	bl	803bd20 <psa_connect>
 803b9fe:	1e05      	subs	r5, r0, #0
 803ba00:	dd0f      	ble.n	803ba22 <psa_hash_update+0x5a>

    status = API_DISPATCH(tfm_crypto_hash_update,
 803ba02:	2301      	movs	r3, #1
 803ba04:	9301      	str	r3, [sp, #4]
 803ba06:	ab03      	add	r3, sp, #12
 803ba08:	9300      	str	r3, [sp, #0]
 803ba0a:	aa05      	add	r2, sp, #20
 803ba0c:	2302      	movs	r3, #2
 803ba0e:	2100      	movs	r1, #0
 803ba10:	f000 f994 	bl	803bd3c <psa_call>
 803ba14:	4604      	mov	r4, r0
                          TFM_CRYPTO_HASH_UPDATE);

    PSA_CLOSE();
 803ba16:	4628      	mov	r0, r5
 803ba18:	f000 f9a4 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 803ba1c:	4620      	mov	r0, r4
 803ba1e:	b016      	add	sp, #88	; 0x58
 803ba20:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803ba22:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803ba26:	e7f9      	b.n	803ba1c <psa_hash_update+0x54>

0803ba28 <psa_hash_verify>:
}

psa_status_t psa_hash_verify(psa_hash_operation_t *operation,
                             const uint8_t *hash,
                             size_t hash_length)
{
 803ba28:	b570      	push	{r4, r5, r6, lr}
 803ba2a:	b096      	sub	sp, #88	; 0x58
 803ba2c:	4604      	mov	r4, r0
 803ba2e:	4615      	mov	r5, r2
 803ba30:	460e      	mov	r6, r1
#if (TFM_CRYPTO_HASH_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803ba32:	2230      	movs	r2, #48	; 0x30
 803ba34:	2100      	movs	r1, #0
 803ba36:	a80a      	add	r0, sp, #40	; 0x28
 803ba38:	f000 fe4e 	bl	803c6d8 <memset>
 803ba3c:	2314      	movs	r3, #20
 803ba3e:	9309      	str	r3, [sp, #36]	; 0x24
 803ba40:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803ba42:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803ba44:	930f      	str	r3, [sp, #60]	; 0x3c
    psa_invec in_vec[] = {
 803ba46:	ab09      	add	r3, sp, #36	; 0x24
 803ba48:	9305      	str	r3, [sp, #20]
 803ba4a:	2334      	movs	r3, #52	; 0x34
 803ba4c:	e9cd 3606 	strd	r3, r6, [sp, #24]
    psa_outvec out_vec[] = {
 803ba50:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803ba52:	2080      	movs	r0, #128	; 0x80
    psa_invec in_vec[] = {
 803ba54:	9508      	str	r5, [sp, #32]
    psa_outvec out_vec[] = {
 803ba56:	9403      	str	r4, [sp, #12]
 803ba58:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
 803ba5a:	f000 f961 	bl	803bd20 <psa_connect>
 803ba5e:	1e05      	subs	r5, r0, #0
 803ba60:	dd0f      	ble.n	803ba82 <psa_hash_verify+0x5a>

    status = API_DISPATCH(tfm_crypto_hash_verify,
 803ba62:	2301      	movs	r3, #1
 803ba64:	9301      	str	r3, [sp, #4]
 803ba66:	ab03      	add	r3, sp, #12
 803ba68:	9300      	str	r3, [sp, #0]
 803ba6a:	aa05      	add	r2, sp, #20
 803ba6c:	2302      	movs	r3, #2
 803ba6e:	2100      	movs	r1, #0
 803ba70:	f000 f964 	bl	803bd3c <psa_call>
 803ba74:	4604      	mov	r4, r0
                          TFM_CRYPTO_HASH_VERIFY);

    PSA_CLOSE();
 803ba76:	4628      	mov	r0, r5
 803ba78:	f000 f974 	bl	803bd64 <psa_close>

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 803ba7c:	4620      	mov	r0, r4
 803ba7e:	b016      	add	sp, #88	; 0x58
 803ba80:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803ba82:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803ba86:	e7f9      	b.n	803ba7c <psa_hash_verify+0x54>

0803ba88 <psa_aead_encrypt>:
                              const uint8_t *plaintext,
                              size_t plaintext_length,
                              uint8_t *ciphertext,
                              size_t ciphertext_size,
                              size_t *ciphertext_length)
{
 803ba88:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 803ba8c:	b099      	sub	sp, #100	; 0x64
 803ba8e:	4681      	mov	r9, r0
 803ba90:	e9dd 4720 	ldrd	r4, r7, [sp, #128]	; 0x80
 803ba94:	4688      	mov	r8, r1
 803ba96:	4616      	mov	r6, r2
#if (TFM_CRYPTO_AEAD_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803ba98:	2100      	movs	r1, #0
 803ba9a:	222a      	movs	r2, #42	; 0x2a
 803ba9c:	f10d 0032 	add.w	r0, sp, #50	; 0x32
{
 803baa0:	461d      	mov	r5, r3
    struct tfm_crypto_pack_iovec iov = {
 803baa2:	f000 fe19 	bl	803c6d8 <memset>
 803baa6:	231d      	movs	r3, #29
 803baa8:	f8ad 9030 	strh.w	r9, [sp, #48]	; 0x30
 803baac:	930b      	str	r3, [sp, #44]	; 0x2c
 803baae:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 803bab2:	9517      	str	r5, [sp, #92]	; 0x5c
        .alg = alg,
        .aead_in = {.nonce = {0}, .nonce_length = nonce_length}
    };

    /* Sanitize the optional input */
    if ((additional_data == NULL) && (additional_data_length != 0)) {
 803bab4:	b934      	cbnz	r4, 803bac4 <psa_aead_encrypt+0x3c>
 803bab6:	b12f      	cbz	r7, 803bac4 <psa_aead_encrypt+0x3c>
        return PSA_ERROR_INVALID_ARGUMENT;
 803bab8:	f06f 0486 	mvn.w	r4, #134	; 0x86

    PSA_CLOSE();

    return status;
#endif /* TFM_CRYPTO_AEAD_MODULE_DISABLED */
}
 803babc:	4620      	mov	r0, r4
 803babe:	b019      	add	sp, #100	; 0x64
 803bac0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    psa_invec in_vec[] = {
 803bac4:	2234      	movs	r2, #52	; 0x34
 803bac6:	9206      	str	r2, [sp, #24]
 803bac8:	9a22      	ldr	r2, [sp, #136]	; 0x88
 803baca:	ab0b      	add	r3, sp, #44	; 0x2c
 803bacc:	9207      	str	r2, [sp, #28]
 803bace:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
 803bad0:	2d10      	cmp	r5, #16
    psa_invec in_vec[] = {
 803bad2:	e9cd 2408 	strd	r2, r4, [sp, #32]
    psa_outvec out_vec[] = {
 803bad6:	9a24      	ldr	r2, [sp, #144]	; 0x90
    psa_invec in_vec[] = {
 803bad8:	9305      	str	r3, [sp, #20]
    psa_outvec out_vec[] = {
 803bada:	9203      	str	r2, [sp, #12]
 803badc:	9a25      	ldr	r2, [sp, #148]	; 0x94
    psa_invec in_vec[] = {
 803bade:	970a      	str	r7, [sp, #40]	; 0x28
    psa_outvec out_vec[] = {
 803bae0:	9204      	str	r2, [sp, #16]
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
 803bae2:	d8e9      	bhi.n	803bab8 <psa_aead_encrypt+0x30>
    if (nonce != NULL) {
 803bae4:	b986      	cbnz	r6, 803bb08 <psa_aead_encrypt+0x80>
    PSA_CONNECT(TFM_CRYPTO);
 803bae6:	2101      	movs	r1, #1
 803bae8:	2080      	movs	r0, #128	; 0x80
 803baea:	f000 f919 	bl	803bd20 <psa_connect>
 803baee:	1e05      	subs	r5, r0, #0
 803baf0:	dc0c      	bgt.n	803bb0c <psa_aead_encrypt+0x84>
 803baf2:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803baf6:	e7e1      	b.n	803babc <psa_aead_encrypt+0x34>
            iov.aead_in.nonce[idx] = nonce[idx];
 803baf8:	5cb0      	ldrb	r0, [r6, r2]
 803bafa:	1899      	adds	r1, r3, r2
 803bafc:	f881 0020 	strb.w	r0, [r1, #32]
        for (idx = 0; idx < nonce_length; idx++) {
 803bb00:	3201      	adds	r2, #1
 803bb02:	42aa      	cmp	r2, r5
 803bb04:	d1f8      	bne.n	803baf8 <psa_aead_encrypt+0x70>
 803bb06:	e7ee      	b.n	803bae6 <psa_aead_encrypt+0x5e>
 803bb08:	2200      	movs	r2, #0
 803bb0a:	e7fa      	b.n	803bb02 <psa_aead_encrypt+0x7a>
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 803bb0c:	2301      	movs	r3, #1
        in_len--;
 803bb0e:	2c00      	cmp	r4, #0
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 803bb10:	9301      	str	r3, [sp, #4]
 803bb12:	ab03      	add	r3, sp, #12
 803bb14:	9300      	str	r3, [sp, #0]
 803bb16:	aa05      	add	r2, sp, #20
 803bb18:	bf14      	ite	ne
 803bb1a:	2303      	movne	r3, #3
 803bb1c:	2302      	moveq	r3, #2
 803bb1e:	2100      	movs	r1, #0
 803bb20:	f000 f90c 	bl	803bd3c <psa_call>
    *ciphertext_length = out_vec[0].len;
 803bb24:	9b26      	ldr	r3, [sp, #152]	; 0x98
 803bb26:	9a04      	ldr	r2, [sp, #16]
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 803bb28:	4604      	mov	r4, r0
    *ciphertext_length = out_vec[0].len;
 803bb2a:	601a      	str	r2, [r3, #0]
    PSA_CLOSE();
 803bb2c:	4628      	mov	r0, r5
 803bb2e:	f000 f919 	bl	803bd64 <psa_close>
    return status;
 803bb32:	e7c3      	b.n	803babc <psa_aead_encrypt+0x34>

0803bb34 <psa_aead_decrypt>:
                              const uint8_t *ciphertext,
                              size_t ciphertext_length,
                              uint8_t *plaintext,
                              size_t plaintext_size,
                              size_t *plaintext_length)
{
 803bb34:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 803bb38:	b099      	sub	sp, #100	; 0x64
 803bb3a:	4681      	mov	r9, r0
 803bb3c:	e9dd 4720 	ldrd	r4, r7, [sp, #128]	; 0x80
 803bb40:	4688      	mov	r8, r1
 803bb42:	4616      	mov	r6, r2
#if (TFM_CRYPTO_AEAD_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803bb44:	2100      	movs	r1, #0
 803bb46:	222a      	movs	r2, #42	; 0x2a
 803bb48:	f10d 0032 	add.w	r0, sp, #50	; 0x32
{
 803bb4c:	461d      	mov	r5, r3
    struct tfm_crypto_pack_iovec iov = {
 803bb4e:	f000 fdc3 	bl	803c6d8 <memset>
 803bb52:	231e      	movs	r3, #30
 803bb54:	f8ad 9030 	strh.w	r9, [sp, #48]	; 0x30
 803bb58:	930b      	str	r3, [sp, #44]	; 0x2c
 803bb5a:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 803bb5e:	9517      	str	r5, [sp, #92]	; 0x5c
        .alg = alg,
        .aead_in = {.nonce = {0}, .nonce_length = nonce_length}
    };

    /* Sanitize the optional input */
    if ((additional_data == NULL) && (additional_data_length != 0)) {
 803bb60:	b934      	cbnz	r4, 803bb70 <psa_aead_decrypt+0x3c>
 803bb62:	b12f      	cbz	r7, 803bb70 <psa_aead_decrypt+0x3c>
        return PSA_ERROR_INVALID_ARGUMENT;
 803bb64:	f06f 0486 	mvn.w	r4, #134	; 0x86

    PSA_CLOSE();

    return status;
#endif /* TFM_CRYPTO_AEAD_MODULE_DISABLED */
}
 803bb68:	4620      	mov	r0, r4
 803bb6a:	b019      	add	sp, #100	; 0x64
 803bb6c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    psa_invec in_vec[] = {
 803bb70:	2234      	movs	r2, #52	; 0x34
 803bb72:	9206      	str	r2, [sp, #24]
 803bb74:	9a22      	ldr	r2, [sp, #136]	; 0x88
 803bb76:	ab0b      	add	r3, sp, #44	; 0x2c
 803bb78:	9207      	str	r2, [sp, #28]
 803bb7a:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
 803bb7c:	2d10      	cmp	r5, #16
    psa_invec in_vec[] = {
 803bb7e:	e9cd 2408 	strd	r2, r4, [sp, #32]
    psa_outvec out_vec[] = {
 803bb82:	9a24      	ldr	r2, [sp, #144]	; 0x90
    psa_invec in_vec[] = {
 803bb84:	9305      	str	r3, [sp, #20]
    psa_outvec out_vec[] = {
 803bb86:	9203      	str	r2, [sp, #12]
 803bb88:	9a25      	ldr	r2, [sp, #148]	; 0x94
    psa_invec in_vec[] = {
 803bb8a:	970a      	str	r7, [sp, #40]	; 0x28
    psa_outvec out_vec[] = {
 803bb8c:	9204      	str	r2, [sp, #16]
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
 803bb8e:	d8e9      	bhi.n	803bb64 <psa_aead_decrypt+0x30>
    if (nonce != NULL) {
 803bb90:	b986      	cbnz	r6, 803bbb4 <psa_aead_decrypt+0x80>
    PSA_CONNECT(TFM_CRYPTO);
 803bb92:	2101      	movs	r1, #1
 803bb94:	2080      	movs	r0, #128	; 0x80
 803bb96:	f000 f8c3 	bl	803bd20 <psa_connect>
 803bb9a:	1e05      	subs	r5, r0, #0
 803bb9c:	dc0c      	bgt.n	803bbb8 <psa_aead_decrypt+0x84>
 803bb9e:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803bba2:	e7e1      	b.n	803bb68 <psa_aead_decrypt+0x34>
            iov.aead_in.nonce[idx] = nonce[idx];
 803bba4:	5cb0      	ldrb	r0, [r6, r2]
 803bba6:	1899      	adds	r1, r3, r2
 803bba8:	f881 0020 	strb.w	r0, [r1, #32]
        for (idx = 0; idx < nonce_length; idx++) {
 803bbac:	3201      	adds	r2, #1
 803bbae:	42aa      	cmp	r2, r5
 803bbb0:	d1f8      	bne.n	803bba4 <psa_aead_decrypt+0x70>
 803bbb2:	e7ee      	b.n	803bb92 <psa_aead_decrypt+0x5e>
 803bbb4:	2200      	movs	r2, #0
 803bbb6:	e7fa      	b.n	803bbae <psa_aead_decrypt+0x7a>
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 803bbb8:	2301      	movs	r3, #1
        in_len--;
 803bbba:	2c00      	cmp	r4, #0
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 803bbbc:	9301      	str	r3, [sp, #4]
 803bbbe:	ab03      	add	r3, sp, #12
 803bbc0:	9300      	str	r3, [sp, #0]
 803bbc2:	aa05      	add	r2, sp, #20
 803bbc4:	bf14      	ite	ne
 803bbc6:	2303      	movne	r3, #3
 803bbc8:	2302      	moveq	r3, #2
 803bbca:	2100      	movs	r1, #0
 803bbcc:	f000 f8b6 	bl	803bd3c <psa_call>
    *plaintext_length = out_vec[0].len;
 803bbd0:	9b26      	ldr	r3, [sp, #152]	; 0x98
 803bbd2:	9a04      	ldr	r2, [sp, #16]
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 803bbd4:	4604      	mov	r4, r0
    *plaintext_length = out_vec[0].len;
 803bbd6:	601a      	str	r2, [r3, #0]
    PSA_CLOSE();
 803bbd8:	4628      	mov	r0, r5
 803bbda:	f000 f8c3 	bl	803bd64 <psa_close>
    return status;
 803bbde:	e7c3      	b.n	803bb68 <psa_aead_decrypt+0x34>

0803bbe0 <psa_initial_attest_get_token>:
enum psa_attest_err_t
psa_initial_attest_get_token(const uint8_t *challenge_obj,
                             uint32_t       challenge_size,
                             uint8_t       *token,
                             uint32_t      *token_size)
{
 803bbe0:	b570      	push	{r4, r5, r6, lr}
 803bbe2:	461d      	mov	r5, r3
 803bbe4:	b086      	sub	sp, #24
    psa_status_t status;

    psa_invec in_vec[] = {
        {challenge_obj, challenge_size}
    };
    psa_outvec out_vec[] = {
 803bbe6:	681b      	ldr	r3, [r3, #0]
    psa_invec in_vec[] = {
 803bbe8:	e9cd 0102 	strd	r0, r1, [sp, #8]
        {token, *token_size}
    };

    handle = psa_connect(TFM_ATTEST_GET_TOKEN_SID,
 803bbec:	2101      	movs	r1, #1
 803bbee:	2020      	movs	r0, #32
    psa_outvec out_vec[] = {
 803bbf0:	9204      	str	r2, [sp, #16]
 803bbf2:	9305      	str	r3, [sp, #20]
    handle = psa_connect(TFM_ATTEST_GET_TOKEN_SID,
 803bbf4:	f000 f894 	bl	803bd20 <psa_connect>
                         TFM_ATTEST_GET_TOKEN_VERSION);
    if (handle <= 0) {
 803bbf8:	1e06      	subs	r6, r0, #0
 803bbfa:	dc02      	bgt.n	803bc02 <psa_initial_attest_get_token+0x22>
        return PSA_ATTEST_ERR_GENERAL;
 803bbfc:	2005      	movs	r0, #5
    if (status == PSA_SUCCESS) {
        *token_size = out_vec[0].len;
    }

    return (enum psa_attest_err_t)status;
}
 803bbfe:	b006      	add	sp, #24
 803bc00:	bd70      	pop	{r4, r5, r6, pc}
    status = psa_call(handle, PSA_IPC_CALL,
 803bc02:	2301      	movs	r3, #1
 803bc04:	aa04      	add	r2, sp, #16
 803bc06:	9301      	str	r3, [sp, #4]
 803bc08:	9200      	str	r2, [sp, #0]
 803bc0a:	2100      	movs	r1, #0
 803bc0c:	aa02      	add	r2, sp, #8
 803bc0e:	f000 f895 	bl	803bd3c <psa_call>
 803bc12:	4604      	mov	r4, r0
    psa_close(handle);
 803bc14:	4630      	mov	r0, r6
 803bc16:	f000 f8a5 	bl	803bd64 <psa_close>
    if (status < PSA_SUCCESS) {
 803bc1a:	2c00      	cmp	r4, #0
 803bc1c:	dbee      	blt.n	803bbfc <psa_initial_attest_get_token+0x1c>
        *token_size = out_vec[0].len;
 803bc1e:	bf08      	it	eq
 803bc20:	9b05      	ldreq	r3, [sp, #20]
    return (enum psa_attest_err_t)status;
 803bc22:	4620      	mov	r0, r4
        *token_size = out_vec[0].len;
 803bc24:	bf08      	it	eq
 803bc26:	602b      	streq	r3, [r5, #0]
    return (enum psa_attest_err_t)status;
 803bc28:	e7e9      	b.n	803bbfe <psa_initial_attest_get_token+0x1e>

0803bc2a <psa_its_set>:

psa_status_t psa_its_set(psa_storage_uid_t uid,
                         size_t data_length,
                         const void *p_data,
                         psa_storage_create_flags_t create_flags)
{
 803bc2a:	b530      	push	{r4, r5, lr}
 803bc2c:	b08b      	sub	sp, #44	; 0x2c
 803bc2e:	ac0a      	add	r4, sp, #40	; 0x28
 803bc30:	e964 0108 	strd	r0, r1, [r4, #-32]!
    psa_status_t status;
    psa_handle_t handle;

    psa_invec in_vec[] = {
 803bc34:	2108      	movs	r1, #8
 803bc36:	e9cd 1305 	strd	r1, r3, [sp, #20]
 803bc3a:	ab0e      	add	r3, sp, #56	; 0x38
 803bc3c:	9308      	str	r3, [sp, #32]
 803bc3e:	2304      	movs	r3, #4
        { .base = &uid, .len = sizeof(uid) },
        { .base = p_data, .len = data_length },
        { .base = &create_flags, .len = sizeof(create_flags) }
    };

    handle = psa_connect(TFM_ITS_SET_SID, TFM_ITS_SET_VERSION);
 803bc40:	2101      	movs	r1, #1
 803bc42:	2070      	movs	r0, #112	; 0x70
    psa_invec in_vec[] = {
 803bc44:	9404      	str	r4, [sp, #16]
 803bc46:	9207      	str	r2, [sp, #28]
 803bc48:	9309      	str	r3, [sp, #36]	; 0x24
    handle = psa_connect(TFM_ITS_SET_SID, TFM_ITS_SET_VERSION);
 803bc4a:	f000 f869 	bl	803bd20 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 803bc4e:	1e05      	subs	r5, r0, #0
 803bc50:	dd11      	ble.n	803bc76 <psa_its_set+0x4c>
        return PSA_ERROR_GENERIC_ERROR;
    }

    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), NULL, 0);
 803bc52:	2100      	movs	r1, #0
 803bc54:	2303      	movs	r3, #3
 803bc56:	e9cd 1100 	strd	r1, r1, [sp]
 803bc5a:	aa04      	add	r2, sp, #16
 803bc5c:	f000 f86e 	bl	803bd3c <psa_call>
 803bc60:	4604      	mov	r4, r0

    psa_close(handle);
 803bc62:	4628      	mov	r0, r5
 803bc64:	f000 f87e 	bl	803bd64 <psa_close>

    if (status == (psa_status_t)TFM_ERROR_INVALID_PARAMETER) {
        return PSA_ERROR_INVALID_ARGUMENT;
 803bc68:	2c03      	cmp	r4, #3
 803bc6a:	bf08      	it	eq
 803bc6c:	f06f 0486 	mvneq.w	r4, #134	; 0x86
    }

    return status;
}
 803bc70:	4620      	mov	r0, r4
 803bc72:	b00b      	add	sp, #44	; 0x2c
 803bc74:	bd30      	pop	{r4, r5, pc}
        return PSA_ERROR_GENERIC_ERROR;
 803bc76:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803bc7a:	e7f9      	b.n	803bc70 <psa_its_set+0x46>

0803bc7c <psa_its_get>:
psa_status_t psa_its_get(psa_storage_uid_t uid,
                         size_t data_offset,
                         size_t data_size,
                         void *p_data,
                         size_t *p_data_length)
{
 803bc7c:	b570      	push	{r4, r5, r6, lr}
 803bc7e:	b08c      	sub	sp, #48	; 0x30
 803bc80:	9203      	str	r2, [sp, #12]
    psa_status_t status;
    psa_handle_t handle;

    psa_invec in_vec[] = {
 803bc82:	aa04      	add	r2, sp, #16
 803bc84:	9208      	str	r2, [sp, #32]
 803bc86:	2208      	movs	r2, #8
 803bc88:	9209      	str	r2, [sp, #36]	; 0x24
 803bc8a:	aa03      	add	r2, sp, #12
 803bc8c:	920a      	str	r2, [sp, #40]	; 0x28
 803bc8e:	2204      	movs	r2, #4
{
 803bc90:	9d11      	ldr	r5, [sp, #68]	; 0x44
    psa_invec in_vec[] = {
 803bc92:	920b      	str	r2, [sp, #44]	; 0x2c
        { .base = &uid, .len = sizeof(uid) },
        { .base = &data_offset, .len = sizeof(data_offset) }
    };

    psa_outvec out_vec[] = {
 803bc94:	9a10      	ldr	r2, [sp, #64]	; 0x40
{
 803bc96:	e9cd 0104 	strd	r0, r1, [sp, #16]
    psa_outvec out_vec[] = {
 803bc9a:	e9cd 2306 	strd	r2, r3, [sp, #24]
        { .base = p_data, .len = data_size }
    };

    if (p_data_length == NULL) {
 803bc9e:	b925      	cbnz	r5, 803bcaa <psa_its_get+0x2e>
        return PSA_ERROR_INVALID_ARGUMENT;
 803bca0:	f06f 0486 	mvn.w	r4, #134	; 0x86
    }

    *p_data_length = out_vec[0].len;

    return status;
}
 803bca4:	4620      	mov	r0, r4
 803bca6:	b00c      	add	sp, #48	; 0x30
 803bca8:	bd70      	pop	{r4, r5, r6, pc}
    handle = psa_connect(TFM_ITS_GET_SID, TFM_ITS_GET_VERSION);
 803bcaa:	2101      	movs	r1, #1
 803bcac:	2071      	movs	r0, #113	; 0x71
 803bcae:	f000 f837 	bl	803bd20 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 803bcb2:	1e06      	subs	r6, r0, #0
 803bcb4:	dd11      	ble.n	803bcda <psa_its_get+0x5e>
    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
 803bcb6:	2301      	movs	r3, #1
 803bcb8:	9301      	str	r3, [sp, #4]
 803bcba:	ab06      	add	r3, sp, #24
 803bcbc:	9300      	str	r3, [sp, #0]
 803bcbe:	aa08      	add	r2, sp, #32
 803bcc0:	2302      	movs	r3, #2
 803bcc2:	2100      	movs	r1, #0
 803bcc4:	f000 f83a 	bl	803bd3c <psa_call>
 803bcc8:	4604      	mov	r4, r0
    psa_close(handle);
 803bcca:	4630      	mov	r0, r6
 803bccc:	f000 f84a 	bl	803bd64 <psa_close>
    if (status == (psa_status_t)TFM_ERROR_INVALID_PARAMETER) {
 803bcd0:	2c03      	cmp	r4, #3
 803bcd2:	d0e5      	beq.n	803bca0 <psa_its_get+0x24>
    *p_data_length = out_vec[0].len;
 803bcd4:	9b07      	ldr	r3, [sp, #28]
 803bcd6:	602b      	str	r3, [r5, #0]
    return status;
 803bcd8:	e7e4      	b.n	803bca4 <psa_its_get+0x28>
        return PSA_ERROR_GENERIC_ERROR;
 803bcda:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803bcde:	e7e1      	b.n	803bca4 <psa_its_get+0x28>

0803bce0 <psa_its_remove>:

    return status;
}

psa_status_t psa_its_remove(psa_storage_uid_t uid)
{
 803bce0:	b530      	push	{r4, r5, lr}
 803bce2:	b087      	sub	sp, #28
 803bce4:	ab06      	add	r3, sp, #24
 803bce6:	e963 0104 	strd	r0, r1, [r3, #-16]!
    psa_status_t status;
    psa_handle_t handle;

    psa_invec in_vec[] = {
 803bcea:	9304      	str	r3, [sp, #16]
 803bcec:	2308      	movs	r3, #8
        { .base = &uid, .len = sizeof(uid) }
    };

    handle = psa_connect(TFM_ITS_REMOVE_SID, TFM_ITS_REMOVE_VERSION);
 803bcee:	2101      	movs	r1, #1
 803bcf0:	2073      	movs	r0, #115	; 0x73
    psa_invec in_vec[] = {
 803bcf2:	9305      	str	r3, [sp, #20]
    handle = psa_connect(TFM_ITS_REMOVE_SID, TFM_ITS_REMOVE_VERSION);
 803bcf4:	f000 f814 	bl	803bd20 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 803bcf8:	1e05      	subs	r5, r0, #0
 803bcfa:	dd0d      	ble.n	803bd18 <psa_its_remove+0x38>
        return PSA_ERROR_GENERIC_ERROR;
    }

    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), NULL, 0);
 803bcfc:	2100      	movs	r1, #0
 803bcfe:	2301      	movs	r3, #1
 803bd00:	e9cd 1100 	strd	r1, r1, [sp]
 803bd04:	aa04      	add	r2, sp, #16
 803bd06:	f000 f819 	bl	803bd3c <psa_call>
 803bd0a:	4604      	mov	r4, r0

    psa_close(handle);
 803bd0c:	4628      	mov	r0, r5
 803bd0e:	f000 f829 	bl	803bd64 <psa_close>

    return status;
}
 803bd12:	4620      	mov	r0, r4
 803bd14:	b007      	add	sp, #28
 803bd16:	bd30      	pop	{r4, r5, pc}
        return PSA_ERROR_GENERIC_ERROR;
 803bd18:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803bd1c:	e7f9      	b.n	803bd12 <psa_its_remove+0x32>
	...

0803bd20 <psa_connect>:
                                0);
}

psa_handle_t psa_connect(uint32_t sid, uint32_t version)
{
    return tfm_ns_interface_dispatch(
 803bd20:	2300      	movs	r3, #0
{
 803bd22:	b507      	push	{r0, r1, r2, lr}
    return tfm_ns_interface_dispatch(
 803bd24:	460a      	mov	r2, r1
 803bd26:	9300      	str	r3, [sp, #0]
 803bd28:	4601      	mov	r1, r0
 803bd2a:	4803      	ldr	r0, [pc, #12]	; (803bd38 <psa_connect+0x18>)
 803bd2c:	f7fd ff36 	bl	8039b9c <tfm_ns_interface_dispatch>
                                (veneer_fn)tfm_psa_connect_veneer,
                                sid,
                                version,
                                0,
                                0);
}
 803bd30:	b003      	add	sp, #12
 803bd32:	f85d fb04 	ldr.w	pc, [sp], #4
 803bd36:	bf00      	nop
 803bd38:	0c035cb1 	.word	0x0c035cb1

0803bd3c <psa_call>:
psa_status_t psa_call(psa_handle_t handle, int32_t type,
                      const psa_invec *in_vec,
                      size_t in_len,
                      psa_outvec *out_vec,
                      size_t out_len)
{
 803bd3c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
     * serialization in order for NS to pass arguments to S
     */
    psa_invec in_vecs, out_vecs;

    in_vecs.base = in_vec;
    in_vecs.len = in_len;
 803bd3e:	e9cd 2302 	strd	r2, r3, [sp, #8]
    out_vecs.base = out_vec;
 803bd42:	9b08      	ldr	r3, [sp, #32]
    out_vecs.len = out_len;
    return tfm_ns_interface_dispatch(
 803bd44:	460a      	mov	r2, r1
    out_vecs.base = out_vec;
 803bd46:	9304      	str	r3, [sp, #16]
    out_vecs.len = out_len;
 803bd48:	9b09      	ldr	r3, [sp, #36]	; 0x24
    return tfm_ns_interface_dispatch(
 803bd4a:	4601      	mov	r1, r0
    out_vecs.len = out_len;
 803bd4c:	9305      	str	r3, [sp, #20]
    return tfm_ns_interface_dispatch(
 803bd4e:	ab04      	add	r3, sp, #16
 803bd50:	9300      	str	r3, [sp, #0]
 803bd52:	4803      	ldr	r0, [pc, #12]	; (803bd60 <psa_call+0x24>)
 803bd54:	ab02      	add	r3, sp, #8
 803bd56:	f7fd ff21 	bl	8039b9c <tfm_ns_interface_dispatch>
                                (veneer_fn)tfm_psa_call_veneer,
                                (uint32_t)handle,
                                (uint32_t)type,
                                (uint32_t)&in_vecs,
                                (uint32_t)&out_vecs);
}
 803bd5a:	b007      	add	sp, #28
 803bd5c:	f85d fb04 	ldr.w	pc, [sp], #4
 803bd60:	0c035cc9 	.word	0x0c035cc9

0803bd64 <psa_close>:

void psa_close(psa_handle_t handle)
{
    (void)tfm_ns_interface_dispatch(
 803bd64:	2300      	movs	r3, #0
{
 803bd66:	b507      	push	{r0, r1, r2, lr}
    (void)tfm_ns_interface_dispatch(
 803bd68:	4601      	mov	r1, r0
 803bd6a:	9300      	str	r3, [sp, #0]
 803bd6c:	461a      	mov	r2, r3
 803bd6e:	4803      	ldr	r0, [pc, #12]	; (803bd7c <psa_close+0x18>)
 803bd70:	f7fd ff14 	bl	8039b9c <tfm_ns_interface_dispatch>
                         (veneer_fn)tfm_psa_close_veneer,
                         (uint32_t)handle,
                         0,
                         0,
                         0);
}
 803bd74:	b003      	add	sp, #12
 803bd76:	f85d fb04 	ldr.w	pc, [sp], #4
 803bd7a:	bf00      	nop
 803bd7c:	0c035ca1 	.word	0x0c035ca1

0803bd80 <psa_ps_set>:

psa_ps_status_t psa_ps_set(psa_ps_uid_t uid,
                           uint32_t data_length,
                           const void *p_data,
                           psa_ps_create_flags_t create_flags)
{
 803bd80:	b530      	push	{r4, r5, lr}
 803bd82:	b08f      	sub	sp, #60	; 0x3c
 803bd84:	ac0e      	add	r4, sp, #56	; 0x38
 803bd86:	e964 010c 	strd	r0, r1, [r4, #-48]!	; 0x30
    psa_status_t status;
    psa_ps_status_t err;
    psa_handle_t handle;

    psa_invec in_vec[] = {
 803bd8a:	2108      	movs	r1, #8
 803bd8c:	e9cd 1309 	strd	r1, r3, [sp, #36]	; 0x24
 803bd90:	ab12      	add	r3, sp, #72	; 0x48
 803bd92:	930c      	str	r3, [sp, #48]	; 0x30
 803bd94:	2304      	movs	r3, #4
 803bd96:	920b      	str	r2, [sp, #44]	; 0x2c

    psa_outvec out_vec[] = {
        { .base = &err , .len = sizeof(err) }
    };

    handle = psa_connect(TFM_SST_SET_SID, TFM_SST_SET_VERSION);
 803bd98:	2101      	movs	r1, #1
    psa_outvec out_vec[] = {
 803bd9a:	aa05      	add	r2, sp, #20
    handle = psa_connect(TFM_SST_SET_SID, TFM_SST_SET_VERSION);
 803bd9c:	2060      	movs	r0, #96	; 0x60
    psa_invec in_vec[] = {
 803bd9e:	9408      	str	r4, [sp, #32]
 803bda0:	930d      	str	r3, [sp, #52]	; 0x34
    psa_outvec out_vec[] = {
 803bda2:	e9cd 2306 	strd	r2, r3, [sp, #24]
    handle = psa_connect(TFM_SST_SET_SID, TFM_SST_SET_VERSION);
 803bda6:	f7ff ffbb 	bl	803bd20 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 803bdaa:	1e05      	subs	r5, r0, #0
 803bdac:	dc02      	bgt.n	803bdb4 <psa_ps_set+0x34>
        return PSA_PS_ERROR_OPERATION_FAILED;
 803bdae:	200b      	movs	r0, #11
    if (status != PSA_SUCCESS) {
        return PSA_PS_ERROR_OPERATION_FAILED;
    }

    return err;
}
 803bdb0:	b00f      	add	sp, #60	; 0x3c
 803bdb2:	bd30      	pop	{r4, r5, pc}
    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
 803bdb4:	2301      	movs	r3, #1
 803bdb6:	9301      	str	r3, [sp, #4]
 803bdb8:	ab06      	add	r3, sp, #24
 803bdba:	9300      	str	r3, [sp, #0]
 803bdbc:	aa08      	add	r2, sp, #32
 803bdbe:	2303      	movs	r3, #3
 803bdc0:	2100      	movs	r1, #0
 803bdc2:	f7ff ffbb 	bl	803bd3c <psa_call>
 803bdc6:	4604      	mov	r4, r0
    psa_close(handle);
 803bdc8:	4628      	mov	r0, r5
 803bdca:	f7ff ffcb 	bl	803bd64 <psa_close>
    if (status != PSA_SUCCESS) {
 803bdce:	2c00      	cmp	r4, #0
 803bdd0:	d1ed      	bne.n	803bdae <psa_ps_set+0x2e>
    return err;
 803bdd2:	9805      	ldr	r0, [sp, #20]
 803bdd4:	e7ec      	b.n	803bdb0 <psa_ps_set+0x30>

0803bdd6 <psa_ps_get>:

psa_ps_status_t psa_ps_get(psa_ps_uid_t uid,
                           uint32_t data_offset,
                           uint32_t data_length,
                           void *p_data)
{
 803bdd6:	b530      	push	{r4, r5, lr}
 803bdd8:	b091      	sub	sp, #68	; 0x44
 803bdda:	9203      	str	r2, [sp, #12]
    psa_status_t status;
    psa_ps_status_t err;
    psa_handle_t handle;

    psa_invec in_vec[] = {
 803bddc:	aa04      	add	r2, sp, #16
 803bdde:	9208      	str	r2, [sp, #32]
 803bde0:	2208      	movs	r2, #8
 803bde2:	9209      	str	r2, [sp, #36]	; 0x24
 803bde4:	aa03      	add	r2, sp, #12
 803bde6:	920a      	str	r2, [sp, #40]	; 0x28
 803bde8:	2204      	movs	r2, #4
{
 803bdea:	e9cd 0104 	strd	r0, r1, [sp, #16]
        { .base = &uid, .len = sizeof(uid) },
        { .base = &data_offset, .len = sizeof(data_offset) }
    };

    psa_outvec out_vec[] = {
 803bdee:	a907      	add	r1, sp, #28
 803bdf0:	e9cd 120c 	strd	r1, r2, [sp, #48]	; 0x30
    psa_invec in_vec[] = {
 803bdf4:	920b      	str	r2, [sp, #44]	; 0x2c
    psa_outvec out_vec[] = {
 803bdf6:	9a14      	ldr	r2, [sp, #80]	; 0x50
        { .base = &err,   .len = sizeof(err) },
        { .base = p_data, .len = data_length }
    };

    handle = psa_connect(TFM_SST_GET_SID, TFM_SST_GET_VERSION);
 803bdf8:	2101      	movs	r1, #1
 803bdfa:	2061      	movs	r0, #97	; 0x61
    psa_outvec out_vec[] = {
 803bdfc:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
    handle = psa_connect(TFM_SST_GET_SID, TFM_SST_GET_VERSION);
 803be00:	f7ff ff8e 	bl	803bd20 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 803be04:	1e05      	subs	r5, r0, #0
 803be06:	dc02      	bgt.n	803be0e <psa_ps_get+0x38>
        return PSA_PS_ERROR_OPERATION_FAILED;
 803be08:	200b      	movs	r0, #11
    if (status != PSA_SUCCESS) {
        return PSA_PS_ERROR_OPERATION_FAILED;
    }

    return err;
}
 803be0a:	b011      	add	sp, #68	; 0x44
 803be0c:	bd30      	pop	{r4, r5, pc}
    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
 803be0e:	2302      	movs	r3, #2
 803be10:	aa0c      	add	r2, sp, #48	; 0x30
 803be12:	9200      	str	r2, [sp, #0]
 803be14:	9301      	str	r3, [sp, #4]
 803be16:	aa08      	add	r2, sp, #32
 803be18:	2100      	movs	r1, #0
 803be1a:	f7ff ff8f 	bl	803bd3c <psa_call>
 803be1e:	4604      	mov	r4, r0
    psa_close(handle);
 803be20:	4628      	mov	r0, r5
 803be22:	f7ff ff9f 	bl	803bd64 <psa_close>
    if (status != PSA_SUCCESS) {
 803be26:	2c00      	cmp	r4, #0
 803be28:	d1ee      	bne.n	803be08 <psa_ps_get+0x32>
    return err;
 803be2a:	9807      	ldr	r0, [sp, #28]
 803be2c:	e7ed      	b.n	803be0a <psa_ps_get+0x34>

0803be2e <psa_ps_remove>:

    return err;
}

psa_ps_status_t psa_ps_remove(psa_ps_uid_t uid)
{
 803be2e:	b530      	push	{r4, r5, lr}
 803be30:	b08b      	sub	sp, #44	; 0x2c
 803be32:	ab0a      	add	r3, sp, #40	; 0x28
 803be34:	e963 0108 	strd	r0, r1, [r3, #-32]!
    psa_status_t status;
    psa_ps_status_t err;
    psa_handle_t handle;

    psa_invec in_vec[] = {
 803be38:	9306      	str	r3, [sp, #24]
 803be3a:	2308      	movs	r3, #8
 803be3c:	9307      	str	r3, [sp, #28]
        { .base = &uid, .len = sizeof(uid) }
    };

    psa_outvec out_vec[] = {
 803be3e:	ab05      	add	r3, sp, #20
 803be40:	9308      	str	r3, [sp, #32]
 803be42:	2304      	movs	r3, #4
        { .base = &err, .len = sizeof(err) }
    };

    handle = psa_connect(TFM_SST_REMOVE_SID, TFM_SST_REMOVE_VERSION);
 803be44:	2101      	movs	r1, #1
 803be46:	2063      	movs	r0, #99	; 0x63
    psa_outvec out_vec[] = {
 803be48:	9309      	str	r3, [sp, #36]	; 0x24
    handle = psa_connect(TFM_SST_REMOVE_SID, TFM_SST_REMOVE_VERSION);
 803be4a:	f7ff ff69 	bl	803bd20 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 803be4e:	1e05      	subs	r5, r0, #0
 803be50:	dc02      	bgt.n	803be58 <psa_ps_remove+0x2a>
        return PSA_PS_ERROR_OPERATION_FAILED;
 803be52:	200b      	movs	r0, #11
    if (status != PSA_SUCCESS) {
        return PSA_PS_ERROR_OPERATION_FAILED;
    }

    return err;
}
 803be54:	b00b      	add	sp, #44	; 0x2c
 803be56:	bd30      	pop	{r4, r5, pc}
    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
 803be58:	2301      	movs	r3, #1
 803be5a:	aa08      	add	r2, sp, #32
 803be5c:	9200      	str	r2, [sp, #0]
 803be5e:	9301      	str	r3, [sp, #4]
 803be60:	aa06      	add	r2, sp, #24
 803be62:	2100      	movs	r1, #0
 803be64:	f7ff ff6a 	bl	803bd3c <psa_call>
 803be68:	4604      	mov	r4, r0
    psa_close(handle);
 803be6a:	4628      	mov	r0, r5
 803be6c:	f7ff ff7a 	bl	803bd64 <psa_close>
    if (status != PSA_SUCCESS) {
 803be70:	2c00      	cmp	r4, #0
 803be72:	d1ee      	bne.n	803be52 <psa_ps_remove+0x24>
    return err;
 803be74:	9805      	ldr	r0, [sp, #20]
 803be76:	e7ed      	b.n	803be54 <psa_ps_remove+0x26>

0803be78 <psa_cipher_test>:
}

void psa_cipher_test(const psa_key_type_t key_type,
                     const psa_algorithm_t alg,
                     struct test_result_t *ret)
{
 803be78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    psa_cipher_operation_t handle = psa_cipher_operation_init();
 803be7c:	2300      	movs	r3, #0
{
 803be7e:	b0ab      	sub	sp, #172	; 0xac
 803be80:	4614      	mov	r4, r2
    psa_cipher_operation_t handle_dec = psa_cipher_operation_init();
    psa_status_t status = PSA_SUCCESS;
    psa_key_handle_t key_handle;
    const uint8_t data[] = "THIS IS MY KEY1";
 803be82:	aa0e      	add	r2, sp, #56	; 0x38
{
 803be84:	4606      	mov	r6, r0
 803be86:	460f      	mov	r7, r1
 803be88:	4693      	mov	fp, r2
    psa_cipher_operation_t handle_dec = psa_cipher_operation_init();
 803be8a:	e9cd 3306 	strd	r3, r3, [sp, #24]
    const uint8_t data[] = "THIS IS MY KEY1";
 803be8e:	4b91      	ldr	r3, [pc, #580]	; (803c0d4 <psa_cipher_test+0x25c>)
 803be90:	f103 0c10 	add.w	ip, r3, #16
 803be94:	4615      	mov	r5, r2
 803be96:	6818      	ldr	r0, [r3, #0]
 803be98:	6859      	ldr	r1, [r3, #4]
 803be9a:	3308      	adds	r3, #8
 803be9c:	c503      	stmia	r5!, {r0, r1}
 803be9e:	4563      	cmp	r3, ip
 803bea0:	462a      	mov	r2, r5
 803bea2:	d1f7      	bne.n	803be94 <psa_cipher_test+0x1c>
    psa_key_type_t type = PSA_KEY_TYPE_NONE;
 803bea4:	2300      	movs	r3, #0
    size_t bits = 0;
 803bea6:	e9cd 3308 	strd	r3, r3, [sp, #32]
    const size_t iv_length = PSA_BLOCK_CIPHER_BLOCK_SIZE(key_type);
 803beaa:	4b8b      	ldr	r3, [pc, #556]	; (803c0d8 <psa_cipher_test+0x260>)
 803beac:	429e      	cmp	r6, r3
 803beae:	d049      	beq.n	803bf44 <psa_cipher_test+0xcc>
 803beb0:	3301      	adds	r3, #1
 803beb2:	429e      	cmp	r6, r3
 803beb4:	d044      	beq.n	803bf40 <psa_cipher_test+0xc8>
 803beb6:	3301      	adds	r3, #1
 803beb8:	429e      	cmp	r6, r3
 803beba:	d043      	beq.n	803bf44 <psa_cipher_test+0xcc>
 803bebc:	4d87      	ldr	r5, [pc, #540]	; (803c0dc <psa_cipher_test+0x264>)
 803bebe:	1b73      	subs	r3, r6, r5
 803bec0:	425d      	negs	r5, r3
 803bec2:	415d      	adcs	r5, r3
    const uint8_t iv[] = "012345678901234";
 803bec4:	aa12      	add	r2, sp, #72	; 0x48
 803bec6:	4692      	mov	sl, r2
 803bec8:	4b85      	ldr	r3, [pc, #532]	; (803c0e0 <psa_cipher_test+0x268>)
 803beca:	f103 0e10 	add.w	lr, r3, #16
 803bece:	4694      	mov	ip, r2
 803bed0:	6818      	ldr	r0, [r3, #0]
 803bed2:	6859      	ldr	r1, [r3, #4]
 803bed4:	3308      	adds	r3, #8
 803bed6:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 803beda:	4573      	cmp	r3, lr
 803bedc:	4662      	mov	r2, ip
 803bede:	d1f6      	bne.n	803bece <psa_cipher_test+0x56>
    const uint8_t plain_text[BYTE_SIZE_CHUNK] = "Sixteen bytes!!";
 803bee0:	aa16      	add	r2, sp, #88	; 0x58
 803bee2:	4691      	mov	r9, r2
 803bee4:	4b7f      	ldr	r3, [pc, #508]	; (803c0e4 <psa_cipher_test+0x26c>)
 803bee6:	f103 0e10 	add.w	lr, r3, #16
 803beea:	4694      	mov	ip, r2
 803beec:	6818      	ldr	r0, [r3, #0]
 803beee:	6859      	ldr	r1, [r3, #4]
 803bef0:	3308      	adds	r3, #8
 803bef2:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 803bef6:	4573      	cmp	r3, lr
 803bef8:	4662      	mov	r2, ip
 803befa:	d1f6      	bne.n	803beea <psa_cipher_test+0x72>
    uint8_t decrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
 803befc:	f04f 0820 	mov.w	r8, #32
 803bf00:	2100      	movs	r1, #0
 803bf02:	4642      	mov	r2, r8
 803bf04:	a81a      	add	r0, sp, #104	; 0x68
 803bf06:	f000 fbe7 	bl	803c6d8 <memset>
    size_t output_length = 0, total_output_length = 0;
 803bf0a:	2300      	movs	r3, #0
    uint8_t encrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
 803bf0c:	4642      	mov	r2, r8
 803bf0e:	4619      	mov	r1, r3
 803bf10:	a822      	add	r0, sp, #136	; 0x88
    size_t output_length = 0, total_output_length = 0;
 803bf12:	930a      	str	r3, [sp, #40]	; 0x28
    uint8_t encrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
 803bf14:	9303      	str	r3, [sp, #12]
 803bf16:	f000 fbdf 	bl	803c6d8 <memset>

#define PSA_KEY_POLICY_INIT {0, 0, 0}
static inline struct psa_key_policy_s psa_key_policy_init( void )
{
    const struct psa_key_policy_s v = PSA_KEY_POLICY_INIT;
    return( v );
 803bf1a:	9b03      	ldr	r3, [sp, #12]
    uint32_t i;

    ret->val = TEST_PASSED;

    /* Allocate a transient key */
    status = psa_allocate_key(&key_handle);
 803bf1c:	f10d 0016 	add.w	r0, sp, #22
    ret->val = TEST_PASSED;
 803bf20:	7023      	strb	r3, [r4, #0]
 803bf22:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
 803bf26:	930d      	str	r3, [sp, #52]	; 0x34
    status = psa_allocate_key(&key_handle);
 803bf28:	f7ff fb1e 	bl	803b568 <psa_allocate_key>
    if (status != PSA_SUCCESS) {
 803bf2c:	b160      	cbz	r0, 803bf48 <psa_cipher_test+0xd0>
        TEST_FAIL("Failed to allocate key");
 803bf2e:	4623      	mov	r3, r4
 803bf30:	2288      	movs	r2, #136	; 0x88
 803bf32:	496d      	ldr	r1, [pc, #436]	; (803c0e8 <psa_cipher_test+0x270>)
 803bf34:	486d      	ldr	r0, [pc, #436]	; (803c0ec <psa_cipher_test+0x274>)

destroy_key:
    /* Destroy the key */
    status = psa_destroy_key(key_handle);
    if (status != PSA_SUCCESS) {
        TEST_FAIL("Error destroying a key");
 803bf36:	f000 fb65 	bl	803c604 <set_test_failed>
    }

}
 803bf3a:	b02b      	add	sp, #172	; 0xac
 803bf3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    const size_t iv_length = PSA_BLOCK_CIPHER_BLOCK_SIZE(key_type);
 803bf40:	2508      	movs	r5, #8
 803bf42:	e7bf      	b.n	803bec4 <psa_cipher_test+0x4c>
 803bf44:	2510      	movs	r5, #16
 803bf46:	e7bd      	b.n	803bec4 <psa_cipher_test+0x4c>
    psa_key_policy_set_usage(&policy, usage, alg);
 803bf48:	f44f 7140 	mov.w	r1, #768	; 0x300
 803bf4c:	a80b      	add	r0, sp, #44	; 0x2c
 803bf4e:	463a      	mov	r2, r7
 803bf50:	f7ff fbb7 	bl	803b6c2 <psa_key_policy_set_usage>
    status = psa_set_key_policy(key_handle, &policy);
 803bf54:	a90b      	add	r1, sp, #44	; 0x2c
 803bf56:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 803bf5a:	f7ff fbb5 	bl	803b6c8 <psa_set_key_policy>
    if (status != PSA_SUCCESS) {
 803bf5e:	b188      	cbz	r0, 803bf84 <psa_cipher_test+0x10c>
        TEST_FAIL("Failed to set key policy");
 803bf60:	4623      	mov	r3, r4
 803bf62:	2290      	movs	r2, #144	; 0x90
 803bf64:	4960      	ldr	r1, [pc, #384]	; (803c0e8 <psa_cipher_test+0x270>)
 803bf66:	4862      	ldr	r0, [pc, #392]	; (803c0f0 <psa_cipher_test+0x278>)
        TEST_FAIL("After finalising, unexpected decrypted length");
 803bf68:	f000 fb4c 	bl	803c604 <set_test_failed>
    status = psa_destroy_key(key_handle);
 803bf6c:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 803bf70:	f7ff fb4e 	bl	803b610 <psa_destroy_key>
    if (status != PSA_SUCCESS) {
 803bf74:	2800      	cmp	r0, #0
 803bf76:	d0e0      	beq.n	803bf3a <psa_cipher_test+0xc2>
        TEST_FAIL("Error destroying a key");
 803bf78:	4623      	mov	r3, r4
 803bf7a:	f240 123f 	movw	r2, #319	; 0x13f
 803bf7e:	495a      	ldr	r1, [pc, #360]	; (803c0e8 <psa_cipher_test+0x270>)
 803bf80:	485c      	ldr	r0, [pc, #368]	; (803c0f4 <psa_cipher_test+0x27c>)
 803bf82:	e7d8      	b.n	803bf36 <psa_cipher_test+0xbe>
    status = psa_import_key(key_handle, key_type, data, sizeof(data));
 803bf84:	2310      	movs	r3, #16
 803bf86:	465a      	mov	r2, fp
 803bf88:	4631      	mov	r1, r6
 803bf8a:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 803bf8e:	f7ff fb12 	bl	803b5b6 <psa_import_key>
    if (status != PSA_SUCCESS) {
 803bf92:	b120      	cbz	r0, 803bf9e <psa_cipher_test+0x126>
        TEST_FAIL("Error importing a key");
 803bf94:	4623      	mov	r3, r4
 803bf96:	2297      	movs	r2, #151	; 0x97
 803bf98:	4953      	ldr	r1, [pc, #332]	; (803c0e8 <psa_cipher_test+0x270>)
 803bf9a:	4857      	ldr	r0, [pc, #348]	; (803c0f8 <psa_cipher_test+0x280>)
 803bf9c:	e7e4      	b.n	803bf68 <psa_cipher_test+0xf0>
    status = psa_get_key_information(key_handle, &type, &bits);
 803bf9e:	aa09      	add	r2, sp, #36	; 0x24
 803bfa0:	a908      	add	r1, sp, #32
 803bfa2:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 803bfa6:	f7ff fb5b 	bl	803b660 <psa_get_key_information>
    if (status != PSA_SUCCESS) {
 803bfaa:	b120      	cbz	r0, 803bfb6 <psa_cipher_test+0x13e>
        TEST_FAIL("Error getting key metadata");
 803bfac:	4623      	mov	r3, r4
 803bfae:	229d      	movs	r2, #157	; 0x9d
 803bfb0:	494d      	ldr	r1, [pc, #308]	; (803c0e8 <psa_cipher_test+0x270>)
 803bfb2:	4852      	ldr	r0, [pc, #328]	; (803c0fc <psa_cipher_test+0x284>)
 803bfb4:	e7d8      	b.n	803bf68 <psa_cipher_test+0xf0>
    if (bits != BIT_SIZE_TEST_KEY) {
 803bfb6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 803bfb8:	2b80      	cmp	r3, #128	; 0x80
 803bfba:	d004      	beq.n	803bfc6 <psa_cipher_test+0x14e>
        TEST_FAIL("The number of key bits is different from expected");
 803bfbc:	4623      	mov	r3, r4
 803bfbe:	22a2      	movs	r2, #162	; 0xa2
 803bfc0:	4949      	ldr	r1, [pc, #292]	; (803c0e8 <psa_cipher_test+0x270>)
 803bfc2:	484f      	ldr	r0, [pc, #316]	; (803c100 <psa_cipher_test+0x288>)
 803bfc4:	e7d0      	b.n	803bf68 <psa_cipher_test+0xf0>
    if (type != key_type) {
 803bfc6:	9b08      	ldr	r3, [sp, #32]
 803bfc8:	42b3      	cmp	r3, r6
 803bfca:	d004      	beq.n	803bfd6 <psa_cipher_test+0x15e>
        TEST_FAIL("The type of the key is different from expected");
 803bfcc:	4623      	mov	r3, r4
 803bfce:	22a7      	movs	r2, #167	; 0xa7
 803bfd0:	4945      	ldr	r1, [pc, #276]	; (803c0e8 <psa_cipher_test+0x270>)
 803bfd2:	484c      	ldr	r0, [pc, #304]	; (803c104 <psa_cipher_test+0x28c>)
 803bfd4:	e7c8      	b.n	803bf68 <psa_cipher_test+0xf0>
    status = psa_cipher_encrypt_setup(&handle, key_handle, alg);
 803bfd6:	463a      	mov	r2, r7
 803bfd8:	f8bd 1016 	ldrh.w	r1, [sp, #22]
 803bfdc:	a806      	add	r0, sp, #24
 803bfde:	f7ff fbcf 	bl	803b780 <psa_cipher_encrypt_setup>
    if (status != PSA_SUCCESS) {
 803bfe2:	b150      	cbz	r0, 803bffa <psa_cipher_test+0x182>
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803bfe4:	3086      	adds	r0, #134	; 0x86
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803bfe6:	4623      	mov	r3, r4
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803bfe8:	d103      	bne.n	803bff2 <psa_cipher_test+0x17a>
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803bfea:	22af      	movs	r2, #175	; 0xaf
 803bfec:	493e      	ldr	r1, [pc, #248]	; (803c0e8 <psa_cipher_test+0x270>)
 803bfee:	4846      	ldr	r0, [pc, #280]	; (803c108 <psa_cipher_test+0x290>)
 803bff0:	e7ba      	b.n	803bf68 <psa_cipher_test+0xf0>
            TEST_FAIL("Error setting up cipher operation object");
 803bff2:	22b1      	movs	r2, #177	; 0xb1
        TEST_FAIL("Error setting up cipher operation object");
 803bff4:	493c      	ldr	r1, [pc, #240]	; (803c0e8 <psa_cipher_test+0x270>)
 803bff6:	4845      	ldr	r0, [pc, #276]	; (803c10c <psa_cipher_test+0x294>)
 803bff8:	e7b6      	b.n	803bf68 <psa_cipher_test+0xf0>
    status = psa_cipher_set_iv(&handle, iv, iv_length);
 803bffa:	462a      	mov	r2, r5
 803bffc:	4651      	mov	r1, sl
 803bffe:	a806      	add	r0, sp, #24
 803c000:	f7ff fb8e 	bl	803b720 <psa_cipher_set_iv>
    if (status != PSA_SUCCESS) {
 803c004:	b178      	cbz	r0, 803c026 <psa_cipher_test+0x1ae>
        TEST_FAIL("Error setting the IV on the cypher operation object");
 803c006:	4842      	ldr	r0, [pc, #264]	; (803c110 <psa_cipher_test+0x298>)
 803c008:	4623      	mov	r3, r4
 803c00a:	22b9      	movs	r2, #185	; 0xb9
 803c00c:	4936      	ldr	r1, [pc, #216]	; (803c0e8 <psa_cipher_test+0x270>)
 803c00e:	f000 faf9 	bl	803c604 <set_test_failed>
        status = psa_cipher_abort(&handle);
 803c012:	a806      	add	r0, sp, #24
 803c014:	f7ff fc4d 	bl	803b8b2 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803c018:	2800      	cmp	r0, #0
 803c01a:	d0a7      	beq.n	803bf6c <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803c01c:	4623      	mov	r3, r4
 803c01e:	22bc      	movs	r2, #188	; 0xbc
            TEST_FAIL("Error aborting the operation");
 803c020:	4931      	ldr	r1, [pc, #196]	; (803c0e8 <psa_cipher_test+0x270>)
 803c022:	483c      	ldr	r0, [pc, #240]	; (803c114 <psa_cipher_test+0x29c>)
 803c024:	e7a0      	b.n	803bf68 <psa_cipher_test+0xf0>
    status = psa_cipher_update(&handle, plain_text, BYTE_SIZE_CHUNK,
 803c026:	ae0a      	add	r6, sp, #40	; 0x28
 803c028:	e9cd 8600 	strd	r8, r6, [sp]
 803c02c:	ab22      	add	r3, sp, #136	; 0x88
 803c02e:	2210      	movs	r2, #16
 803c030:	4649      	mov	r1, r9
 803c032:	a806      	add	r0, sp, #24
 803c034:	f7ff fc06 	bl	803b844 <psa_cipher_update>
    if (status != PSA_SUCCESS) {
 803c038:	b168      	cbz	r0, 803c056 <psa_cipher_test+0x1de>
        TEST_FAIL("Error encrypting one chunk of information");
 803c03a:	4837      	ldr	r0, [pc, #220]	; (803c118 <psa_cipher_test+0x2a0>)
 803c03c:	4623      	mov	r3, r4
 803c03e:	22c7      	movs	r2, #199	; 0xc7
 803c040:	4929      	ldr	r1, [pc, #164]	; (803c0e8 <psa_cipher_test+0x270>)
 803c042:	f000 fadf 	bl	803c604 <set_test_failed>
        status = psa_cipher_abort(&handle);
 803c046:	a806      	add	r0, sp, #24
 803c048:	f7ff fc33 	bl	803b8b2 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803c04c:	2800      	cmp	r0, #0
 803c04e:	d08d      	beq.n	803bf6c <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803c050:	4623      	mov	r3, r4
 803c052:	22ca      	movs	r2, #202	; 0xca
 803c054:	e7e4      	b.n	803c020 <psa_cipher_test+0x1a8>
    if (output_length != BYTE_SIZE_CHUNK) {
 803c056:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 803c058:	2a10      	cmp	r2, #16
 803c05a:	d00e      	beq.n	803c07a <psa_cipher_test+0x202>
        TEST_FAIL("Expected encrypted data length is different from expected");
 803c05c:	482f      	ldr	r0, [pc, #188]	; (803c11c <psa_cipher_test+0x2a4>)
 803c05e:	4623      	mov	r3, r4
 803c060:	22d0      	movs	r2, #208	; 0xd0
 803c062:	4921      	ldr	r1, [pc, #132]	; (803c0e8 <psa_cipher_test+0x270>)
 803c064:	f000 face 	bl	803c604 <set_test_failed>
        status = psa_cipher_abort(&handle);
 803c068:	a806      	add	r0, sp, #24
 803c06a:	f7ff fc22 	bl	803b8b2 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803c06e:	2800      	cmp	r0, #0
 803c070:	f43f af7c 	beq.w	803bf6c <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803c074:	4623      	mov	r3, r4
 803c076:	22d3      	movs	r2, #211	; 0xd3
 803c078:	e7d2      	b.n	803c020 <psa_cipher_test+0x1a8>
    status = psa_cipher_finish(&handle, &encrypted_data[output_length],
 803c07a:	4633      	mov	r3, r6
 803c07c:	a926      	add	r1, sp, #152	; 0x98
 803c07e:	a806      	add	r0, sp, #24
 803c080:	f7ff fc42 	bl	803b908 <psa_cipher_finish>
    if (status != PSA_SUCCESS) {
 803c084:	b170      	cbz	r0, 803c0a4 <psa_cipher_test+0x22c>
        TEST_FAIL("Error finalising the cipher operation");
 803c086:	4826      	ldr	r0, [pc, #152]	; (803c120 <psa_cipher_test+0x2a8>)
 803c088:	4623      	mov	r3, r4
 803c08a:	22de      	movs	r2, #222	; 0xde
 803c08c:	4916      	ldr	r1, [pc, #88]	; (803c0e8 <psa_cipher_test+0x270>)
 803c08e:	f000 fab9 	bl	803c604 <set_test_failed>
        status = psa_cipher_abort(&handle);
 803c092:	a806      	add	r0, sp, #24
 803c094:	f7ff fc0d 	bl	803b8b2 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803c098:	2800      	cmp	r0, #0
 803c09a:	f43f af67 	beq.w	803bf6c <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803c09e:	4623      	mov	r3, r4
 803c0a0:	22e1      	movs	r2, #225	; 0xe1
 803c0a2:	e7bd      	b.n	803c020 <psa_cipher_test+0x1a8>
    if (output_length != 0) {
 803c0a4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 803c0a6:	b123      	cbz	r3, 803c0b2 <psa_cipher_test+0x23a>
        TEST_FAIL("Unexpected output length after finalisation");
 803c0a8:	4623      	mov	r3, r4
 803c0aa:	22e7      	movs	r2, #231	; 0xe7
 803c0ac:	490e      	ldr	r1, [pc, #56]	; (803c0e8 <psa_cipher_test+0x270>)
 803c0ae:	481d      	ldr	r0, [pc, #116]	; (803c124 <psa_cipher_test+0x2ac>)
 803c0b0:	e75a      	b.n	803bf68 <psa_cipher_test+0xf0>
    if (alg == PSA_ALG_CFB) {
 803c0b2:	4b1d      	ldr	r3, [pc, #116]	; (803c128 <psa_cipher_test+0x2b0>)
 803c0b4:	f8bd 1016 	ldrh.w	r1, [sp, #22]
 803c0b8:	429f      	cmp	r7, r3
        status = psa_cipher_encrypt_setup(&handle_dec, key_handle, alg);
 803c0ba:	463a      	mov	r2, r7
 803c0bc:	a807      	add	r0, sp, #28
    if (alg == PSA_ALG_CFB) {
 803c0be:	d105      	bne.n	803c0cc <psa_cipher_test+0x254>
        status = psa_cipher_encrypt_setup(&handle_dec, key_handle, alg);
 803c0c0:	f7ff fb5e 	bl	803b780 <psa_cipher_encrypt_setup>
    if (status != PSA_SUCCESS) {
 803c0c4:	b390      	cbz	r0, 803c12c <psa_cipher_test+0x2b4>
        TEST_FAIL("Error setting up cipher operation object");
 803c0c6:	4623      	mov	r3, r4
 803c0c8:	22f4      	movs	r2, #244	; 0xf4
 803c0ca:	e793      	b.n	803bff4 <psa_cipher_test+0x17c>
        status = psa_cipher_decrypt_setup(&handle_dec, key_handle, alg);
 803c0cc:	f7ff fb89 	bl	803b7e2 <psa_cipher_decrypt_setup>
 803c0d0:	e7f8      	b.n	803c0c4 <psa_cipher_test+0x24c>
 803c0d2:	bf00      	nop
 803c0d4:	0803f197 	.word	0x0803f197
 803c0d8:	40000001 	.word	0x40000001
 803c0dc:	40000004 	.word	0x40000004
 803c0e0:	0803ef5a 	.word	0x0803ef5a
 803c0e4:	0803ef6a 	.word	0x0803ef6a
 803c0e8:	0803eb18 	.word	0x0803eb18
 803c0ec:	0803eff4 	.word	0x0803eff4
 803c0f0:	0803f00b 	.word	0x0803f00b
 803c0f4:	0803ef43 	.word	0x0803ef43
 803c0f8:	0803f051 	.word	0x0803f051
 803c0fc:	0803f067 	.word	0x0803f067
 803c100:	0803f082 	.word	0x0803f082
 803c104:	0803f0b4 	.word	0x0803f0b4
 803c108:	0803ed4e 	.word	0x0803ed4e
 803c10c:	0803ed7c 	.word	0x0803ed7c
 803c110:	0803eda5 	.word	0x0803eda5
 803c114:	0803edd9 	.word	0x0803edd9
 803c118:	0803edf6 	.word	0x0803edf6
 803c11c:	0803ee20 	.word	0x0803ee20
 803c120:	0803ee5a 	.word	0x0803ee5a
 803c124:	0803ee80 	.word	0x0803ee80
 803c128:	04c00002 	.word	0x04c00002
    status = psa_cipher_set_iv(&handle_dec, iv, iv_length);
 803c12c:	462a      	mov	r2, r5
 803c12e:	4651      	mov	r1, sl
 803c130:	a807      	add	r0, sp, #28
 803c132:	f7ff faf5 	bl	803b720 <psa_cipher_set_iv>
    if (status != PSA_SUCCESS) {
 803c136:	2800      	cmp	r0, #0
 803c138:	d138      	bne.n	803c1ac <psa_cipher_test+0x334>
        status = psa_cipher_update(&handle_dec,
 803c13a:	2320      	movs	r3, #32
 803c13c:	9601      	str	r6, [sp, #4]
 803c13e:	9300      	str	r3, [sp, #0]
 803c140:	2210      	movs	r2, #16
 803c142:	ab1a      	add	r3, sp, #104	; 0x68
 803c144:	a922      	add	r1, sp, #136	; 0x88
 803c146:	a807      	add	r0, sp, #28
 803c148:	f7ff fb7c 	bl	803b844 <psa_cipher_update>
        if (status != PSA_SUCCESS) {
 803c14c:	2800      	cmp	r0, #0
 803c14e:	d13c      	bne.n	803c1ca <psa_cipher_test+0x352>
        total_output_length += output_length;
 803c150:	9d0a      	ldr	r5, [sp, #40]	; 0x28
        status = psa_cipher_update(&handle_dec,
 803c152:	9601      	str	r6, [sp, #4]
 803c154:	f1c5 0320 	rsb	r3, r5, #32
 803c158:	9300      	str	r3, [sp, #0]
 803c15a:	ab1a      	add	r3, sp, #104	; 0x68
 803c15c:	442b      	add	r3, r5
 803c15e:	2210      	movs	r2, #16
 803c160:	a926      	add	r1, sp, #152	; 0x98
 803c162:	a807      	add	r0, sp, #28
 803c164:	f7ff fb6e 	bl	803b844 <psa_cipher_update>
        if (status != PSA_SUCCESS) {
 803c168:	bb78      	cbnz	r0, 803c1ca <psa_cipher_test+0x352>
}

__attribute__ ((always_inline)) __STATIC_INLINE
int tfm_memcmp(const void *ptr1, const void *ptr2, size_t num)
{
    return (memcmp(ptr1, ptr2, num));
 803c16a:	2210      	movs	r2, #16
 803c16c:	a91a      	add	r1, sp, #104	; 0x68
 803c16e:	4648      	mov	r0, r9
 803c170:	f000 fa98 	bl	803c6a4 <memcmp>
    if (comp_result != 0) {
 803c174:	2800      	cmp	r0, #0
 803c176:	d139      	bne.n	803c1ec <psa_cipher_test+0x374>
    status = psa_cipher_finish(&handle_dec, decrypted_data, BYTE_SIZE_CHUNK,
 803c178:	4633      	mov	r3, r6
 803c17a:	2210      	movs	r2, #16
 803c17c:	a91a      	add	r1, sp, #104	; 0x68
 803c17e:	a807      	add	r0, sp, #28
        total_output_length += output_length;
 803c180:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    status = psa_cipher_finish(&handle_dec, decrypted_data, BYTE_SIZE_CHUNK,
 803c182:	f7ff fbc1 	bl	803b908 <psa_cipher_finish>
    if (status != PSA_SUCCESS) {
 803c186:	2800      	cmp	r0, #0
 803c188:	d041      	beq.n	803c20e <psa_cipher_test+0x396>
        TEST_FAIL("Error finalising the cipher operation");
 803c18a:	4827      	ldr	r0, [pc, #156]	; (803c228 <psa_cipher_test+0x3b0>)
 803c18c:	4623      	mov	r3, r4
 803c18e:	f240 122b 	movw	r2, #299	; 0x12b
 803c192:	4926      	ldr	r1, [pc, #152]	; (803c22c <psa_cipher_test+0x3b4>)
 803c194:	f000 fa36 	bl	803c604 <set_test_failed>
        status = psa_cipher_abort(&handle_dec);
 803c198:	a807      	add	r0, sp, #28
 803c19a:	f7ff fb8a 	bl	803b8b2 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803c19e:	2800      	cmp	r0, #0
 803c1a0:	f43f aee4 	beq.w	803bf6c <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803c1a4:	4623      	mov	r3, r4
 803c1a6:	f44f 7297 	mov.w	r2, #302	; 0x12e
 803c1aa:	e739      	b.n	803c020 <psa_cipher_test+0x1a8>
        TEST_FAIL("Error setting the IV for decryption");
 803c1ac:	4820      	ldr	r0, [pc, #128]	; (803c230 <psa_cipher_test+0x3b8>)
 803c1ae:	4623      	mov	r3, r4
 803c1b0:	22fb      	movs	r2, #251	; 0xfb
 803c1b2:	491e      	ldr	r1, [pc, #120]	; (803c22c <psa_cipher_test+0x3b4>)
 803c1b4:	f000 fa26 	bl	803c604 <set_test_failed>
        status = psa_cipher_abort(&handle_dec);
 803c1b8:	a807      	add	r0, sp, #28
 803c1ba:	f7ff fb7a 	bl	803b8b2 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803c1be:	2800      	cmp	r0, #0
 803c1c0:	f43f aed4 	beq.w	803bf6c <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803c1c4:	4623      	mov	r3, r4
 803c1c6:	22fe      	movs	r2, #254	; 0xfe
 803c1c8:	e72a      	b.n	803c020 <psa_cipher_test+0x1a8>
            TEST_FAIL("Error during decryption");
 803c1ca:	481a      	ldr	r0, [pc, #104]	; (803c234 <psa_cipher_test+0x3bc>)
 803c1cc:	4623      	mov	r3, r4
 803c1ce:	f44f 7286 	mov.w	r2, #268	; 0x10c
 803c1d2:	4916      	ldr	r1, [pc, #88]	; (803c22c <psa_cipher_test+0x3b4>)
 803c1d4:	f000 fa16 	bl	803c604 <set_test_failed>
            status = psa_cipher_abort(&handle_dec);
 803c1d8:	a807      	add	r0, sp, #28
 803c1da:	f7ff fb6a 	bl	803b8b2 <psa_cipher_abort>
            if (status != PSA_SUCCESS) {
 803c1de:	2800      	cmp	r0, #0
 803c1e0:	f43f aec4 	beq.w	803bf6c <psa_cipher_test+0xf4>
                TEST_FAIL("Error aborting the operation");
 803c1e4:	4623      	mov	r3, r4
 803c1e6:	f240 120f 	movw	r2, #271	; 0x10f
 803c1ea:	e719      	b.n	803c020 <psa_cipher_test+0x1a8>
        TEST_FAIL("Decrypted data doesn't match with plain text");
 803c1ec:	4812      	ldr	r0, [pc, #72]	; (803c238 <psa_cipher_test+0x3c0>)
 803c1ee:	4623      	mov	r3, r4
 803c1f0:	f44f 728f 	mov.w	r2, #286	; 0x11e
 803c1f4:	490d      	ldr	r1, [pc, #52]	; (803c22c <psa_cipher_test+0x3b4>)
 803c1f6:	f000 fa05 	bl	803c604 <set_test_failed>
        status = psa_cipher_abort(&handle_dec);
 803c1fa:	a807      	add	r0, sp, #28
 803c1fc:	f7ff fb59 	bl	803b8b2 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803c200:	2800      	cmp	r0, #0
 803c202:	f43f aeb3 	beq.w	803bf6c <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803c206:	4623      	mov	r3, r4
 803c208:	f240 1221 	movw	r2, #289	; 0x121
 803c20c:	e708      	b.n	803c020 <psa_cipher_test+0x1a8>
    total_output_length += output_length;
 803c20e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        total_output_length += output_length;
 803c210:	443d      	add	r5, r7
    total_output_length += output_length;
 803c212:	441d      	add	r5, r3
    if (total_output_length != ENC_DEC_BUFFER_SIZE) {
 803c214:	2d20      	cmp	r5, #32
 803c216:	f43f aea9 	beq.w	803bf6c <psa_cipher_test+0xf4>
        TEST_FAIL("After finalising, unexpected decrypted length");
 803c21a:	4623      	mov	r3, r4
 803c21c:	f240 1237 	movw	r2, #311	; 0x137
 803c220:	4902      	ldr	r1, [pc, #8]	; (803c22c <psa_cipher_test+0x3b4>)
 803c222:	4806      	ldr	r0, [pc, #24]	; (803c23c <psa_cipher_test+0x3c4>)
 803c224:	e6a0      	b.n	803bf68 <psa_cipher_test+0xf0>
 803c226:	bf00      	nop
 803c228:	0803ee5a 	.word	0x0803ee5a
 803c22c:	0803eb18 	.word	0x0803eb18
 803c230:	0803eeac 	.word	0x0803eeac
 803c234:	0803eed0 	.word	0x0803eed0
 803c238:	0803eee8 	.word	0x0803eee8
 803c23c:	0803ef15 	.word	0x0803ef15

0803c240 <psa_hash_test>:
    const size_t msg_size[] = {25, 32}; /* Length in bytes of msg[0], msg[1] */
    const uint32_t msg_num = sizeof(msg)/sizeof(msg[0]);
    uint32_t idx;

    psa_status_t status;
    psa_hash_operation_t handle = psa_hash_operation_init();
 803c240:	2300      	movs	r3, #0
{
 803c242:	b573      	push	{r0, r1, r4, r5, r6, lr}
    psa_hash_operation_t handle = psa_hash_operation_init();
 803c244:	ae02      	add	r6, sp, #8
 803c246:	f846 3d04 	str.w	r3, [r6, #-4]!
{
 803c24a:	4604      	mov	r4, r0
 803c24c:	460d      	mov	r5, r1

    /* Setup the hash object for the desired hash*/
    status = psa_hash_setup(&handle, alg);
 803c24e:	4601      	mov	r1, r0
 803c250:	4630      	mov	r0, r6
 803c252:	f7ff fb8c 	bl	803b96e <psa_hash_setup>

    if (status != PSA_SUCCESS) {
 803c256:	2800      	cmp	r0, #0
 803c258:	d14b      	bne.n	803c2f2 <psa_hash_test+0xb2>
        return;
    }

    /* Update object with all the chunks of message */
    for (idx=0; idx<msg_num; idx++) {
        status = psa_hash_update(&handle,
 803c25a:	2219      	movs	r2, #25
 803c25c:	493f      	ldr	r1, [pc, #252]	; (803c35c <psa_hash_test+0x11c>)
 803c25e:	4630      	mov	r0, r6
 803c260:	f7ff fbb2 	bl	803b9c8 <psa_hash_update>
                                 (const uint8_t *)msg[idx],msg_size[idx]);
        if (status != PSA_SUCCESS) {
 803c264:	2800      	cmp	r0, #0
 803c266:	d154      	bne.n	803c312 <psa_hash_test+0xd2>
        status = psa_hash_update(&handle,
 803c268:	2220      	movs	r2, #32
 803c26a:	493d      	ldr	r1, [pc, #244]	; (803c360 <psa_hash_test+0x120>)
 803c26c:	4630      	mov	r0, r6
 803c26e:	f7ff fbab 	bl	803b9c8 <psa_hash_update>
        if (status != PSA_SUCCESS) {
 803c272:	2800      	cmp	r0, #0
 803c274:	d14d      	bne.n	803c312 <psa_hash_test+0xd2>
            return;
        }
    }

    /* Cycle until idx points to the correct index in the algorithm table */
    for (idx=0; hash_alg[idx] != alg; idx++);
 803c276:	4b3b      	ldr	r3, [pc, #236]	; (803c364 <psa_hash_test+0x124>)
 803c278:	429c      	cmp	r4, r3
 803c27a:	d150      	bne.n	803c31e <psa_hash_test+0xde>

    /* Finalise and verify that the hash is as expected */
    status = psa_hash_verify(&handle, &(hash_val[idx][0]), PSA_HASH_SIZE(alg));
 803c27c:	b2e2      	uxtb	r2, r4
 803c27e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 803c282:	f102 437f 	add.w	r3, r2, #4278190080	; 0xff000000
 803c286:	4938      	ldr	r1, [pc, #224]	; (803c368 <psa_hash_test+0x128>)
 803c288:	3b01      	subs	r3, #1
 803c28a:	2b02      	cmp	r3, #2
 803c28c:	eb01 1180 	add.w	r1, r1, r0, lsl #6
 803c290:	d955      	bls.n	803c33e <psa_hash_test+0xfe>
 803c292:	f102 437f 	add.w	r3, r2, #4278190080	; 0xff000000
 803c296:	3b04      	subs	r3, #4
 803c298:	2b01      	cmp	r3, #1
 803c29a:	d952      	bls.n	803c342 <psa_hash_test+0x102>
 803c29c:	4b33      	ldr	r3, [pc, #204]	; (803c36c <psa_hash_test+0x12c>)
 803c29e:	429a      	cmp	r2, r3
 803c2a0:	d053      	beq.n	803c34a <psa_hash_test+0x10a>
 803c2a2:	3301      	adds	r3, #1
 803c2a4:	429a      	cmp	r2, r3
 803c2a6:	d052      	beq.n	803c34e <psa_hash_test+0x10e>
 803c2a8:	3301      	adds	r3, #1
 803c2aa:	429a      	cmp	r2, r3
 803c2ac:	d051      	beq.n	803c352 <psa_hash_test+0x112>
 803c2ae:	3301      	adds	r3, #1
 803c2b0:	429a      	cmp	r2, r3
 803c2b2:	d048      	beq.n	803c346 <psa_hash_test+0x106>
 803c2b4:	3301      	adds	r3, #1
 803c2b6:	429a      	cmp	r2, r3
 803c2b8:	d047      	beq.n	803c34a <psa_hash_test+0x10a>
 803c2ba:	3301      	adds	r3, #1
 803c2bc:	429a      	cmp	r2, r3
 803c2be:	d046      	beq.n	803c34e <psa_hash_test+0x10e>
 803c2c0:	3303      	adds	r3, #3
 803c2c2:	429a      	cmp	r2, r3
 803c2c4:	d041      	beq.n	803c34a <psa_hash_test+0x10a>
 803c2c6:	3301      	adds	r3, #1
 803c2c8:	429a      	cmp	r2, r3
 803c2ca:	d040      	beq.n	803c34e <psa_hash_test+0x10e>
 803c2cc:	3301      	adds	r3, #1
 803c2ce:	429a      	cmp	r2, r3
 803c2d0:	d03f      	beq.n	803c352 <psa_hash_test+0x112>
 803c2d2:	3301      	adds	r3, #1
 803c2d4:	429a      	cmp	r2, r3
 803c2d6:	bf0c      	ite	eq
 803c2d8:	2240      	moveq	r2, #64	; 0x40
 803c2da:	2200      	movne	r2, #0
 803c2dc:	4630      	mov	r0, r6
 803c2de:	f7ff fba3 	bl	803ba28 <psa_hash_verify>
    if (status != PSA_SUCCESS) {
 803c2e2:	2800      	cmp	r0, #0
 803c2e4:	d037      	beq.n	803c356 <psa_hash_test+0x116>
        TEST_FAIL("Error verifying the hash operation object");
 803c2e6:	462b      	mov	r3, r5
 803c2e8:	f240 12d3 	movw	r2, #467	; 0x1d3
 803c2ec:	4920      	ldr	r1, [pc, #128]	; (803c370 <psa_hash_test+0x130>)
 803c2ee:	4821      	ldr	r0, [pc, #132]	; (803c374 <psa_hash_test+0x134>)
 803c2f0:	e00b      	b.n	803c30a <psa_hash_test+0xca>
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803c2f2:	3086      	adds	r0, #134	; 0x86
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c2f4:	462b      	mov	r3, r5
 803c2f6:	bf09      	itett	eq
 803c2f8:	f240 12bb 	movweq	r2, #443	; 0x1bb
        TEST_FAIL("Error setting up hash operation object");
 803c2fc:	f240 12bf 	movwne	r2, #447	; 0x1bf
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c300:	491b      	ldreq	r1, [pc, #108]	; (803c370 <psa_hash_test+0x130>)
 803c302:	481d      	ldreq	r0, [pc, #116]	; (803c378 <psa_hash_test+0x138>)
        TEST_FAIL("Error setting up hash operation object");
 803c304:	bf1c      	itt	ne
 803c306:	491a      	ldrne	r1, [pc, #104]	; (803c370 <psa_hash_test+0x130>)
 803c308:	481c      	ldrne	r0, [pc, #112]	; (803c37c <psa_hash_test+0x13c>)
        TEST_FAIL("Error verifying the hash operation object");
 803c30a:	f000 f97b 	bl	803c604 <set_test_failed>
        return;
    }

    ret->val = TEST_PASSED;
}
 803c30e:	b002      	add	sp, #8
 803c310:	bd70      	pop	{r4, r5, r6, pc}
            TEST_FAIL("Error updating the hash operation object");
 803c312:	462b      	mov	r3, r5
 803c314:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
 803c318:	4915      	ldr	r1, [pc, #84]	; (803c370 <psa_hash_test+0x130>)
 803c31a:	4819      	ldr	r0, [pc, #100]	; (803c380 <psa_hash_test+0x140>)
 803c31c:	e7f5      	b.n	803c30a <psa_hash_test+0xca>
    for (idx=0; hash_alg[idx] != alg; idx++);
 803c31e:	4b13      	ldr	r3, [pc, #76]	; (803c36c <psa_hash_test+0x12c>)
 803c320:	429c      	cmp	r4, r3
 803c322:	d008      	beq.n	803c336 <psa_hash_test+0xf6>
 803c324:	3301      	adds	r3, #1
 803c326:	429c      	cmp	r4, r3
 803c328:	d007      	beq.n	803c33a <psa_hash_test+0xfa>
 803c32a:	4816      	ldr	r0, [pc, #88]	; (803c384 <psa_hash_test+0x144>)
 803c32c:	4284      	cmp	r4, r0
 803c32e:	bf0c      	ite	eq
 803c330:	2003      	moveq	r0, #3
 803c332:	2004      	movne	r0, #4
 803c334:	e7a2      	b.n	803c27c <psa_hash_test+0x3c>
 803c336:	2001      	movs	r0, #1
 803c338:	e7a0      	b.n	803c27c <psa_hash_test+0x3c>
 803c33a:	2002      	movs	r0, #2
 803c33c:	e79e      	b.n	803c27c <psa_hash_test+0x3c>
    status = psa_hash_verify(&handle, &(hash_val[idx][0]), PSA_HASH_SIZE(alg));
 803c33e:	2210      	movs	r2, #16
 803c340:	e7cc      	b.n	803c2dc <psa_hash_test+0x9c>
 803c342:	2214      	movs	r2, #20
 803c344:	e7ca      	b.n	803c2dc <psa_hash_test+0x9c>
 803c346:	2240      	movs	r2, #64	; 0x40
 803c348:	e7c8      	b.n	803c2dc <psa_hash_test+0x9c>
 803c34a:	221c      	movs	r2, #28
 803c34c:	e7c6      	b.n	803c2dc <psa_hash_test+0x9c>
 803c34e:	2220      	movs	r2, #32
 803c350:	e7c4      	b.n	803c2dc <psa_hash_test+0x9c>
 803c352:	2230      	movs	r2, #48	; 0x30
 803c354:	e7c2      	b.n	803c2dc <psa_hash_test+0x9c>
    ret->val = TEST_PASSED;
 803c356:	7028      	strb	r0, [r5, #0]
 803c358:	e7d9      	b.n	803c30e <psa_hash_test+0xce>
 803c35a:	bf00      	nop
 803c35c:	0803f1a7 	.word	0x0803f1a7
 803c360:	0803f1c1 	.word	0x0803f1c1
 803c364:	01000005 	.word	0x01000005
 803c368:	0803eb44 	.word	0x0803eb44
 803c36c:	01000008 	.word	0x01000008
 803c370:	0803eb28 	.word	0x0803eb28
 803c374:	0803efca 	.word	0x0803efca
 803c378:	0803ed4e 	.word	0x0803ed4e
 803c37c:	0803ef7a 	.word	0x0803ef7a
 803c380:	0803efa1 	.word	0x0803efa1
 803c384:	0100000a 	.word	0x0100000a

0803c388 <psa_aead_test>:
}

void psa_aead_test(const psa_key_type_t key_type,
                   const psa_algorithm_t alg,
                   struct test_result_t *ret)
{
 803c388:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803c38c:	4614      	mov	r4, r2
    psa_key_handle_t key_handle;
    const size_t nonce_length = 12;
    const uint8_t nonce[] = "01234567890";
 803c38e:	4a84      	ldr	r2, [pc, #528]	; (803c5a0 <psa_aead_test+0x218>)
{
 803c390:	b0b3      	sub	sp, #204	; 0xcc
 803c392:	4682      	mov	sl, r0
 803c394:	460e      	mov	r6, r1
    const uint8_t nonce[] = "01234567890";
 803c396:	6810      	ldr	r0, [r2, #0]
 803c398:	6851      	ldr	r1, [r2, #4]
 803c39a:	ab0e      	add	r3, sp, #56	; 0x38
 803c39c:	c303      	stmia	r3!, {r0, r1}
 803c39e:	6890      	ldr	r0, [r2, #8]
    const uint8_t plain_text[BYTE_SIZE_CHUNK] = "Sixteen bytes!!";
 803c3a0:	aa14      	add	r2, sp, #80	; 0x50
 803c3a2:	4690      	mov	r8, r2
    const uint8_t nonce[] = "01234567890";
 803c3a4:	6018      	str	r0, [r3, #0]
    const uint8_t plain_text[BYTE_SIZE_CHUNK] = "Sixteen bytes!!";
 803c3a6:	4b7f      	ldr	r3, [pc, #508]	; (803c5a4 <psa_aead_test+0x21c>)
 803c3a8:	f103 0710 	add.w	r7, r3, #16
 803c3ac:	4615      	mov	r5, r2
 803c3ae:	6818      	ldr	r0, [r3, #0]
 803c3b0:	6859      	ldr	r1, [r3, #4]
 803c3b2:	3308      	adds	r3, #8
 803c3b4:	c503      	stmia	r5!, {r0, r1}
 803c3b6:	42bb      	cmp	r3, r7
 803c3b8:	462a      	mov	r2, r5
 803c3ba:	d1f7      	bne.n	803c3ac <psa_aead_test+0x24>
    const uint8_t associated_data[ASSOCIATED_DATA_SIZE] =
 803c3bc:	aa1c      	add	r2, sp, #112	; 0x70
 803c3be:	4691      	mov	r9, r2
 803c3c0:	4b79      	ldr	r3, [pc, #484]	; (803c5a8 <psa_aead_test+0x220>)
 803c3c2:	f103 0718 	add.w	r7, r3, #24
 803c3c6:	4615      	mov	r5, r2
 803c3c8:	6818      	ldr	r0, [r3, #0]
 803c3ca:	6859      	ldr	r1, [r3, #4]
 803c3cc:	3308      	adds	r3, #8
 803c3ce:	c503      	stmia	r5!, {r0, r1}
 803c3d0:	42bb      	cmp	r3, r7
 803c3d2:	462a      	mov	r2, r5
 803c3d4:	d1f7      	bne.n	803c3c6 <psa_aead_test+0x3e>
                                                      "This is associated data";
    uint8_t encrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
 803c3d6:	ad22      	add	r5, sp, #136	; 0x88
 803c3d8:	2220      	movs	r2, #32
 803c3da:	2100      	movs	r1, #0
 803c3dc:	4628      	mov	r0, r5
 803c3de:	f000 f97b 	bl	803c6d8 <memset>
    size_t encrypted_data_length = 0, decrypted_data_length = 0;
 803c3e2:	2100      	movs	r1, #0
    uint8_t decrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
 803c3e4:	af2a      	add	r7, sp, #168	; 0xa8
 803c3e6:	2220      	movs	r2, #32
 803c3e8:	4638      	mov	r0, r7
    size_t encrypted_data_length = 0, decrypted_data_length = 0;
 803c3ea:	e9cd 110a 	strd	r1, r1, [sp, #40]	; 0x28
    uint8_t decrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
 803c3ee:	f000 f973 	bl	803c6d8 <memset>
    psa_status_t status;
    const uint8_t data[] = "THIS IS MY KEY1";
 803c3f2:	aa18      	add	r2, sp, #96	; 0x60
 803c3f4:	4693      	mov	fp, r2
 803c3f6:	4b6d      	ldr	r3, [pc, #436]	; (803c5ac <psa_aead_test+0x224>)
 803c3f8:	f103 0e10 	add.w	lr, r3, #16
 803c3fc:	4694      	mov	ip, r2
 803c3fe:	6818      	ldr	r0, [r3, #0]
 803c400:	6859      	ldr	r1, [r3, #4]
 803c402:	3308      	adds	r3, #8
 803c404:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 803c408:	4573      	cmp	r3, lr
 803c40a:	4662      	mov	r2, ip
 803c40c:	d1f6      	bne.n	803c3fc <psa_aead_test+0x74>
    psa_key_type_t type = PSA_KEY_TYPE_NONE;
 803c40e:	2300      	movs	r3, #0
    psa_key_usage_t usage = (PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);

    ret->val = TEST_PASSED;

    /* Allocate a transient key */
    status = psa_allocate_key(&key_handle);
 803c410:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    ret->val = TEST_PASSED;
 803c414:	7023      	strb	r3, [r4, #0]
    size_t bits = 0;
 803c416:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
 803c41a:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
 803c41e:	9313      	str	r3, [sp, #76]	; 0x4c
    status = psa_allocate_key(&key_handle);
 803c420:	f7ff f8a2 	bl	803b568 <psa_allocate_key>
    if (status != PSA_SUCCESS) {
 803c424:	b148      	cbz	r0, 803c43a <psa_aead_test+0xb2>
        TEST_FAIL("Failed to allocate key");
 803c426:	4623      	mov	r3, r4
 803c428:	f240 2292 	movw	r2, #658	; 0x292
 803c42c:	4960      	ldr	r1, [pc, #384]	; (803c5b0 <psa_aead_test+0x228>)
 803c42e:	4861      	ldr	r0, [pc, #388]	; (803c5b4 <psa_aead_test+0x22c>)

destroy_key_aead:
    /* Destroy the key */
    status = psa_destroy_key(key_handle);
    if (status != PSA_SUCCESS) {
        TEST_FAIL("Error destroying a key");
 803c430:	f000 f8e8 	bl	803c604 <set_test_failed>
    }
}
 803c434:	b033      	add	sp, #204	; 0xcc
 803c436:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    psa_key_policy_set_usage(&policy, usage, alg);
 803c43a:	f44f 7140 	mov.w	r1, #768	; 0x300
 803c43e:	a811      	add	r0, sp, #68	; 0x44
 803c440:	4632      	mov	r2, r6
 803c442:	f7ff f93e 	bl	803b6c2 <psa_key_policy_set_usage>
    status = psa_set_key_policy(key_handle, &policy);
 803c446:	a911      	add	r1, sp, #68	; 0x44
 803c448:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
 803c44c:	f7ff f93c 	bl	803b6c8 <psa_set_key_policy>
    if (status != PSA_SUCCESS) {
 803c450:	b190      	cbz	r0, 803c478 <psa_aead_test+0xf0>
        TEST_FAIL("Failed to set key policy");
 803c452:	4623      	mov	r3, r4
 803c454:	f240 229a 	movw	r2, #666	; 0x29a
 803c458:	4955      	ldr	r1, [pc, #340]	; (803c5b0 <psa_aead_test+0x228>)
 803c45a:	4857      	ldr	r0, [pc, #348]	; (803c5b8 <psa_aead_test+0x230>)
        TEST_FAIL("Decrypted data doesn't match with plain text");
 803c45c:	f000 f8d2 	bl	803c604 <set_test_failed>
    status = psa_destroy_key(key_handle);
 803c460:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
 803c464:	f7ff f8d4 	bl	803b610 <psa_destroy_key>
    if (status != PSA_SUCCESS) {
 803c468:	2800      	cmp	r0, #0
 803c46a:	d0e3      	beq.n	803c434 <psa_aead_test+0xac>
        TEST_FAIL("Error destroying a key");
 803c46c:	4623      	mov	r3, r4
 803c46e:	f240 22f7 	movw	r2, #759	; 0x2f7
 803c472:	494f      	ldr	r1, [pc, #316]	; (803c5b0 <psa_aead_test+0x228>)
 803c474:	4851      	ldr	r0, [pc, #324]	; (803c5bc <psa_aead_test+0x234>)
 803c476:	e7db      	b.n	803c430 <psa_aead_test+0xa8>
    status = psa_import_key(key_handle, key_type, data, sizeof(data));
 803c478:	2310      	movs	r3, #16
 803c47a:	465a      	mov	r2, fp
 803c47c:	4651      	mov	r1, sl
 803c47e:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
 803c482:	f7ff f898 	bl	803b5b6 <psa_import_key>
    if (status != PSA_SUCCESS) {
 803c486:	b128      	cbz	r0, 803c494 <psa_aead_test+0x10c>
        TEST_FAIL("Error importing a key");
 803c488:	4623      	mov	r3, r4
 803c48a:	f240 22a1 	movw	r2, #673	; 0x2a1
 803c48e:	4948      	ldr	r1, [pc, #288]	; (803c5b0 <psa_aead_test+0x228>)
 803c490:	484b      	ldr	r0, [pc, #300]	; (803c5c0 <psa_aead_test+0x238>)
 803c492:	e7e3      	b.n	803c45c <psa_aead_test+0xd4>
    status = psa_get_key_information(key_handle, &type, &bits);
 803c494:	aa0d      	add	r2, sp, #52	; 0x34
 803c496:	a90c      	add	r1, sp, #48	; 0x30
 803c498:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
 803c49c:	f7ff f8e0 	bl	803b660 <psa_get_key_information>
    if (status != PSA_SUCCESS) {
 803c4a0:	b128      	cbz	r0, 803c4ae <psa_aead_test+0x126>
        TEST_FAIL("Error getting key metadata");
 803c4a2:	4623      	mov	r3, r4
 803c4a4:	f240 22a7 	movw	r2, #679	; 0x2a7
 803c4a8:	4941      	ldr	r1, [pc, #260]	; (803c5b0 <psa_aead_test+0x228>)
 803c4aa:	4846      	ldr	r0, [pc, #280]	; (803c5c4 <psa_aead_test+0x23c>)
 803c4ac:	e7d6      	b.n	803c45c <psa_aead_test+0xd4>
    if (bits != BIT_SIZE_TEST_KEY) {
 803c4ae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 803c4b0:	2b80      	cmp	r3, #128	; 0x80
 803c4b2:	d005      	beq.n	803c4c0 <psa_aead_test+0x138>
        TEST_FAIL("The number of key bits is different from expected");
 803c4b4:	4623      	mov	r3, r4
 803c4b6:	f44f 722b 	mov.w	r2, #684	; 0x2ac
 803c4ba:	493d      	ldr	r1, [pc, #244]	; (803c5b0 <psa_aead_test+0x228>)
 803c4bc:	4842      	ldr	r0, [pc, #264]	; (803c5c8 <psa_aead_test+0x240>)
 803c4be:	e7cd      	b.n	803c45c <psa_aead_test+0xd4>
    if (type != key_type) {
 803c4c0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 803c4c2:	4553      	cmp	r3, sl
 803c4c4:	d005      	beq.n	803c4d2 <psa_aead_test+0x14a>
        TEST_FAIL("The type of the key is different from expected");
 803c4c6:	4623      	mov	r3, r4
 803c4c8:	f240 22b1 	movw	r2, #689	; 0x2b1
 803c4cc:	4938      	ldr	r1, [pc, #224]	; (803c5b0 <psa_aead_test+0x228>)
 803c4ce:	483f      	ldr	r0, [pc, #252]	; (803c5cc <psa_aead_test+0x244>)
 803c4d0:	e7c4      	b.n	803c45c <psa_aead_test+0xd4>
    status = psa_aead_encrypt(key_handle, alg, nonce, nonce_length,
 803c4d2:	ab0a      	add	r3, sp, #40	; 0x28
 803c4d4:	9306      	str	r3, [sp, #24]
 803c4d6:	2320      	movs	r3, #32
 803c4d8:	e9cd 5304 	strd	r5, r3, [sp, #16]
 803c4dc:	2310      	movs	r3, #16
 803c4de:	e9cd 8302 	strd	r8, r3, [sp, #8]
 803c4e2:	2318      	movs	r3, #24
 803c4e4:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
 803c4e8:	e9cd 9300 	strd	r9, r3, [sp]
 803c4ec:	aa0e      	add	r2, sp, #56	; 0x38
 803c4ee:	230c      	movs	r3, #12
 803c4f0:	4631      	mov	r1, r6
 803c4f2:	f7ff fac9 	bl	803ba88 <psa_aead_encrypt>
    if (status != PSA_SUCCESS) {
 803c4f6:	b160      	cbz	r0, 803c512 <psa_aead_test+0x18a>
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803c4f8:	3086      	adds	r0, #134	; 0x86
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c4fa:	4623      	mov	r3, r4
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803c4fc:	d104      	bne.n	803c508 <psa_aead_test+0x180>
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c4fe:	f240 22c1 	movw	r2, #705	; 0x2c1
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c502:	492b      	ldr	r1, [pc, #172]	; (803c5b0 <psa_aead_test+0x228>)
 803c504:	4832      	ldr	r0, [pc, #200]	; (803c5d0 <psa_aead_test+0x248>)
 803c506:	e7a9      	b.n	803c45c <psa_aead_test+0xd4>
        TEST_FAIL("Error performing AEAD encryption");
 803c508:	f240 22c5 	movw	r2, #709	; 0x2c5
 803c50c:	4928      	ldr	r1, [pc, #160]	; (803c5b0 <psa_aead_test+0x228>)
 803c50e:	4831      	ldr	r0, [pc, #196]	; (803c5d4 <psa_aead_test+0x24c>)
 803c510:	e7a4      	b.n	803c45c <psa_aead_test+0xd4>
        != PSA_AEAD_ENCRYPT_OUTPUT_SIZE(alg, sizeof(plain_text))) {
 803c512:	f006 43fe 	and.w	r3, r6, #2130706432	; 0x7f000000
 803c516:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
 803c51a:	d10c      	bne.n	803c536 <psa_aead_test+0x1ae>
 803c51c:	f3c6 2305 	ubfx	r3, r6, #8, #6
 803c520:	b103      	cbz	r3, 803c524 <psa_aead_test+0x19c>
 803c522:	3310      	adds	r3, #16
 803c524:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    if (encrypted_data_length
 803c526:	429a      	cmp	r2, r3
 803c528:	d007      	beq.n	803c53a <psa_aead_test+0x1b2>
        TEST_FAIL("Encrypted data length is different than expected");
 803c52a:	4623      	mov	r3, r4
 803c52c:	f240 22cb 	movw	r2, #715	; 0x2cb
 803c530:	491f      	ldr	r1, [pc, #124]	; (803c5b0 <psa_aead_test+0x228>)
 803c532:	4829      	ldr	r0, [pc, #164]	; (803c5d8 <psa_aead_test+0x250>)
 803c534:	e792      	b.n	803c45c <psa_aead_test+0xd4>
        != PSA_AEAD_ENCRYPT_OUTPUT_SIZE(alg, sizeof(plain_text))) {
 803c536:	4603      	mov	r3, r0
 803c538:	e7f4      	b.n	803c524 <psa_aead_test+0x19c>
    status = psa_aead_decrypt(key_handle, alg, nonce, nonce_length,
 803c53a:	aa0b      	add	r2, sp, #44	; 0x2c
 803c53c:	9206      	str	r2, [sp, #24]
 803c53e:	e9cd 5302 	strd	r5, r3, [sp, #8]
 803c542:	2220      	movs	r2, #32
 803c544:	2318      	movs	r3, #24
 803c546:	e9cd 7204 	strd	r7, r2, [sp, #16]
 803c54a:	e9cd 9300 	strd	r9, r3, [sp]
 803c54e:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
 803c552:	230c      	movs	r3, #12
 803c554:	aa0e      	add	r2, sp, #56	; 0x38
 803c556:	4631      	mov	r1, r6
 803c558:	f7ff faec 	bl	803bb34 <psa_aead_decrypt>
    if (status != PSA_SUCCESS) {
 803c55c:	b150      	cbz	r0, 803c574 <psa_aead_test+0x1ec>
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803c55e:	3086      	adds	r0, #134	; 0x86
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c560:	4623      	mov	r3, r4
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803c562:	d102      	bne.n	803c56a <psa_aead_test+0x1e2>
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c564:	f240 22db 	movw	r2, #731	; 0x2db
 803c568:	e7cb      	b.n	803c502 <psa_aead_test+0x17a>
            TEST_FAIL("Error performing AEAD decryption");
 803c56a:	f240 22dd 	movw	r2, #733	; 0x2dd
 803c56e:	4910      	ldr	r1, [pc, #64]	; (803c5b0 <psa_aead_test+0x228>)
 803c570:	481a      	ldr	r0, [pc, #104]	; (803c5dc <psa_aead_test+0x254>)
 803c572:	e773      	b.n	803c45c <psa_aead_test+0xd4>
    if (sizeof(plain_text) != decrypted_data_length) {
 803c574:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 803c576:	2a10      	cmp	r2, #16
 803c578:	d005      	beq.n	803c586 <psa_aead_test+0x1fe>
        TEST_FAIL("Decrypted data length is different from plain text");
 803c57a:	4623      	mov	r3, r4
 803c57c:	f44f 7239 	mov.w	r2, #740	; 0x2e4
 803c580:	490b      	ldr	r1, [pc, #44]	; (803c5b0 <psa_aead_test+0x228>)
 803c582:	4817      	ldr	r0, [pc, #92]	; (803c5e0 <psa_aead_test+0x258>)
 803c584:	e76a      	b.n	803c45c <psa_aead_test+0xd4>
 803c586:	4639      	mov	r1, r7
 803c588:	4640      	mov	r0, r8
 803c58a:	f000 f88b 	bl	803c6a4 <memcmp>
    if (comp_result != 0) {
 803c58e:	2800      	cmp	r0, #0
 803c590:	f43f af66 	beq.w	803c460 <psa_aead_test+0xd8>
        TEST_FAIL("Decrypted data doesn't match with plain text");
 803c594:	4623      	mov	r3, r4
 803c596:	f240 22ef 	movw	r2, #751	; 0x2ef
 803c59a:	4905      	ldr	r1, [pc, #20]	; (803c5b0 <psa_aead_test+0x228>)
 803c59c:	4811      	ldr	r0, [pc, #68]	; (803c5e4 <psa_aead_test+0x25c>)
 803c59e:	e75d      	b.n	803c45c <psa_aead_test+0xd4>
 803c5a0:	0803ed2a 	.word	0x0803ed2a
 803c5a4:	0803ef6a 	.word	0x0803ef6a
 803c5a8:	0803ed36 	.word	0x0803ed36
 803c5ac:	0803f197 	.word	0x0803f197
 803c5b0:	0803eb36 	.word	0x0803eb36
 803c5b4:	0803eff4 	.word	0x0803eff4
 803c5b8:	0803f00b 	.word	0x0803f00b
 803c5bc:	0803ef43 	.word	0x0803ef43
 803c5c0:	0803f051 	.word	0x0803f051
 803c5c4:	0803f067 	.word	0x0803f067
 803c5c8:	0803f082 	.word	0x0803f082
 803c5cc:	0803f0b4 	.word	0x0803f0b4
 803c5d0:	0803ed4e 	.word	0x0803ed4e
 803c5d4:	0803ec84 	.word	0x0803ec84
 803c5d8:	0803eca5 	.word	0x0803eca5
 803c5dc:	0803ecd6 	.word	0x0803ecd6
 803c5e0:	0803ecf7 	.word	0x0803ecf7
 803c5e4:	0803eee8 	.word	0x0803eee8

0803c5e8 <print_error>:

    printf("  TEST FAILED!\r\n");
}

static void print_error(const char *err_msg)
{
 803c5e8:	b510      	push	{r4, lr}
 803c5ea:	4604      	mov	r4, r0
    printf_set_color(RED);
 803c5ec:	2001      	movs	r0, #1
 803c5ee:	f000 f81b 	bl	803c628 <printf_set_color>
    printf("Error ( %s )\r\n", err_msg);
 803c5f2:	4621      	mov	r1, r4
}
 803c5f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    printf("Error ( %s )\r\n", err_msg);
 803c5f8:	4801      	ldr	r0, [pc, #4]	; (803c600 <print_error+0x18>)
 803c5fa:	f000 b875 	b.w	803c6e8 <iprintf>
 803c5fe:	bf00      	nop
 803c600:	0803f203 	.word	0x0803f203

0803c604 <set_test_failed>:
    return TEST_SUITE_ERR_NO_ERROR;
}

void set_test_failed(const char *info_msg, const char *filename, uint32_t line,
                     struct test_result_t *ret)
{
 803c604:	b410      	push	{r4}
    if (ret == 0) {
 803c606:	b923      	cbnz	r3, 803c612 <set_test_failed+0xe>
        print_error("TEST_SUITE_ERR_INVALID_TEST_DATA!");
 803c608:	4806      	ldr	r0, [pc, #24]	; (803c624 <set_test_failed+0x20>)

    ret->val = TEST_FAILED;
    ret->info_msg = info_msg;
    ret->filename = filename;
    ret->line = line;
}
 803c60a:	f85d 4b04 	ldr.w	r4, [sp], #4
        print_error("TEST_SUITE_ERR_INVALID_TEST_DATA!");
 803c60e:	f7ff bfeb 	b.w	803c5e8 <print_error>
    ret->val = TEST_FAILED;
 803c612:	2401      	movs	r4, #1
    ret->filename = filename;
 803c614:	e9c3 0101 	strd	r0, r1, [r3, #4]
    ret->val = TEST_FAILED;
 803c618:	701c      	strb	r4, [r3, #0]
    ret->line = line;
 803c61a:	60da      	str	r2, [r3, #12]
}
 803c61c:	f85d 4b04 	ldr.w	r4, [sp], #4
 803c620:	4770      	bx	lr
 803c622:	bf00      	nop
 803c624:	0803f212 	.word	0x0803f212

0803c628 <printf_set_color>:
    }
}

void printf_set_color(enum serial_color_t color_id)
{
    printf("\33[3%dm", color_id);
 803c628:	4601      	mov	r1, r0
 803c62a:	4801      	ldr	r0, [pc, #4]	; (803c630 <printf_set_color+0x8>)
 803c62c:	f000 b85c 	b.w	803c6e8 <iprintf>
 803c630:	0803f234 	.word	0x0803f234

0803c634 <exit>:
 803c634:	b508      	push	{r3, lr}
 803c636:	4b07      	ldr	r3, [pc, #28]	; (803c654 <exit+0x20>)
 803c638:	4604      	mov	r4, r0
 803c63a:	b113      	cbz	r3, 803c642 <exit+0xe>
 803c63c:	2100      	movs	r1, #0
 803c63e:	e000      	b.n	803c642 <exit+0xe>
 803c640:	bf00      	nop
 803c642:	4b05      	ldr	r3, [pc, #20]	; (803c658 <exit+0x24>)
 803c644:	6818      	ldr	r0, [r3, #0]
 803c646:	6a83      	ldr	r3, [r0, #40]	; 0x28
 803c648:	b103      	cbz	r3, 803c64c <exit+0x18>
 803c64a:	4798      	blx	r3
 803c64c:	4620      	mov	r0, r4
 803c64e:	f001 fa27 	bl	803daa0 <_exit>
 803c652:	bf00      	nop
 803c654:	00000000 	.word	0x00000000
 803c658:	0803f23c 	.word	0x0803f23c

0803c65c <__libc_init_array>:
 803c65c:	b570      	push	{r4, r5, r6, lr}
 803c65e:	4e0d      	ldr	r6, [pc, #52]	; (803c694 <__libc_init_array+0x38>)
 803c660:	2500      	movs	r5, #0
 803c662:	4c0d      	ldr	r4, [pc, #52]	; (803c698 <__libc_init_array+0x3c>)
 803c664:	1ba4      	subs	r4, r4, r6
 803c666:	10a4      	asrs	r4, r4, #2
 803c668:	42a5      	cmp	r5, r4
 803c66a:	d109      	bne.n	803c680 <__libc_init_array+0x24>
 803c66c:	4e0b      	ldr	r6, [pc, #44]	; (803c69c <__libc_init_array+0x40>)
 803c66e:	2500      	movs	r5, #0
 803c670:	4c0b      	ldr	r4, [pc, #44]	; (803c6a0 <__libc_init_array+0x44>)
 803c672:	f001 fa17 	bl	803daa4 <_init>
 803c676:	1ba4      	subs	r4, r4, r6
 803c678:	10a4      	asrs	r4, r4, #2
 803c67a:	42a5      	cmp	r5, r4
 803c67c:	d105      	bne.n	803c68a <__libc_init_array+0x2e>
 803c67e:	bd70      	pop	{r4, r5, r6, pc}
 803c680:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 803c684:	3501      	adds	r5, #1
 803c686:	4798      	blx	r3
 803c688:	e7ee      	b.n	803c668 <__libc_init_array+0xc>
 803c68a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 803c68e:	3501      	adds	r5, #1
 803c690:	4798      	blx	r3
 803c692:	e7f2      	b.n	803c67a <__libc_init_array+0x1e>
 803c694:	2000018c 	.word	0x2000018c
 803c698:	2000018c 	.word	0x2000018c
 803c69c:	2000018c 	.word	0x2000018c
 803c6a0:	20000190 	.word	0x20000190

0803c6a4 <memcmp>:
 803c6a4:	b530      	push	{r4, r5, lr}
 803c6a6:	2400      	movs	r4, #0
 803c6a8:	42a2      	cmp	r2, r4
 803c6aa:	d101      	bne.n	803c6b0 <memcmp+0xc>
 803c6ac:	2000      	movs	r0, #0
 803c6ae:	e007      	b.n	803c6c0 <memcmp+0x1c>
 803c6b0:	5d03      	ldrb	r3, [r0, r4]
 803c6b2:	3401      	adds	r4, #1
 803c6b4:	190d      	adds	r5, r1, r4
 803c6b6:	f815 5c01 	ldrb.w	r5, [r5, #-1]
 803c6ba:	42ab      	cmp	r3, r5
 803c6bc:	d0f4      	beq.n	803c6a8 <memcmp+0x4>
 803c6be:	1b58      	subs	r0, r3, r5
 803c6c0:	bd30      	pop	{r4, r5, pc}

0803c6c2 <memcpy>:
 803c6c2:	1e43      	subs	r3, r0, #1
 803c6c4:	440a      	add	r2, r1
 803c6c6:	b510      	push	{r4, lr}
 803c6c8:	4291      	cmp	r1, r2
 803c6ca:	d100      	bne.n	803c6ce <memcpy+0xc>
 803c6cc:	bd10      	pop	{r4, pc}
 803c6ce:	f811 4b01 	ldrb.w	r4, [r1], #1
 803c6d2:	f803 4f01 	strb.w	r4, [r3, #1]!
 803c6d6:	e7f7      	b.n	803c6c8 <memcpy+0x6>

0803c6d8 <memset>:
 803c6d8:	4402      	add	r2, r0
 803c6da:	4603      	mov	r3, r0
 803c6dc:	4293      	cmp	r3, r2
 803c6de:	d100      	bne.n	803c6e2 <memset+0xa>
 803c6e0:	4770      	bx	lr
 803c6e2:	f803 1b01 	strb.w	r1, [r3], #1
 803c6e6:	e7f9      	b.n	803c6dc <memset+0x4>

0803c6e8 <iprintf>:
 803c6e8:	b40f      	push	{r0, r1, r2, r3}
 803c6ea:	4b0a      	ldr	r3, [pc, #40]	; (803c714 <iprintf+0x2c>)
 803c6ec:	b513      	push	{r0, r1, r4, lr}
 803c6ee:	681c      	ldr	r4, [r3, #0]
 803c6f0:	b124      	cbz	r4, 803c6fc <iprintf+0x14>
 803c6f2:	69a3      	ldr	r3, [r4, #24]
 803c6f4:	b913      	cbnz	r3, 803c6fc <iprintf+0x14>
 803c6f6:	4620      	mov	r0, r4
 803c6f8:	f000 fade 	bl	803ccb8 <__sinit>
 803c6fc:	ab05      	add	r3, sp, #20
 803c6fe:	9a04      	ldr	r2, [sp, #16]
 803c700:	68a1      	ldr	r1, [r4, #8]
 803c702:	4620      	mov	r0, r4
 803c704:	9301      	str	r3, [sp, #4]
 803c706:	f000 fc9f 	bl	803d048 <_vfiprintf_r>
 803c70a:	b002      	add	sp, #8
 803c70c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 803c710:	b004      	add	sp, #16
 803c712:	4770      	bx	lr
 803c714:	20000128 	.word	0x20000128

0803c718 <_puts_r>:
 803c718:	b570      	push	{r4, r5, r6, lr}
 803c71a:	460e      	mov	r6, r1
 803c71c:	4605      	mov	r5, r0
 803c71e:	b118      	cbz	r0, 803c728 <_puts_r+0x10>
 803c720:	6983      	ldr	r3, [r0, #24]
 803c722:	b90b      	cbnz	r3, 803c728 <_puts_r+0x10>
 803c724:	f000 fac8 	bl	803ccb8 <__sinit>
 803c728:	69ab      	ldr	r3, [r5, #24]
 803c72a:	68ac      	ldr	r4, [r5, #8]
 803c72c:	b913      	cbnz	r3, 803c734 <_puts_r+0x1c>
 803c72e:	4628      	mov	r0, r5
 803c730:	f000 fac2 	bl	803ccb8 <__sinit>
 803c734:	4b23      	ldr	r3, [pc, #140]	; (803c7c4 <_puts_r+0xac>)
 803c736:	429c      	cmp	r4, r3
 803c738:	d117      	bne.n	803c76a <_puts_r+0x52>
 803c73a:	686c      	ldr	r4, [r5, #4]
 803c73c:	89a3      	ldrh	r3, [r4, #12]
 803c73e:	071b      	lsls	r3, r3, #28
 803c740:	d51d      	bpl.n	803c77e <_puts_r+0x66>
 803c742:	6923      	ldr	r3, [r4, #16]
 803c744:	b1db      	cbz	r3, 803c77e <_puts_r+0x66>
 803c746:	3e01      	subs	r6, #1
 803c748:	68a3      	ldr	r3, [r4, #8]
 803c74a:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 803c74e:	3b01      	subs	r3, #1
 803c750:	60a3      	str	r3, [r4, #8]
 803c752:	b9e9      	cbnz	r1, 803c790 <_puts_r+0x78>
 803c754:	2b00      	cmp	r3, #0
 803c756:	da2e      	bge.n	803c7b6 <_puts_r+0x9e>
 803c758:	4622      	mov	r2, r4
 803c75a:	210a      	movs	r1, #10
 803c75c:	4628      	mov	r0, r5
 803c75e:	f000 f8fd 	bl	803c95c <__swbuf_r>
 803c762:	3001      	adds	r0, #1
 803c764:	d011      	beq.n	803c78a <_puts_r+0x72>
 803c766:	200a      	movs	r0, #10
 803c768:	e011      	b.n	803c78e <_puts_r+0x76>
 803c76a:	4b17      	ldr	r3, [pc, #92]	; (803c7c8 <_puts_r+0xb0>)
 803c76c:	429c      	cmp	r4, r3
 803c76e:	d101      	bne.n	803c774 <_puts_r+0x5c>
 803c770:	68ac      	ldr	r4, [r5, #8]
 803c772:	e7e3      	b.n	803c73c <_puts_r+0x24>
 803c774:	4b15      	ldr	r3, [pc, #84]	; (803c7cc <_puts_r+0xb4>)
 803c776:	429c      	cmp	r4, r3
 803c778:	bf08      	it	eq
 803c77a:	68ec      	ldreq	r4, [r5, #12]
 803c77c:	e7de      	b.n	803c73c <_puts_r+0x24>
 803c77e:	4621      	mov	r1, r4
 803c780:	4628      	mov	r0, r5
 803c782:	f000 f93d 	bl	803ca00 <__swsetup_r>
 803c786:	2800      	cmp	r0, #0
 803c788:	d0dd      	beq.n	803c746 <_puts_r+0x2e>
 803c78a:	f04f 30ff 	mov.w	r0, #4294967295
 803c78e:	bd70      	pop	{r4, r5, r6, pc}
 803c790:	2b00      	cmp	r3, #0
 803c792:	da04      	bge.n	803c79e <_puts_r+0x86>
 803c794:	69a2      	ldr	r2, [r4, #24]
 803c796:	429a      	cmp	r2, r3
 803c798:	dc06      	bgt.n	803c7a8 <_puts_r+0x90>
 803c79a:	290a      	cmp	r1, #10
 803c79c:	d004      	beq.n	803c7a8 <_puts_r+0x90>
 803c79e:	6823      	ldr	r3, [r4, #0]
 803c7a0:	1c5a      	adds	r2, r3, #1
 803c7a2:	6022      	str	r2, [r4, #0]
 803c7a4:	7019      	strb	r1, [r3, #0]
 803c7a6:	e7cf      	b.n	803c748 <_puts_r+0x30>
 803c7a8:	4622      	mov	r2, r4
 803c7aa:	4628      	mov	r0, r5
 803c7ac:	f000 f8d6 	bl	803c95c <__swbuf_r>
 803c7b0:	3001      	adds	r0, #1
 803c7b2:	d1c9      	bne.n	803c748 <_puts_r+0x30>
 803c7b4:	e7e9      	b.n	803c78a <_puts_r+0x72>
 803c7b6:	6823      	ldr	r3, [r4, #0]
 803c7b8:	200a      	movs	r0, #10
 803c7ba:	1c5a      	adds	r2, r3, #1
 803c7bc:	6022      	str	r2, [r4, #0]
 803c7be:	7018      	strb	r0, [r3, #0]
 803c7c0:	e7e5      	b.n	803c78e <_puts_r+0x76>
 803c7c2:	bf00      	nop
 803c7c4:	0803f260 	.word	0x0803f260
 803c7c8:	0803f280 	.word	0x0803f280
 803c7cc:	0803f240 	.word	0x0803f240

0803c7d0 <puts>:
 803c7d0:	4b02      	ldr	r3, [pc, #8]	; (803c7dc <puts+0xc>)
 803c7d2:	4601      	mov	r1, r0
 803c7d4:	6818      	ldr	r0, [r3, #0]
 803c7d6:	f7ff bf9f 	b.w	803c718 <_puts_r>
 803c7da:	bf00      	nop
 803c7dc:	20000128 	.word	0x20000128

0803c7e0 <setvbuf>:
 803c7e0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 803c7e4:	461d      	mov	r5, r3
 803c7e6:	4b50      	ldr	r3, [pc, #320]	; (803c928 <setvbuf+0x148>)
 803c7e8:	4604      	mov	r4, r0
 803c7ea:	460f      	mov	r7, r1
 803c7ec:	681e      	ldr	r6, [r3, #0]
 803c7ee:	4690      	mov	r8, r2
 803c7f0:	b126      	cbz	r6, 803c7fc <setvbuf+0x1c>
 803c7f2:	69b3      	ldr	r3, [r6, #24]
 803c7f4:	b913      	cbnz	r3, 803c7fc <setvbuf+0x1c>
 803c7f6:	4630      	mov	r0, r6
 803c7f8:	f000 fa5e 	bl	803ccb8 <__sinit>
 803c7fc:	4b4b      	ldr	r3, [pc, #300]	; (803c92c <setvbuf+0x14c>)
 803c7fe:	429c      	cmp	r4, r3
 803c800:	d152      	bne.n	803c8a8 <setvbuf+0xc8>
 803c802:	6874      	ldr	r4, [r6, #4]
 803c804:	f1b8 0f02 	cmp.w	r8, #2
 803c808:	d006      	beq.n	803c818 <setvbuf+0x38>
 803c80a:	f1b8 0f01 	cmp.w	r8, #1
 803c80e:	f200 8088 	bhi.w	803c922 <setvbuf+0x142>
 803c812:	2d00      	cmp	r5, #0
 803c814:	f2c0 8085 	blt.w	803c922 <setvbuf+0x142>
 803c818:	4621      	mov	r1, r4
 803c81a:	4630      	mov	r0, r6
 803c81c:	f000 f9e2 	bl	803cbe4 <_fflush_r>
 803c820:	6b61      	ldr	r1, [r4, #52]	; 0x34
 803c822:	b141      	cbz	r1, 803c836 <setvbuf+0x56>
 803c824:	f104 0344 	add.w	r3, r4, #68	; 0x44
 803c828:	4299      	cmp	r1, r3
 803c82a:	d002      	beq.n	803c832 <setvbuf+0x52>
 803c82c:	4630      	mov	r0, r6
 803c82e:	f000 fb39 	bl	803cea4 <_free_r>
 803c832:	2300      	movs	r3, #0
 803c834:	6363      	str	r3, [r4, #52]	; 0x34
 803c836:	2300      	movs	r3, #0
 803c838:	61a3      	str	r3, [r4, #24]
 803c83a:	6063      	str	r3, [r4, #4]
 803c83c:	89a3      	ldrh	r3, [r4, #12]
 803c83e:	061b      	lsls	r3, r3, #24
 803c840:	d503      	bpl.n	803c84a <setvbuf+0x6a>
 803c842:	6921      	ldr	r1, [r4, #16]
 803c844:	4630      	mov	r0, r6
 803c846:	f000 fb2d 	bl	803cea4 <_free_r>
 803c84a:	89a3      	ldrh	r3, [r4, #12]
 803c84c:	f1b8 0f02 	cmp.w	r8, #2
 803c850:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
 803c854:	f023 0303 	bic.w	r3, r3, #3
 803c858:	81a3      	strh	r3, [r4, #12]
 803c85a:	d05c      	beq.n	803c916 <setvbuf+0x136>
 803c85c:	ab01      	add	r3, sp, #4
 803c85e:	466a      	mov	r2, sp
 803c860:	4621      	mov	r1, r4
 803c862:	4630      	mov	r0, r6
 803c864:	f000 fab2 	bl	803cdcc <__swhatbuf_r>
 803c868:	89a3      	ldrh	r3, [r4, #12]
 803c86a:	4318      	orrs	r0, r3
 803c86c:	81a0      	strh	r0, [r4, #12]
 803c86e:	bb2d      	cbnz	r5, 803c8bc <setvbuf+0xdc>
 803c870:	9d00      	ldr	r5, [sp, #0]
 803c872:	4628      	mov	r0, r5
 803c874:	f000 fb0e 	bl	803ce94 <malloc>
 803c878:	4607      	mov	r7, r0
 803c87a:	2800      	cmp	r0, #0
 803c87c:	d14d      	bne.n	803c91a <setvbuf+0x13a>
 803c87e:	f8dd 9000 	ldr.w	r9, [sp]
 803c882:	45a9      	cmp	r9, r5
 803c884:	d13b      	bne.n	803c8fe <setvbuf+0x11e>
 803c886:	f04f 30ff 	mov.w	r0, #4294967295
 803c88a:	89a3      	ldrh	r3, [r4, #12]
 803c88c:	f043 0302 	orr.w	r3, r3, #2
 803c890:	81a3      	strh	r3, [r4, #12]
 803c892:	2300      	movs	r3, #0
 803c894:	60a3      	str	r3, [r4, #8]
 803c896:	f104 0347 	add.w	r3, r4, #71	; 0x47
 803c89a:	6023      	str	r3, [r4, #0]
 803c89c:	6123      	str	r3, [r4, #16]
 803c89e:	2301      	movs	r3, #1
 803c8a0:	6163      	str	r3, [r4, #20]
 803c8a2:	b003      	add	sp, #12
 803c8a4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 803c8a8:	4b21      	ldr	r3, [pc, #132]	; (803c930 <setvbuf+0x150>)
 803c8aa:	429c      	cmp	r4, r3
 803c8ac:	d101      	bne.n	803c8b2 <setvbuf+0xd2>
 803c8ae:	68b4      	ldr	r4, [r6, #8]
 803c8b0:	e7a8      	b.n	803c804 <setvbuf+0x24>
 803c8b2:	4b20      	ldr	r3, [pc, #128]	; (803c934 <setvbuf+0x154>)
 803c8b4:	429c      	cmp	r4, r3
 803c8b6:	bf08      	it	eq
 803c8b8:	68f4      	ldreq	r4, [r6, #12]
 803c8ba:	e7a3      	b.n	803c804 <setvbuf+0x24>
 803c8bc:	2f00      	cmp	r7, #0
 803c8be:	d0d8      	beq.n	803c872 <setvbuf+0x92>
 803c8c0:	69b3      	ldr	r3, [r6, #24]
 803c8c2:	b913      	cbnz	r3, 803c8ca <setvbuf+0xea>
 803c8c4:	4630      	mov	r0, r6
 803c8c6:	f000 f9f7 	bl	803ccb8 <__sinit>
 803c8ca:	f1b8 0f01 	cmp.w	r8, #1
 803c8ce:	6027      	str	r7, [r4, #0]
 803c8d0:	bf02      	ittt	eq
 803c8d2:	89a3      	ldrheq	r3, [r4, #12]
 803c8d4:	f043 0301 	orreq.w	r3, r3, #1
 803c8d8:	81a3      	strheq	r3, [r4, #12]
 803c8da:	89a3      	ldrh	r3, [r4, #12]
 803c8dc:	f013 0008 	ands.w	r0, r3, #8
 803c8e0:	e9c4 7504 	strd	r7, r5, [r4, #16]
 803c8e4:	d01b      	beq.n	803c91e <setvbuf+0x13e>
 803c8e6:	f013 0001 	ands.w	r0, r3, #1
 803c8ea:	f04f 0300 	mov.w	r3, #0
 803c8ee:	bf1d      	ittte	ne
 803c8f0:	426d      	negne	r5, r5
 803c8f2:	60a3      	strne	r3, [r4, #8]
 803c8f4:	4618      	movne	r0, r3
 803c8f6:	60a5      	streq	r5, [r4, #8]
 803c8f8:	bf18      	it	ne
 803c8fa:	61a5      	strne	r5, [r4, #24]
 803c8fc:	e7d1      	b.n	803c8a2 <setvbuf+0xc2>
 803c8fe:	4648      	mov	r0, r9
 803c900:	f000 fac8 	bl	803ce94 <malloc>
 803c904:	4607      	mov	r7, r0
 803c906:	2800      	cmp	r0, #0
 803c908:	d0bd      	beq.n	803c886 <setvbuf+0xa6>
 803c90a:	89a3      	ldrh	r3, [r4, #12]
 803c90c:	464d      	mov	r5, r9
 803c90e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 803c912:	81a3      	strh	r3, [r4, #12]
 803c914:	e7d4      	b.n	803c8c0 <setvbuf+0xe0>
 803c916:	2000      	movs	r0, #0
 803c918:	e7b7      	b.n	803c88a <setvbuf+0xaa>
 803c91a:	46a9      	mov	r9, r5
 803c91c:	e7f5      	b.n	803c90a <setvbuf+0x12a>
 803c91e:	60a0      	str	r0, [r4, #8]
 803c920:	e7bf      	b.n	803c8a2 <setvbuf+0xc2>
 803c922:	f04f 30ff 	mov.w	r0, #4294967295
 803c926:	e7bc      	b.n	803c8a2 <setvbuf+0xc2>
 803c928:	20000128 	.word	0x20000128
 803c92c:	0803f260 	.word	0x0803f260
 803c930:	0803f280 	.word	0x0803f280
 803c934:	0803f240 	.word	0x0803f240

0803c938 <strncmp>:
 803c938:	b510      	push	{r4, lr}
 803c93a:	b16a      	cbz	r2, 803c958 <strncmp+0x20>
 803c93c:	3901      	subs	r1, #1
 803c93e:	1884      	adds	r4, r0, r2
 803c940:	f810 3b01 	ldrb.w	r3, [r0], #1
 803c944:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 803c948:	4293      	cmp	r3, r2
 803c94a:	d103      	bne.n	803c954 <strncmp+0x1c>
 803c94c:	42a0      	cmp	r0, r4
 803c94e:	d001      	beq.n	803c954 <strncmp+0x1c>
 803c950:	2b00      	cmp	r3, #0
 803c952:	d1f5      	bne.n	803c940 <strncmp+0x8>
 803c954:	1a98      	subs	r0, r3, r2
 803c956:	bd10      	pop	{r4, pc}
 803c958:	4610      	mov	r0, r2
 803c95a:	e7fc      	b.n	803c956 <strncmp+0x1e>

0803c95c <__swbuf_r>:
 803c95c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803c95e:	460e      	mov	r6, r1
 803c960:	4614      	mov	r4, r2
 803c962:	4605      	mov	r5, r0
 803c964:	b118      	cbz	r0, 803c96e <__swbuf_r+0x12>
 803c966:	6983      	ldr	r3, [r0, #24]
 803c968:	b90b      	cbnz	r3, 803c96e <__swbuf_r+0x12>
 803c96a:	f000 f9a5 	bl	803ccb8 <__sinit>
 803c96e:	4b21      	ldr	r3, [pc, #132]	; (803c9f4 <__swbuf_r+0x98>)
 803c970:	429c      	cmp	r4, r3
 803c972:	d12a      	bne.n	803c9ca <__swbuf_r+0x6e>
 803c974:	686c      	ldr	r4, [r5, #4]
 803c976:	69a3      	ldr	r3, [r4, #24]
 803c978:	60a3      	str	r3, [r4, #8]
 803c97a:	89a3      	ldrh	r3, [r4, #12]
 803c97c:	071a      	lsls	r2, r3, #28
 803c97e:	d52e      	bpl.n	803c9de <__swbuf_r+0x82>
 803c980:	6923      	ldr	r3, [r4, #16]
 803c982:	b363      	cbz	r3, 803c9de <__swbuf_r+0x82>
 803c984:	6923      	ldr	r3, [r4, #16]
 803c986:	b2f6      	uxtb	r6, r6
 803c988:	6820      	ldr	r0, [r4, #0]
 803c98a:	4637      	mov	r7, r6
 803c98c:	1ac0      	subs	r0, r0, r3
 803c98e:	6963      	ldr	r3, [r4, #20]
 803c990:	4283      	cmp	r3, r0
 803c992:	dc04      	bgt.n	803c99e <__swbuf_r+0x42>
 803c994:	4621      	mov	r1, r4
 803c996:	4628      	mov	r0, r5
 803c998:	f000 f924 	bl	803cbe4 <_fflush_r>
 803c99c:	bb28      	cbnz	r0, 803c9ea <__swbuf_r+0x8e>
 803c99e:	68a3      	ldr	r3, [r4, #8]
 803c9a0:	3001      	adds	r0, #1
 803c9a2:	3b01      	subs	r3, #1
 803c9a4:	60a3      	str	r3, [r4, #8]
 803c9a6:	6823      	ldr	r3, [r4, #0]
 803c9a8:	1c5a      	adds	r2, r3, #1
 803c9aa:	6022      	str	r2, [r4, #0]
 803c9ac:	701e      	strb	r6, [r3, #0]
 803c9ae:	6963      	ldr	r3, [r4, #20]
 803c9b0:	4283      	cmp	r3, r0
 803c9b2:	d004      	beq.n	803c9be <__swbuf_r+0x62>
 803c9b4:	89a3      	ldrh	r3, [r4, #12]
 803c9b6:	07db      	lsls	r3, r3, #31
 803c9b8:	d519      	bpl.n	803c9ee <__swbuf_r+0x92>
 803c9ba:	2e0a      	cmp	r6, #10
 803c9bc:	d117      	bne.n	803c9ee <__swbuf_r+0x92>
 803c9be:	4621      	mov	r1, r4
 803c9c0:	4628      	mov	r0, r5
 803c9c2:	f000 f90f 	bl	803cbe4 <_fflush_r>
 803c9c6:	b190      	cbz	r0, 803c9ee <__swbuf_r+0x92>
 803c9c8:	e00f      	b.n	803c9ea <__swbuf_r+0x8e>
 803c9ca:	4b0b      	ldr	r3, [pc, #44]	; (803c9f8 <__swbuf_r+0x9c>)
 803c9cc:	429c      	cmp	r4, r3
 803c9ce:	d101      	bne.n	803c9d4 <__swbuf_r+0x78>
 803c9d0:	68ac      	ldr	r4, [r5, #8]
 803c9d2:	e7d0      	b.n	803c976 <__swbuf_r+0x1a>
 803c9d4:	4b09      	ldr	r3, [pc, #36]	; (803c9fc <__swbuf_r+0xa0>)
 803c9d6:	429c      	cmp	r4, r3
 803c9d8:	bf08      	it	eq
 803c9da:	68ec      	ldreq	r4, [r5, #12]
 803c9dc:	e7cb      	b.n	803c976 <__swbuf_r+0x1a>
 803c9de:	4621      	mov	r1, r4
 803c9e0:	4628      	mov	r0, r5
 803c9e2:	f000 f80d 	bl	803ca00 <__swsetup_r>
 803c9e6:	2800      	cmp	r0, #0
 803c9e8:	d0cc      	beq.n	803c984 <__swbuf_r+0x28>
 803c9ea:	f04f 37ff 	mov.w	r7, #4294967295
 803c9ee:	4638      	mov	r0, r7
 803c9f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 803c9f2:	bf00      	nop
 803c9f4:	0803f260 	.word	0x0803f260
 803c9f8:	0803f280 	.word	0x0803f280
 803c9fc:	0803f240 	.word	0x0803f240

0803ca00 <__swsetup_r>:
 803ca00:	4b32      	ldr	r3, [pc, #200]	; (803cacc <__swsetup_r+0xcc>)
 803ca02:	b570      	push	{r4, r5, r6, lr}
 803ca04:	681d      	ldr	r5, [r3, #0]
 803ca06:	4606      	mov	r6, r0
 803ca08:	460c      	mov	r4, r1
 803ca0a:	b125      	cbz	r5, 803ca16 <__swsetup_r+0x16>
 803ca0c:	69ab      	ldr	r3, [r5, #24]
 803ca0e:	b913      	cbnz	r3, 803ca16 <__swsetup_r+0x16>
 803ca10:	4628      	mov	r0, r5
 803ca12:	f000 f951 	bl	803ccb8 <__sinit>
 803ca16:	4b2e      	ldr	r3, [pc, #184]	; (803cad0 <__swsetup_r+0xd0>)
 803ca18:	429c      	cmp	r4, r3
 803ca1a:	d10f      	bne.n	803ca3c <__swsetup_r+0x3c>
 803ca1c:	686c      	ldr	r4, [r5, #4]
 803ca1e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 803ca22:	b29a      	uxth	r2, r3
 803ca24:	0715      	lsls	r5, r2, #28
 803ca26:	d42c      	bmi.n	803ca82 <__swsetup_r+0x82>
 803ca28:	06d0      	lsls	r0, r2, #27
 803ca2a:	d411      	bmi.n	803ca50 <__swsetup_r+0x50>
 803ca2c:	2209      	movs	r2, #9
 803ca2e:	6032      	str	r2, [r6, #0]
 803ca30:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 803ca34:	f04f 30ff 	mov.w	r0, #4294967295
 803ca38:	81a3      	strh	r3, [r4, #12]
 803ca3a:	e03e      	b.n	803caba <__swsetup_r+0xba>
 803ca3c:	4b25      	ldr	r3, [pc, #148]	; (803cad4 <__swsetup_r+0xd4>)
 803ca3e:	429c      	cmp	r4, r3
 803ca40:	d101      	bne.n	803ca46 <__swsetup_r+0x46>
 803ca42:	68ac      	ldr	r4, [r5, #8]
 803ca44:	e7eb      	b.n	803ca1e <__swsetup_r+0x1e>
 803ca46:	4b24      	ldr	r3, [pc, #144]	; (803cad8 <__swsetup_r+0xd8>)
 803ca48:	429c      	cmp	r4, r3
 803ca4a:	bf08      	it	eq
 803ca4c:	68ec      	ldreq	r4, [r5, #12]
 803ca4e:	e7e6      	b.n	803ca1e <__swsetup_r+0x1e>
 803ca50:	0751      	lsls	r1, r2, #29
 803ca52:	d512      	bpl.n	803ca7a <__swsetup_r+0x7a>
 803ca54:	6b61      	ldr	r1, [r4, #52]	; 0x34
 803ca56:	b141      	cbz	r1, 803ca6a <__swsetup_r+0x6a>
 803ca58:	f104 0344 	add.w	r3, r4, #68	; 0x44
 803ca5c:	4299      	cmp	r1, r3
 803ca5e:	d002      	beq.n	803ca66 <__swsetup_r+0x66>
 803ca60:	4630      	mov	r0, r6
 803ca62:	f000 fa1f 	bl	803cea4 <_free_r>
 803ca66:	2300      	movs	r3, #0
 803ca68:	6363      	str	r3, [r4, #52]	; 0x34
 803ca6a:	89a3      	ldrh	r3, [r4, #12]
 803ca6c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 803ca70:	81a3      	strh	r3, [r4, #12]
 803ca72:	2300      	movs	r3, #0
 803ca74:	6063      	str	r3, [r4, #4]
 803ca76:	6923      	ldr	r3, [r4, #16]
 803ca78:	6023      	str	r3, [r4, #0]
 803ca7a:	89a3      	ldrh	r3, [r4, #12]
 803ca7c:	f043 0308 	orr.w	r3, r3, #8
 803ca80:	81a3      	strh	r3, [r4, #12]
 803ca82:	6923      	ldr	r3, [r4, #16]
 803ca84:	b94b      	cbnz	r3, 803ca9a <__swsetup_r+0x9a>
 803ca86:	89a3      	ldrh	r3, [r4, #12]
 803ca88:	f403 7320 	and.w	r3, r3, #640	; 0x280
 803ca8c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 803ca90:	d003      	beq.n	803ca9a <__swsetup_r+0x9a>
 803ca92:	4621      	mov	r1, r4
 803ca94:	4630      	mov	r0, r6
 803ca96:	f000 f9bd 	bl	803ce14 <__smakebuf_r>
 803ca9a:	89a2      	ldrh	r2, [r4, #12]
 803ca9c:	f012 0301 	ands.w	r3, r2, #1
 803caa0:	d00c      	beq.n	803cabc <__swsetup_r+0xbc>
 803caa2:	2300      	movs	r3, #0
 803caa4:	60a3      	str	r3, [r4, #8]
 803caa6:	6963      	ldr	r3, [r4, #20]
 803caa8:	425b      	negs	r3, r3
 803caaa:	61a3      	str	r3, [r4, #24]
 803caac:	6923      	ldr	r3, [r4, #16]
 803caae:	b953      	cbnz	r3, 803cac6 <__swsetup_r+0xc6>
 803cab0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 803cab4:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 803cab8:	d1ba      	bne.n	803ca30 <__swsetup_r+0x30>
 803caba:	bd70      	pop	{r4, r5, r6, pc}
 803cabc:	0792      	lsls	r2, r2, #30
 803cabe:	bf58      	it	pl
 803cac0:	6963      	ldrpl	r3, [r4, #20]
 803cac2:	60a3      	str	r3, [r4, #8]
 803cac4:	e7f2      	b.n	803caac <__swsetup_r+0xac>
 803cac6:	2000      	movs	r0, #0
 803cac8:	e7f7      	b.n	803caba <__swsetup_r+0xba>
 803caca:	bf00      	nop
 803cacc:	20000128 	.word	0x20000128
 803cad0:	0803f260 	.word	0x0803f260
 803cad4:	0803f280 	.word	0x0803f280
 803cad8:	0803f240 	.word	0x0803f240

0803cadc <__sflush_r>:
 803cadc:	898a      	ldrh	r2, [r1, #12]
 803cade:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 803cae2:	4605      	mov	r5, r0
 803cae4:	0710      	lsls	r0, r2, #28
 803cae6:	460c      	mov	r4, r1
 803cae8:	d458      	bmi.n	803cb9c <__sflush_r+0xc0>
 803caea:	684b      	ldr	r3, [r1, #4]
 803caec:	2b00      	cmp	r3, #0
 803caee:	dc05      	bgt.n	803cafc <__sflush_r+0x20>
 803caf0:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 803caf2:	2b00      	cmp	r3, #0
 803caf4:	dc02      	bgt.n	803cafc <__sflush_r+0x20>
 803caf6:	2000      	movs	r0, #0
 803caf8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 803cafc:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 803cafe:	2e00      	cmp	r6, #0
 803cb00:	d0f9      	beq.n	803caf6 <__sflush_r+0x1a>
 803cb02:	2300      	movs	r3, #0
 803cb04:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 803cb08:	682f      	ldr	r7, [r5, #0]
 803cb0a:	6a21      	ldr	r1, [r4, #32]
 803cb0c:	602b      	str	r3, [r5, #0]
 803cb0e:	d032      	beq.n	803cb76 <__sflush_r+0x9a>
 803cb10:	6d60      	ldr	r0, [r4, #84]	; 0x54
 803cb12:	89a3      	ldrh	r3, [r4, #12]
 803cb14:	075a      	lsls	r2, r3, #29
 803cb16:	d505      	bpl.n	803cb24 <__sflush_r+0x48>
 803cb18:	6863      	ldr	r3, [r4, #4]
 803cb1a:	1ac0      	subs	r0, r0, r3
 803cb1c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 803cb1e:	b10b      	cbz	r3, 803cb24 <__sflush_r+0x48>
 803cb20:	6c23      	ldr	r3, [r4, #64]	; 0x40
 803cb22:	1ac0      	subs	r0, r0, r3
 803cb24:	2300      	movs	r3, #0
 803cb26:	4602      	mov	r2, r0
 803cb28:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 803cb2a:	4628      	mov	r0, r5
 803cb2c:	6a21      	ldr	r1, [r4, #32]
 803cb2e:	47b0      	blx	r6
 803cb30:	1c43      	adds	r3, r0, #1
 803cb32:	89a3      	ldrh	r3, [r4, #12]
 803cb34:	d106      	bne.n	803cb44 <__sflush_r+0x68>
 803cb36:	6829      	ldr	r1, [r5, #0]
 803cb38:	291d      	cmp	r1, #29
 803cb3a:	d847      	bhi.n	803cbcc <__sflush_r+0xf0>
 803cb3c:	4a28      	ldr	r2, [pc, #160]	; (803cbe0 <__sflush_r+0x104>)
 803cb3e:	40ca      	lsrs	r2, r1
 803cb40:	07d6      	lsls	r6, r2, #31
 803cb42:	d543      	bpl.n	803cbcc <__sflush_r+0xf0>
 803cb44:	2200      	movs	r2, #0
 803cb46:	04d9      	lsls	r1, r3, #19
 803cb48:	6062      	str	r2, [r4, #4]
 803cb4a:	6922      	ldr	r2, [r4, #16]
 803cb4c:	6022      	str	r2, [r4, #0]
 803cb4e:	d504      	bpl.n	803cb5a <__sflush_r+0x7e>
 803cb50:	1c42      	adds	r2, r0, #1
 803cb52:	d101      	bne.n	803cb58 <__sflush_r+0x7c>
 803cb54:	682b      	ldr	r3, [r5, #0]
 803cb56:	b903      	cbnz	r3, 803cb5a <__sflush_r+0x7e>
 803cb58:	6560      	str	r0, [r4, #84]	; 0x54
 803cb5a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 803cb5c:	602f      	str	r7, [r5, #0]
 803cb5e:	2900      	cmp	r1, #0
 803cb60:	d0c9      	beq.n	803caf6 <__sflush_r+0x1a>
 803cb62:	f104 0344 	add.w	r3, r4, #68	; 0x44
 803cb66:	4299      	cmp	r1, r3
 803cb68:	d002      	beq.n	803cb70 <__sflush_r+0x94>
 803cb6a:	4628      	mov	r0, r5
 803cb6c:	f000 f99a 	bl	803cea4 <_free_r>
 803cb70:	2000      	movs	r0, #0
 803cb72:	6360      	str	r0, [r4, #52]	; 0x34
 803cb74:	e7c0      	b.n	803caf8 <__sflush_r+0x1c>
 803cb76:	2301      	movs	r3, #1
 803cb78:	4628      	mov	r0, r5
 803cb7a:	47b0      	blx	r6
 803cb7c:	1c41      	adds	r1, r0, #1
 803cb7e:	d1c8      	bne.n	803cb12 <__sflush_r+0x36>
 803cb80:	682b      	ldr	r3, [r5, #0]
 803cb82:	2b00      	cmp	r3, #0
 803cb84:	d0c5      	beq.n	803cb12 <__sflush_r+0x36>
 803cb86:	2b1d      	cmp	r3, #29
 803cb88:	d001      	beq.n	803cb8e <__sflush_r+0xb2>
 803cb8a:	2b16      	cmp	r3, #22
 803cb8c:	d101      	bne.n	803cb92 <__sflush_r+0xb6>
 803cb8e:	602f      	str	r7, [r5, #0]
 803cb90:	e7b1      	b.n	803caf6 <__sflush_r+0x1a>
 803cb92:	89a3      	ldrh	r3, [r4, #12]
 803cb94:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 803cb98:	81a3      	strh	r3, [r4, #12]
 803cb9a:	e7ad      	b.n	803caf8 <__sflush_r+0x1c>
 803cb9c:	690f      	ldr	r7, [r1, #16]
 803cb9e:	2f00      	cmp	r7, #0
 803cba0:	d0a9      	beq.n	803caf6 <__sflush_r+0x1a>
 803cba2:	0793      	lsls	r3, r2, #30
 803cba4:	680e      	ldr	r6, [r1, #0]
 803cba6:	600f      	str	r7, [r1, #0]
 803cba8:	bf0c      	ite	eq
 803cbaa:	694b      	ldreq	r3, [r1, #20]
 803cbac:	2300      	movne	r3, #0
 803cbae:	eba6 0807 	sub.w	r8, r6, r7
 803cbb2:	608b      	str	r3, [r1, #8]
 803cbb4:	f1b8 0f00 	cmp.w	r8, #0
 803cbb8:	dd9d      	ble.n	803caf6 <__sflush_r+0x1a>
 803cbba:	4643      	mov	r3, r8
 803cbbc:	463a      	mov	r2, r7
 803cbbe:	6a21      	ldr	r1, [r4, #32]
 803cbc0:	4628      	mov	r0, r5
 803cbc2:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 803cbc4:	47b0      	blx	r6
 803cbc6:	2800      	cmp	r0, #0
 803cbc8:	dc06      	bgt.n	803cbd8 <__sflush_r+0xfc>
 803cbca:	89a3      	ldrh	r3, [r4, #12]
 803cbcc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 803cbd0:	f04f 30ff 	mov.w	r0, #4294967295
 803cbd4:	81a3      	strh	r3, [r4, #12]
 803cbd6:	e78f      	b.n	803caf8 <__sflush_r+0x1c>
 803cbd8:	4407      	add	r7, r0
 803cbda:	eba8 0800 	sub.w	r8, r8, r0
 803cbde:	e7e9      	b.n	803cbb4 <__sflush_r+0xd8>
 803cbe0:	20400001 	.word	0x20400001

0803cbe4 <_fflush_r>:
 803cbe4:	b538      	push	{r3, r4, r5, lr}
 803cbe6:	690b      	ldr	r3, [r1, #16]
 803cbe8:	4605      	mov	r5, r0
 803cbea:	460c      	mov	r4, r1
 803cbec:	b1db      	cbz	r3, 803cc26 <_fflush_r+0x42>
 803cbee:	b118      	cbz	r0, 803cbf8 <_fflush_r+0x14>
 803cbf0:	6983      	ldr	r3, [r0, #24]
 803cbf2:	b90b      	cbnz	r3, 803cbf8 <_fflush_r+0x14>
 803cbf4:	f000 f860 	bl	803ccb8 <__sinit>
 803cbf8:	4b0c      	ldr	r3, [pc, #48]	; (803cc2c <_fflush_r+0x48>)
 803cbfa:	429c      	cmp	r4, r3
 803cbfc:	d109      	bne.n	803cc12 <_fflush_r+0x2e>
 803cbfe:	686c      	ldr	r4, [r5, #4]
 803cc00:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 803cc04:	b17b      	cbz	r3, 803cc26 <_fflush_r+0x42>
 803cc06:	4621      	mov	r1, r4
 803cc08:	4628      	mov	r0, r5
 803cc0a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 803cc0e:	f7ff bf65 	b.w	803cadc <__sflush_r>
 803cc12:	4b07      	ldr	r3, [pc, #28]	; (803cc30 <_fflush_r+0x4c>)
 803cc14:	429c      	cmp	r4, r3
 803cc16:	d101      	bne.n	803cc1c <_fflush_r+0x38>
 803cc18:	68ac      	ldr	r4, [r5, #8]
 803cc1a:	e7f1      	b.n	803cc00 <_fflush_r+0x1c>
 803cc1c:	4b05      	ldr	r3, [pc, #20]	; (803cc34 <_fflush_r+0x50>)
 803cc1e:	429c      	cmp	r4, r3
 803cc20:	bf08      	it	eq
 803cc22:	68ec      	ldreq	r4, [r5, #12]
 803cc24:	e7ec      	b.n	803cc00 <_fflush_r+0x1c>
 803cc26:	2000      	movs	r0, #0
 803cc28:	bd38      	pop	{r3, r4, r5, pc}
 803cc2a:	bf00      	nop
 803cc2c:	0803f260 	.word	0x0803f260
 803cc30:	0803f280 	.word	0x0803f280
 803cc34:	0803f240 	.word	0x0803f240

0803cc38 <std>:
 803cc38:	2300      	movs	r3, #0
 803cc3a:	b510      	push	{r4, lr}
 803cc3c:	4604      	mov	r4, r0
 803cc3e:	6083      	str	r3, [r0, #8]
 803cc40:	8181      	strh	r1, [r0, #12]
 803cc42:	4619      	mov	r1, r3
 803cc44:	6643      	str	r3, [r0, #100]	; 0x64
 803cc46:	81c2      	strh	r2, [r0, #14]
 803cc48:	2208      	movs	r2, #8
 803cc4a:	6183      	str	r3, [r0, #24]
 803cc4c:	e9c0 3300 	strd	r3, r3, [r0]
 803cc50:	e9c0 3304 	strd	r3, r3, [r0, #16]
 803cc54:	305c      	adds	r0, #92	; 0x5c
 803cc56:	f7ff fd3f 	bl	803c6d8 <memset>
 803cc5a:	4b05      	ldr	r3, [pc, #20]	; (803cc70 <std+0x38>)
 803cc5c:	6224      	str	r4, [r4, #32]
 803cc5e:	6263      	str	r3, [r4, #36]	; 0x24
 803cc60:	4b04      	ldr	r3, [pc, #16]	; (803cc74 <std+0x3c>)
 803cc62:	62a3      	str	r3, [r4, #40]	; 0x28
 803cc64:	4b04      	ldr	r3, [pc, #16]	; (803cc78 <std+0x40>)
 803cc66:	62e3      	str	r3, [r4, #44]	; 0x2c
 803cc68:	4b04      	ldr	r3, [pc, #16]	; (803cc7c <std+0x44>)
 803cc6a:	6323      	str	r3, [r4, #48]	; 0x30
 803cc6c:	bd10      	pop	{r4, pc}
 803cc6e:	bf00      	nop
 803cc70:	0803d5a9 	.word	0x0803d5a9
 803cc74:	0803d5cb 	.word	0x0803d5cb
 803cc78:	0803d603 	.word	0x0803d603
 803cc7c:	0803d627 	.word	0x0803d627

0803cc80 <_cleanup_r>:
 803cc80:	4901      	ldr	r1, [pc, #4]	; (803cc88 <_cleanup_r+0x8>)
 803cc82:	f000 b885 	b.w	803cd90 <_fwalk_reent>
 803cc86:	bf00      	nop
 803cc88:	0803cbe5 	.word	0x0803cbe5

0803cc8c <__sfmoreglue>:
 803cc8c:	b570      	push	{r4, r5, r6, lr}
 803cc8e:	1e4a      	subs	r2, r1, #1
 803cc90:	2568      	movs	r5, #104	; 0x68
 803cc92:	460e      	mov	r6, r1
 803cc94:	4355      	muls	r5, r2
 803cc96:	f105 0174 	add.w	r1, r5, #116	; 0x74
 803cc9a:	f000 f951 	bl	803cf40 <_malloc_r>
 803cc9e:	4604      	mov	r4, r0
 803cca0:	b140      	cbz	r0, 803ccb4 <__sfmoreglue+0x28>
 803cca2:	2100      	movs	r1, #0
 803cca4:	f105 0268 	add.w	r2, r5, #104	; 0x68
 803cca8:	e9c0 1600 	strd	r1, r6, [r0]
 803ccac:	300c      	adds	r0, #12
 803ccae:	60a0      	str	r0, [r4, #8]
 803ccb0:	f7ff fd12 	bl	803c6d8 <memset>
 803ccb4:	4620      	mov	r0, r4
 803ccb6:	bd70      	pop	{r4, r5, r6, pc}

0803ccb8 <__sinit>:
 803ccb8:	6983      	ldr	r3, [r0, #24]
 803ccba:	b510      	push	{r4, lr}
 803ccbc:	4604      	mov	r4, r0
 803ccbe:	bb33      	cbnz	r3, 803cd0e <__sinit+0x56>
 803ccc0:	6503      	str	r3, [r0, #80]	; 0x50
 803ccc2:	4a13      	ldr	r2, [pc, #76]	; (803cd10 <__sinit+0x58>)
 803ccc4:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 803ccc8:	4b12      	ldr	r3, [pc, #72]	; (803cd14 <__sinit+0x5c>)
 803ccca:	6282      	str	r2, [r0, #40]	; 0x28
 803cccc:	681b      	ldr	r3, [r3, #0]
 803ccce:	4298      	cmp	r0, r3
 803ccd0:	bf04      	itt	eq
 803ccd2:	2301      	moveq	r3, #1
 803ccd4:	6183      	streq	r3, [r0, #24]
 803ccd6:	f000 f81f 	bl	803cd18 <__sfp>
 803ccda:	6060      	str	r0, [r4, #4]
 803ccdc:	4620      	mov	r0, r4
 803ccde:	f000 f81b 	bl	803cd18 <__sfp>
 803cce2:	60a0      	str	r0, [r4, #8]
 803cce4:	4620      	mov	r0, r4
 803cce6:	f000 f817 	bl	803cd18 <__sfp>
 803ccea:	2200      	movs	r2, #0
 803ccec:	60e0      	str	r0, [r4, #12]
 803ccee:	2104      	movs	r1, #4
 803ccf0:	6860      	ldr	r0, [r4, #4]
 803ccf2:	f7ff ffa1 	bl	803cc38 <std>
 803ccf6:	2201      	movs	r2, #1
 803ccf8:	2109      	movs	r1, #9
 803ccfa:	68a0      	ldr	r0, [r4, #8]
 803ccfc:	f7ff ff9c 	bl	803cc38 <std>
 803cd00:	2202      	movs	r2, #2
 803cd02:	2112      	movs	r1, #18
 803cd04:	68e0      	ldr	r0, [r4, #12]
 803cd06:	f7ff ff97 	bl	803cc38 <std>
 803cd0a:	2301      	movs	r3, #1
 803cd0c:	61a3      	str	r3, [r4, #24]
 803cd0e:	bd10      	pop	{r4, pc}
 803cd10:	0803cc81 	.word	0x0803cc81
 803cd14:	0803f23c 	.word	0x0803f23c

0803cd18 <__sfp>:
 803cd18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803cd1a:	4b1b      	ldr	r3, [pc, #108]	; (803cd88 <__sfp+0x70>)
 803cd1c:	4607      	mov	r7, r0
 803cd1e:	681e      	ldr	r6, [r3, #0]
 803cd20:	69b3      	ldr	r3, [r6, #24]
 803cd22:	b913      	cbnz	r3, 803cd2a <__sfp+0x12>
 803cd24:	4630      	mov	r0, r6
 803cd26:	f7ff ffc7 	bl	803ccb8 <__sinit>
 803cd2a:	3648      	adds	r6, #72	; 0x48
 803cd2c:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 803cd30:	3b01      	subs	r3, #1
 803cd32:	d503      	bpl.n	803cd3c <__sfp+0x24>
 803cd34:	6833      	ldr	r3, [r6, #0]
 803cd36:	b133      	cbz	r3, 803cd46 <__sfp+0x2e>
 803cd38:	6836      	ldr	r6, [r6, #0]
 803cd3a:	e7f7      	b.n	803cd2c <__sfp+0x14>
 803cd3c:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 803cd40:	b16d      	cbz	r5, 803cd5e <__sfp+0x46>
 803cd42:	3468      	adds	r4, #104	; 0x68
 803cd44:	e7f4      	b.n	803cd30 <__sfp+0x18>
 803cd46:	2104      	movs	r1, #4
 803cd48:	4638      	mov	r0, r7
 803cd4a:	f7ff ff9f 	bl	803cc8c <__sfmoreglue>
 803cd4e:	6030      	str	r0, [r6, #0]
 803cd50:	2800      	cmp	r0, #0
 803cd52:	d1f1      	bne.n	803cd38 <__sfp+0x20>
 803cd54:	230c      	movs	r3, #12
 803cd56:	4604      	mov	r4, r0
 803cd58:	603b      	str	r3, [r7, #0]
 803cd5a:	4620      	mov	r0, r4
 803cd5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 803cd5e:	4b0b      	ldr	r3, [pc, #44]	; (803cd8c <__sfp+0x74>)
 803cd60:	2208      	movs	r2, #8
 803cd62:	6665      	str	r5, [r4, #100]	; 0x64
 803cd64:	4629      	mov	r1, r5
 803cd66:	60a5      	str	r5, [r4, #8]
 803cd68:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 803cd6c:	e9c4 5500 	strd	r5, r5, [r4]
 803cd70:	e9c4 3503 	strd	r3, r5, [r4, #12]
 803cd74:	e9c4 5505 	strd	r5, r5, [r4, #20]
 803cd78:	f7ff fcae 	bl	803c6d8 <memset>
 803cd7c:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 803cd80:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 803cd84:	e7e9      	b.n	803cd5a <__sfp+0x42>
 803cd86:	bf00      	nop
 803cd88:	0803f23c 	.word	0x0803f23c
 803cd8c:	ffff0001 	.word	0xffff0001

0803cd90 <_fwalk_reent>:
 803cd90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 803cd94:	4680      	mov	r8, r0
 803cd96:	4689      	mov	r9, r1
 803cd98:	f100 0448 	add.w	r4, r0, #72	; 0x48
 803cd9c:	2600      	movs	r6, #0
 803cd9e:	b914      	cbnz	r4, 803cda6 <_fwalk_reent+0x16>
 803cda0:	4630      	mov	r0, r6
 803cda2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 803cda6:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 803cdaa:	3f01      	subs	r7, #1
 803cdac:	d501      	bpl.n	803cdb2 <_fwalk_reent+0x22>
 803cdae:	6824      	ldr	r4, [r4, #0]
 803cdb0:	e7f5      	b.n	803cd9e <_fwalk_reent+0xe>
 803cdb2:	89ab      	ldrh	r3, [r5, #12]
 803cdb4:	2b01      	cmp	r3, #1
 803cdb6:	d907      	bls.n	803cdc8 <_fwalk_reent+0x38>
 803cdb8:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 803cdbc:	3301      	adds	r3, #1
 803cdbe:	d003      	beq.n	803cdc8 <_fwalk_reent+0x38>
 803cdc0:	4629      	mov	r1, r5
 803cdc2:	4640      	mov	r0, r8
 803cdc4:	47c8      	blx	r9
 803cdc6:	4306      	orrs	r6, r0
 803cdc8:	3568      	adds	r5, #104	; 0x68
 803cdca:	e7ee      	b.n	803cdaa <_fwalk_reent+0x1a>

0803cdcc <__swhatbuf_r>:
 803cdcc:	b570      	push	{r4, r5, r6, lr}
 803cdce:	460e      	mov	r6, r1
 803cdd0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 803cdd4:	b096      	sub	sp, #88	; 0x58
 803cdd6:	4614      	mov	r4, r2
 803cdd8:	2900      	cmp	r1, #0
 803cdda:	461d      	mov	r5, r3
 803cddc:	da07      	bge.n	803cdee <__swhatbuf_r+0x22>
 803cdde:	2300      	movs	r3, #0
 803cde0:	602b      	str	r3, [r5, #0]
 803cde2:	89b3      	ldrh	r3, [r6, #12]
 803cde4:	061a      	lsls	r2, r3, #24
 803cde6:	d410      	bmi.n	803ce0a <__swhatbuf_r+0x3e>
 803cde8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 803cdec:	e00e      	b.n	803ce0c <__swhatbuf_r+0x40>
 803cdee:	466a      	mov	r2, sp
 803cdf0:	f000 fc40 	bl	803d674 <_fstat_r>
 803cdf4:	2800      	cmp	r0, #0
 803cdf6:	dbf2      	blt.n	803cdde <__swhatbuf_r+0x12>
 803cdf8:	9a01      	ldr	r2, [sp, #4]
 803cdfa:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 803cdfe:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 803ce02:	425a      	negs	r2, r3
 803ce04:	415a      	adcs	r2, r3
 803ce06:	602a      	str	r2, [r5, #0]
 803ce08:	e7ee      	b.n	803cde8 <__swhatbuf_r+0x1c>
 803ce0a:	2340      	movs	r3, #64	; 0x40
 803ce0c:	2000      	movs	r0, #0
 803ce0e:	6023      	str	r3, [r4, #0]
 803ce10:	b016      	add	sp, #88	; 0x58
 803ce12:	bd70      	pop	{r4, r5, r6, pc}

0803ce14 <__smakebuf_r>:
 803ce14:	898b      	ldrh	r3, [r1, #12]
 803ce16:	b573      	push	{r0, r1, r4, r5, r6, lr}
 803ce18:	079d      	lsls	r5, r3, #30
 803ce1a:	4606      	mov	r6, r0
 803ce1c:	460c      	mov	r4, r1
 803ce1e:	d507      	bpl.n	803ce30 <__smakebuf_r+0x1c>
 803ce20:	f104 0347 	add.w	r3, r4, #71	; 0x47
 803ce24:	6023      	str	r3, [r4, #0]
 803ce26:	6123      	str	r3, [r4, #16]
 803ce28:	2301      	movs	r3, #1
 803ce2a:	6163      	str	r3, [r4, #20]
 803ce2c:	b002      	add	sp, #8
 803ce2e:	bd70      	pop	{r4, r5, r6, pc}
 803ce30:	ab01      	add	r3, sp, #4
 803ce32:	466a      	mov	r2, sp
 803ce34:	f7ff ffca 	bl	803cdcc <__swhatbuf_r>
 803ce38:	9900      	ldr	r1, [sp, #0]
 803ce3a:	4605      	mov	r5, r0
 803ce3c:	4630      	mov	r0, r6
 803ce3e:	f000 f87f 	bl	803cf40 <_malloc_r>
 803ce42:	b948      	cbnz	r0, 803ce58 <__smakebuf_r+0x44>
 803ce44:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 803ce48:	059a      	lsls	r2, r3, #22
 803ce4a:	d4ef      	bmi.n	803ce2c <__smakebuf_r+0x18>
 803ce4c:	f023 0303 	bic.w	r3, r3, #3
 803ce50:	f043 0302 	orr.w	r3, r3, #2
 803ce54:	81a3      	strh	r3, [r4, #12]
 803ce56:	e7e3      	b.n	803ce20 <__smakebuf_r+0xc>
 803ce58:	4b0d      	ldr	r3, [pc, #52]	; (803ce90 <__smakebuf_r+0x7c>)
 803ce5a:	62b3      	str	r3, [r6, #40]	; 0x28
 803ce5c:	89a3      	ldrh	r3, [r4, #12]
 803ce5e:	6020      	str	r0, [r4, #0]
 803ce60:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 803ce64:	6120      	str	r0, [r4, #16]
 803ce66:	81a3      	strh	r3, [r4, #12]
 803ce68:	9b00      	ldr	r3, [sp, #0]
 803ce6a:	6163      	str	r3, [r4, #20]
 803ce6c:	9b01      	ldr	r3, [sp, #4]
 803ce6e:	b15b      	cbz	r3, 803ce88 <__smakebuf_r+0x74>
 803ce70:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 803ce74:	4630      	mov	r0, r6
 803ce76:	f000 fc0f 	bl	803d698 <_isatty_r>
 803ce7a:	b128      	cbz	r0, 803ce88 <__smakebuf_r+0x74>
 803ce7c:	89a3      	ldrh	r3, [r4, #12]
 803ce7e:	f023 0303 	bic.w	r3, r3, #3
 803ce82:	f043 0301 	orr.w	r3, r3, #1
 803ce86:	81a3      	strh	r3, [r4, #12]
 803ce88:	89a3      	ldrh	r3, [r4, #12]
 803ce8a:	431d      	orrs	r5, r3
 803ce8c:	81a5      	strh	r5, [r4, #12]
 803ce8e:	e7cd      	b.n	803ce2c <__smakebuf_r+0x18>
 803ce90:	0803cc81 	.word	0x0803cc81

0803ce94 <malloc>:
 803ce94:	4b02      	ldr	r3, [pc, #8]	; (803cea0 <malloc+0xc>)
 803ce96:	4601      	mov	r1, r0
 803ce98:	6818      	ldr	r0, [r3, #0]
 803ce9a:	f000 b851 	b.w	803cf40 <_malloc_r>
 803ce9e:	bf00      	nop
 803cea0:	20000128 	.word	0x20000128

0803cea4 <_free_r>:
 803cea4:	b538      	push	{r3, r4, r5, lr}
 803cea6:	4605      	mov	r5, r0
 803cea8:	2900      	cmp	r1, #0
 803ceaa:	d045      	beq.n	803cf38 <_free_r+0x94>
 803ceac:	f851 3c04 	ldr.w	r3, [r1, #-4]
 803ceb0:	1f0c      	subs	r4, r1, #4
 803ceb2:	2b00      	cmp	r3, #0
 803ceb4:	bfb8      	it	lt
 803ceb6:	18e4      	addlt	r4, r4, r3
 803ceb8:	f000 fc1e 	bl	803d6f8 <__malloc_lock>
 803cebc:	4a1f      	ldr	r2, [pc, #124]	; (803cf3c <_free_r+0x98>)
 803cebe:	6813      	ldr	r3, [r2, #0]
 803cec0:	4610      	mov	r0, r2
 803cec2:	b933      	cbnz	r3, 803ced2 <_free_r+0x2e>
 803cec4:	6063      	str	r3, [r4, #4]
 803cec6:	6014      	str	r4, [r2, #0]
 803cec8:	4628      	mov	r0, r5
 803ceca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 803cece:	f000 bc14 	b.w	803d6fa <__malloc_unlock>
 803ced2:	42a3      	cmp	r3, r4
 803ced4:	d90c      	bls.n	803cef0 <_free_r+0x4c>
 803ced6:	6821      	ldr	r1, [r4, #0]
 803ced8:	1862      	adds	r2, r4, r1
 803ceda:	4293      	cmp	r3, r2
 803cedc:	bf02      	ittt	eq
 803cede:	681a      	ldreq	r2, [r3, #0]
 803cee0:	685b      	ldreq	r3, [r3, #4]
 803cee2:	1852      	addeq	r2, r2, r1
 803cee4:	6063      	str	r3, [r4, #4]
 803cee6:	bf08      	it	eq
 803cee8:	6022      	streq	r2, [r4, #0]
 803ceea:	6004      	str	r4, [r0, #0]
 803ceec:	e7ec      	b.n	803cec8 <_free_r+0x24>
 803ceee:	4613      	mov	r3, r2
 803cef0:	685a      	ldr	r2, [r3, #4]
 803cef2:	b10a      	cbz	r2, 803cef8 <_free_r+0x54>
 803cef4:	42a2      	cmp	r2, r4
 803cef6:	d9fa      	bls.n	803ceee <_free_r+0x4a>
 803cef8:	6819      	ldr	r1, [r3, #0]
 803cefa:	1858      	adds	r0, r3, r1
 803cefc:	42a0      	cmp	r0, r4
 803cefe:	d10b      	bne.n	803cf18 <_free_r+0x74>
 803cf00:	6820      	ldr	r0, [r4, #0]
 803cf02:	4401      	add	r1, r0
 803cf04:	1858      	adds	r0, r3, r1
 803cf06:	6019      	str	r1, [r3, #0]
 803cf08:	4282      	cmp	r2, r0
 803cf0a:	d1dd      	bne.n	803cec8 <_free_r+0x24>
 803cf0c:	6810      	ldr	r0, [r2, #0]
 803cf0e:	6852      	ldr	r2, [r2, #4]
 803cf10:	4401      	add	r1, r0
 803cf12:	605a      	str	r2, [r3, #4]
 803cf14:	6019      	str	r1, [r3, #0]
 803cf16:	e7d7      	b.n	803cec8 <_free_r+0x24>
 803cf18:	d902      	bls.n	803cf20 <_free_r+0x7c>
 803cf1a:	230c      	movs	r3, #12
 803cf1c:	602b      	str	r3, [r5, #0]
 803cf1e:	e7d3      	b.n	803cec8 <_free_r+0x24>
 803cf20:	6820      	ldr	r0, [r4, #0]
 803cf22:	1821      	adds	r1, r4, r0
 803cf24:	428a      	cmp	r2, r1
 803cf26:	bf02      	ittt	eq
 803cf28:	6811      	ldreq	r1, [r2, #0]
 803cf2a:	6852      	ldreq	r2, [r2, #4]
 803cf2c:	1809      	addeq	r1, r1, r0
 803cf2e:	6062      	str	r2, [r4, #4]
 803cf30:	bf08      	it	eq
 803cf32:	6021      	streq	r1, [r4, #0]
 803cf34:	605c      	str	r4, [r3, #4]
 803cf36:	e7c7      	b.n	803cec8 <_free_r+0x24>
 803cf38:	bd38      	pop	{r3, r4, r5, pc}
 803cf3a:	bf00      	nop
 803cf3c:	20000678 	.word	0x20000678

0803cf40 <_malloc_r>:
 803cf40:	b570      	push	{r4, r5, r6, lr}
 803cf42:	1ccd      	adds	r5, r1, #3
 803cf44:	4606      	mov	r6, r0
 803cf46:	f025 0503 	bic.w	r5, r5, #3
 803cf4a:	3508      	adds	r5, #8
 803cf4c:	2d0c      	cmp	r5, #12
 803cf4e:	bf38      	it	cc
 803cf50:	250c      	movcc	r5, #12
 803cf52:	2d00      	cmp	r5, #0
 803cf54:	db01      	blt.n	803cf5a <_malloc_r+0x1a>
 803cf56:	42a9      	cmp	r1, r5
 803cf58:	d903      	bls.n	803cf62 <_malloc_r+0x22>
 803cf5a:	230c      	movs	r3, #12
 803cf5c:	6033      	str	r3, [r6, #0]
 803cf5e:	2000      	movs	r0, #0
 803cf60:	bd70      	pop	{r4, r5, r6, pc}
 803cf62:	f000 fbc9 	bl	803d6f8 <__malloc_lock>
 803cf66:	4a21      	ldr	r2, [pc, #132]	; (803cfec <_malloc_r+0xac>)
 803cf68:	6814      	ldr	r4, [r2, #0]
 803cf6a:	4621      	mov	r1, r4
 803cf6c:	b991      	cbnz	r1, 803cf94 <_malloc_r+0x54>
 803cf6e:	4c20      	ldr	r4, [pc, #128]	; (803cff0 <_malloc_r+0xb0>)
 803cf70:	6823      	ldr	r3, [r4, #0]
 803cf72:	b91b      	cbnz	r3, 803cf7c <_malloc_r+0x3c>
 803cf74:	4630      	mov	r0, r6
 803cf76:	f000 fb07 	bl	803d588 <_sbrk_r>
 803cf7a:	6020      	str	r0, [r4, #0]
 803cf7c:	4629      	mov	r1, r5
 803cf7e:	4630      	mov	r0, r6
 803cf80:	f000 fb02 	bl	803d588 <_sbrk_r>
 803cf84:	1c43      	adds	r3, r0, #1
 803cf86:	d124      	bne.n	803cfd2 <_malloc_r+0x92>
 803cf88:	230c      	movs	r3, #12
 803cf8a:	4630      	mov	r0, r6
 803cf8c:	6033      	str	r3, [r6, #0]
 803cf8e:	f000 fbb4 	bl	803d6fa <__malloc_unlock>
 803cf92:	e7e4      	b.n	803cf5e <_malloc_r+0x1e>
 803cf94:	680b      	ldr	r3, [r1, #0]
 803cf96:	1b5b      	subs	r3, r3, r5
 803cf98:	d418      	bmi.n	803cfcc <_malloc_r+0x8c>
 803cf9a:	2b0b      	cmp	r3, #11
 803cf9c:	d90f      	bls.n	803cfbe <_malloc_r+0x7e>
 803cf9e:	18cc      	adds	r4, r1, r3
 803cfa0:	600b      	str	r3, [r1, #0]
 803cfa2:	50cd      	str	r5, [r1, r3]
 803cfa4:	4630      	mov	r0, r6
 803cfa6:	f000 fba8 	bl	803d6fa <__malloc_unlock>
 803cfaa:	f104 000b 	add.w	r0, r4, #11
 803cfae:	1d23      	adds	r3, r4, #4
 803cfb0:	f020 0007 	bic.w	r0, r0, #7
 803cfb4:	1ac3      	subs	r3, r0, r3
 803cfb6:	d0d3      	beq.n	803cf60 <_malloc_r+0x20>
 803cfb8:	425a      	negs	r2, r3
 803cfba:	50e2      	str	r2, [r4, r3]
 803cfbc:	e7d0      	b.n	803cf60 <_malloc_r+0x20>
 803cfbe:	428c      	cmp	r4, r1
 803cfc0:	684b      	ldr	r3, [r1, #4]
 803cfc2:	bf1a      	itte	ne
 803cfc4:	6063      	strne	r3, [r4, #4]
 803cfc6:	460c      	movne	r4, r1
 803cfc8:	6013      	streq	r3, [r2, #0]
 803cfca:	e7eb      	b.n	803cfa4 <_malloc_r+0x64>
 803cfcc:	460c      	mov	r4, r1
 803cfce:	6849      	ldr	r1, [r1, #4]
 803cfd0:	e7cc      	b.n	803cf6c <_malloc_r+0x2c>
 803cfd2:	1cc4      	adds	r4, r0, #3
 803cfd4:	f024 0403 	bic.w	r4, r4, #3
 803cfd8:	42a0      	cmp	r0, r4
 803cfda:	d005      	beq.n	803cfe8 <_malloc_r+0xa8>
 803cfdc:	1a21      	subs	r1, r4, r0
 803cfde:	4630      	mov	r0, r6
 803cfe0:	f000 fad2 	bl	803d588 <_sbrk_r>
 803cfe4:	3001      	adds	r0, #1
 803cfe6:	d0cf      	beq.n	803cf88 <_malloc_r+0x48>
 803cfe8:	6025      	str	r5, [r4, #0]
 803cfea:	e7db      	b.n	803cfa4 <_malloc_r+0x64>
 803cfec:	20000678 	.word	0x20000678
 803cff0:	2000067c 	.word	0x2000067c

0803cff4 <__sfputc_r>:
 803cff4:	6893      	ldr	r3, [r2, #8]
 803cff6:	3b01      	subs	r3, #1
 803cff8:	2b00      	cmp	r3, #0
 803cffa:	6093      	str	r3, [r2, #8]
 803cffc:	b410      	push	{r4}
 803cffe:	da08      	bge.n	803d012 <__sfputc_r+0x1e>
 803d000:	6994      	ldr	r4, [r2, #24]
 803d002:	42a3      	cmp	r3, r4
 803d004:	db01      	blt.n	803d00a <__sfputc_r+0x16>
 803d006:	290a      	cmp	r1, #10
 803d008:	d103      	bne.n	803d012 <__sfputc_r+0x1e>
 803d00a:	f85d 4b04 	ldr.w	r4, [sp], #4
 803d00e:	f7ff bca5 	b.w	803c95c <__swbuf_r>
 803d012:	6813      	ldr	r3, [r2, #0]
 803d014:	1c58      	adds	r0, r3, #1
 803d016:	6010      	str	r0, [r2, #0]
 803d018:	4608      	mov	r0, r1
 803d01a:	7019      	strb	r1, [r3, #0]
 803d01c:	f85d 4b04 	ldr.w	r4, [sp], #4
 803d020:	4770      	bx	lr

0803d022 <__sfputs_r>:
 803d022:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803d024:	4606      	mov	r6, r0
 803d026:	460f      	mov	r7, r1
 803d028:	4614      	mov	r4, r2
 803d02a:	18d5      	adds	r5, r2, r3
 803d02c:	42ac      	cmp	r4, r5
 803d02e:	d101      	bne.n	803d034 <__sfputs_r+0x12>
 803d030:	2000      	movs	r0, #0
 803d032:	e007      	b.n	803d044 <__sfputs_r+0x22>
 803d034:	463a      	mov	r2, r7
 803d036:	f814 1b01 	ldrb.w	r1, [r4], #1
 803d03a:	4630      	mov	r0, r6
 803d03c:	f7ff ffda 	bl	803cff4 <__sfputc_r>
 803d040:	1c43      	adds	r3, r0, #1
 803d042:	d1f3      	bne.n	803d02c <__sfputs_r+0xa>
 803d044:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0803d048 <_vfiprintf_r>:
 803d048:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803d04c:	460c      	mov	r4, r1
 803d04e:	b09d      	sub	sp, #116	; 0x74
 803d050:	4617      	mov	r7, r2
 803d052:	461d      	mov	r5, r3
 803d054:	4606      	mov	r6, r0
 803d056:	b118      	cbz	r0, 803d060 <_vfiprintf_r+0x18>
 803d058:	6983      	ldr	r3, [r0, #24]
 803d05a:	b90b      	cbnz	r3, 803d060 <_vfiprintf_r+0x18>
 803d05c:	f7ff fe2c 	bl	803ccb8 <__sinit>
 803d060:	4b7c      	ldr	r3, [pc, #496]	; (803d254 <_vfiprintf_r+0x20c>)
 803d062:	429c      	cmp	r4, r3
 803d064:	d158      	bne.n	803d118 <_vfiprintf_r+0xd0>
 803d066:	6874      	ldr	r4, [r6, #4]
 803d068:	89a3      	ldrh	r3, [r4, #12]
 803d06a:	0718      	lsls	r0, r3, #28
 803d06c:	d55e      	bpl.n	803d12c <_vfiprintf_r+0xe4>
 803d06e:	6923      	ldr	r3, [r4, #16]
 803d070:	2b00      	cmp	r3, #0
 803d072:	d05b      	beq.n	803d12c <_vfiprintf_r+0xe4>
 803d074:	2300      	movs	r3, #0
 803d076:	f04f 0b01 	mov.w	fp, #1
 803d07a:	9503      	str	r5, [sp, #12]
 803d07c:	9309      	str	r3, [sp, #36]	; 0x24
 803d07e:	2320      	movs	r3, #32
 803d080:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 803d084:	2330      	movs	r3, #48	; 0x30
 803d086:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 803d08a:	46b8      	mov	r8, r7
 803d08c:	4645      	mov	r5, r8
 803d08e:	f815 3b01 	ldrb.w	r3, [r5], #1
 803d092:	b10b      	cbz	r3, 803d098 <_vfiprintf_r+0x50>
 803d094:	2b25      	cmp	r3, #37	; 0x25
 803d096:	d154      	bne.n	803d142 <_vfiprintf_r+0xfa>
 803d098:	ebb8 0a07 	subs.w	sl, r8, r7
 803d09c:	d00b      	beq.n	803d0b6 <_vfiprintf_r+0x6e>
 803d09e:	4653      	mov	r3, sl
 803d0a0:	463a      	mov	r2, r7
 803d0a2:	4621      	mov	r1, r4
 803d0a4:	4630      	mov	r0, r6
 803d0a6:	f7ff ffbc 	bl	803d022 <__sfputs_r>
 803d0aa:	3001      	adds	r0, #1
 803d0ac:	f000 80c2 	beq.w	803d234 <_vfiprintf_r+0x1ec>
 803d0b0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 803d0b2:	4453      	add	r3, sl
 803d0b4:	9309      	str	r3, [sp, #36]	; 0x24
 803d0b6:	f898 3000 	ldrb.w	r3, [r8]
 803d0ba:	2b00      	cmp	r3, #0
 803d0bc:	f000 80ba 	beq.w	803d234 <_vfiprintf_r+0x1ec>
 803d0c0:	2300      	movs	r3, #0
 803d0c2:	f04f 32ff 	mov.w	r2, #4294967295
 803d0c6:	9304      	str	r3, [sp, #16]
 803d0c8:	9307      	str	r3, [sp, #28]
 803d0ca:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 803d0ce:	931a      	str	r3, [sp, #104]	; 0x68
 803d0d0:	e9cd 2305 	strd	r2, r3, [sp, #20]
 803d0d4:	46a8      	mov	r8, r5
 803d0d6:	2205      	movs	r2, #5
 803d0d8:	485f      	ldr	r0, [pc, #380]	; (803d258 <_vfiprintf_r+0x210>)
 803d0da:	f818 1b01 	ldrb.w	r1, [r8], #1
 803d0de:	f000 fafd 	bl	803d6dc <memchr>
 803d0e2:	9b04      	ldr	r3, [sp, #16]
 803d0e4:	bb78      	cbnz	r0, 803d146 <_vfiprintf_r+0xfe>
 803d0e6:	06d9      	lsls	r1, r3, #27
 803d0e8:	bf44      	itt	mi
 803d0ea:	2220      	movmi	r2, #32
 803d0ec:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 803d0f0:	071a      	lsls	r2, r3, #28
 803d0f2:	bf44      	itt	mi
 803d0f4:	222b      	movmi	r2, #43	; 0x2b
 803d0f6:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 803d0fa:	782a      	ldrb	r2, [r5, #0]
 803d0fc:	2a2a      	cmp	r2, #42	; 0x2a
 803d0fe:	d02a      	beq.n	803d156 <_vfiprintf_r+0x10e>
 803d100:	46a8      	mov	r8, r5
 803d102:	9a07      	ldr	r2, [sp, #28]
 803d104:	2000      	movs	r0, #0
 803d106:	250a      	movs	r5, #10
 803d108:	4641      	mov	r1, r8
 803d10a:	f811 3b01 	ldrb.w	r3, [r1], #1
 803d10e:	3b30      	subs	r3, #48	; 0x30
 803d110:	2b09      	cmp	r3, #9
 803d112:	d969      	bls.n	803d1e8 <_vfiprintf_r+0x1a0>
 803d114:	b360      	cbz	r0, 803d170 <_vfiprintf_r+0x128>
 803d116:	e024      	b.n	803d162 <_vfiprintf_r+0x11a>
 803d118:	4b50      	ldr	r3, [pc, #320]	; (803d25c <_vfiprintf_r+0x214>)
 803d11a:	429c      	cmp	r4, r3
 803d11c:	d101      	bne.n	803d122 <_vfiprintf_r+0xda>
 803d11e:	68b4      	ldr	r4, [r6, #8]
 803d120:	e7a2      	b.n	803d068 <_vfiprintf_r+0x20>
 803d122:	4b4f      	ldr	r3, [pc, #316]	; (803d260 <_vfiprintf_r+0x218>)
 803d124:	429c      	cmp	r4, r3
 803d126:	bf08      	it	eq
 803d128:	68f4      	ldreq	r4, [r6, #12]
 803d12a:	e79d      	b.n	803d068 <_vfiprintf_r+0x20>
 803d12c:	4621      	mov	r1, r4
 803d12e:	4630      	mov	r0, r6
 803d130:	f7ff fc66 	bl	803ca00 <__swsetup_r>
 803d134:	2800      	cmp	r0, #0
 803d136:	d09d      	beq.n	803d074 <_vfiprintf_r+0x2c>
 803d138:	f04f 30ff 	mov.w	r0, #4294967295
 803d13c:	b01d      	add	sp, #116	; 0x74
 803d13e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 803d142:	46a8      	mov	r8, r5
 803d144:	e7a2      	b.n	803d08c <_vfiprintf_r+0x44>
 803d146:	4a44      	ldr	r2, [pc, #272]	; (803d258 <_vfiprintf_r+0x210>)
 803d148:	4645      	mov	r5, r8
 803d14a:	1a80      	subs	r0, r0, r2
 803d14c:	fa0b f000 	lsl.w	r0, fp, r0
 803d150:	4318      	orrs	r0, r3
 803d152:	9004      	str	r0, [sp, #16]
 803d154:	e7be      	b.n	803d0d4 <_vfiprintf_r+0x8c>
 803d156:	9a03      	ldr	r2, [sp, #12]
 803d158:	1d11      	adds	r1, r2, #4
 803d15a:	6812      	ldr	r2, [r2, #0]
 803d15c:	2a00      	cmp	r2, #0
 803d15e:	9103      	str	r1, [sp, #12]
 803d160:	db01      	blt.n	803d166 <_vfiprintf_r+0x11e>
 803d162:	9207      	str	r2, [sp, #28]
 803d164:	e004      	b.n	803d170 <_vfiprintf_r+0x128>
 803d166:	4252      	negs	r2, r2
 803d168:	f043 0302 	orr.w	r3, r3, #2
 803d16c:	9207      	str	r2, [sp, #28]
 803d16e:	9304      	str	r3, [sp, #16]
 803d170:	f898 3000 	ldrb.w	r3, [r8]
 803d174:	2b2e      	cmp	r3, #46	; 0x2e
 803d176:	d10e      	bne.n	803d196 <_vfiprintf_r+0x14e>
 803d178:	f898 3001 	ldrb.w	r3, [r8, #1]
 803d17c:	2b2a      	cmp	r3, #42	; 0x2a
 803d17e:	d138      	bne.n	803d1f2 <_vfiprintf_r+0x1aa>
 803d180:	9b03      	ldr	r3, [sp, #12]
 803d182:	f108 0802 	add.w	r8, r8, #2
 803d186:	1d1a      	adds	r2, r3, #4
 803d188:	681b      	ldr	r3, [r3, #0]
 803d18a:	2b00      	cmp	r3, #0
 803d18c:	9203      	str	r2, [sp, #12]
 803d18e:	bfb8      	it	lt
 803d190:	f04f 33ff 	movlt.w	r3, #4294967295
 803d194:	9305      	str	r3, [sp, #20]
 803d196:	4d33      	ldr	r5, [pc, #204]	; (803d264 <_vfiprintf_r+0x21c>)
 803d198:	2203      	movs	r2, #3
 803d19a:	f898 1000 	ldrb.w	r1, [r8]
 803d19e:	4628      	mov	r0, r5
 803d1a0:	f000 fa9c 	bl	803d6dc <memchr>
 803d1a4:	b140      	cbz	r0, 803d1b8 <_vfiprintf_r+0x170>
 803d1a6:	2340      	movs	r3, #64	; 0x40
 803d1a8:	1b40      	subs	r0, r0, r5
 803d1aa:	f108 0801 	add.w	r8, r8, #1
 803d1ae:	fa03 f000 	lsl.w	r0, r3, r0
 803d1b2:	9b04      	ldr	r3, [sp, #16]
 803d1b4:	4303      	orrs	r3, r0
 803d1b6:	9304      	str	r3, [sp, #16]
 803d1b8:	f898 1000 	ldrb.w	r1, [r8]
 803d1bc:	2206      	movs	r2, #6
 803d1be:	482a      	ldr	r0, [pc, #168]	; (803d268 <_vfiprintf_r+0x220>)
 803d1c0:	f108 0701 	add.w	r7, r8, #1
 803d1c4:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 803d1c8:	f000 fa88 	bl	803d6dc <memchr>
 803d1cc:	2800      	cmp	r0, #0
 803d1ce:	d037      	beq.n	803d240 <_vfiprintf_r+0x1f8>
 803d1d0:	4b26      	ldr	r3, [pc, #152]	; (803d26c <_vfiprintf_r+0x224>)
 803d1d2:	bb1b      	cbnz	r3, 803d21c <_vfiprintf_r+0x1d4>
 803d1d4:	9b03      	ldr	r3, [sp, #12]
 803d1d6:	3307      	adds	r3, #7
 803d1d8:	f023 0307 	bic.w	r3, r3, #7
 803d1dc:	3308      	adds	r3, #8
 803d1de:	9303      	str	r3, [sp, #12]
 803d1e0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 803d1e2:	444b      	add	r3, r9
 803d1e4:	9309      	str	r3, [sp, #36]	; 0x24
 803d1e6:	e750      	b.n	803d08a <_vfiprintf_r+0x42>
 803d1e8:	fb05 3202 	mla	r2, r5, r2, r3
 803d1ec:	2001      	movs	r0, #1
 803d1ee:	4688      	mov	r8, r1
 803d1f0:	e78a      	b.n	803d108 <_vfiprintf_r+0xc0>
 803d1f2:	2300      	movs	r3, #0
 803d1f4:	f108 0801 	add.w	r8, r8, #1
 803d1f8:	250a      	movs	r5, #10
 803d1fa:	4619      	mov	r1, r3
 803d1fc:	9305      	str	r3, [sp, #20]
 803d1fe:	4640      	mov	r0, r8
 803d200:	f810 2b01 	ldrb.w	r2, [r0], #1
 803d204:	3a30      	subs	r2, #48	; 0x30
 803d206:	2a09      	cmp	r2, #9
 803d208:	d903      	bls.n	803d212 <_vfiprintf_r+0x1ca>
 803d20a:	2b00      	cmp	r3, #0
 803d20c:	d0c3      	beq.n	803d196 <_vfiprintf_r+0x14e>
 803d20e:	9105      	str	r1, [sp, #20]
 803d210:	e7c1      	b.n	803d196 <_vfiprintf_r+0x14e>
 803d212:	fb05 2101 	mla	r1, r5, r1, r2
 803d216:	2301      	movs	r3, #1
 803d218:	4680      	mov	r8, r0
 803d21a:	e7f0      	b.n	803d1fe <_vfiprintf_r+0x1b6>
 803d21c:	ab03      	add	r3, sp, #12
 803d21e:	4622      	mov	r2, r4
 803d220:	a904      	add	r1, sp, #16
 803d222:	4630      	mov	r0, r6
 803d224:	9300      	str	r3, [sp, #0]
 803d226:	4b12      	ldr	r3, [pc, #72]	; (803d270 <_vfiprintf_r+0x228>)
 803d228:	e000      	b.n	803d22c <_vfiprintf_r+0x1e4>
 803d22a:	bf00      	nop
 803d22c:	f1b0 3fff 	cmp.w	r0, #4294967295
 803d230:	4681      	mov	r9, r0
 803d232:	d1d5      	bne.n	803d1e0 <_vfiprintf_r+0x198>
 803d234:	89a3      	ldrh	r3, [r4, #12]
 803d236:	065b      	lsls	r3, r3, #25
 803d238:	f53f af7e 	bmi.w	803d138 <_vfiprintf_r+0xf0>
 803d23c:	9809      	ldr	r0, [sp, #36]	; 0x24
 803d23e:	e77d      	b.n	803d13c <_vfiprintf_r+0xf4>
 803d240:	ab03      	add	r3, sp, #12
 803d242:	4622      	mov	r2, r4
 803d244:	a904      	add	r1, sp, #16
 803d246:	4630      	mov	r0, r6
 803d248:	9300      	str	r3, [sp, #0]
 803d24a:	4b09      	ldr	r3, [pc, #36]	; (803d270 <_vfiprintf_r+0x228>)
 803d24c:	f000 f88a 	bl	803d364 <_printf_i>
 803d250:	e7ec      	b.n	803d22c <_vfiprintf_r+0x1e4>
 803d252:	bf00      	nop
 803d254:	0803f260 	.word	0x0803f260
 803d258:	0803f2a0 	.word	0x0803f2a0
 803d25c:	0803f280 	.word	0x0803f280
 803d260:	0803f240 	.word	0x0803f240
 803d264:	0803f2a6 	.word	0x0803f2a6
 803d268:	0803f2aa 	.word	0x0803f2aa
 803d26c:	00000000 	.word	0x00000000
 803d270:	0803d023 	.word	0x0803d023

0803d274 <_printf_common>:
 803d274:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 803d278:	4691      	mov	r9, r2
 803d27a:	461f      	mov	r7, r3
 803d27c:	688a      	ldr	r2, [r1, #8]
 803d27e:	4606      	mov	r6, r0
 803d280:	690b      	ldr	r3, [r1, #16]
 803d282:	460c      	mov	r4, r1
 803d284:	f8dd 8020 	ldr.w	r8, [sp, #32]
 803d288:	4293      	cmp	r3, r2
 803d28a:	bfb8      	it	lt
 803d28c:	4613      	movlt	r3, r2
 803d28e:	f8c9 3000 	str.w	r3, [r9]
 803d292:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 803d296:	b112      	cbz	r2, 803d29e <_printf_common+0x2a>
 803d298:	3301      	adds	r3, #1
 803d29a:	f8c9 3000 	str.w	r3, [r9]
 803d29e:	6823      	ldr	r3, [r4, #0]
 803d2a0:	0699      	lsls	r1, r3, #26
 803d2a2:	bf42      	ittt	mi
 803d2a4:	f8d9 3000 	ldrmi.w	r3, [r9]
 803d2a8:	3302      	addmi	r3, #2
 803d2aa:	f8c9 3000 	strmi.w	r3, [r9]
 803d2ae:	6825      	ldr	r5, [r4, #0]
 803d2b0:	f015 0506 	ands.w	r5, r5, #6
 803d2b4:	d107      	bne.n	803d2c6 <_printf_common+0x52>
 803d2b6:	f104 0a19 	add.w	sl, r4, #25
 803d2ba:	68e3      	ldr	r3, [r4, #12]
 803d2bc:	f8d9 2000 	ldr.w	r2, [r9]
 803d2c0:	1a9b      	subs	r3, r3, r2
 803d2c2:	42ab      	cmp	r3, r5
 803d2c4:	dc2b      	bgt.n	803d31e <_printf_common+0xaa>
 803d2c6:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 803d2ca:	6822      	ldr	r2, [r4, #0]
 803d2cc:	3300      	adds	r3, #0
 803d2ce:	bf18      	it	ne
 803d2d0:	2301      	movne	r3, #1
 803d2d2:	0692      	lsls	r2, r2, #26
 803d2d4:	d430      	bmi.n	803d338 <_printf_common+0xc4>
 803d2d6:	f104 0243 	add.w	r2, r4, #67	; 0x43
 803d2da:	4639      	mov	r1, r7
 803d2dc:	4630      	mov	r0, r6
 803d2de:	47c0      	blx	r8
 803d2e0:	3001      	adds	r0, #1
 803d2e2:	d023      	beq.n	803d32c <_printf_common+0xb8>
 803d2e4:	6823      	ldr	r3, [r4, #0]
 803d2e6:	341a      	adds	r4, #26
 803d2e8:	f854 5c0e 	ldr.w	r5, [r4, #-14]
 803d2ec:	f003 0306 	and.w	r3, r3, #6
 803d2f0:	f8d9 2000 	ldr.w	r2, [r9]
 803d2f4:	f04f 0900 	mov.w	r9, #0
 803d2f8:	2b04      	cmp	r3, #4
 803d2fa:	f854 3c12 	ldr.w	r3, [r4, #-18]
 803d2fe:	bf08      	it	eq
 803d300:	1aad      	subeq	r5, r5, r2
 803d302:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 803d306:	bf14      	ite	ne
 803d308:	2500      	movne	r5, #0
 803d30a:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 803d30e:	4293      	cmp	r3, r2
 803d310:	bfc4      	itt	gt
 803d312:	1a9b      	subgt	r3, r3, r2
 803d314:	18ed      	addgt	r5, r5, r3
 803d316:	454d      	cmp	r5, r9
 803d318:	d11a      	bne.n	803d350 <_printf_common+0xdc>
 803d31a:	2000      	movs	r0, #0
 803d31c:	e008      	b.n	803d330 <_printf_common+0xbc>
 803d31e:	2301      	movs	r3, #1
 803d320:	4652      	mov	r2, sl
 803d322:	4639      	mov	r1, r7
 803d324:	4630      	mov	r0, r6
 803d326:	47c0      	blx	r8
 803d328:	3001      	adds	r0, #1
 803d32a:	d103      	bne.n	803d334 <_printf_common+0xc0>
 803d32c:	f04f 30ff 	mov.w	r0, #4294967295
 803d330:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 803d334:	3501      	adds	r5, #1
 803d336:	e7c0      	b.n	803d2ba <_printf_common+0x46>
 803d338:	18e1      	adds	r1, r4, r3
 803d33a:	1c5a      	adds	r2, r3, #1
 803d33c:	2030      	movs	r0, #48	; 0x30
 803d33e:	3302      	adds	r3, #2
 803d340:	4422      	add	r2, r4
 803d342:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 803d346:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 803d34a:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 803d34e:	e7c2      	b.n	803d2d6 <_printf_common+0x62>
 803d350:	2301      	movs	r3, #1
 803d352:	4622      	mov	r2, r4
 803d354:	4639      	mov	r1, r7
 803d356:	4630      	mov	r0, r6
 803d358:	47c0      	blx	r8
 803d35a:	3001      	adds	r0, #1
 803d35c:	d0e6      	beq.n	803d32c <_printf_common+0xb8>
 803d35e:	f109 0901 	add.w	r9, r9, #1
 803d362:	e7d8      	b.n	803d316 <_printf_common+0xa2>

0803d364 <_printf_i>:
 803d364:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 803d368:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 803d36c:	460c      	mov	r4, r1
 803d36e:	7e09      	ldrb	r1, [r1, #24]
 803d370:	b085      	sub	sp, #20
 803d372:	4617      	mov	r7, r2
 803d374:	4606      	mov	r6, r0
 803d376:	296e      	cmp	r1, #110	; 0x6e
 803d378:	4698      	mov	r8, r3
 803d37a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 803d37c:	f000 80b3 	beq.w	803d4e6 <_printf_i+0x182>
 803d380:	d822      	bhi.n	803d3c8 <_printf_i+0x64>
 803d382:	2963      	cmp	r1, #99	; 0x63
 803d384:	d036      	beq.n	803d3f4 <_printf_i+0x90>
 803d386:	d80a      	bhi.n	803d39e <_printf_i+0x3a>
 803d388:	2900      	cmp	r1, #0
 803d38a:	f000 80b9 	beq.w	803d500 <_printf_i+0x19c>
 803d38e:	2958      	cmp	r1, #88	; 0x58
 803d390:	f000 8083 	beq.w	803d49a <_printf_i+0x136>
 803d394:	f104 0542 	add.w	r5, r4, #66	; 0x42
 803d398:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 803d39c:	e032      	b.n	803d404 <_printf_i+0xa0>
 803d39e:	2964      	cmp	r1, #100	; 0x64
 803d3a0:	d001      	beq.n	803d3a6 <_printf_i+0x42>
 803d3a2:	2969      	cmp	r1, #105	; 0x69
 803d3a4:	d1f6      	bne.n	803d394 <_printf_i+0x30>
 803d3a6:	6820      	ldr	r0, [r4, #0]
 803d3a8:	6813      	ldr	r3, [r2, #0]
 803d3aa:	0605      	lsls	r5, r0, #24
 803d3ac:	f103 0104 	add.w	r1, r3, #4
 803d3b0:	d52a      	bpl.n	803d408 <_printf_i+0xa4>
 803d3b2:	681b      	ldr	r3, [r3, #0]
 803d3b4:	6011      	str	r1, [r2, #0]
 803d3b6:	2b00      	cmp	r3, #0
 803d3b8:	da03      	bge.n	803d3c2 <_printf_i+0x5e>
 803d3ba:	222d      	movs	r2, #45	; 0x2d
 803d3bc:	425b      	negs	r3, r3
 803d3be:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 803d3c2:	486f      	ldr	r0, [pc, #444]	; (803d580 <_printf_i+0x21c>)
 803d3c4:	220a      	movs	r2, #10
 803d3c6:	e039      	b.n	803d43c <_printf_i+0xd8>
 803d3c8:	2973      	cmp	r1, #115	; 0x73
 803d3ca:	f000 809d 	beq.w	803d508 <_printf_i+0x1a4>
 803d3ce:	d808      	bhi.n	803d3e2 <_printf_i+0x7e>
 803d3d0:	296f      	cmp	r1, #111	; 0x6f
 803d3d2:	d020      	beq.n	803d416 <_printf_i+0xb2>
 803d3d4:	2970      	cmp	r1, #112	; 0x70
 803d3d6:	d1dd      	bne.n	803d394 <_printf_i+0x30>
 803d3d8:	6823      	ldr	r3, [r4, #0]
 803d3da:	f043 0320 	orr.w	r3, r3, #32
 803d3de:	6023      	str	r3, [r4, #0]
 803d3e0:	e003      	b.n	803d3ea <_printf_i+0x86>
 803d3e2:	2975      	cmp	r1, #117	; 0x75
 803d3e4:	d017      	beq.n	803d416 <_printf_i+0xb2>
 803d3e6:	2978      	cmp	r1, #120	; 0x78
 803d3e8:	d1d4      	bne.n	803d394 <_printf_i+0x30>
 803d3ea:	2378      	movs	r3, #120	; 0x78
 803d3ec:	4865      	ldr	r0, [pc, #404]	; (803d584 <_printf_i+0x220>)
 803d3ee:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 803d3f2:	e055      	b.n	803d4a0 <_printf_i+0x13c>
 803d3f4:	6813      	ldr	r3, [r2, #0]
 803d3f6:	f104 0542 	add.w	r5, r4, #66	; 0x42
 803d3fa:	1d19      	adds	r1, r3, #4
 803d3fc:	681b      	ldr	r3, [r3, #0]
 803d3fe:	6011      	str	r1, [r2, #0]
 803d400:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 803d404:	2301      	movs	r3, #1
 803d406:	e08c      	b.n	803d522 <_printf_i+0x1be>
 803d408:	681b      	ldr	r3, [r3, #0]
 803d40a:	f010 0f40 	tst.w	r0, #64	; 0x40
 803d40e:	6011      	str	r1, [r2, #0]
 803d410:	bf18      	it	ne
 803d412:	b21b      	sxthne	r3, r3
 803d414:	e7cf      	b.n	803d3b6 <_printf_i+0x52>
 803d416:	6813      	ldr	r3, [r2, #0]
 803d418:	6825      	ldr	r5, [r4, #0]
 803d41a:	1d18      	adds	r0, r3, #4
 803d41c:	6010      	str	r0, [r2, #0]
 803d41e:	0628      	lsls	r0, r5, #24
 803d420:	d501      	bpl.n	803d426 <_printf_i+0xc2>
 803d422:	681b      	ldr	r3, [r3, #0]
 803d424:	e002      	b.n	803d42c <_printf_i+0xc8>
 803d426:	0668      	lsls	r0, r5, #25
 803d428:	d5fb      	bpl.n	803d422 <_printf_i+0xbe>
 803d42a:	881b      	ldrh	r3, [r3, #0]
 803d42c:	296f      	cmp	r1, #111	; 0x6f
 803d42e:	4854      	ldr	r0, [pc, #336]	; (803d580 <_printf_i+0x21c>)
 803d430:	bf14      	ite	ne
 803d432:	220a      	movne	r2, #10
 803d434:	2208      	moveq	r2, #8
 803d436:	2100      	movs	r1, #0
 803d438:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 803d43c:	6865      	ldr	r5, [r4, #4]
 803d43e:	2d00      	cmp	r5, #0
 803d440:	60a5      	str	r5, [r4, #8]
 803d442:	f2c0 8095 	blt.w	803d570 <_printf_i+0x20c>
 803d446:	6821      	ldr	r1, [r4, #0]
 803d448:	f021 0104 	bic.w	r1, r1, #4
 803d44c:	6021      	str	r1, [r4, #0]
 803d44e:	2b00      	cmp	r3, #0
 803d450:	d13d      	bne.n	803d4ce <_printf_i+0x16a>
 803d452:	2d00      	cmp	r5, #0
 803d454:	f040 808e 	bne.w	803d574 <_printf_i+0x210>
 803d458:	4665      	mov	r5, ip
 803d45a:	2a08      	cmp	r2, #8
 803d45c:	d10b      	bne.n	803d476 <_printf_i+0x112>
 803d45e:	6823      	ldr	r3, [r4, #0]
 803d460:	07db      	lsls	r3, r3, #31
 803d462:	d508      	bpl.n	803d476 <_printf_i+0x112>
 803d464:	6923      	ldr	r3, [r4, #16]
 803d466:	6862      	ldr	r2, [r4, #4]
 803d468:	429a      	cmp	r2, r3
 803d46a:	bfde      	ittt	le
 803d46c:	2330      	movle	r3, #48	; 0x30
 803d46e:	f805 3c01 	strble.w	r3, [r5, #-1]
 803d472:	f105 35ff 	addle.w	r5, r5, #4294967295
 803d476:	ebac 0305 	sub.w	r3, ip, r5
 803d47a:	6123      	str	r3, [r4, #16]
 803d47c:	f8cd 8000 	str.w	r8, [sp]
 803d480:	463b      	mov	r3, r7
 803d482:	aa03      	add	r2, sp, #12
 803d484:	4621      	mov	r1, r4
 803d486:	4630      	mov	r0, r6
 803d488:	f7ff fef4 	bl	803d274 <_printf_common>
 803d48c:	3001      	adds	r0, #1
 803d48e:	d14d      	bne.n	803d52c <_printf_i+0x1c8>
 803d490:	f04f 30ff 	mov.w	r0, #4294967295
 803d494:	b005      	add	sp, #20
 803d496:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 803d49a:	4839      	ldr	r0, [pc, #228]	; (803d580 <_printf_i+0x21c>)
 803d49c:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 803d4a0:	6813      	ldr	r3, [r2, #0]
 803d4a2:	6821      	ldr	r1, [r4, #0]
 803d4a4:	1d1d      	adds	r5, r3, #4
 803d4a6:	681b      	ldr	r3, [r3, #0]
 803d4a8:	6015      	str	r5, [r2, #0]
 803d4aa:	060a      	lsls	r2, r1, #24
 803d4ac:	d50b      	bpl.n	803d4c6 <_printf_i+0x162>
 803d4ae:	07ca      	lsls	r2, r1, #31
 803d4b0:	bf44      	itt	mi
 803d4b2:	f041 0120 	orrmi.w	r1, r1, #32
 803d4b6:	6021      	strmi	r1, [r4, #0]
 803d4b8:	b91b      	cbnz	r3, 803d4c2 <_printf_i+0x15e>
 803d4ba:	6822      	ldr	r2, [r4, #0]
 803d4bc:	f022 0220 	bic.w	r2, r2, #32
 803d4c0:	6022      	str	r2, [r4, #0]
 803d4c2:	2210      	movs	r2, #16
 803d4c4:	e7b7      	b.n	803d436 <_printf_i+0xd2>
 803d4c6:	064d      	lsls	r5, r1, #25
 803d4c8:	bf48      	it	mi
 803d4ca:	b29b      	uxthmi	r3, r3
 803d4cc:	e7ef      	b.n	803d4ae <_printf_i+0x14a>
 803d4ce:	4665      	mov	r5, ip
 803d4d0:	fbb3 f1f2 	udiv	r1, r3, r2
 803d4d4:	fb02 3311 	mls	r3, r2, r1, r3
 803d4d8:	5cc3      	ldrb	r3, [r0, r3]
 803d4da:	f805 3d01 	strb.w	r3, [r5, #-1]!
 803d4de:	460b      	mov	r3, r1
 803d4e0:	2900      	cmp	r1, #0
 803d4e2:	d1f5      	bne.n	803d4d0 <_printf_i+0x16c>
 803d4e4:	e7b9      	b.n	803d45a <_printf_i+0xf6>
 803d4e6:	6813      	ldr	r3, [r2, #0]
 803d4e8:	6825      	ldr	r5, [r4, #0]
 803d4ea:	1d18      	adds	r0, r3, #4
 803d4ec:	6961      	ldr	r1, [r4, #20]
 803d4ee:	6010      	str	r0, [r2, #0]
 803d4f0:	0628      	lsls	r0, r5, #24
 803d4f2:	681b      	ldr	r3, [r3, #0]
 803d4f4:	d501      	bpl.n	803d4fa <_printf_i+0x196>
 803d4f6:	6019      	str	r1, [r3, #0]
 803d4f8:	e002      	b.n	803d500 <_printf_i+0x19c>
 803d4fa:	066a      	lsls	r2, r5, #25
 803d4fc:	d5fb      	bpl.n	803d4f6 <_printf_i+0x192>
 803d4fe:	8019      	strh	r1, [r3, #0]
 803d500:	2300      	movs	r3, #0
 803d502:	4665      	mov	r5, ip
 803d504:	6123      	str	r3, [r4, #16]
 803d506:	e7b9      	b.n	803d47c <_printf_i+0x118>
 803d508:	6813      	ldr	r3, [r2, #0]
 803d50a:	1d19      	adds	r1, r3, #4
 803d50c:	6011      	str	r1, [r2, #0]
 803d50e:	2100      	movs	r1, #0
 803d510:	681d      	ldr	r5, [r3, #0]
 803d512:	6862      	ldr	r2, [r4, #4]
 803d514:	4628      	mov	r0, r5
 803d516:	f000 f8e1 	bl	803d6dc <memchr>
 803d51a:	b108      	cbz	r0, 803d520 <_printf_i+0x1bc>
 803d51c:	1b40      	subs	r0, r0, r5
 803d51e:	6060      	str	r0, [r4, #4]
 803d520:	6863      	ldr	r3, [r4, #4]
 803d522:	6123      	str	r3, [r4, #16]
 803d524:	2300      	movs	r3, #0
 803d526:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 803d52a:	e7a7      	b.n	803d47c <_printf_i+0x118>
 803d52c:	6923      	ldr	r3, [r4, #16]
 803d52e:	462a      	mov	r2, r5
 803d530:	4639      	mov	r1, r7
 803d532:	4630      	mov	r0, r6
 803d534:	47c0      	blx	r8
 803d536:	3001      	adds	r0, #1
 803d538:	d0aa      	beq.n	803d490 <_printf_i+0x12c>
 803d53a:	6823      	ldr	r3, [r4, #0]
 803d53c:	079b      	lsls	r3, r3, #30
 803d53e:	d413      	bmi.n	803d568 <_printf_i+0x204>
 803d540:	68e0      	ldr	r0, [r4, #12]
 803d542:	9b03      	ldr	r3, [sp, #12]
 803d544:	4298      	cmp	r0, r3
 803d546:	bfb8      	it	lt
 803d548:	4618      	movlt	r0, r3
 803d54a:	e7a3      	b.n	803d494 <_printf_i+0x130>
 803d54c:	2301      	movs	r3, #1
 803d54e:	464a      	mov	r2, r9
 803d550:	4639      	mov	r1, r7
 803d552:	4630      	mov	r0, r6
 803d554:	47c0      	blx	r8
 803d556:	3001      	adds	r0, #1
 803d558:	d09a      	beq.n	803d490 <_printf_i+0x12c>
 803d55a:	3501      	adds	r5, #1
 803d55c:	68e3      	ldr	r3, [r4, #12]
 803d55e:	9a03      	ldr	r2, [sp, #12]
 803d560:	1a9b      	subs	r3, r3, r2
 803d562:	42ab      	cmp	r3, r5
 803d564:	dcf2      	bgt.n	803d54c <_printf_i+0x1e8>
 803d566:	e7eb      	b.n	803d540 <_printf_i+0x1dc>
 803d568:	2500      	movs	r5, #0
 803d56a:	f104 0919 	add.w	r9, r4, #25
 803d56e:	e7f5      	b.n	803d55c <_printf_i+0x1f8>
 803d570:	2b00      	cmp	r3, #0
 803d572:	d1ac      	bne.n	803d4ce <_printf_i+0x16a>
 803d574:	7803      	ldrb	r3, [r0, #0]
 803d576:	f104 0542 	add.w	r5, r4, #66	; 0x42
 803d57a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 803d57e:	e76c      	b.n	803d45a <_printf_i+0xf6>
 803d580:	0803f2b1 	.word	0x0803f2b1
 803d584:	0803f2c2 	.word	0x0803f2c2

0803d588 <_sbrk_r>:
 803d588:	b538      	push	{r3, r4, r5, lr}
 803d58a:	2300      	movs	r3, #0
 803d58c:	4c05      	ldr	r4, [pc, #20]	; (803d5a4 <_sbrk_r+0x1c>)
 803d58e:	4605      	mov	r5, r0
 803d590:	4608      	mov	r0, r1
 803d592:	6023      	str	r3, [r4, #0]
 803d594:	f000 fa76 	bl	803da84 <_sbrk>
 803d598:	1c43      	adds	r3, r0, #1
 803d59a:	d102      	bne.n	803d5a2 <_sbrk_r+0x1a>
 803d59c:	6823      	ldr	r3, [r4, #0]
 803d59e:	b103      	cbz	r3, 803d5a2 <_sbrk_r+0x1a>
 803d5a0:	602b      	str	r3, [r5, #0]
 803d5a2:	bd38      	pop	{r3, r4, r5, pc}
 803d5a4:	200006d0 	.word	0x200006d0

0803d5a8 <__sread>:
 803d5a8:	b510      	push	{r4, lr}
 803d5aa:	460c      	mov	r4, r1
 803d5ac:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 803d5b0:	f000 f8a4 	bl	803d6fc <_read_r>
 803d5b4:	2800      	cmp	r0, #0
 803d5b6:	bfab      	itete	ge
 803d5b8:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 803d5ba:	89a3      	ldrhlt	r3, [r4, #12]
 803d5bc:	181b      	addge	r3, r3, r0
 803d5be:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 803d5c2:	bfac      	ite	ge
 803d5c4:	6563      	strge	r3, [r4, #84]	; 0x54
 803d5c6:	81a3      	strhlt	r3, [r4, #12]
 803d5c8:	bd10      	pop	{r4, pc}

0803d5ca <__swrite>:
 803d5ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 803d5ce:	461f      	mov	r7, r3
 803d5d0:	898b      	ldrh	r3, [r1, #12]
 803d5d2:	4605      	mov	r5, r0
 803d5d4:	460c      	mov	r4, r1
 803d5d6:	05db      	lsls	r3, r3, #23
 803d5d8:	4616      	mov	r6, r2
 803d5da:	d505      	bpl.n	803d5e8 <__swrite+0x1e>
 803d5dc:	2302      	movs	r3, #2
 803d5de:	2200      	movs	r2, #0
 803d5e0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 803d5e4:	f000 f868 	bl	803d6b8 <_lseek_r>
 803d5e8:	89a3      	ldrh	r3, [r4, #12]
 803d5ea:	4632      	mov	r2, r6
 803d5ec:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 803d5f0:	4628      	mov	r0, r5
 803d5f2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 803d5f6:	81a3      	strh	r3, [r4, #12]
 803d5f8:	463b      	mov	r3, r7
 803d5fa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 803d5fe:	f000 b817 	b.w	803d630 <_write_r>

0803d602 <__sseek>:
 803d602:	b510      	push	{r4, lr}
 803d604:	460c      	mov	r4, r1
 803d606:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 803d60a:	f000 f855 	bl	803d6b8 <_lseek_r>
 803d60e:	1c43      	adds	r3, r0, #1
 803d610:	89a3      	ldrh	r3, [r4, #12]
 803d612:	bf15      	itete	ne
 803d614:	6560      	strne	r0, [r4, #84]	; 0x54
 803d616:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 803d61a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 803d61e:	81a3      	strheq	r3, [r4, #12]
 803d620:	bf18      	it	ne
 803d622:	81a3      	strhne	r3, [r4, #12]
 803d624:	bd10      	pop	{r4, pc}

0803d626 <__sclose>:
 803d626:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 803d62a:	f000 b813 	b.w	803d654 <_close_r>
	...

0803d630 <_write_r>:
 803d630:	b538      	push	{r3, r4, r5, lr}
 803d632:	4605      	mov	r5, r0
 803d634:	4c06      	ldr	r4, [pc, #24]	; (803d650 <_write_r+0x20>)
 803d636:	4608      	mov	r0, r1
 803d638:	4611      	mov	r1, r2
 803d63a:	2200      	movs	r2, #0
 803d63c:	6022      	str	r2, [r4, #0]
 803d63e:	461a      	mov	r2, r3
 803d640:	f7fb fc54 	bl	8038eec <_write>
 803d644:	1c43      	adds	r3, r0, #1
 803d646:	d102      	bne.n	803d64e <_write_r+0x1e>
 803d648:	6823      	ldr	r3, [r4, #0]
 803d64a:	b103      	cbz	r3, 803d64e <_write_r+0x1e>
 803d64c:	602b      	str	r3, [r5, #0]
 803d64e:	bd38      	pop	{r3, r4, r5, pc}
 803d650:	200006d0 	.word	0x200006d0

0803d654 <_close_r>:
 803d654:	b538      	push	{r3, r4, r5, lr}
 803d656:	2300      	movs	r3, #0
 803d658:	4c05      	ldr	r4, [pc, #20]	; (803d670 <_close_r+0x1c>)
 803d65a:	4605      	mov	r5, r0
 803d65c:	4608      	mov	r0, r1
 803d65e:	6023      	str	r3, [r4, #0]
 803d660:	f000 f9e8 	bl	803da34 <_close>
 803d664:	1c43      	adds	r3, r0, #1
 803d666:	d102      	bne.n	803d66e <_close_r+0x1a>
 803d668:	6823      	ldr	r3, [r4, #0]
 803d66a:	b103      	cbz	r3, 803d66e <_close_r+0x1a>
 803d66c:	602b      	str	r3, [r5, #0]
 803d66e:	bd38      	pop	{r3, r4, r5, pc}
 803d670:	200006d0 	.word	0x200006d0

0803d674 <_fstat_r>:
 803d674:	b538      	push	{r3, r4, r5, lr}
 803d676:	2300      	movs	r3, #0
 803d678:	4c06      	ldr	r4, [pc, #24]	; (803d694 <_fstat_r+0x20>)
 803d67a:	4605      	mov	r5, r0
 803d67c:	4608      	mov	r0, r1
 803d67e:	4611      	mov	r1, r2
 803d680:	6023      	str	r3, [r4, #0]
 803d682:	f000 f9df 	bl	803da44 <_fstat>
 803d686:	1c43      	adds	r3, r0, #1
 803d688:	d102      	bne.n	803d690 <_fstat_r+0x1c>
 803d68a:	6823      	ldr	r3, [r4, #0]
 803d68c:	b103      	cbz	r3, 803d690 <_fstat_r+0x1c>
 803d68e:	602b      	str	r3, [r5, #0]
 803d690:	bd38      	pop	{r3, r4, r5, pc}
 803d692:	bf00      	nop
 803d694:	200006d0 	.word	0x200006d0

0803d698 <_isatty_r>:
 803d698:	b538      	push	{r3, r4, r5, lr}
 803d69a:	2300      	movs	r3, #0
 803d69c:	4c05      	ldr	r4, [pc, #20]	; (803d6b4 <_isatty_r+0x1c>)
 803d69e:	4605      	mov	r5, r0
 803d6a0:	4608      	mov	r0, r1
 803d6a2:	6023      	str	r3, [r4, #0]
 803d6a4:	f000 f9d6 	bl	803da54 <_isatty>
 803d6a8:	1c43      	adds	r3, r0, #1
 803d6aa:	d102      	bne.n	803d6b2 <_isatty_r+0x1a>
 803d6ac:	6823      	ldr	r3, [r4, #0]
 803d6ae:	b103      	cbz	r3, 803d6b2 <_isatty_r+0x1a>
 803d6b0:	602b      	str	r3, [r5, #0]
 803d6b2:	bd38      	pop	{r3, r4, r5, pc}
 803d6b4:	200006d0 	.word	0x200006d0

0803d6b8 <_lseek_r>:
 803d6b8:	b538      	push	{r3, r4, r5, lr}
 803d6ba:	4605      	mov	r5, r0
 803d6bc:	4c06      	ldr	r4, [pc, #24]	; (803d6d8 <_lseek_r+0x20>)
 803d6be:	4608      	mov	r0, r1
 803d6c0:	4611      	mov	r1, r2
 803d6c2:	2200      	movs	r2, #0
 803d6c4:	6022      	str	r2, [r4, #0]
 803d6c6:	461a      	mov	r2, r3
 803d6c8:	f000 f9cc 	bl	803da64 <_lseek>
 803d6cc:	1c43      	adds	r3, r0, #1
 803d6ce:	d102      	bne.n	803d6d6 <_lseek_r+0x1e>
 803d6d0:	6823      	ldr	r3, [r4, #0]
 803d6d2:	b103      	cbz	r3, 803d6d6 <_lseek_r+0x1e>
 803d6d4:	602b      	str	r3, [r5, #0]
 803d6d6:	bd38      	pop	{r3, r4, r5, pc}
 803d6d8:	200006d0 	.word	0x200006d0

0803d6dc <memchr>:
 803d6dc:	b2c9      	uxtb	r1, r1
 803d6de:	4402      	add	r2, r0
 803d6e0:	b510      	push	{r4, lr}
 803d6e2:	4290      	cmp	r0, r2
 803d6e4:	4603      	mov	r3, r0
 803d6e6:	d101      	bne.n	803d6ec <memchr+0x10>
 803d6e8:	2300      	movs	r3, #0
 803d6ea:	e003      	b.n	803d6f4 <memchr+0x18>
 803d6ec:	781c      	ldrb	r4, [r3, #0]
 803d6ee:	3001      	adds	r0, #1
 803d6f0:	428c      	cmp	r4, r1
 803d6f2:	d1f6      	bne.n	803d6e2 <memchr+0x6>
 803d6f4:	4618      	mov	r0, r3
 803d6f6:	bd10      	pop	{r4, pc}

0803d6f8 <__malloc_lock>:
 803d6f8:	4770      	bx	lr

0803d6fa <__malloc_unlock>:
 803d6fa:	4770      	bx	lr

0803d6fc <_read_r>:
 803d6fc:	b538      	push	{r3, r4, r5, lr}
 803d6fe:	4605      	mov	r5, r0
 803d700:	4c06      	ldr	r4, [pc, #24]	; (803d71c <_read_r+0x20>)
 803d702:	4608      	mov	r0, r1
 803d704:	4611      	mov	r1, r2
 803d706:	2200      	movs	r2, #0
 803d708:	6022      	str	r2, [r4, #0]
 803d70a:	461a      	mov	r2, r3
 803d70c:	f000 f9b2 	bl	803da74 <_read>
 803d710:	1c43      	adds	r3, r0, #1
 803d712:	d102      	bne.n	803d71a <_read_r+0x1e>
 803d714:	6823      	ldr	r3, [r4, #0]
 803d716:	b103      	cbz	r3, 803d71a <_read_r+0x1e>
 803d718:	602b      	str	r3, [r5, #0]
 803d71a:	bd38      	pop	{r3, r4, r5, pc}
 803d71c:	200006d0 	.word	0x200006d0

0803d720 <__aeabi_uldivmod>:
 803d720:	b953      	cbnz	r3, 803d738 <__aeabi_uldivmod+0x18>
 803d722:	b94a      	cbnz	r2, 803d738 <__aeabi_uldivmod+0x18>
 803d724:	2900      	cmp	r1, #0
 803d726:	bf08      	it	eq
 803d728:	2800      	cmpeq	r0, #0
 803d72a:	bf1c      	itt	ne
 803d72c:	f04f 31ff 	movne.w	r1, #4294967295
 803d730:	f04f 30ff 	movne.w	r0, #4294967295
 803d734:	f000 b97c 	b.w	803da30 <__aeabi_idiv0>
 803d738:	f1ad 0c08 	sub.w	ip, sp, #8
 803d73c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 803d740:	f000 f806 	bl	803d750 <__udivmoddi4>
 803d744:	f8dd e004 	ldr.w	lr, [sp, #4]
 803d748:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 803d74c:	b004      	add	sp, #16
 803d74e:	4770      	bx	lr

0803d750 <__udivmoddi4>:
 803d750:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 803d754:	468c      	mov	ip, r1
 803d756:	9d08      	ldr	r5, [sp, #32]
 803d758:	4604      	mov	r4, r0
 803d75a:	468a      	mov	sl, r1
 803d75c:	2b00      	cmp	r3, #0
 803d75e:	d14a      	bne.n	803d7f6 <__udivmoddi4+0xa6>
 803d760:	428a      	cmp	r2, r1
 803d762:	4617      	mov	r7, r2
 803d764:	d962      	bls.n	803d82c <__udivmoddi4+0xdc>
 803d766:	fab2 f682 	clz	r6, r2
 803d76a:	b14e      	cbz	r6, 803d780 <__udivmoddi4+0x30>
 803d76c:	f1c6 0e20 	rsb	lr, r6, #32
 803d770:	fa01 f306 	lsl.w	r3, r1, r6
 803d774:	40b7      	lsls	r7, r6
 803d776:	40b4      	lsls	r4, r6
 803d778:	fa20 fe0e 	lsr.w	lr, r0, lr
 803d77c:	ea4e 0a03 	orr.w	sl, lr, r3
 803d780:	ea4f 4817 	mov.w	r8, r7, lsr #16
 803d784:	0c23      	lsrs	r3, r4, #16
 803d786:	fa1f f987 	uxth.w	r9, r7
 803d78a:	fbba fef8 	udiv	lr, sl, r8
 803d78e:	fb08 aa1e 	mls	sl, r8, lr, sl
 803d792:	fb0e f209 	mul.w	r2, lr, r9
 803d796:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
 803d79a:	429a      	cmp	r2, r3
 803d79c:	d90b      	bls.n	803d7b6 <__udivmoddi4+0x66>
 803d79e:	18fb      	adds	r3, r7, r3
 803d7a0:	f10e 31ff 	add.w	r1, lr, #4294967295
 803d7a4:	bf2c      	ite	cs
 803d7a6:	2001      	movcs	r0, #1
 803d7a8:	2000      	movcc	r0, #0
 803d7aa:	429a      	cmp	r2, r3
 803d7ac:	d902      	bls.n	803d7b4 <__udivmoddi4+0x64>
 803d7ae:	2800      	cmp	r0, #0
 803d7b0:	f000 812a 	beq.w	803da08 <__udivmoddi4+0x2b8>
 803d7b4:	468e      	mov	lr, r1
 803d7b6:	1a9a      	subs	r2, r3, r2
 803d7b8:	b2a3      	uxth	r3, r4
 803d7ba:	fbb2 f0f8 	udiv	r0, r2, r8
 803d7be:	fb08 2210 	mls	r2, r8, r0, r2
 803d7c2:	fb00 f909 	mul.w	r9, r0, r9
 803d7c6:	ea43 4402 	orr.w	r4, r3, r2, lsl #16
 803d7ca:	45a1      	cmp	r9, r4
 803d7cc:	d907      	bls.n	803d7de <__udivmoddi4+0x8e>
 803d7ce:	193c      	adds	r4, r7, r4
 803d7d0:	f100 33ff 	add.w	r3, r0, #4294967295
 803d7d4:	d202      	bcs.n	803d7dc <__udivmoddi4+0x8c>
 803d7d6:	45a1      	cmp	r9, r4
 803d7d8:	f200 8110 	bhi.w	803d9fc <__udivmoddi4+0x2ac>
 803d7dc:	4618      	mov	r0, r3
 803d7de:	eba4 0409 	sub.w	r4, r4, r9
 803d7e2:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
 803d7e6:	2100      	movs	r1, #0
 803d7e8:	b11d      	cbz	r5, 803d7f2 <__udivmoddi4+0xa2>
 803d7ea:	40f4      	lsrs	r4, r6
 803d7ec:	2300      	movs	r3, #0
 803d7ee:	e9c5 4300 	strd	r4, r3, [r5]
 803d7f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 803d7f6:	428b      	cmp	r3, r1
 803d7f8:	d908      	bls.n	803d80c <__udivmoddi4+0xbc>
 803d7fa:	2d00      	cmp	r5, #0
 803d7fc:	f000 80f2 	beq.w	803d9e4 <__udivmoddi4+0x294>
 803d800:	2100      	movs	r1, #0
 803d802:	e9c5 0c00 	strd	r0, ip, [r5]
 803d806:	4608      	mov	r0, r1
 803d808:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 803d80c:	fab3 f183 	clz	r1, r3
 803d810:	2900      	cmp	r1, #0
 803d812:	d14e      	bne.n	803d8b2 <__udivmoddi4+0x162>
 803d814:	4563      	cmp	r3, ip
 803d816:	f0c0 80e8 	bcc.w	803d9ea <__udivmoddi4+0x29a>
 803d81a:	4282      	cmp	r2, r0
 803d81c:	f240 80e5 	bls.w	803d9ea <__udivmoddi4+0x29a>
 803d820:	4608      	mov	r0, r1
 803d822:	2d00      	cmp	r5, #0
 803d824:	d0e5      	beq.n	803d7f2 <__udivmoddi4+0xa2>
 803d826:	e9c5 4a00 	strd	r4, sl, [r5]
 803d82a:	e7e2      	b.n	803d7f2 <__udivmoddi4+0xa2>
 803d82c:	b902      	cbnz	r2, 803d830 <__udivmoddi4+0xe0>
 803d82e:	deff      	udf	#255	; 0xff
 803d830:	fab2 f682 	clz	r6, r2
 803d834:	2e00      	cmp	r6, #0
 803d836:	f040 8099 	bne.w	803d96c <__udivmoddi4+0x21c>
 803d83a:	1a8b      	subs	r3, r1, r2
 803d83c:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 803d840:	fa1f f882 	uxth.w	r8, r2
 803d844:	2101      	movs	r1, #1
 803d846:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 803d84a:	fbb3 f2fe 	udiv	r2, r3, lr
 803d84e:	fb0e 3012 	mls	r0, lr, r2, r3
 803d852:	fb08 f902 	mul.w	r9, r8, r2
 803d856:	ea4c 4c00 	orr.w	ip, ip, r0, lsl #16
 803d85a:	45e1      	cmp	r9, ip
 803d85c:	d908      	bls.n	803d870 <__udivmoddi4+0x120>
 803d85e:	eb17 0c0c 	adds.w	ip, r7, ip
 803d862:	f102 33ff 	add.w	r3, r2, #4294967295
 803d866:	d202      	bcs.n	803d86e <__udivmoddi4+0x11e>
 803d868:	45e1      	cmp	r9, ip
 803d86a:	f200 80ca 	bhi.w	803da02 <__udivmoddi4+0x2b2>
 803d86e:	461a      	mov	r2, r3
 803d870:	ebac 0c09 	sub.w	ip, ip, r9
 803d874:	b2a3      	uxth	r3, r4
 803d876:	fbbc f0fe 	udiv	r0, ip, lr
 803d87a:	fb0e cc10 	mls	ip, lr, r0, ip
 803d87e:	fb08 f800 	mul.w	r8, r8, r0
 803d882:	ea43 440c 	orr.w	r4, r3, ip, lsl #16
 803d886:	45a0      	cmp	r8, r4
 803d888:	d90e      	bls.n	803d8a8 <__udivmoddi4+0x158>
 803d88a:	193c      	adds	r4, r7, r4
 803d88c:	f100 33ff 	add.w	r3, r0, #4294967295
 803d890:	bf2c      	ite	cs
 803d892:	f04f 0c01 	movcs.w	ip, #1
 803d896:	f04f 0c00 	movcc.w	ip, #0
 803d89a:	45a0      	cmp	r8, r4
 803d89c:	d903      	bls.n	803d8a6 <__udivmoddi4+0x156>
 803d89e:	f1bc 0f00 	cmp.w	ip, #0
 803d8a2:	f000 80a8 	beq.w	803d9f6 <__udivmoddi4+0x2a6>
 803d8a6:	4618      	mov	r0, r3
 803d8a8:	eba4 0408 	sub.w	r4, r4, r8
 803d8ac:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 803d8b0:	e79a      	b.n	803d7e8 <__udivmoddi4+0x98>
 803d8b2:	f1c1 0420 	rsb	r4, r1, #32
 803d8b6:	408b      	lsls	r3, r1
 803d8b8:	fa02 fe01 	lsl.w	lr, r2, r1
 803d8bc:	fa0c f601 	lsl.w	r6, ip, r1
 803d8c0:	40e2      	lsrs	r2, r4
 803d8c2:	fa20 f704 	lsr.w	r7, r0, r4
 803d8c6:	fa2c fc04 	lsr.w	ip, ip, r4
 803d8ca:	fa00 f801 	lsl.w	r8, r0, r1
 803d8ce:	4313      	orrs	r3, r2
 803d8d0:	433e      	orrs	r6, r7
 803d8d2:	0c1f      	lsrs	r7, r3, #16
 803d8d4:	0c32      	lsrs	r2, r6, #16
 803d8d6:	fa1f f983 	uxth.w	r9, r3
 803d8da:	fbbc f0f7 	udiv	r0, ip, r7
 803d8de:	fb07 cc10 	mls	ip, r7, r0, ip
 803d8e2:	fb00 fa09 	mul.w	sl, r0, r9
 803d8e6:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
 803d8ea:	45e2      	cmp	sl, ip
 803d8ec:	d908      	bls.n	803d900 <__udivmoddi4+0x1b0>
 803d8ee:	eb13 0c0c 	adds.w	ip, r3, ip
 803d8f2:	f100 32ff 	add.w	r2, r0, #4294967295
 803d8f6:	d202      	bcs.n	803d8fe <__udivmoddi4+0x1ae>
 803d8f8:	45e2      	cmp	sl, ip
 803d8fa:	f200 8089 	bhi.w	803da10 <__udivmoddi4+0x2c0>
 803d8fe:	4610      	mov	r0, r2
 803d900:	ebac 0c0a 	sub.w	ip, ip, sl
 803d904:	b2b6      	uxth	r6, r6
 803d906:	fbbc faf7 	udiv	sl, ip, r7
 803d90a:	fb07 cc1a 	mls	ip, r7, sl, ip
 803d90e:	fb0a f909 	mul.w	r9, sl, r9
 803d912:	ea46 420c 	orr.w	r2, r6, ip, lsl #16
 803d916:	4591      	cmp	r9, r2
 803d918:	d906      	bls.n	803d928 <__udivmoddi4+0x1d8>
 803d91a:	189a      	adds	r2, r3, r2
 803d91c:	f10a 36ff 	add.w	r6, sl, #4294967295
 803d920:	d201      	bcs.n	803d926 <__udivmoddi4+0x1d6>
 803d922:	4591      	cmp	r9, r2
 803d924:	d87a      	bhi.n	803da1c <__udivmoddi4+0x2cc>
 803d926:	46b2      	mov	sl, r6
 803d928:	ea4a 4000 	orr.w	r0, sl, r0, lsl #16
 803d92c:	eba2 0209 	sub.w	r2, r2, r9
 803d930:	fba0 670e 	umull	r6, r7, r0, lr
 803d934:	42ba      	cmp	r2, r7
 803d936:	46b4      	mov	ip, r6
 803d938:	46b9      	mov	r9, r7
 803d93a:	d302      	bcc.n	803d942 <__udivmoddi4+0x1f2>
 803d93c:	d107      	bne.n	803d94e <__udivmoddi4+0x1fe>
 803d93e:	45b0      	cmp	r8, r6
 803d940:	d205      	bcs.n	803d94e <__udivmoddi4+0x1fe>
 803d942:	ebb6 0c0e 	subs.w	ip, r6, lr
 803d946:	eb67 0303 	sbc.w	r3, r7, r3
 803d94a:	3801      	subs	r0, #1
 803d94c:	4699      	mov	r9, r3
 803d94e:	2d00      	cmp	r5, #0
 803d950:	d06b      	beq.n	803da2a <__udivmoddi4+0x2da>
 803d952:	ebb8 030c 	subs.w	r3, r8, ip
 803d956:	eb62 0209 	sbc.w	r2, r2, r9
 803d95a:	fa02 f404 	lsl.w	r4, r2, r4
 803d95e:	40cb      	lsrs	r3, r1
 803d960:	40ca      	lsrs	r2, r1
 803d962:	2100      	movs	r1, #0
 803d964:	431c      	orrs	r4, r3
 803d966:	e9c5 4200 	strd	r4, r2, [r5]
 803d96a:	e742      	b.n	803d7f2 <__udivmoddi4+0xa2>
 803d96c:	40b7      	lsls	r7, r6
 803d96e:	f1c6 0220 	rsb	r2, r6, #32
 803d972:	fa01 f306 	lsl.w	r3, r1, r6
 803d976:	40b4      	lsls	r4, r6
 803d978:	fa21 fc02 	lsr.w	ip, r1, r2
 803d97c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 803d980:	fa20 f202 	lsr.w	r2, r0, r2
 803d984:	fa1f f887 	uxth.w	r8, r7
 803d988:	fbbc f1fe 	udiv	r1, ip, lr
 803d98c:	431a      	orrs	r2, r3
 803d98e:	fb0e cc11 	mls	ip, lr, r1, ip
 803d992:	fb01 f008 	mul.w	r0, r1, r8
 803d996:	0c13      	lsrs	r3, r2, #16
 803d998:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
 803d99c:	4560      	cmp	r0, ip
 803d99e:	d907      	bls.n	803d9b0 <__udivmoddi4+0x260>
 803d9a0:	eb17 0c0c 	adds.w	ip, r7, ip
 803d9a4:	f101 33ff 	add.w	r3, r1, #4294967295
 803d9a8:	d201      	bcs.n	803d9ae <__udivmoddi4+0x25e>
 803d9aa:	4560      	cmp	r0, ip
 803d9ac:	d833      	bhi.n	803da16 <__udivmoddi4+0x2c6>
 803d9ae:	4619      	mov	r1, r3
 803d9b0:	ebac 0c00 	sub.w	ip, ip, r0
 803d9b4:	b292      	uxth	r2, r2
 803d9b6:	fbbc f0fe 	udiv	r0, ip, lr
 803d9ba:	fb0e cc10 	mls	ip, lr, r0, ip
 803d9be:	fb00 f308 	mul.w	r3, r0, r8
 803d9c2:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
 803d9c6:	4563      	cmp	r3, ip
 803d9c8:	d907      	bls.n	803d9da <__udivmoddi4+0x28a>
 803d9ca:	eb17 0c0c 	adds.w	ip, r7, ip
 803d9ce:	f100 32ff 	add.w	r2, r0, #4294967295
 803d9d2:	d201      	bcs.n	803d9d8 <__udivmoddi4+0x288>
 803d9d4:	4563      	cmp	r3, ip
 803d9d6:	d825      	bhi.n	803da24 <__udivmoddi4+0x2d4>
 803d9d8:	4610      	mov	r0, r2
 803d9da:	ebac 0303 	sub.w	r3, ip, r3
 803d9de:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 803d9e2:	e730      	b.n	803d846 <__udivmoddi4+0xf6>
 803d9e4:	4629      	mov	r1, r5
 803d9e6:	4628      	mov	r0, r5
 803d9e8:	e703      	b.n	803d7f2 <__udivmoddi4+0xa2>
 803d9ea:	1a84      	subs	r4, r0, r2
 803d9ec:	eb6c 0303 	sbc.w	r3, ip, r3
 803d9f0:	2001      	movs	r0, #1
 803d9f2:	469a      	mov	sl, r3
 803d9f4:	e715      	b.n	803d822 <__udivmoddi4+0xd2>
 803d9f6:	3802      	subs	r0, #2
 803d9f8:	443c      	add	r4, r7
 803d9fa:	e755      	b.n	803d8a8 <__udivmoddi4+0x158>
 803d9fc:	3802      	subs	r0, #2
 803d9fe:	443c      	add	r4, r7
 803da00:	e6ed      	b.n	803d7de <__udivmoddi4+0x8e>
 803da02:	3a02      	subs	r2, #2
 803da04:	44bc      	add	ip, r7
 803da06:	e733      	b.n	803d870 <__udivmoddi4+0x120>
 803da08:	f1ae 0e02 	sub.w	lr, lr, #2
 803da0c:	443b      	add	r3, r7
 803da0e:	e6d2      	b.n	803d7b6 <__udivmoddi4+0x66>
 803da10:	3802      	subs	r0, #2
 803da12:	449c      	add	ip, r3
 803da14:	e774      	b.n	803d900 <__udivmoddi4+0x1b0>
 803da16:	3902      	subs	r1, #2
 803da18:	44bc      	add	ip, r7
 803da1a:	e7c9      	b.n	803d9b0 <__udivmoddi4+0x260>
 803da1c:	f1aa 0a02 	sub.w	sl, sl, #2
 803da20:	441a      	add	r2, r3
 803da22:	e781      	b.n	803d928 <__udivmoddi4+0x1d8>
 803da24:	3802      	subs	r0, #2
 803da26:	44bc      	add	ip, r7
 803da28:	e7d7      	b.n	803d9da <__udivmoddi4+0x28a>
 803da2a:	4629      	mov	r1, r5
 803da2c:	e6e1      	b.n	803d7f2 <__udivmoddi4+0xa2>
 803da2e:	bf00      	nop

0803da30 <__aeabi_idiv0>:
 803da30:	4770      	bx	lr
 803da32:	bf00      	nop

0803da34 <_close>:
 803da34:	4b02      	ldr	r3, [pc, #8]	; (803da40 <_close+0xc>)
 803da36:	2258      	movs	r2, #88	; 0x58
 803da38:	f04f 30ff 	mov.w	r0, #4294967295
 803da3c:	601a      	str	r2, [r3, #0]
 803da3e:	4770      	bx	lr
 803da40:	200006d0 	.word	0x200006d0

0803da44 <_fstat>:
 803da44:	4b02      	ldr	r3, [pc, #8]	; (803da50 <_fstat+0xc>)
 803da46:	2258      	movs	r2, #88	; 0x58
 803da48:	f04f 30ff 	mov.w	r0, #4294967295
 803da4c:	601a      	str	r2, [r3, #0]
 803da4e:	4770      	bx	lr
 803da50:	200006d0 	.word	0x200006d0

0803da54 <_isatty>:
 803da54:	4b02      	ldr	r3, [pc, #8]	; (803da60 <_isatty+0xc>)
 803da56:	2258      	movs	r2, #88	; 0x58
 803da58:	2000      	movs	r0, #0
 803da5a:	601a      	str	r2, [r3, #0]
 803da5c:	4770      	bx	lr
 803da5e:	bf00      	nop
 803da60:	200006d0 	.word	0x200006d0

0803da64 <_lseek>:
 803da64:	4b02      	ldr	r3, [pc, #8]	; (803da70 <_lseek+0xc>)
 803da66:	2258      	movs	r2, #88	; 0x58
 803da68:	f04f 30ff 	mov.w	r0, #4294967295
 803da6c:	601a      	str	r2, [r3, #0]
 803da6e:	4770      	bx	lr
 803da70:	200006d0 	.word	0x200006d0

0803da74 <_read>:
 803da74:	4b02      	ldr	r3, [pc, #8]	; (803da80 <_read+0xc>)
 803da76:	2258      	movs	r2, #88	; 0x58
 803da78:	f04f 30ff 	mov.w	r0, #4294967295
 803da7c:	601a      	str	r2, [r3, #0]
 803da7e:	4770      	bx	lr
 803da80:	200006d0 	.word	0x200006d0

0803da84 <_sbrk>:
 803da84:	4b04      	ldr	r3, [pc, #16]	; (803da98 <_sbrk+0x14>)
 803da86:	4602      	mov	r2, r0
 803da88:	6819      	ldr	r1, [r3, #0]
 803da8a:	b909      	cbnz	r1, 803da90 <_sbrk+0xc>
 803da8c:	4903      	ldr	r1, [pc, #12]	; (803da9c <_sbrk+0x18>)
 803da8e:	6019      	str	r1, [r3, #0]
 803da90:	6818      	ldr	r0, [r3, #0]
 803da92:	4402      	add	r2, r0
 803da94:	601a      	str	r2, [r3, #0]
 803da96:	4770      	bx	lr
 803da98:	20000680 	.word	0x20000680
 803da9c:	200016e0 	.word	0x200016e0

0803daa0 <_exit>:
 803daa0:	e7fe      	b.n	803daa0 <_exit>
	...

0803daa4 <_init>:
 803daa4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803daa6:	bf00      	nop
 803daa8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803daaa:	bc08      	pop	{r3}
 803daac:	469e      	mov	lr, r3
 803daae:	4770      	bx	lr

0803dab0 <_fini>:
 803dab0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803dab2:	bf00      	nop
 803dab4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803dab6:	bc08      	pop	{r3}
 803dab8:	469e      	mov	lr, r3
 803daba:	4770      	bx	lr
 803dabc:	414c465b 	.word	0x414c465b
 803dac0:	495f4853 	.word	0x495f4853
 803dac4:	4c205d46 	.word	0x4c205d46
 803dac8:	206b636f 	.word	0x206b636f
 803dacc:	6c696166 	.word	0x6c696166
 803dad0:	0d657275 	.word	0x0d657275
 803dad4:	4c465b00 	.word	0x4c465b00
 803dad8:	5f485341 	.word	0x5f485341
 803dadc:	205d4649 	.word	0x205d4649
 803dae0:	6f6c6e55 	.word	0x6f6c6e55
 803dae4:	66206b63 	.word	0x66206b63
 803dae8:	756c6961 	.word	0x756c6961
 803daec:	000d6572 	.word	0x000d6572
 803daf0:	2d2d2020 	.word	0x2d2d2020
 803daf4:	6e655320 	.word	0x6e655320
 803daf8:	69462064 	.word	0x69462064
 803dafc:	61776d72 	.word	0x61776d72
 803db00:	0d206572 	.word	0x0d206572
 803db04:	2020000a 	.word	0x2020000a
 803db08:	2d202d2d 	.word	0x2d202d2d
 803db0c:	6946202d 	.word	0x6946202d
 803db10:	203e656c 	.word	0x203e656c
 803db14:	6e617254 	.word	0x6e617254
 803db18:	72656673 	.word	0x72656673
 803db1c:	4d59203e 	.word	0x4d59203e
 803db20:	4d45444f 	.word	0x4d45444f
 803db24:	6553203e 	.word	0x6553203e
 803db28:	0920646e 	.word	0x0920646e
 803db2c:	2d202000 	.word	0x2d202000
 803db30:	2d2d202d 	.word	0x2d2d202d
 803db34:	6f725020 	.word	0x6f725020
 803db38:	6d617267 	.word	0x6d617267
 803db3c:	676e696d 	.word	0x676e696d
 803db40:	6d6f4320 	.word	0x6d6f4320
 803db44:	74656c70 	.word	0x74656c70
 803db48:	53206465 	.word	0x53206465
 803db4c:	65636375 	.word	0x65636375
 803db50:	75667373 	.word	0x75667373
 803db54:	21796c6c 	.word	0x21796c6c
 803db58:	20000a0d 	.word	0x20000a0d
 803db5c:	202d2d20 	.word	0x202d2d20
 803db60:	42202d2d 	.word	0x42202d2d
 803db64:	73657479 	.word	0x73657479
 803db68:	6c25203a 	.word	0x6c25203a
 803db6c:	0a0a0d75 	.word	0x0a0a0d75
 803db70:	2d202000 	.word	0x2d202000
 803db74:	2d2d202d 	.word	0x2d2d202d
 803db78:	41212120 	.word	0x41212120
 803db7c:	74726f62 	.word	0x74726f62
 803db80:	62206465 	.word	0x62206465
 803db84:	73752079 	.word	0x73752079
 803db88:	21217265 	.word	0x21217265
 803db8c:	20000a0d 	.word	0x20000a0d
 803db90:	202d2d20 	.word	0x202d2d20
 803db94:	21202d2d 	.word	0x21202d2d
 803db98:	72724521 	.word	0x72724521
 803db9c:	6420726f 	.word	0x6420726f
 803dba0:	6e697275 	.word	0x6e697275
 803dba4:	69662067 	.word	0x69662067
 803dba8:	6420656c 	.word	0x6420656c
 803dbac:	6c6e776f 	.word	0x6c6e776f
 803dbb0:	2164616f 	.word	0x2164616f
 803dbb4:	000a0d21 	.word	0x000a0d21
 803dbb8:	3d3d0a0d 	.word	0x3d3d0a0d
 803dbbc:	3d3d3d3d 	.word	0x3d3d3d3d
 803dbc0:	3d3d3d3d 	.word	0x3d3d3d3d
 803dbc4:	3d3d3d3d 	.word	0x3d3d3d3d
 803dbc8:	4e203d3d 	.word	0x4e203d3d
 803dbcc:	46207765 	.word	0x46207765
 803dbd0:	6f442077 	.word	0x6f442077
 803dbd4:	6f6c6e77 	.word	0x6f6c6e77
 803dbd8:	3d206461 	.word	0x3d206461
 803dbdc:	3d3d3d3d 	.word	0x3d3d3d3d
 803dbe0:	3d3d3d3d 	.word	0x3d3d3d3d
 803dbe4:	3d3d3d3d 	.word	0x3d3d3d3d
 803dbe8:	3d3d3d3d 	.word	0x3d3d3d3d
 803dbec:	3d3d3d3d 	.word	0x3d3d3d3d
 803dbf0:	3d3d3d3d 	.word	0x3d3d3d3d
 803dbf4:	20000a0d 	.word	0x20000a0d
 803dbf8:	776f4420 	.word	0x776f4420
 803dbfc:	616f6c6e 	.word	0x616f6c6e
 803dc00:	65532064 	.word	0x65532064
 803dc04:	65727563 	.word	0x65727563
 803dc08:	616d4920 	.word	0x616d4920
 803dc0c:	2d206567 	.word	0x2d206567
 803dc10:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc14:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc18:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc1c:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc20:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc24:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc28:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc2c:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc30:	0a0d3120 	.word	0x0a0d3120
 803dc34:	44202000 	.word	0x44202000
 803dc38:	6c6e776f 	.word	0x6c6e776f
 803dc3c:	2064616f 	.word	0x2064616f
 803dc40:	536e6f4e 	.word	0x536e6f4e
 803dc44:	72756365 	.word	0x72756365
 803dc48:	6d492065 	.word	0x6d492065
 803dc4c:	2d656761 	.word	0x2d656761
 803dc50:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc54:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc58:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc5c:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc60:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc64:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc68:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc6c:	32202d2d 	.word	0x32202d2d
 803dc70:	20000a0d 	.word	0x20000a0d
 803dc74:	73655220 	.word	0x73655220
 803dc78:	74207465 	.word	0x74207465
 803dc7c:	7274206f 	.word	0x7274206f
 803dc80:	65676769 	.word	0x65676769
 803dc84:	6e492072 	.word	0x6e492072
 803dc88:	6c617473 	.word	0x6c617473
 803dc8c:	6974616c 	.word	0x6974616c
 803dc90:	2d2d6e6f 	.word	0x2d2d6e6f
 803dc94:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc98:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc9c:	2d2d2d2d 	.word	0x2d2d2d2d
 803dca0:	2d2d2d2d 	.word	0x2d2d2d2d
 803dca4:	2d2d2d2d 	.word	0x2d2d2d2d
 803dca8:	2d2d2d2d 	.word	0x2d2d2d2d
 803dcac:	0a0d3320 	.word	0x0a0d3320
 803dcb0:	45202000 	.word	0x45202000
 803dcb4:	20746978 	.word	0x20746978
 803dcb8:	2077654e 	.word	0x2077654e
 803dcbc:	44205746 	.word	0x44205746
 803dcc0:	6c6e776f 	.word	0x6c6e776f
 803dcc4:	2064616f 	.word	0x2064616f
 803dcc8:	756e654d 	.word	0x756e654d
 803dccc:	2d2d2d20 	.word	0x2d2d2d20
 803dcd0:	2d2d2d2d 	.word	0x2d2d2d2d
 803dcd4:	2d2d2d2d 	.word	0x2d2d2d2d
 803dcd8:	2d2d2d2d 	.word	0x2d2d2d2d
 803dcdc:	2d2d2d2d 	.word	0x2d2d2d2d
 803dce0:	2d2d2d2d 	.word	0x2d2d2d2d
 803dce4:	2d2d2d2d 	.word	0x2d2d2d2d
 803dce8:	78202d2d 	.word	0x78202d2d
 803dcec:	0a0d      	.short	0x0a0d
 803dcee:	00          	.byte	0x00
 803dcef:	44          	.byte	0x44
 803dcf0:	6c6e776f 	.word	0x6c6e776f
 803dcf4:	2064616f 	.word	0x2064616f
 803dcf8:	75636553 	.word	0x75636553
 803dcfc:	49206572 	.word	0x49206572
 803dd00:	6567616d 	.word	0x6567616d
 803dd04:	2020000d 	.word	0x2020000d
 803dd08:	53202d2d 	.word	0x53202d2d
 803dd0c:	72756365 	.word	0x72756365
 803dd10:	6d492065 	.word	0x6d492065
 803dd14:	20656761 	.word	0x20656761
 803dd18:	72726f63 	.word	0x72726f63
 803dd1c:	6c746365 	.word	0x6c746365
 803dd20:	6f642079 	.word	0x6f642079
 803dd24:	6f6c6e77 	.word	0x6f6c6e77
 803dd28:	64656461 	.word	0x64656461
 803dd2c:	000a0d20 	.word	0x000a0d20
 803dd30:	6e776f44 	.word	0x6e776f44
 803dd34:	64616f6c 	.word	0x64616f6c
 803dd38:	6e6f4e20 	.word	0x6e6f4e20
 803dd3c:	75636553 	.word	0x75636553
 803dd40:	49206572 	.word	0x49206572
 803dd44:	6567616d 	.word	0x6567616d
 803dd48:	2020000d 	.word	0x2020000d
 803dd4c:	4e202d2d 	.word	0x4e202d2d
 803dd50:	65536e6f 	.word	0x65536e6f
 803dd54:	65727563 	.word	0x65727563
 803dd58:	616d4920 	.word	0x616d4920
 803dd5c:	63206567 	.word	0x63206567
 803dd60:	6572726f 	.word	0x6572726f
 803dd64:	796c7463 	.word	0x796c7463
 803dd68:	776f6420 	.word	0x776f6420
 803dd6c:	616f6c6e 	.word	0x616f6c6e
 803dd70:	20646564 	.word	0x20646564
 803dd74:	20000a0d 	.word	0x20000a0d
 803dd78:	202d2d20 	.word	0x202d2d20
 803dd7c:	74736e49 	.word	0x74736e49
 803dd80:	206c6c61 	.word	0x206c6c61
 803dd84:	67616d69 	.word	0x67616d69
 803dd88:	203a2065 	.word	0x203a2065
 803dd8c:	6f626572 	.word	0x6f626572
 803dd90:	0a0d746f 	.word	0x0a0d746f
 803dd94:	766e4900 	.word	0x766e4900
 803dd98:	64696c61 	.word	0x64696c61
 803dd9c:	6d754e20 	.word	0x6d754e20
 803dda0:	20726562 	.word	0x20726562
 803dda4:	0d21      	.short	0x0d21
 803dda6:	00          	.byte	0x00
 803dda7:	63          	.byte	0x63
 803dda8:	2c6c6f6f 	.word	0x2c6c6f6f
 803ddac:	74756220 	.word	0x74756220
 803ddb0:	756f7920 	.word	0x756f7920
 803ddb4:	6e616320 	.word	0x6e616320
 803ddb8:	72207427 	.word	0x72207427
 803ddbc:	72757465 	.word	0x72757465
 803ddc0:	0d2e2e6e 	.word	0x0d2e2e6e
 803ddc4:	6b6a000a 	.word	0x6b6a000a
 803ddc8:	73756a20 	.word	0x73756a20
 803ddcc:	72702074 	.word	0x72702074
 803ddd0:	20737365 	.word	0x20737365
 803ddd4:	000a0d78 	.word	0x000a0d78
 803ddd8:	61766e49 	.word	0x61766e49
 803dddc:	2064696c 	.word	0x2064696c
 803dde0:	626d754e 	.word	0x626d754e
 803dde4:	21207265 	.word	0x21207265
 803dde8:	65727020 	.word	0x65727020
 803ddec:	78207373 	.word	0x78207373
 803ddf0:	206f7420 	.word	0x206f7420
 803ddf4:	75746572 	.word	0x75746572
 803ddf8:	0d206e72 	.word	0x0d206e72
 803ddfc:	00          	.byte	0x00
 803ddfd:	0d          	.byte	0x0d
 803ddfe:	3d0a      	.short	0x3d0a
 803de00:	3d3d3d3d 	.word	0x3d3d3d3d
 803de04:	3d3d3d3d 	.word	0x3d3d3d3d
 803de08:	3d3d3d3d 	.word	0x3d3d3d3d
 803de0c:	3d3d3d3d 	.word	0x3d3d3d3d
 803de10:	4d203d3d 	.word	0x4d203d3d
 803de14:	206e6961 	.word	0x206e6961
 803de18:	756e654d 	.word	0x756e654d
 803de1c:	3d3d3d20 	.word	0x3d3d3d20
 803de20:	3d3d3d3d 	.word	0x3d3d3d3d
 803de24:	3d3d3d3d 	.word	0x3d3d3d3d
 803de28:	3d3d3d3d 	.word	0x3d3d3d3d
 803de2c:	3d3d3d3d 	.word	0x3d3d3d3d
 803de30:	3d3d3d3d 	.word	0x3d3d3d3d
 803de34:	3d3d3d3d 	.word	0x3d3d3d3d
 803de38:	000a0d3d 	.word	0x000a0d3d
 803de3c:	6f442020 	.word	0x6f442020
 803de40:	75747320 	.word	0x75747320
 803de44:	66206666 	.word	0x66206666
 803de48:	7420726f 	.word	0x7420726f
 803de4c:	69747365 	.word	0x69747365
 803de50:	6220676e 	.word	0x6220676e
 803de54:	6220696c 	.word	0x6220696c
 803de58:	6220616c 	.word	0x6220616c
 803de5c:	2062756c 	.word	0x2062756c
 803de60:	2d2d2d2d 	.word	0x2d2d2d2d
 803de64:	2d2d2d2d 	.word	0x2d2d2d2d
 803de68:	2d2d2d2d 	.word	0x2d2d2d2d
 803de6c:	2d2d2d2d 	.word	0x2d2d2d2d
 803de70:	2d2d2d2d 	.word	0x2d2d2d2d
 803de74:	0d30202d 	.word	0x0d30202d
 803de78:	2020000a 	.word	0x2020000a
 803de7c:	6e776f44 	.word	0x6e776f44
 803de80:	64616f6c 	.word	0x64616f6c
 803de84:	6e206120 	.word	0x6e206120
 803de88:	46207765 	.word	0x46207765
 803de8c:	6d492077 	.word	0x6d492077
 803de90:	20656761 	.word	0x20656761
 803de94:	2d2d2d2d 	.word	0x2d2d2d2d
 803de98:	2d2d2d2d 	.word	0x2d2d2d2d
 803de9c:	2d2d2d2d 	.word	0x2d2d2d2d
 803dea0:	2d2d2d2d 	.word	0x2d2d2d2d
 803dea4:	2d2d2d2d 	.word	0x2d2d2d2d
 803dea8:	2d2d2d2d 	.word	0x2d2d2d2d
 803deac:	2d2d2d2d 	.word	0x2d2d2d2d
 803deb0:	202d2d2d 	.word	0x202d2d2d
 803deb4:	000a0d31 	.word	0x000a0d31
 803deb8:	65542020 	.word	0x65542020
 803debc:	50207473 	.word	0x50207473
 803dec0:	65746f72 	.word	0x65746f72
 803dec4:	6f697463 	.word	0x6f697463
 803dec8:	2d20736e 	.word	0x2d20736e
 803decc:	2d2d2d2d 	.word	0x2d2d2d2d
 803ded0:	2d2d2d2d 	.word	0x2d2d2d2d
 803ded4:	2d2d2d2d 	.word	0x2d2d2d2d
 803ded8:	2d2d2d2d 	.word	0x2d2d2d2d
 803dedc:	2d2d2d2d 	.word	0x2d2d2d2d
 803dee0:	2d2d2d2d 	.word	0x2d2d2d2d
 803dee4:	2d2d2d2d 	.word	0x2d2d2d2d
 803dee8:	2d2d2d2d 	.word	0x2d2d2d2d
 803deec:	2d2d2d2d 	.word	0x2d2d2d2d
 803def0:	0d32202d 	.word	0x0d32202d
 803def4:	2020000a 	.word	0x2020000a
 803def8:	74736554 	.word	0x74736554
 803defc:	4d465420 	.word	0x4d465420
 803df00:	2d2d2d20 	.word	0x2d2d2d20
 803df04:	2d2d2d2d 	.word	0x2d2d2d2d
 803df08:	2d2d2d2d 	.word	0x2d2d2d2d
 803df0c:	2d2d2d2d 	.word	0x2d2d2d2d
 803df10:	2d2d2d2d 	.word	0x2d2d2d2d
 803df14:	2d2d2d2d 	.word	0x2d2d2d2d
 803df18:	2d2d2d2d 	.word	0x2d2d2d2d
 803df1c:	2d2d2d2d 	.word	0x2d2d2d2d
 803df20:	2d2d2d2d 	.word	0x2d2d2d2d
 803df24:	2d2d2d2d 	.word	0x2d2d2d2d
 803df28:	2d2d2d2d 	.word	0x2d2d2d2d
 803df2c:	202d2d2d 	.word	0x202d2d2d
 803df30:	000a0d33 	.word	0x000a0d33
 803df34:	65532020 	.word	0x65532020
 803df38:	7463656c 	.word	0x7463656c
 803df3c:	206e6f69 	.word	0x206e6f69
 803df40:	000a0d3a 	.word	0x000a0d3a

0803df44 <UserAppId>:
 803df44:	3d0a0d41 3d3d3d3d 3d3d3d3d 3d3d3d3d     A..=============
 803df54:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 803df64:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 803df74:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 803df84:	3d3d3d3d 3d3d3d3d 0a0d003d 2020203d     =========...=   
 803df94:	20202020 20202020 28202020 43202943                (C) C
 803dfa4:	5259504f 54484749 31303220 54532039     OPYRIGHT 2019 ST
 803dfb4:	7263694d 656c656f 6f727463 7363696e     Microelectronics
 803dfc4:	20202020 20202020 20202020 20202020                     
 803dfd4:	0d003d20 20203d0a 20202020 20202020      =...=          
 803dfe4:	20202020 20202020 20202020 20202020                     
 803dff4:	20202020 20202020 20202020 20202020                     
 803e004:	20202020 20202020 20202020 20202020                     
 803e014:	20202020 20202020 003d2020 203d0a0d               =...= 
 803e024:	20202020 20202020 20202020 20202020                     
 803e034:	20202020 20202020 65735520 70412072              User Ap
 803e044:	25232070 20202063 20202020 20202020     p #%c           
 803e054:	20202020 20202020 20202020 20202020                     
 803e064:	20202020 0a0d003d                            =.....

0803e06e <AHBPrescTable>:
	...
 803e076:	04030201 09080706                       ........

0803e07e <APBPrescTable>:
 803e07e:	00000000 04030201                        ..........

0803e088 <MSIRangeTable>:
 803e088:	000186a0 00030d40 00061a80 000c3500     ....@........5..
 803e098:	000f4240 001e8480 003d0900 007a1200     @B........=...z.
 803e0a8:	00f42400 016e3600 01e84800 02dc6c00     .$...6n..H...l..
	...
 803e0c8:	3d3d0a0d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ..==============
 803e0d8:	3d3d3d3d 6554203d 4d207473 20756e65     ===== Test Menu 
 803e0e8:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 803e0f8:	3d3d3d3d 3d3d3d3d 3d3d3d3d 20000a0d     ============... 
 803e108:	73655420 72502074 6365746f 6e6f6974      Test Protection
 803e118:	4e203a20 65536e6f 65727563 79727420      : NonSecure try
 803e128:	206f7420 65636361 74207373 6553206f      to access to Se
 803e138:	65727563 2d2d2d20 0a0d3120 52202000     cure --- 1...  R
 803e148:	52205044 65726765 6f697373 2d2d206e     DP Regression --
 803e158:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e168:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e178:	2d2d2d2d 32202d2d 20000a0d 65725020     ------ 2...  Pre
 803e188:	756f6976 654d2073 2d20756e 2d2d2d2d     vious Menu -----
 803e198:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e1a8:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e1b8:	2d2d2d2d 0a0d7820 200a0d00 69766544     ---- x..... Devi
 803e1c8:	72206563 79646165 726f6620 67657220     ce ready for reg
 803e1d8:	73736572 206e6f69 000d203a 2d200a0d     ression : .... -
 803e1e8:	6e6f4320 7463656e 4d545320 75433233      Connect STM32Cu
 803e1f8:	72506562 6172676f 72656d6d 646f6d20     beProgrammer mod
 803e208:	6f483d65 756c5074 0a0d0067 50202d20     e=HotPlug... - P
 803e218:	6f667265 52206d72 52205044 65726765     erform RDP Regre
 803e228:	6f697373 0d00206e 0d00200a 5b203d0a     ssion ... ...= [
 803e238:	54534554 7325205d 25204020 30252073     TEST] %s @ %s %0
 803e248:	0d007838 616c660a 65206873 726f7272     8x...flash error
 803e258:	646f6320 25203a65 424f0078 00402073      code: %x.OBs @.
 803e268:	6c6f7349 64657461 61762000 2065756c     Isolated. value 
 803e278:	6425203a 76200020 65756c61 25203a20     : %d . value : %
 803e288:	0d002078 4554200a 505f5453 45544f52     x ... TEST_PROTE
 803e298:	4f495443 525f534e 535f6e75 73556365     CTIONS_Run_SecUs
 803e2a8:	654d7265 203a206d 73736150 0d006465     erMem : Passed..
 803e2b8:	4554200a 505f5453 45544f52 4f495443     . TEST_PROTECTIO
 803e2c8:	525f534e 535f6e75 73556365 654d7265     NS_Run_SecUserMe
 803e2d8:	203a206d 6c696146 08006465 08080808     m : Failed......
 803e2e8:	00080808                                ....

0803e2ec <aProtectTests>:
 803e2ec:	20030000 61746144 63655320 20657275     ... Data Secure 
 803e2fc:	72617453 00000074 00000000 00000000     Start...........
 803e30c:	00000000 00000104 2003fc00 61746144     ........... Data
 803e31c:	63655320 20657275 00646e45 00000000      Secure End.....
	...
 803e338:	00000104 0c000400 65646f43 63655320     ........Code Sec
 803e348:	20657275 72617453 00000074 00000000     ure Start.......
	...
 803e360:	00000101 0c024400 65646f43 63655320     .....D..Code Sec
 803e370:	20657275 28444e45 656e6576 00297265     ure END(veneer).
	...
 803e388:	00000101 420c0804 20474e52 53205049     .......BRNG IP S
 803e398:	00000052 00000000 00000000 00000000     R...............
	...
 803e3b0:	00000006 420c0808 20474e52 44205049     .......BRNG IP D
 803e3c0:	00000052 00000000 00000000 00000000     R...............
	...
 803e3d8:	00000006 40003500 4b434142 52205055     .....5.@BACKUP R
 803e3e8:	30204745 00000000 00000000 00000000     EG 0............
	...
 803e400:	00000106 4000351c 4b434142 52205055     .....5.@BACKUP R
 803e410:	37204745 00000000 00000000 00000000     EG 7............
	...
 803e428:	00000106 00000000 63657845 6f697475     ........Executio
 803e438:	7573206e 73656363 6c756673 00000000     n successful....
	...
 803e450:	00000007                                ....

0803e454 <aTestOperation>:
 803e454:	74697277 20382065 65747962 00000073     write 8 bytes...
 803e464:	00000000 64616572 62203120 00657479     ....read 1 byte.
	...
 803e47c:	73617265 31352065 79622032 00736574     erase 512 bytes.
 803e48c:	00000000 74697277 20342065 65747962     ....write 4 byte
 803e49c:	00000073 00000000 64616572 62203120     s.......read 1 b
 803e4ac:	00657479 00000000 00000000 63657865     yte.........exec
 803e4bc:	00657475 00000000 00000000 00000000     ute.............
 803e4cc:	64616572 62203420 73657479 00000000     read 4 bytes....
 803e4dc:	00000000 00646e65 00000000 00000000     ....end.........
	...
 803e4f4:	322e3225 55530078 53454343 4c554653     %2.2x.SUCCESSFUL
 803e504:	4146004c 44454c49 53454100 4d434720     L.FAILED.AES GCM
 803e514:	73657420 73252074 41000a0d 43205345      test %s...AES C
 803e524:	74204342 20747365 0a0d7325 54535300     BC test %s...SST
 803e534:	74657320 44495520 73657420 73252074      set UID test %s
 803e544:	53000a0d 72205453 20646165 6863202f     ...SST read / ch
 803e554:	206b6365 20444955 74736574 0d732520     eck UID test %s.
 803e564:	5353000a 65722054 65766f6d 44495520     ..SST remove UID
 803e574:	73657420 73252074 45000a0d 6e205441      test %s...EAT n
 803e584:	616d726f 6963206c 69756372 69732074     ormal circuit si
 803e594:	65742067 25207473 000a0d73 20535449     g test %s...ITS 
 803e5a4:	20746573 20444955 74736574 0d732520     set UID test %s.
 803e5b4:	5449000a 65722053 2f206461 65686320     ..ITS read / che
 803e5c4:	55206b63 74204449 20747365 0a0d7325     ck UID test %s..
 803e5d4:	53544900 6d657220 2065766f 20444955     .ITS remove UID 
 803e5e4:	74736574 0d732520 4853000a 34323241     test %s...SHA224
 803e5f4:	73657420 73252074 53000a0d 35324148      test %s...SHA25
 803e604:	65742036 25207473 000a0d73 554d5543     6 test %s...CUMU
 803e614:	4954414c 52204556 4c555345 25203a54     LATIVE RESULT: %
 803e624:	64252f64 63757320 73736563 0d000a0d     d/%d success....
 803e634:	3d3d3d0a 3d3d3d3d 3d3d3d3d 3d3d3d3d     .===============
 803e644:	3d3d3d3d 3d3d3d3d 4d465420 61784520     ======== TFM Exa
 803e654:	656c706d 654d2073 3d20756e 3d3d3d3d     mples Menu =====
 803e664:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 803e674:	3d3d3d3d 0a0d3d3d 54202000 2d204d46     ======...  TFM -
 803e684:	73655420 6c412074 2020206c 20202020      Test All       
 803e694:	20202020 20202020 20202020 20202020                     
 803e6a4:	20202020 20202020 20202020 2d2d2d2d                 ----
 803e6b4:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e6c4:	0d30202d 2020000a 204d4654 6554202d     - 0...  TFM - Te
 803e6d4:	41207473 472d5345 20204d43 20202020     st AES-GCM      
 803e6e4:	20202020 20202020 20202020 20202020                     
 803e6f4:	20202020 20202020 2d2d2d20 2d2d2d2d              -------
 803e704:	2d2d2d2d 2d2d2d2d 2d2d2d2d 31202d2d     -------------- 1
 803e714:	20000a0d 4d465420 54202d20 20747365     ...  TFM - Test 
 803e724:	2d534541 20434243 20202020 20202020     AES-CBC         
 803e734:	20202020 20202020 20202020 20202020                     
 803e744:	20202020 2d2d2020 2d2d2d2d 2d2d2d2d           ----------
 803e754:	2d2d2d2d 2d2d2d2d 202d2d2d 000a0d32     ----------- 2...
 803e764:	46542020 202d204d 74736554 54535320       TFM - Test SST
 803e774:	74657320 44495520 20202020 20202020      set UID        
 803e784:	20202020 20202020 20202020 20202020                     
 803e794:	2d202020 2d2d2d2d 2d2d2d2d 2d2d2d2d        -------------
 803e7a4:	2d2d2d2d 2d2d2d2d 0a0d3320 54202000     -------- 3...  T
 803e7b4:	2d204d46 73655420 53532074 65722054     FM - Test SST re
 803e7c4:	2f206461 65686320 55206b63 20204449     ad / check UID  
 803e7d4:	20202020 20202020 20202020 20202020                     
 803e7e4:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e7f4:	2d2d2d2d 0d34202d 2020000a 204d4654     ----- 4...  TFM 
 803e804:	6554202d 53207473 72205453 766f6d65     - Test SST remov
 803e814:	49552065 20202044 20202020 20202020     e UID           
 803e824:	20202020 20202020 20202020 2d2d2d20                  ---
 803e834:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e844:	35202d2d 20000a0d 4d465420 54202d20     -- 5...  TFM - T
 803e854:	20747365 20544145 20202020 20202020     est EAT         
 803e864:	20202020 20202020 20202020 20202020                     
 803e874:	20202020 20202020 2d2d2020 2d2d2d2d               ------
 803e884:	2d2d2d2d 2d2d2d2d 2d2d2d2d 202d2d2d     --------------- 
 803e894:	000a0d36 46542020 202d204d 74736554     6...  TFM - Test
 803e8a4:	53544920 74657320 44495520 20202020      ITS set UID    
 803e8b4:	20202020 20202020 20202020 20202020                     
 803e8c4:	20202020 2d202020 2d2d2d2d 2d2d2d2d            ---------
 803e8d4:	2d2d2d2d 2d2d2d2d 2d2d2d2d 0a0d3720     ------------ 7..
 803e8e4:	54202000 2d204d46 73655420 54492074     .  TFM - Test IT
 803e8f4:	65722053 2f206461 65686320 55206b63     S read / check U
 803e904:	20204449 20202020 20202020 20202020     ID              
 803e914:	20202020 2d2d2d2d 2d2d2d2d 2d2d2d2d         ------------
 803e924:	2d2d2d2d 2d2d2d2d 0d38202d 2020000a     --------- 8...  
 803e934:	204d4654 6554202d 49207473 72205354     TFM - Test ITS r
 803e944:	766f6d65 49552065 20202044 20202020     emove UID       
 803e954:	20202020 20202020 20202020 20202020                     
 803e964:	2d2d2d20 2d2d2d2d 2d2d2d2d 2d2d2d2d      ---------------
 803e974:	2d2d2d2d 39202d2d 20000a0d 4d465420     ------ 9...  TFM
 803e984:	54202d20 20747365 32414853 20203432      - Test SHA224  
 803e994:	20202020 20202020 20202020 20202020                     
 803e9a4:	20202020 20202020 20202020 2d2d2020                   --
 803e9b4:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e9c4:	202d2d2d 000a0d61 46542020 202d204d     --- a...  TFM - 
 803e9d4:	74736554 41485320 20363532 20202020     Test SHA256     
 803e9e4:	20202020 20202020 20202020 20202020                     
 803e9f4:	20202020 20202020 2d202020 2d2d2d2d                -----
 803ea04:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803ea14:	0a0d6220 45202000 20746978 204d4654      b...  Exit TFM 
 803ea24:	6d617845 73656c70 6e654d20 20202075     Examples Menu   
 803ea34:	20202020 20202020 20202020 20202020                     
 803ea44:	20202020 20202020 2d2d2d2d 2d2d2d2d             --------
 803ea54:	2d2d2d2d 2d2d2d2d 2d2d2d2d 0d78202d     ------------- x.
 803ea64:	6f74000a 206e656b 75716572 20747365     ..token request 
 803ea74:	756c6176 0d3a2065 6b6f7400 72206e65     value :..token r
 803ea84:	6f707365 2065736e 756c6176 0d3a2065     esponse value :.
 803ea94:	69616600 2064656c 74617473 25207375     .failed status %
 803eaa4:	000a0d64 23232323 23232323 23232323     d...############
 803eab4:	23232323 23232323 23232323 23232323     ################
 803eac4:	23232323 23232323 23232323 23232323     ################
 803ead4:	55525400 44455453 4d524946 45524157     .TRUSTEDFIRMWARE
 803eae4:	524f465f 4d54535f 08003233 5f65002e     _FOR_STM32....e_
 803eaf4:	75736572 3d20746c 20782520 6c25202c     result = %x , %l
 803eb04:	                                         u..

0803eb07 <CSWTCH.301>:
 803eb07:	08020401                                ....

0803eb0b <CSWTCH.302>:
 803eb0b:	10101000 10101004 10101002               .............

0803eb18 <__func__.7640>:
 803eb18:	5f617370 68706963 745f7265 00747365     psa_cipher_test.

0803eb28 <__func__.7670>:
 803eb28:	5f617370 68736168 7365745f               psa_hash_test.

0803eb36 <__func__.7727>:
 803eb36:	5f617370 64616561 7365745f               psa_aead_test.

0803eb44 <hash_val>:
 803eb44:	350e4a56 d0bcc7f1 bcb1cf7d 2efa16c9     VJ.5....}.......
 803eb54:	b296bef5 00000000 00000000 00000000     ................
	...
 803eb84:	e290d200 7ec14e0e 10f5957a 0474765c     .....N.~z...\vt.
 803eb94:	5e56b56e 15bae7e5 f347236c 00000000     n.V^....l#G.....
	...
 803ebc4:	2a09226b 14f51e37 cf4d39f7 46174dad     k".*7....9M..M.F
 803ebd4:	a033cb66 4e41d839 4dd32af1 3eb5c369     f.3.9.AN.*.Mi..>
	...
 803ec04:	bb117964 59474e47 60bc4d3e 9cbff9a5     dy..GNGY>M.`....
 803ec14:	0f55bac0 df72ca93 56501e57 d6014af9     ..U...r.W.PV.J..
 803ec24:	62f76fa5 fd484f34 4207159d b89472b7     .o.b4OH....B.r..
	...
 803ec44:	6ca31cb4 ad1d67a9 1bbe1f34 2a40c483     ...l.g..4.....@*
 803ec54:	bb794247 60f0ca21 9b6ed2e4 3f341270     GBy.!..`..n.p.4?
 803ec64:	31092c55 21405b0a 583ba801 1a1348e7     U,.1.[@!..;X.H..
 803ec74:	d2e1cd7e 34581046 aa4b1449 b1f5a989     ~...F.X4I.K.....
 803ec84:	6f727245 65702072 726f6672 676e696d     Error performing
 803ec94:	41454120 6e652044 70797263 6e6f6974      AEAD encryption
 803eca4:	636e4500 74707972 64206465 20617461     .Encrypted data 
 803ecb4:	676e656c 69206874 69642073 72656666     length is differ
 803ecc4:	20746e65 6e616874 70786520 65746365     ent than expecte
 803ecd4:	72450064 20726f72 66726570 696d726f     d.Error performi
 803ece4:	4120676e 20444145 72636564 69747079     ng AEAD decrypti
 803ecf4:	44006e6f 79726365 64657470 74616420     on.Decrypted dat
 803ed04:	656c2061 6874676e 20736920 66666964     a length is diff
 803ed14:	6e657265 72662074 70206d6f 6e69616c     erent from plain
 803ed24:	78657420 31300074 35343332 39383736      text.0123456789
 803ed34:	68540030 69207369 73612073 69636f73     0.This is associ
 803ed44:	64657461 74616420 6c410061 69726f67     ated data.Algori
 803ed54:	206d6874 20544f4e 50505553 4554524f     thm NOT SUPPORTE
 803ed64:	79622044 65687420 706d6920 656d656c     D by the impleme
 803ed74:	7461746e 006e6f69 6f727245 65732072     ntation.Error se
 803ed84:	6e697474 70752067 70696320 20726568     tting up cipher 
 803ed94:	7265706f 6f697461 626f206e 7463656a     operation object
 803eda4:	72724500 7320726f 69747465 7420676e     .Error setting t
 803edb4:	49206568 6e6f2056 65687420 70796320     he IV on the cyp
 803edc4:	20726568 7265706f 6f697461 626f206e     her operation ob
 803edd4:	7463656a 72724500 6120726f 74726f62     ject.Error abort
 803ede4:	20676e69 20656874 7265706f 6f697461     ing the operatio
 803edf4:	7245006e 20726f72 72636e65 69747079     n.Error encrypti
 803ee04:	6f20676e 6320656e 6b6e7568 20666f20     ng one chunk of 
 803ee14:	6f666e69 74616d72 006e6f69 65707845     information.Expe
 803ee24:	64657463 636e6520 74707972 64206465     cted encrypted d
 803ee34:	20617461 676e656c 69206874 69642073     ata length is di
 803ee44:	72656666 20746e65 6d6f7266 70786520     fferent from exp
 803ee54:	65746365 72450064 20726f72 616e6966     ected.Error fina
 803ee64:	6973696c 7420676e 63206568 65687069     lising the ciphe
 803ee74:	706f2072 74617265 006e6f69 78656e55     r operation.Unex
 803ee84:	74636570 6f206465 75707475 656c2074     pected output le
 803ee94:	6874676e 74666120 66207265 6c616e69     ngth after final
 803eea4:	74617369 006e6f69 6f727245 65732072     isation.Error se
 803eeb4:	6e697474 68742067 56492065 726f6620     tting the IV for
 803eec4:	63656420 74707972 006e6f69 6f727245      decryption.Erro
 803eed4:	75642072 676e6972 63656420 74707972     r during decrypt
 803eee4:	006e6f69 72636544 65747079 61642064     ion.Decrypted da
 803eef4:	64206174 6e73656f 6d207427 68637461     ta doesn't match
 803ef04:	74697720 6c702068 206e6961 74786574      with plain text
 803ef14:	74664100 66207265 6c616e69 6e697369     .After finalisin
 803ef24:	75202c67 7078656e 65746365 65642064     g, unexpected de
 803ef34:	70797263 20646574 676e656c 45006874     crypted length.E
 803ef44:	726f7272 73656420 796f7274 20676e69     rror destroying 
 803ef54:	656b2061 31300079 35343332 39383736     a key.0123456789
 803ef64:	33323130 69530034 65657478 7962206e     01234.Sixteen by
 803ef74:	21736574 72450021 20726f72 74746573     tes!!.Error sett
 803ef84:	20676e69 68207075 20687361 7265706f     ing up hash oper
 803ef94:	6f697461 626f206e 7463656a 72724500     ation object.Err
 803efa4:	7520726f 74616470 20676e69 20656874     or updating the 
 803efb4:	68736168 65706f20 69746172 6f206e6f     hash operation o
 803efc4:	63656a62 72450074 20726f72 69726576     bject.Error veri
 803efd4:	6e697966 68742067 61682065 6f206873     fying the hash o
 803efe4:	61726570 6e6f6974 6a626f20 00746365     peration object.
 803eff4:	6c696146 74206465 6c61206f 61636f6c     Failed to alloca
 803f004:	6b206574 46007965 656c6961 6f742064     te key.Failed to
 803f014:	74657320 79656b20 6c6f7020 00796369      set key policy.
 803f024:	2079654b 646e6168 6420656c 2073656f     Key handle does 
 803f034:	20746f6e 20746579 746e6f63 206e6961     not yet contain 
 803f044:	2079656b 6574616d 6c616972 72724500     key material.Err
 803f054:	6920726f 726f706d 676e6974 6b206120     or importing a k
 803f064:	45007965 726f7272 74656720 676e6974     ey.Error getting
 803f074:	79656b20 74656d20 74616461 68540061      key metadata.Th
 803f084:	756e2065 7265626d 20666f20 2079656b     e number of key 
 803f094:	73746962 20736920 66666964 6e657265     bits is differen
 803f0a4:	72662074 65206d6f 63657078 00646574     t from expected.
 803f0b4:	20656854 65707974 20666f20 20656874     The type of the 
 803f0c4:	2079656b 64207369 65666669 746e6572     key is different
 803f0d4:	6f726620 7865206d 74636570 45006465      from expected.E
 803f0e4:	726f7272 70786520 6974726f 6120676e     rror exporting a
 803f0f4:	79656b20 6d754e00 20726562 6220666f      key.Number of b
 803f104:	73657479 20666f20 6f707865 64657472     ytes of exported
 803f114:	79656b20 66696420 65726566 6620746e      key different f
 803f124:	206d6f72 65707865 64657463 70784500     rom expected.Exp
 803f134:	6574726f 656b2064 6f642079 276e7365     orted key doesn'
 803f144:	616d2074 20686374 20656874 6f706d69     t match the impo
 803f154:	64657472 79656b20 72724500 6420726f     rted key.Error d
 803f164:	72747365 6e69796f 68742067 656b2065     estroying the ke
 803f174:	654b0079 61682079 656c646e 6f687320     y.Key handle sho
 803f184:	20646c75 69206562 6c61766e 6e206469     uld be invalid n
 803f194:	5400776f 20534948 4d205349 454b2059     ow.THIS IS MY KE
 803f1a4:	54003159 20736968 6d207369 65742079     Y1.This is my te
 803f1b4:	6d207473 61737365 202c6567 656c7000     st message, .ple
 803f1c4:	20657361 656e6567 65746172 68206120     ase generate a h
 803f1d4:	20687361 20726f66 73696874 6c70002e     ash for this..pl
 803f1e4:	65736165 6e656720 74617265 20612065     ease generate a 
 803f1f4:	63616d68 726f6620 69687420 45002e73     hmac for this..E
 803f204:	726f7272 25202820 0d292073 4554000a     rror ( %s )...TE
 803f214:	535f5453 45544955 5252455f 564e495f     ST_SUITE_ERR_INV
 803f224:	44494c41 5345545f 41445f54 00214154     ALID_TEST_DATA!.
 803f234:	25335b1b 00006d64                       .[3%dm..

0803f23c <_global_impure_ptr>:
 803f23c:	2000012c                                ,.. 

0803f240 <__sf_fake_stderr>:
	...

0803f260 <__sf_fake_stdin>:
	...

0803f280 <__sf_fake_stdout>:
	...
 803f2a0:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
 803f2b0:	32313000 36353433 41393837 45444342     .0123456789ABCDE
 803f2c0:	31300046 35343332 39383736 64636261     F.0123456789abcd
 803f2d0:	00006665                                ef..

0803f2d4 <__EH_FRAME_BEGIN__>:
 803f2d4:	00000000                                ....

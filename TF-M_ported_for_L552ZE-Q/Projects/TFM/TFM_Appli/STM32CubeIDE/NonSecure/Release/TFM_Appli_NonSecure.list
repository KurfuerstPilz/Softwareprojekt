
TFM_Appli_NonSecure.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006d8c  08038400  08038400  00008400  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0803f18c  0803f18c  0000f18c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .copy.table   00000018  0803f194  0803f194  0000f194  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .zero.table   00000010  0803f1ac  0803f1ac  0000f1ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .testprotection 00000004  20000000  20000000  00020000  2**2
                  ALLOC
  5 .data         00000094  20000100  0803f1bc  00010100  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000540  20000194  0803f250  00010194  2**2
                  ALLOC
  7 .msp_stack    00000400  200006e0  0803f7a0  000106e0  2**5
                  ALLOC
  8 .psp_stack    00000c00  20000ae0  0803fba0  000106e0  2**5
                  ALLOC
  9 .heap         00001000  200016e0  080407a0  000106e0  2**3
                  ALLOC
 10 .ARM.attributes 00000034  00000000  00000000  00010194  2**0
                  CONTENTS, READONLY
 11 .comment      0000007b  00000000  00000000  000101c8  2**0
                  CONTENTS, READONLY
 12 .debug_line   00013614  00000000  00000000  00010243  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0001d44d  00000000  00000000  00023857  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00004d0f  00000000  00000000  00040ca4  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00000e40  00000000  00000000  000459b8  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0010ebfb  00000000  00000000  000467f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000aa1a  00000000  00000000  001553f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00001020  00000000  00000000  0015fe0d  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macro  0002d604  00000000  00000000  00160e2d  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_frame  00003010  00000000  00000000  0018e434  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .stab         00000084  00000000  00000000  00191444  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .stabstr      00000117  00000000  00000000  001914c8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08038400 <__Vectors>:
 8038400:	20000ae0 	.word	0x20000ae0
 8038404:	080386a9 	.word	0x080386a9
 8038408:	08039079 	.word	0x08039079
 803840c:	0803907b 	.word	0x0803907b
 8038410:	0803907d 	.word	0x0803907d
 8038414:	0803907f 	.word	0x0803907f
 8038418:	08039081 	.word	0x08039081
 803841c:	0803870d 	.word	0x0803870d
	...
 803842c:	08038711 	.word	0x08038711
 8038430:	08039083 	.word	0x08039083
 8038434:	00000000 	.word	0x00000000
 8038438:	08038719 	.word	0x08038719
 803843c:	08039085 	.word	0x08039085
 8038440:	08038721 	.word	0x08038721
 8038444:	08038725 	.word	0x08038725
 8038448:	08038729 	.word	0x08038729
 803844c:	0803872d 	.word	0x0803872d
 8038450:	08038731 	.word	0x08038731
 8038454:	08038735 	.word	0x08038735
 8038458:	08039089 	.word	0x08039089
 803845c:	0803873d 	.word	0x0803873d
 8038460:	08038741 	.word	0x08038741
 8038464:	08038745 	.word	0x08038745
 8038468:	08038749 	.word	0x08038749
 803846c:	0803874d 	.word	0x0803874d
 8038470:	08038751 	.word	0x08038751
 8038474:	08038755 	.word	0x08038755
 8038478:	08038759 	.word	0x08038759
 803847c:	0803875d 	.word	0x0803875d
 8038480:	08038761 	.word	0x08038761
 8038484:	08038765 	.word	0x08038765
 8038488:	08038769 	.word	0x08038769
 803848c:	0803876d 	.word	0x0803876d
 8038490:	08038771 	.word	0x08038771
 8038494:	08038775 	.word	0x08038775
 8038498:	08038779 	.word	0x08038779
 803849c:	0803877d 	.word	0x0803877d
 80384a0:	08038781 	.word	0x08038781
 80384a4:	08038785 	.word	0x08038785
 80384a8:	08038789 	.word	0x08038789
 80384ac:	0803878d 	.word	0x0803878d
 80384b0:	08038791 	.word	0x08038791
 80384b4:	08038795 	.word	0x08038795
 80384b8:	08038799 	.word	0x08038799
 80384bc:	0803879d 	.word	0x0803879d
 80384c0:	080387a1 	.word	0x080387a1
 80384c4:	080387a5 	.word	0x080387a5
 80384c8:	080387a9 	.word	0x080387a9
 80384cc:	080387ad 	.word	0x080387ad
 80384d0:	080387b1 	.word	0x080387b1
 80384d4:	080387b5 	.word	0x080387b5
 80384d8:	080387b9 	.word	0x080387b9
 80384dc:	080387bd 	.word	0x080387bd
 80384e0:	080387c1 	.word	0x080387c1
 80384e4:	080387c5 	.word	0x080387c5
 80384e8:	080387c9 	.word	0x080387c9
 80384ec:	080387cd 	.word	0x080387cd
 80384f0:	080387d1 	.word	0x080387d1
 80384f4:	080387d5 	.word	0x080387d5
 80384f8:	080387d9 	.word	0x080387d9
 80384fc:	080387dd 	.word	0x080387dd
 8038500:	080387e1 	.word	0x080387e1
 8038504:	080387e5 	.word	0x080387e5
 8038508:	080387e9 	.word	0x080387e9
 803850c:	080387ed 	.word	0x080387ed
 8038510:	080387f1 	.word	0x080387f1
 8038514:	080387f5 	.word	0x080387f5
 8038518:	080387f9 	.word	0x080387f9
 803851c:	080387fd 	.word	0x080387fd
 8038520:	08038801 	.word	0x08038801
 8038524:	08038805 	.word	0x08038805
 8038528:	08038809 	.word	0x08038809
 803852c:	0803880d 	.word	0x0803880d
 8038530:	08038811 	.word	0x08038811
 8038534:	08038815 	.word	0x08038815
 8038538:	08038819 	.word	0x08038819
 803853c:	0803881d 	.word	0x0803881d
 8038540:	08038821 	.word	0x08038821
 8038544:	08038825 	.word	0x08038825
 8038548:	08038829 	.word	0x08038829
 803854c:	0803882d 	.word	0x0803882d
 8038550:	08038831 	.word	0x08038831
 8038554:	08038835 	.word	0x08038835
 8038558:	08038839 	.word	0x08038839
 803855c:	0803883d 	.word	0x0803883d
 8038560:	08038841 	.word	0x08038841
 8038564:	08038845 	.word	0x08038845
 8038568:	08038849 	.word	0x08038849
 803856c:	0803884d 	.word	0x0803884d
 8038570:	08038851 	.word	0x08038851
 8038574:	00000000 	.word	0x00000000
 8038578:	08038855 	.word	0x08038855
 803857c:	00000000 	.word	0x00000000
 8038580:	08038859 	.word	0x08038859
 8038584:	0803885d 	.word	0x0803885d
 8038588:	08038861 	.word	0x08038861
 803858c:	08038865 	.word	0x08038865
 8038590:	08038869 	.word	0x08038869
 8038594:	0803886d 	.word	0x0803886d
 8038598:	08038871 	.word	0x08038871
 803859c:	08038875 	.word	0x08038875
 80385a0:	08038879 	.word	0x08038879
 80385a4:	0803887d 	.word	0x0803887d
 80385a8:	08038881 	.word	0x08038881
 80385ac:	08038885 	.word	0x08038885
 80385b0:	08038889 	.word	0x08038889
 80385b4:	00000000 	.word	0x00000000
 80385b8:	0803888d 	.word	0x0803888d
 80385bc:	08038891 	.word	0x08038891
	...
 80385c8:	08038895 	.word	0x08038895
 80385cc:	08038899 	.word	0x08038899
 80385d0:	0803889d 	.word	0x0803889d
 80385d4:	080388a1 	.word	0x080388a1
 80385d8:	080388a5 	.word	0x080388a5
 80385dc:	080388a9 	.word	0x080388a9
 80385e0:	080388ad 	.word	0x080388ad
 80385e4:	080388b1 	.word	0x080388b1
 80385e8:	080388b5 	.word	0x080388b5
 80385ec:	080388b9 	.word	0x080388b9
 80385f0:	080388bd 	.word	0x080388bd

080385f4 <__do_global_dtors_aux>:
 80385f4:	b510      	push	{r4, lr}
 80385f6:	4c05      	ldr	r4, [pc, #20]	; (803860c <__do_global_dtors_aux+0x18>)
 80385f8:	7823      	ldrb	r3, [r4, #0]
 80385fa:	b933      	cbnz	r3, 803860a <__do_global_dtors_aux+0x16>
 80385fc:	4b04      	ldr	r3, [pc, #16]	; (8038610 <__do_global_dtors_aux+0x1c>)
 80385fe:	b113      	cbz	r3, 8038606 <__do_global_dtors_aux+0x12>
 8038600:	4804      	ldr	r0, [pc, #16]	; (8038614 <__do_global_dtors_aux+0x20>)
 8038602:	e000      	b.n	8038606 <__do_global_dtors_aux+0x12>
 8038604:	bf00      	nop
 8038606:	2301      	movs	r3, #1
 8038608:	7023      	strb	r3, [r4, #0]
 803860a:	bd10      	pop	{r4, pc}
 803860c:	20000194 	.word	0x20000194
 8038610:	00000000 	.word	0x00000000
 8038614:	0803f188 	.word	0x0803f188

08038618 <frame_dummy>:
 8038618:	b508      	push	{r3, lr}
 803861a:	4b03      	ldr	r3, [pc, #12]	; (8038628 <frame_dummy+0x10>)
 803861c:	b11b      	cbz	r3, 8038626 <frame_dummy+0xe>
 803861e:	4903      	ldr	r1, [pc, #12]	; (803862c <frame_dummy+0x14>)
 8038620:	4803      	ldr	r0, [pc, #12]	; (8038630 <frame_dummy+0x18>)
 8038622:	e000      	b.n	8038626 <frame_dummy+0xe>
 8038624:	bf00      	nop
 8038626:	bd08      	pop	{r3, pc}
 8038628:	00000000 	.word	0x00000000
 803862c:	20000198 	.word	0x20000198
 8038630:	0803f188 	.word	0x0803f188

08038634 <_mainCRTStartup>:
 8038634:	4b15      	ldr	r3, [pc, #84]	; (803868c <_mainCRTStartup+0x58>)
 8038636:	2b00      	cmp	r3, #0
 8038638:	bf08      	it	eq
 803863a:	4b13      	ldreq	r3, [pc, #76]	; (8038688 <_mainCRTStartup+0x54>)
 803863c:	469d      	mov	sp, r3
 803863e:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
 8038642:	2100      	movs	r1, #0
 8038644:	468b      	mov	fp, r1
 8038646:	460f      	mov	r7, r1
 8038648:	4813      	ldr	r0, [pc, #76]	; (8038698 <_mainCRTStartup+0x64>)
 803864a:	4a14      	ldr	r2, [pc, #80]	; (803869c <_mainCRTStartup+0x68>)
 803864c:	1a12      	subs	r2, r2, r0
 803864e:	f003 ffe7 	bl	803c620 <memset>
 8038652:	4b0f      	ldr	r3, [pc, #60]	; (8038690 <_mainCRTStartup+0x5c>)
 8038654:	2b00      	cmp	r3, #0
 8038656:	d000      	beq.n	803865a <_mainCRTStartup+0x26>
 8038658:	4798      	blx	r3
 803865a:	4b0e      	ldr	r3, [pc, #56]	; (8038694 <_mainCRTStartup+0x60>)
 803865c:	2b00      	cmp	r3, #0
 803865e:	d000      	beq.n	8038662 <_mainCRTStartup+0x2e>
 8038660:	4798      	blx	r3
 8038662:	2000      	movs	r0, #0
 8038664:	2100      	movs	r1, #0
 8038666:	0004      	movs	r4, r0
 8038668:	000d      	movs	r5, r1
 803866a:	480d      	ldr	r0, [pc, #52]	; (80386a0 <_mainCRTStartup+0x6c>)
 803866c:	2800      	cmp	r0, #0
 803866e:	d002      	beq.n	8038676 <_mainCRTStartup+0x42>
 8038670:	480c      	ldr	r0, [pc, #48]	; (80386a4 <_mainCRTStartup+0x70>)
 8038672:	e000      	b.n	8038676 <_mainCRTStartup+0x42>
 8038674:	bf00      	nop
 8038676:	f003 ff95 	bl	803c5a4 <__libc_init_array>
 803867a:	0020      	movs	r0, r4
 803867c:	0029      	movs	r1, r5
 803867e:	f000 fc93 	bl	8038fa8 <main>
 8038682:	f003 ff7b 	bl	803c57c <exit>
 8038686:	bf00      	nop
 8038688:	00080000 	.word	0x00080000
 803868c:	200016e0 	.word	0x200016e0
	...
 8038698:	20000194 	.word	0x20000194
 803869c:	200006d4 	.word	0x200006d4
	...

080386a8 <Reset_Handler>:
 *    offset 4: VMA of start of a section to copy to
 *    offset 8: size of the section to copy. Must be multiply of 4
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
    ldr    r4, =__copy_table_start__
 80386a8:	4c0f      	ldr	r4, [pc, #60]	; (80386e8 <Reset_Handler+0x40>)
    ldr    r5, =__copy_table_end__
 80386aa:	4d10      	ldr	r5, [pc, #64]	; (80386ec <Reset_Handler+0x44>)

.L_loop0:
    cmp    r4, r5
 80386ac:	42ac      	cmp	r4, r5
    bge    .L_loop0_done
 80386ae:	da09      	bge.n	80386c4 <Reset_Handler+0x1c>
    ldr    r1, [r4]
 80386b0:	6821      	ldr	r1, [r4, #0]
    ldr    r2, [r4, #4]
 80386b2:	6862      	ldr	r2, [r4, #4]
    ldr    r3, [r4, #8]
 80386b4:	68a3      	ldr	r3, [r4, #8]

.L_loop0_0:
    subs    r3, #4
 80386b6:	3b04      	subs	r3, #4
    ittt    ge
 80386b8:	bfa2      	ittt	ge
    ldrge    r0, [r1, r3]
 80386ba:	58c8      	ldrge	r0, [r1, r3]
    strge    r0, [r2, r3]
 80386bc:	50d0      	strge	r0, [r2, r3]
    bge    .L_loop0_0
 80386be:	e7fa      	bge.n	80386b6 <Reset_Handler+0xe>

    adds    r4, #12
 80386c0:	340c      	adds	r4, #12
    b    .L_loop0
 80386c2:	e7f3      	b.n	80386ac <Reset_Handler+0x4>
 *  Between symbol address __copy_table_start__ and __copy_table_end__,
 *  there are array of tuples specifying:
 *    offset 0: Start of a BSS section
 *    offset 4: Size of this BSS section. Must be multiply of 4
 */
    ldr    r3, =__zero_table_start__
 80386c4:	4b0a      	ldr	r3, [pc, #40]	; (80386f0 <Reset_Handler+0x48>)
    ldr    r4, =__zero_table_end__
 80386c6:	4c0b      	ldr	r4, [pc, #44]	; (80386f4 <Reset_Handler+0x4c>)

.L_loop2:
    cmp    r3, r4
 80386c8:	42a3      	cmp	r3, r4
    bge    .L_loop2_done
 80386ca:	da08      	bge.n	80386de <Reset_Handler+0x36>
    ldr    r1, [r3]
 80386cc:	6819      	ldr	r1, [r3, #0]
    ldr    r2, [r3, #4]
 80386ce:	685a      	ldr	r2, [r3, #4]
    movs    r0, 0
 80386d0:	2000      	movs	r0, #0

.L_loop2_0:
    subs    r2, #4
 80386d2:	3a04      	subs	r2, #4
    itt    ge
 80386d4:	bfa4      	itt	ge
    strge    r0, [r1, r2]
 80386d6:	5088      	strge	r0, [r1, r2]
    bge    .L_loop2_0
 80386d8:	e7fb      	bge.n	80386d2 <Reset_Handler+0x2a>

    adds    r3, #8
 80386da:	3308      	adds	r3, #8
    b    .L_loop2
 80386dc:	e7f4      	b.n	80386c8 <Reset_Handler+0x20>

/*    mrs     r0, control   */ /* Get control value */
/*   orr     r0, r0, #1     *//* Select switch to unprivilage mode */
 /*   orr     r0, r0, #2    */ /* Select switch to PSP */
/*    msr     control, r0 */
    bl    SystemInit
 80386de:	f000 fcd5 	bl	803908c <SystemInit>


#ifndef __START
#define __START _start
#endif
    bl    __START
 80386e2:	f7ff ffa7 	bl	8038634 <_mainCRTStartup>
 80386e6:	0000      	.short	0x0000
    ldr    r4, =__copy_table_start__
 80386e8:	0803f194 	.word	0x0803f194
    ldr    r5, =__copy_table_end__
 80386ec:	0803f1ac 	.word	0x0803f1ac
    ldr    r3, =__zero_table_start__
 80386f0:	0803f1ac 	.word	0x0803f1ac
    ldr    r4, =__zero_table_end__
 80386f4:	0803f1bc 	.word	0x0803f1bc
    .weak    \handler_name
    \handler_name:
    b        \handler_name
    .endm

   def_irq_handler             NMI_Handler
 80386f8:	f000 bcbe 	b.w	8039078 <NMI_Handler>
   def_irq_handler             HardFault_Handler
 80386fc:	f000 bcbd 	b.w	803907a <HardFault_Handler>
   def_irq_handler             MemManage_Handler
 8038700:	f000 bcbc 	b.w	803907c <MemManage_Handler>
   def_irq_handler             BusFault_Handler
 8038704:	f000 bcbb 	b.w	803907e <BusFault_Handler>
   def_irq_handler             UsageFault_Handler
 8038708:	f000 bcba 	b.w	8039080 <UsageFault_Handler>

0803870c <SecureFault_Handler>:
   def_irq_handler             SecureFault_Handler
 803870c:	f7ff bffe 	b.w	803870c <SecureFault_Handler>

08038710 <SVC_Handler>:
   def_irq_handler             SVC_Handler
 8038710:	f7ff bffe 	b.w	8038710 <SVC_Handler>
   def_irq_handler             DebugMon_Handler
 8038714:	f000 bcb5 	b.w	8039082 <DebugMon_Handler>

08038718 <PendSV_Handler>:
   def_irq_handler             PendSV_Handler
 8038718:	f7ff bffe 	b.w	8038718 <PendSV_Handler>
   def_irq_handler             SysTick_Handler
 803871c:	f000 bcb2 	b.w	8039084 <SysTick_Handler>

08038720 <WWDG_IRQHandler>:
   def_irq_handler             WWDG_IRQHandler
 8038720:	f7ff bffe 	b.w	8038720 <WWDG_IRQHandler>

08038724 <PVD_PVM_IRQHandler>:
   def_irq_handler             PVD_PVM_IRQHandler
 8038724:	f7ff bffe 	b.w	8038724 <PVD_PVM_IRQHandler>

08038728 <RTC_IRQHandler>:
   def_irq_handler             RTC_IRQHandler
 8038728:	f7ff bffe 	b.w	8038728 <RTC_IRQHandler>

0803872c <RTC_IRQHandler_S>:
   def_irq_handler             RTC_IRQHandler_S
 803872c:	f7ff bffe 	b.w	803872c <RTC_IRQHandler_S>

08038730 <TAMP_IRQHandler>:
   def_irq_handler             TAMP_IRQHandler
 8038730:	f7ff bffe 	b.w	8038730 <TAMP_IRQHandler>

08038734 <TAMP_IRQHandler_S>:
   def_irq_handler             TAMP_IRQHandler_S
 8038734:	f7ff bffe 	b.w	8038734 <TAMP_IRQHandler_S>
   def_irq_handler             FLASH_IRQHandler
 8038738:	f000 bca6 	b.w	8039088 <FLASH_IRQHandler>

0803873c <FLASH_IRQHandler_S>:
   def_irq_handler             FLASH_IRQHandler_S
 803873c:	f7ff bffe 	b.w	803873c <FLASH_IRQHandler_S>

08038740 <SERR_IRQHandler>:
   def_irq_handler             SERR_IRQHandler
 8038740:	f7ff bffe 	b.w	8038740 <SERR_IRQHandler>

08038744 <RCC_IRQHandler>:
   def_irq_handler             RCC_IRQHandler
 8038744:	f7ff bffe 	b.w	8038744 <RCC_IRQHandler>

08038748 <RCC_IRQHandler_S>:
   def_irq_handler             RCC_IRQHandler_S
 8038748:	f7ff bffe 	b.w	8038748 <RCC_IRQHandler_S>

0803874c <EXTI0_IRQHandler>:
   def_irq_handler             EXTI0_IRQHandler
 803874c:	f7ff bffe 	b.w	803874c <EXTI0_IRQHandler>

08038750 <EXTI1_IRQHandler>:
   def_irq_handler             EXTI1_IRQHandler
 8038750:	f7ff bffe 	b.w	8038750 <EXTI1_IRQHandler>

08038754 <EXTI2_IRQHandler>:
   def_irq_handler             EXTI2_IRQHandler
 8038754:	f7ff bffe 	b.w	8038754 <EXTI2_IRQHandler>

08038758 <EXTI3_IRQHandler>:
   def_irq_handler             EXTI3_IRQHandler
 8038758:	f7ff bffe 	b.w	8038758 <EXTI3_IRQHandler>

0803875c <EXTI4_IRQHandler>:
   def_irq_handler             EXTI4_IRQHandler
 803875c:	f7ff bffe 	b.w	803875c <EXTI4_IRQHandler>

08038760 <EXTI5_IRQHandler>:
   def_irq_handler             EXTI5_IRQHandler
 8038760:	f7ff bffe 	b.w	8038760 <EXTI5_IRQHandler>

08038764 <EXTI6_IRQHandler>:
   def_irq_handler             EXTI6_IRQHandler
 8038764:	f7ff bffe 	b.w	8038764 <EXTI6_IRQHandler>

08038768 <EXTI7_IRQHandler>:
   def_irq_handler             EXTI7_IRQHandler
 8038768:	f7ff bffe 	b.w	8038768 <EXTI7_IRQHandler>

0803876c <EXTI8_IRQHandler>:
   def_irq_handler             EXTI8_IRQHandler
 803876c:	f7ff bffe 	b.w	803876c <EXTI8_IRQHandler>

08038770 <EXTI9_IRQHandler>:
   def_irq_handler             EXTI9_IRQHandler
 8038770:	f7ff bffe 	b.w	8038770 <EXTI9_IRQHandler>

08038774 <EXTI10_IRQHandler>:
   def_irq_handler             EXTI10_IRQHandler
 8038774:	f7ff bffe 	b.w	8038774 <EXTI10_IRQHandler>

08038778 <EXTI11_IRQHandler>:
   def_irq_handler             EXTI11_IRQHandler
 8038778:	f7ff bffe 	b.w	8038778 <EXTI11_IRQHandler>

0803877c <EXTI12_IRQHandler>:
   def_irq_handler             EXTI12_IRQHandler
 803877c:	f7ff bffe 	b.w	803877c <EXTI12_IRQHandler>

08038780 <EXTI13_IRQHandler>:
   def_irq_handler             EXTI13_IRQHandler
 8038780:	f7ff bffe 	b.w	8038780 <EXTI13_IRQHandler>

08038784 <EXTI14_IRQHandler>:
   def_irq_handler             EXTI14_IRQHandler
 8038784:	f7ff bffe 	b.w	8038784 <EXTI14_IRQHandler>

08038788 <EXTI15_IRQHandler>:
   def_irq_handler             EXTI15_IRQHandler
 8038788:	f7ff bffe 	b.w	8038788 <EXTI15_IRQHandler>

0803878c <DMAMUX1_IRQHandler>:
   def_irq_handler             DMAMUX1_IRQHandler
 803878c:	f7ff bffe 	b.w	803878c <DMAMUX1_IRQHandler>

08038790 <DMAMUX1_IRQHandler_S>:
   def_irq_handler             DMAMUX1_IRQHandler_S
 8038790:	f7ff bffe 	b.w	8038790 <DMAMUX1_IRQHandler_S>

08038794 <DMA1_Channel1_IRQHandler>:
   def_irq_handler             DMA1_Channel1_IRQHandler
 8038794:	f7ff bffe 	b.w	8038794 <DMA1_Channel1_IRQHandler>

08038798 <DMA1_Channel2_IRQHandler>:
   def_irq_handler             DMA1_Channel2_IRQHandler
 8038798:	f7ff bffe 	b.w	8038798 <DMA1_Channel2_IRQHandler>

0803879c <DMA1_Channel3_IRQHandler>:
   def_irq_handler             DMA1_Channel3_IRQHandler
 803879c:	f7ff bffe 	b.w	803879c <DMA1_Channel3_IRQHandler>

080387a0 <DMA1_Channel4_IRQHandler>:
   def_irq_handler             DMA1_Channel4_IRQHandler
 80387a0:	f7ff bffe 	b.w	80387a0 <DMA1_Channel4_IRQHandler>

080387a4 <DMA1_Channel5_IRQHandler>:
   def_irq_handler             DMA1_Channel5_IRQHandler
 80387a4:	f7ff bffe 	b.w	80387a4 <DMA1_Channel5_IRQHandler>

080387a8 <DMA1_Channel6_IRQHandler>:
   def_irq_handler             DMA1_Channel6_IRQHandler
 80387a8:	f7ff bffe 	b.w	80387a8 <DMA1_Channel6_IRQHandler>

080387ac <DMA1_Channel7_IRQHandler>:
   def_irq_handler             DMA1_Channel7_IRQHandler
 80387ac:	f7ff bffe 	b.w	80387ac <DMA1_Channel7_IRQHandler>

080387b0 <DMA1_Channel8_IRQHandler>:
   def_irq_handler             DMA1_Channel8_IRQHandler
 80387b0:	f7ff bffe 	b.w	80387b0 <DMA1_Channel8_IRQHandler>

080387b4 <ADC1_2_IRQHandler>:
   def_irq_handler             ADC1_2_IRQHandler
 80387b4:	f7ff bffe 	b.w	80387b4 <ADC1_2_IRQHandler>

080387b8 <DAC_IRQHandler>:
   def_irq_handler             DAC_IRQHandler
 80387b8:	f7ff bffe 	b.w	80387b8 <DAC_IRQHandler>

080387bc <FDCAN1_IT0_IRQHandler>:
   def_irq_handler             FDCAN1_IT0_IRQHandler
 80387bc:	f7ff bffe 	b.w	80387bc <FDCAN1_IT0_IRQHandler>

080387c0 <FDCAN1_IT1_IRQHandler>:
   def_irq_handler             FDCAN1_IT1_IRQHandler
 80387c0:	f7ff bffe 	b.w	80387c0 <FDCAN1_IT1_IRQHandler>

080387c4 <TIM1_BRK_IRQHandler>:
   def_irq_handler             TIM1_BRK_IRQHandler
 80387c4:	f7ff bffe 	b.w	80387c4 <TIM1_BRK_IRQHandler>

080387c8 <TIM1_UP_IRQHandler>:
   def_irq_handler             TIM1_UP_IRQHandler
 80387c8:	f7ff bffe 	b.w	80387c8 <TIM1_UP_IRQHandler>

080387cc <TIM1_TRG_COM_IRQHandler>:
   def_irq_handler             TIM1_TRG_COM_IRQHandler
 80387cc:	f7ff bffe 	b.w	80387cc <TIM1_TRG_COM_IRQHandler>

080387d0 <TIM1_CC_IRQHandler>:
   def_irq_handler             TIM1_CC_IRQHandler
 80387d0:	f7ff bffe 	b.w	80387d0 <TIM1_CC_IRQHandler>

080387d4 <TIM2_IRQHandler>:
   def_irq_handler             TIM2_IRQHandler
 80387d4:	f7ff bffe 	b.w	80387d4 <TIM2_IRQHandler>

080387d8 <TIM3_IRQHandler>:
   def_irq_handler             TIM3_IRQHandler
 80387d8:	f7ff bffe 	b.w	80387d8 <TIM3_IRQHandler>

080387dc <TIM4_IRQHandler>:
   def_irq_handler             TIM4_IRQHandler
 80387dc:	f7ff bffe 	b.w	80387dc <TIM4_IRQHandler>

080387e0 <TIM5_IRQHandler>:
   def_irq_handler             TIM5_IRQHandler
 80387e0:	f7ff bffe 	b.w	80387e0 <TIM5_IRQHandler>

080387e4 <TIM6_IRQHandler>:
   def_irq_handler             TIM6_IRQHandler
 80387e4:	f7ff bffe 	b.w	80387e4 <TIM6_IRQHandler>

080387e8 <TIM7_IRQHandler>:
   def_irq_handler             TIM7_IRQHandler
 80387e8:	f7ff bffe 	b.w	80387e8 <TIM7_IRQHandler>

080387ec <TIM8_BRK_IRQHandler>:
   def_irq_handler             TIM8_BRK_IRQHandler
 80387ec:	f7ff bffe 	b.w	80387ec <TIM8_BRK_IRQHandler>

080387f0 <TIM8_UP_IRQHandler>:
   def_irq_handler             TIM8_UP_IRQHandler
 80387f0:	f7ff bffe 	b.w	80387f0 <TIM8_UP_IRQHandler>

080387f4 <TIM8_TRG_COM_IRQHandler>:
   def_irq_handler             TIM8_TRG_COM_IRQHandler
 80387f4:	f7ff bffe 	b.w	80387f4 <TIM8_TRG_COM_IRQHandler>

080387f8 <TIM8_CC_IRQHandler>:
   def_irq_handler             TIM8_CC_IRQHandler
 80387f8:	f7ff bffe 	b.w	80387f8 <TIM8_CC_IRQHandler>

080387fc <I2C1_EV_IRQHandler>:
   def_irq_handler             I2C1_EV_IRQHandler
 80387fc:	f7ff bffe 	b.w	80387fc <I2C1_EV_IRQHandler>

08038800 <I2C1_ER_IRQHandler>:
   def_irq_handler             I2C1_ER_IRQHandler
 8038800:	f7ff bffe 	b.w	8038800 <I2C1_ER_IRQHandler>

08038804 <I2C2_EV_IRQHandler>:
   def_irq_handler             I2C2_EV_IRQHandler
 8038804:	f7ff bffe 	b.w	8038804 <I2C2_EV_IRQHandler>

08038808 <I2C2_ER_IRQHandler>:
   def_irq_handler             I2C2_ER_IRQHandler
 8038808:	f7ff bffe 	b.w	8038808 <I2C2_ER_IRQHandler>

0803880c <SPI1_IRQHandler>:
   def_irq_handler             SPI1_IRQHandler
 803880c:	f7ff bffe 	b.w	803880c <SPI1_IRQHandler>

08038810 <SPI2_IRQHandler>:
   def_irq_handler             SPI2_IRQHandler
 8038810:	f7ff bffe 	b.w	8038810 <SPI2_IRQHandler>

08038814 <USART1_IRQHandler>:
   def_irq_handler             USART1_IRQHandler
 8038814:	f7ff bffe 	b.w	8038814 <USART1_IRQHandler>

08038818 <USART2_IRQHandler>:
   def_irq_handler             USART2_IRQHandler
 8038818:	f7ff bffe 	b.w	8038818 <USART2_IRQHandler>

0803881c <USART3_IRQHandler>:
   def_irq_handler             USART3_IRQHandler
 803881c:	f7ff bffe 	b.w	803881c <USART3_IRQHandler>

08038820 <UART4_IRQHandler>:
   def_irq_handler             UART4_IRQHandler
 8038820:	f7ff bffe 	b.w	8038820 <UART4_IRQHandler>

08038824 <UART5_IRQHandler>:
   def_irq_handler             UART5_IRQHandler
 8038824:	f7ff bffe 	b.w	8038824 <UART5_IRQHandler>

08038828 <LPUART1_IRQHandler>:
   def_irq_handler             LPUART1_IRQHandler
 8038828:	f7ff bffe 	b.w	8038828 <LPUART1_IRQHandler>

0803882c <LPTIM1_IRQHandler>:
   def_irq_handler             LPTIM1_IRQHandler
 803882c:	f7ff bffe 	b.w	803882c <LPTIM1_IRQHandler>

08038830 <LPTIM2_IRQHandler>:
   def_irq_handler             LPTIM2_IRQHandler
 8038830:	f7ff bffe 	b.w	8038830 <LPTIM2_IRQHandler>

08038834 <TIM15_IRQHandler>:
   def_irq_handler             TIM15_IRQHandler
 8038834:	f7ff bffe 	b.w	8038834 <TIM15_IRQHandler>

08038838 <TIM16_IRQHandler>:
   def_irq_handler             TIM16_IRQHandler
 8038838:	f7ff bffe 	b.w	8038838 <TIM16_IRQHandler>

0803883c <TIM17_IRQHandler>:
   def_irq_handler             TIM17_IRQHandler
 803883c:	f7ff bffe 	b.w	803883c <TIM17_IRQHandler>

08038840 <COMP_IRQHandler>:
   def_irq_handler             COMP_IRQHandler
 8038840:	f7ff bffe 	b.w	8038840 <COMP_IRQHandler>

08038844 <USB_FS_IRQHandler>:
   def_irq_handler             USB_FS_IRQHandler
 8038844:	f7ff bffe 	b.w	8038844 <USB_FS_IRQHandler>

08038848 <CRS_IRQHandler>:
   def_irq_handler             CRS_IRQHandler
 8038848:	f7ff bffe 	b.w	8038848 <CRS_IRQHandler>

0803884c <FMC_IRQHandler>:
   def_irq_handler             FMC_IRQHandler
 803884c:	f7ff bffe 	b.w	803884c <FMC_IRQHandler>

08038850 <OCTOSPI1_IRQHandler>:
   def_irq_handler             OCTOSPI1_IRQHandler
 8038850:	f7ff bffe 	b.w	8038850 <OCTOSPI1_IRQHandler>

08038854 <SDMMC1_IRQHandler>:
   def_irq_handler             SDMMC1_IRQHandler
 8038854:	f7ff bffe 	b.w	8038854 <SDMMC1_IRQHandler>

08038858 <DMA2_Channel1_IRQHandler>:
   def_irq_handler             DMA2_Channel1_IRQHandler
 8038858:	f7ff bffe 	b.w	8038858 <DMA2_Channel1_IRQHandler>

0803885c <DMA2_Channel2_IRQHandler>:
   def_irq_handler             DMA2_Channel2_IRQHandler
 803885c:	f7ff bffe 	b.w	803885c <DMA2_Channel2_IRQHandler>

08038860 <DMA2_Channel3_IRQHandler>:
   def_irq_handler             DMA2_Channel3_IRQHandler
 8038860:	f7ff bffe 	b.w	8038860 <DMA2_Channel3_IRQHandler>

08038864 <DMA2_Channel4_IRQHandler>:
   def_irq_handler             DMA2_Channel4_IRQHandler
 8038864:	f7ff bffe 	b.w	8038864 <DMA2_Channel4_IRQHandler>

08038868 <DMA2_Channel5_IRQHandler>:
   def_irq_handler             DMA2_Channel5_IRQHandler
 8038868:	f7ff bffe 	b.w	8038868 <DMA2_Channel5_IRQHandler>

0803886c <DMA2_Channel6_IRQHandler>:
   def_irq_handler             DMA2_Channel6_IRQHandler
 803886c:	f7ff bffe 	b.w	803886c <DMA2_Channel6_IRQHandler>

08038870 <DMA2_Channel7_IRQHandler>:
   def_irq_handler             DMA2_Channel7_IRQHandler
 8038870:	f7ff bffe 	b.w	8038870 <DMA2_Channel7_IRQHandler>

08038874 <DMA2_Channel8_IRQHandler>:
   def_irq_handler             DMA2_Channel8_IRQHandler
 8038874:	f7ff bffe 	b.w	8038874 <DMA2_Channel8_IRQHandler>

08038878 <I2C3_EV_IRQHandler>:
   def_irq_handler             I2C3_EV_IRQHandler
 8038878:	f7ff bffe 	b.w	8038878 <I2C3_EV_IRQHandler>

0803887c <I2C3_ER_IRQHandler>:
   def_irq_handler             I2C3_ER_IRQHandler
 803887c:	f7ff bffe 	b.w	803887c <I2C3_ER_IRQHandler>

08038880 <SAI1_IRQHandler>:
   def_irq_handler             SAI1_IRQHandler
 8038880:	f7ff bffe 	b.w	8038880 <SAI1_IRQHandler>

08038884 <SAI2_IRQHandler>:
   def_irq_handler             SAI2_IRQHandler
 8038884:	f7ff bffe 	b.w	8038884 <SAI2_IRQHandler>

08038888 <TSC_IRQHandler>:
   def_irq_handler             TSC_IRQHandler
 8038888:	f7ff bffe 	b.w	8038888 <TSC_IRQHandler>

0803888c <RNG_IRQHandler>:
   def_irq_handler             RNG_IRQHandler
 803888c:	f7ff bffe 	b.w	803888c <RNG_IRQHandler>

08038890 <FPU_IRQHandler>:
   def_irq_handler             FPU_IRQHandler
 8038890:	f7ff bffe 	b.w	8038890 <FPU_IRQHandler>

08038894 <LPTIM3_IRQHandler>:
   def_irq_handler             LPTIM3_IRQHandler
 8038894:	f7ff bffe 	b.w	8038894 <LPTIM3_IRQHandler>

08038898 <SPI3_IRQHandler>:
   def_irq_handler             SPI3_IRQHandler
 8038898:	f7ff bffe 	b.w	8038898 <SPI3_IRQHandler>

0803889c <I2C4_ER_IRQHandler>:
   def_irq_handler             I2C4_ER_IRQHandler
 803889c:	f7ff bffe 	b.w	803889c <I2C4_ER_IRQHandler>

080388a0 <I2C4_EV_IRQHandler>:
   def_irq_handler             I2C4_EV_IRQHandler
 80388a0:	f7ff bffe 	b.w	80388a0 <I2C4_EV_IRQHandler>

080388a4 <DFSDM1_FLT0_IRQHandler>:
   def_irq_handler             DFSDM1_FLT0_IRQHandler
 80388a4:	f7ff bffe 	b.w	80388a4 <DFSDM1_FLT0_IRQHandler>

080388a8 <DFSDM1_FLT1_IRQHandler>:
   def_irq_handler             DFSDM1_FLT1_IRQHandler
 80388a8:	f7ff bffe 	b.w	80388a8 <DFSDM1_FLT1_IRQHandler>

080388ac <DFSDM1_FLT2_IRQHandler>:
   def_irq_handler             DFSDM1_FLT2_IRQHandler
 80388ac:	f7ff bffe 	b.w	80388ac <DFSDM1_FLT2_IRQHandler>

080388b0 <DFSDM1_FLT3_IRQHandler>:
   def_irq_handler             DFSDM1_FLT3_IRQHandler
 80388b0:	f7ff bffe 	b.w	80388b0 <DFSDM1_FLT3_IRQHandler>

080388b4 <UCPD1_IRQHandler>:
   def_irq_handler             UCPD1_IRQHandler
 80388b4:	f7ff bffe 	b.w	80388b4 <UCPD1_IRQHandler>

080388b8 <ICACHE_IRQHandler>:
   def_irq_handler             ICACHE_IRQHandler
 80388b8:	f7ff bffe 	b.w	80388b8 <ICACHE_IRQHandler>

080388bc <OTFDEC1_IRQHandler>:
   def_irq_handler             OTFDEC1_IRQHandler
 80388bc:	f7ff bffe 	b.w	80388bc <OTFDEC1_IRQHandler>

080388c0 <COM_Init>:
  * @brief  Initialize COM module.
  * @param  None.
  * @retval HAL Status.
  */
HAL_StatusTypeDef  COM_Init(void)
{
 80388c0:	b508      	push	{r3, lr}
#if defined(__GNUC__)
  setvbuf(stdout, NULL, _IONBF, 0);
 80388c2:	4b10      	ldr	r3, [pc, #64]	; (8038904 <COM_Init+0x44>)
 80388c4:	2202      	movs	r2, #2
 80388c6:	6818      	ldr	r0, [r3, #0]
 80388c8:	2300      	movs	r3, #0
 80388ca:	6880      	ldr	r0, [r0, #8]
 80388cc:	4619      	mov	r1, r3
 80388ce:	f003 ff2b 	bl	803c728 <setvbuf>
  - No parity
  - Hardware flow control disabled (RTS and CTS signals)
  - Receive and transmit enabled
  */
  UartHandle.Instance = COM_UART;
  UartHandle.Init.BaudRate = 115200U;
 80388d2:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
  UartHandle.Instance = COM_UART;
 80388d6:	480c      	ldr	r0, [pc, #48]	; (8038908 <COM_Init+0x48>)
  UartHandle.Init.BaudRate = 115200U;
 80388d8:	4a0c      	ldr	r2, [pc, #48]	; (803890c <COM_Init+0x4c>)
 80388da:	e9c0 2300 	strd	r2, r3, [r0]
  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 80388de:	2300      	movs	r3, #0
  UartHandle.Init.StopBits = UART_STOPBITS_1;
 80388e0:	e9c0 3302 	strd	r3, r3, [r0, #8]
  UartHandle.Init.Parity = UART_PARITY_NONE;
 80388e4:	6103      	str	r3, [r0, #16]
  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80388e6:	6183      	str	r3, [r0, #24]
  UartHandle.Init.Mode = UART_MODE_RX | UART_MODE_TX;
 80388e8:	230c      	movs	r3, #12
 80388ea:	6143      	str	r3, [r0, #20]
  UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT;
 80388ec:	2310      	movs	r3, #16
 80388ee:	6283      	str	r3, [r0, #40]	; 0x28
  UartHandle.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;
 80388f0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80388f4:	63c3      	str	r3, [r0, #60]	; 0x3c
  UartHandle.FifoMode = UART_FIFOMODE_ENABLE;
 80388f6:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80388fa:	6643      	str	r3, [r0, #100]	; 0x64
  return HAL_UART_Init(&UartHandle);
}
 80388fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return HAL_UART_Init(&UartHandle);
 8038900:	f002 bd6f 	b.w	803b3e2 <HAL_UART_Init>
 8038904:	20000128 	.word	0x20000128
 8038908:	200001b0 	.word	0x200001b0
 803890c:	40008000 	.word	0x40008000

08038910 <HAL_UART_MspInit>:
  * @brief  UART MSP Init.
  * @param  huart: UART handler pointer.
  * @retval None.
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 8038910:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if (huart->Instance == COM_UART)
 8038912:	6802      	ldr	r2, [r0, #0]
 8038914:	4b22      	ldr	r3, [pc, #136]	; (80389a0 <HAL_UART_MspInit+0x90>)
{
 8038916:	b08b      	sub	sp, #44	; 0x2c
  if (huart->Instance == COM_UART)
 8038918:	429a      	cmp	r2, r3
 803891a:	d13f      	bne.n	803899c <HAL_UART_MspInit+0x8c>
  {
    /* Peripheral Clock Enable */
    COM_UART_CLK_ENABLE();
 803891c:	4c21      	ldr	r4, [pc, #132]	; (80389a4 <HAL_UART_MspInit+0x94>)
    COM_UART_TX_GPIO_CLK_ENABLE();
    COM_UART_RX_GPIO_CLK_ENABLE();

    /*Configure GPIO pins : COM_UART_TX_Pin  */
    GPIO_InitStruct.Pin = COM_UART_TX_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 803891e:	2702      	movs	r7, #2
    COM_UART_CLK_ENABLE();
 8038920:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8038922:	2600      	movs	r6, #0
    COM_UART_CLK_ENABLE();
 8038924:	f043 0301 	orr.w	r3, r3, #1
 8038928:	65e3      	str	r3, [r4, #92]	; 0x5c
 803892a:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 803892c:	2503      	movs	r5, #3
    COM_UART_CLK_ENABLE();
 803892e:	f003 0301 	and.w	r3, r3, #1
 8038932:	9301      	str	r3, [sp, #4]
 8038934:	9b01      	ldr	r3, [sp, #4]
 8038936:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8038938:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 803893c:	65a3      	str	r3, [r4, #88]	; 0x58
 803893e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8038940:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8038944:	9302      	str	r3, [sp, #8]
 8038946:	9b02      	ldr	r3, [sp, #8]
 8038948:	f001 fe26 	bl	803a598 <HAL_PWREx_EnableVddIO2>
    COM_UART_TX_GPIO_CLK_ENABLE();
 803894c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    GPIO_InitStruct.Alternate = COM_UART_TX_AF;
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 803894e:	a905      	add	r1, sp, #20
    COM_UART_TX_GPIO_CLK_ENABLE();
 8038950:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8038954:	64e3      	str	r3, [r4, #76]	; 0x4c
 8038956:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 8038958:	4813      	ldr	r0, [pc, #76]	; (80389a8 <HAL_UART_MspInit+0x98>)
    COM_UART_TX_GPIO_CLK_ENABLE();
 803895a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 803895e:	9303      	str	r3, [sp, #12]
 8038960:	9b03      	ldr	r3, [sp, #12]
    COM_UART_RX_GPIO_CLK_ENABLE();
 8038962:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8038964:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8038968:	64e3      	str	r3, [r4, #76]	; 0x4c
 803896a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    GPIO_InitStruct.Alternate = COM_UART_TX_AF;
 803896c:	2408      	movs	r4, #8
    COM_UART_RX_GPIO_CLK_ENABLE();
 803896e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8038972:	9304      	str	r3, [sp, #16]
 8038974:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8038976:	2380      	movs	r3, #128	; 0x80
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8038978:	e9cd 6507 	strd	r6, r5, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 803897c:	e9cd 3705 	strd	r3, r7, [sp, #20]
    GPIO_InitStruct.Alternate = COM_UART_TX_AF;
 8038980:	9409      	str	r4, [sp, #36]	; 0x24
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 8038982:	f001 fd41 	bl	803a408 <HAL_GPIO_Init>

    /*Configure GPIO pins : COM_UART_RX_Pin  */
    GPIO_InitStruct.Pin = COM_UART_RX_PIN;
 8038986:	f44f 7380 	mov.w	r3, #256	; 0x100
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = COM_UART_RX_AF;
    HAL_GPIO_Init(COM_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 803898a:	a905      	add	r1, sp, #20
 803898c:	4806      	ldr	r0, [pc, #24]	; (80389a8 <HAL_UART_MspInit+0x98>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 803898e:	e9cd 3705 	strd	r3, r7, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8038992:	e9cd 6507 	strd	r6, r5, [sp, #28]
    GPIO_InitStruct.Alternate = COM_UART_RX_AF;
 8038996:	9409      	str	r4, [sp, #36]	; 0x24
    HAL_GPIO_Init(COM_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 8038998:	f001 fd36 	bl	803a408 <HAL_GPIO_Init>

  }

}
 803899c:	b00b      	add	sp, #44	; 0x2c
 803899e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80389a0:	40008000 	.word	0x40008000
 80389a4:	40021000 	.word	0x40021000
 80389a8:	42021800 	.word	0x42021800

080389ac <COM_Transmit>:
  * @param uTimeout: Timeout duration.
  * @retval Status of the Transmit operation.
  */
HAL_StatusTypeDef COM_Transmit(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
{
  return HAL_UART_Transmit(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
 80389ac:	4613      	mov	r3, r2
 80389ae:	460a      	mov	r2, r1
 80389b0:	4601      	mov	r1, r0
 80389b2:	4801      	ldr	r0, [pc, #4]	; (80389b8 <COM_Transmit+0xc>)
 80389b4:	f002 bc10 	b.w	803b1d8 <HAL_UART_Transmit>
 80389b8:	200001b0 	.word	0x200001b0

080389bc <COM_Receive>:
  * @param uTimeout: Timeout duration.
  * @retval Status of the Receive operation.
  */
HAL_StatusTypeDef COM_Receive(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
{
  return HAL_UART_Receive(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
 80389bc:	4613      	mov	r3, r2
 80389be:	460a      	mov	r2, r1
 80389c0:	4601      	mov	r1, r0
 80389c2:	4801      	ldr	r0, [pc, #4]	; (80389c8 <COM_Receive+0xc>)
 80389c4:	f002 bc64 	b.w	803b290 <HAL_UART_Receive>
 80389c8:	200001b0 	.word	0x200001b0

080389cc <COM_Flush>:
  * @retval HAL_Status.
  */
HAL_StatusTypeDef COM_Flush(void)
{
  /* Clean the input path */
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 80389cc:	4b05      	ldr	r3, [pc, #20]	; (80389e4 <COM_Flush+0x18>)
  return HAL_OK;
}
 80389ce:	2000      	movs	r0, #0
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 80389d0:	681b      	ldr	r3, [r3, #0]
 80389d2:	699a      	ldr	r2, [r3, #24]
 80389d4:	f042 0208 	orr.w	r2, r2, #8
 80389d8:	619a      	str	r2, [r3, #24]
 80389da:	699a      	ldr	r2, [r3, #24]
 80389dc:	f042 0210 	orr.w	r2, r2, #16
 80389e0:	619a      	str	r2, [r3, #24]
}
 80389e2:	4770      	bx	lr
 80389e4:	200001b0 	.word	0x200001b0

080389e8 <Str2Int>:
  * @param  pIntNum: The integer value
  * @retval 1: Correct
  *         0: Error
  */
uint32_t Str2Int(uint8_t *pInputStr, uint32_t *pIntNum)
{
 80389e8:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t i = 0U, res = 0U;
  uint32_t val = 0U;

  if ((pInputStr[0U] == '0') && ((pInputStr[1U] == 'x') || (pInputStr[1U] == 'X')))
 80389ea:	7803      	ldrb	r3, [r0, #0]
 80389ec:	2b30      	cmp	r3, #48	; 0x30
 80389ee:	d127      	bne.n	8038a40 <Str2Int+0x58>
 80389f0:	7843      	ldrb	r3, [r0, #1]
 80389f2:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80389f6:	2b58      	cmp	r3, #88	; 0x58
 80389f8:	d122      	bne.n	8038a40 <Str2Int+0x58>
 80389fa:	2400      	movs	r4, #0
 80389fc:	2502      	movs	r5, #2
  {
    i = 2U;
    while ((i < 11U) && (pInputStr[i] != '\0'))
 80389fe:	5d43      	ldrb	r3, [r0, r5]
 8038a00:	b193      	cbz	r3, 8038a28 <Str2Int+0x40>
    {
      if (ISVALIDHEX(pInputStr[i]))
 8038a02:	f023 0620 	bic.w	r6, r3, #32
 8038a06:	3e41      	subs	r6, #65	; 0x41
 8038a08:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8038a0c:	2e05      	cmp	r6, #5
 8038a0e:	b2d7      	uxtb	r7, r2
 8038a10:	d901      	bls.n	8038a16 <Str2Int+0x2e>
 8038a12:	2f09      	cmp	r7, #9
 8038a14:	d808      	bhi.n	8038a28 <Str2Int+0x40>
      {
        val = (val << 4U) + CONVERTHEX(pInputStr[i]);
 8038a16:	2f09      	cmp	r7, #9
 8038a18:	ea4f 1404 	mov.w	r4, r4, lsl #4
 8038a1c:	d809      	bhi.n	8038a32 <Str2Int+0x4a>
 8038a1e:	4613      	mov	r3, r2
      {
        /* Return 0, Invalid input */
        res = 0U;
        break;
      }
      i++;
 8038a20:	3501      	adds	r5, #1
    while ((i < 11U) && (pInputStr[i] != '\0'))
 8038a22:	2d0b      	cmp	r5, #11
        val = (val << 4U) + CONVERTHEX(pInputStr[i]);
 8038a24:	441c      	add	r4, r3
    while ((i < 11U) && (pInputStr[i] != '\0'))
 8038a26:	d1ea      	bne.n	80389fe <Str2Int+0x16>
    }

    /* valid result */
    if (pInputStr[i] == '\0')
 8038a28:	5d43      	ldrb	r3, [r0, r5]
 8038a2a:	bb4b      	cbnz	r3, 8038a80 <Str2Int+0x98>
    {
      *pIntNum = val;
 8038a2c:	600c      	str	r4, [r1, #0]
      res = 1U;
 8038a2e:	2001      	movs	r0, #1
 8038a30:	e027      	b.n	8038a82 <Str2Int+0x9a>
        val = (val << 4U) + CONVERTHEX(pInputStr[i]);
 8038a32:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8038a36:	2a05      	cmp	r2, #5
 8038a38:	bf94      	ite	ls
 8038a3a:	3b37      	subls	r3, #55	; 0x37
 8038a3c:	3b57      	subhi	r3, #87	; 0x57
 8038a3e:	e7ef      	b.n	8038a20 <Str2Int+0x38>
 8038a40:	2300      	movs	r3, #0
        *pIntNum = val;
        res = 1U;
      }
      else if (ISVALIDDEC(pInputStr[i]))
      {
        val = val * 10U + CONVERTDEC(pInputStr[i]);
 8038a42:	270a      	movs	r7, #10
 8038a44:	1e44      	subs	r4, r0, #1
 8038a46:	f100 060a 	add.w	r6, r0, #10
      if (pInputStr[i] == '\0')
 8038a4a:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 8038a4e:	b90a      	cbnz	r2, 8038a54 <Str2Int+0x6c>
        *pIntNum = val;
 8038a50:	600b      	str	r3, [r1, #0]
        res = 1U;
 8038a52:	e7ec      	b.n	8038a2e <Str2Int+0x46>
      else if (((pInputStr[i] == 'k') || (pInputStr[i] == 'K')) && (i > 0U))
 8038a54:	f002 05df 	and.w	r5, r2, #223	; 0xdf
 8038a58:	2d4b      	cmp	r5, #75	; 0x4b
 8038a5a:	d103      	bne.n	8038a64 <Str2Int+0x7c>
 8038a5c:	4284      	cmp	r4, r0
 8038a5e:	d007      	beq.n	8038a70 <Str2Int+0x88>
        val = val << 10U;
 8038a60:	029b      	lsls	r3, r3, #10
 8038a62:	e7f5      	b.n	8038a50 <Str2Int+0x68>
      else if (((pInputStr[i] == 'm') || (pInputStr[i] == 'M')) && (i > 0U))
 8038a64:	2d4d      	cmp	r5, #77	; 0x4d
 8038a66:	d103      	bne.n	8038a70 <Str2Int+0x88>
 8038a68:	4284      	cmp	r4, r0
 8038a6a:	d009      	beq.n	8038a80 <Str2Int+0x98>
        val = val << 20U;
 8038a6c:	051b      	lsls	r3, r3, #20
 8038a6e:	e7ef      	b.n	8038a50 <Str2Int+0x68>
      else if (ISVALIDDEC(pInputStr[i]))
 8038a70:	3a30      	subs	r2, #48	; 0x30
 8038a72:	b2d5      	uxtb	r5, r2
 8038a74:	2d09      	cmp	r5, #9
 8038a76:	d803      	bhi.n	8038a80 <Str2Int+0x98>
    while ((i < 11U) && (res != 1U))
 8038a78:	42b4      	cmp	r4, r6
        val = val * 10U + CONVERTDEC(pInputStr[i]);
 8038a7a:	fb07 2303 	mla	r3, r7, r3, r2
    while ((i < 11U) && (res != 1U))
 8038a7e:	d1e4      	bne.n	8038a4a <Str2Int+0x62>
      res = 1U;
 8038a80:	2000      	movs	r0, #0
      i++;
    }
  }

  return res;
}
 8038a82:	bdf0      	pop	{r4, r5, r6, r7, pc}

08038a84 <Serial_PutByte>:
  * @brief  Transmit a byte to the HyperTerminal
  * @param  param The byte to be sent
  * @retval HAL_StatusTypeDef HAL_OK if OK
  */
HAL_StatusTypeDef Serial_PutByte(uint8_t uParam)
{
 8038a84:	b507      	push	{r0, r1, r2, lr}
 8038a86:	ab02      	add	r3, sp, #8
 8038a88:	f803 0d01 	strb.w	r0, [r3, #-1]!
  return COM_Transmit(&uParam, 1U, TX_TIMEOUT);
 8038a8c:	2264      	movs	r2, #100	; 0x64
 8038a8e:	2101      	movs	r1, #1
 8038a90:	4618      	mov	r0, r3
 8038a92:	f7ff ff8b 	bl	80389ac <COM_Transmit>
}
 8038a96:	b003      	add	sp, #12
 8038a98:	f85d fb04 	ldr.w	pc, [sp], #4

08038a9c <GetPage>:
  */
static uint32_t GetPage(uint32_t uAddr)
{
  uint32_t page = 0U;

  if (uAddr < (FLASH_BASE + (FLASH_BANK_SIZE)))
 8038a9c:	4b0a      	ldr	r3, [pc, #40]	; (8038ac8 <GetPage+0x2c>)
 8038a9e:	8819      	ldrh	r1, [r3, #0]
 8038aa0:	f64f 73fd 	movw	r3, #65533	; 0xfffd
 8038aa4:	1e4a      	subs	r2, r1, #1
 8038aa6:	b292      	uxth	r2, r2
 8038aa8:	429a      	cmp	r2, r3
 8038aaa:	bf97      	itett	ls
 8038aac:	4b07      	ldrls	r3, [pc, #28]	; (8038acc <GetPage+0x30>)
 8038aae:	4b08      	ldrhi	r3, [pc, #32]	; (8038ad0 <GetPage+0x34>)
 8038ab0:	ea03 2341 	andls.w	r3, r3, r1, lsl #9
 8038ab4:	f103 6300 	addls.w	r3, r3, #134217728	; 0x8000000
 8038ab8:	4283      	cmp	r3, r0
  {
    /* Bank 1 */
    page = (uAddr - FLASH_BASE) / FLASH_PAGE_SIZE;
 8038aba:	bf8c      	ite	hi
 8038abc:	f100 4078 	addhi.w	r0, r0, #4160749568	; 0xf8000000
  }
  else
  {
    /* Bank 2 */
    page = (uAddr - (FLASH_BASE + (FLASH_BANK_SIZE))) / FLASH_PAGE_SIZE;
 8038ac0:	1ac0      	subls	r0, r0, r3
 8038ac2:	0ac0      	lsrs	r0, r0, #11
  }

  return page;
}
 8038ac4:	4770      	bx	lr
 8038ac6:	bf00      	nop
 8038ac8:	0bfa05e0 	.word	0x0bfa05e0
 8038acc:	001ffe00 	.word	0x001ffe00
 8038ad0:	08040000 	.word	0x08040000

08038ad4 <GetBank>:
/*
  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0U)
  {
*/
    /* No Bank swap */
    if (uAddr < (FLASH_BASE + (FLASH_BANK_SIZE)))
 8038ad4:	4b09      	ldr	r3, [pc, #36]	; (8038afc <GetBank+0x28>)
 8038ad6:	8819      	ldrh	r1, [r3, #0]
 8038ad8:	f64f 73fd 	movw	r3, #65533	; 0xfffd
 8038adc:	1e4a      	subs	r2, r1, #1
 8038ade:	b292      	uxth	r2, r2
 8038ae0:	429a      	cmp	r2, r3
 8038ae2:	bf97      	itett	ls
 8038ae4:	4b06      	ldrls	r3, [pc, #24]	; (8038b00 <GetBank+0x2c>)
 8038ae6:	4b07      	ldrhi	r3, [pc, #28]	; (8038b04 <GetBank+0x30>)
 8038ae8:	ea03 2341 	andls.w	r3, r3, r1, lsl #9
 8038aec:	f103 6300 	addls.w	r3, r3, #134217728	; 0x8000000
      bank = FLASH_BANK_1;
    }
  }
#endif
  return bank;
}
 8038af0:	4283      	cmp	r3, r0
 8038af2:	bf8c      	ite	hi
 8038af4:	2001      	movhi	r0, #1
 8038af6:	2002      	movls	r0, #2
 8038af8:	4770      	bx	lr
 8038afa:	bf00      	nop
 8038afc:	0bfa05e0 	.word	0x0bfa05e0
 8038b00:	001ffe00 	.word	0x001ffe00
 8038b04:	08040000 	.word	0x08040000

08038b08 <FLASH_If_Init>:
#ifdef USE_SVC
static HAL_StatusTypeDef FLASH_If_Init_svc(void)
#else
static HAL_StatusTypeDef FLASH_If_Init(void)
#endif
{
 8038b08:	b508      	push	{r3, lr}
  HAL_StatusTypeDef ret = HAL_ERROR;

  /* Unlock the Program memory */
  if (HAL_FLASH_Unlock() == HAL_OK)
 8038b0a:	f001 fb61 	bl	803a1d0 <HAL_FLASH_Unlock>
 8038b0e:	b978      	cbnz	r0, 8038b30 <FLASH_If_Init+0x28>
  {
    /* Clear all FLASH flags */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 8038b10:	4b08      	ldr	r3, [pc, #32]	; (8038b34 <FLASH_If_Init+0x2c>)
 8038b12:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8038b14:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 8038b18:	631a      	str	r2, [r3, #48]	; 0x30
 8038b1a:	f242 02fa 	movw	r2, #8442	; 0x20fa
 8038b1e:	621a      	str	r2, [r3, #32]
    /* Unlock the Program memory */
    if (HAL_FLASH_Lock() == HAL_OK)
 8038b20:	f001 fb68 	bl	803a1f4 <HAL_FLASH_Lock>
 8038b24:	b118      	cbz	r0, 8038b2e <FLASH_If_Init+0x26>
      ret = HAL_OK;
    }
#ifdef FLASH_IF_DBG
    else
    {
      FLASH_IF_TRACE("[FLASH_IF] Lock failure\r\n");
 8038b26:	4804      	ldr	r0, [pc, #16]	; (8038b38 <FLASH_If_Init+0x30>)
#endif /* FLASH_IF_DBG */
  }
#ifdef FLASH_IF_DBG
  else
  {
    FLASH_IF_TRACE("[FLASH_IF] Unlock failure\r\n");
 8038b28:	f003 fdf6 	bl	803c718 <puts>
  HAL_StatusTypeDef ret = HAL_ERROR;
 8038b2c:	2001      	movs	r0, #1
  }
#endif /* FLASH_IF_DBG */
  return ret;
}
 8038b2e:	bd08      	pop	{r3, pc}
    FLASH_IF_TRACE("[FLASH_IF] Unlock failure\r\n");
 8038b30:	4802      	ldr	r0, [pc, #8]	; (8038b3c <FLASH_If_Init+0x34>)
 8038b32:	e7f9      	b.n	8038b28 <FLASH_If_Init+0x20>
 8038b34:	40022000 	.word	0x40022000
 8038b38:	0803da04 	.word	0x0803da04
 8038b3c:	0803da1d 	.word	0x0803da1d

08038b40 <FLASH_If_Erase_Size>:
static HAL_StatusTypeDef FLASH_If_Erase_Size_svc(void *pStart, uint32_t uLength)
#else
HAL_StatusTypeDef FLASH_If_Erase_Size(void *pStart, uint32_t uLength)
#endif
{
  uint32_t page_error = 0U;
 8038b40:	2300      	movs	r3, #0
{
 8038b42:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8038b46:	b087      	sub	sp, #28
 8038b48:	4604      	mov	r4, r0
 8038b4a:	460f      	mov	r7, r1
  uint32_t page_error = 0U;
 8038b4c:	9301      	str	r3, [sp, #4]

  /* Initialize Flash */
	#ifdef USE_SVC
  e_ret_status = FLASH_If_Init_svc();
  #else
	e_ret_status = FLASH_If_Init();
 8038b4e:	f7ff ffdb 	bl	8038b08 <FLASH_If_Init>
	#endif


  if (e_ret_status == HAL_OK)
 8038b52:	4606      	mov	r6, r0
 8038b54:	2800      	cmp	r0, #0
 8038b56:	d167      	bne.n	8038c28 <FLASH_If_Erase_Size+0xe8>
  {
    /* Unlock the Flash to enable the flash control register access *************/
    if (HAL_FLASH_Unlock() == HAL_OK)
 8038b58:	f001 fb3a 	bl	803a1d0 <HAL_FLASH_Unlock>
 8038b5c:	4606      	mov	r6, r0
 8038b5e:	2800      	cmp	r0, #0
 8038b60:	d161      	bne.n	8038c26 <FLASH_If_Erase_Size+0xe6>
    return  FLASH_BASE + (FLASH_BANK_SIZE);
 8038b62:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 8038c34 <FLASH_If_Erase_Size+0xf4>
    {
      do
      {
        /* Get the 1st page to erase */
        first_page = GetPage(uStart);
 8038b66:	4620      	mov	r0, r4
 8038b68:	f7ff ff98 	bl	8038a9c <GetPage>
 8038b6c:	4605      	mov	r5, r0
        bank_number = GetBank(uStart);
 8038b6e:	4620      	mov	r0, r4
 8038b70:	f7ff ffb0 	bl	8038ad4 <GetBank>
        if (GetBank(uStart + uLength - 1U) == bank_number)
 8038b74:	193a      	adds	r2, r7, r4
 8038b76:	f102 3aff 	add.w	sl, r2, #4294967295
        bank_number = GetBank(uStart);
 8038b7a:	4680      	mov	r8, r0
        if (GetBank(uStart + uLength - 1U) == bank_number)
 8038b7c:	4650      	mov	r0, sl
 8038b7e:	f7ff ffa9 	bl	8038ad4 <GetBank>
 8038b82:	4540      	cmp	r0, r8
 8038b84:	4681      	mov	r9, r0
 8038b86:	d11c      	bne.n	8038bc2 <FLASH_If_Erase_Size+0x82>
        {
          /* Get the number of pages to erase from 1st page */
          nb_pages = GetPage(uStart + uLength - 1U) - first_page + 1U;
 8038b88:	4650      	mov	r0, sl
 8038b8a:	f7ff ff87 	bl	8038a9c <GetPage>

          /* Fill EraseInit structure*/
          x_erase_init.TypeErase = FLASH_TYPEERASE_PAGES;
 8038b8e:	2202      	movs	r2, #2
          x_erase_init.Banks = bank_number;
 8038b90:	e9cd 2902 	strd	r2, r9, [sp, #8]
          nb_pages = GetPage(uStart + uLength - 1U) - first_page + 1U;
 8038b94:	3001      	adds	r0, #1
 8038b96:	1b44      	subs	r4, r0, r5

          /* Erase flash per NB_PAGE_SECTOR_PER_ERASE to avoid watch-dog */
          do
          {
            chunk_nb_pages = (nb_pages >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_pages;
 8038b98:	2c02      	cmp	r4, #2
 8038b9a:	4623      	mov	r3, r4
 8038b9c:	bf28      	it	cs
 8038b9e:	2302      	movcs	r3, #2
            x_erase_init.Page = first_page;
            x_erase_init.NbPages = chunk_nb_pages;
            first_page += chunk_nb_pages;
            nb_pages -= chunk_nb_pages;
            if (HAL_FLASHEx_Erase(&x_erase_init, &page_error) != HAL_OK)
 8038ba0:	a901      	add	r1, sp, #4
 8038ba2:	a802      	add	r0, sp, #8
            x_erase_init.NbPages = chunk_nb_pages;
 8038ba4:	e9cd 5304 	strd	r5, r3, [sp, #16]
            nb_pages -= chunk_nb_pages;
 8038ba8:	1ae4      	subs	r4, r4, r3
            first_page += chunk_nb_pages;
 8038baa:	441d      	add	r5, r3
            if (HAL_FLASHEx_Erase(&x_erase_init, &page_error) != HAL_OK)
 8038bac:	f001 fbde 	bl	803a36c <HAL_FLASHEx_Erase>
 8038bb0:	b110      	cbz	r0, 8038bb8 <FLASH_If_Erase_Size+0x78>
            {
              HAL_FLASH_GetError();
 8038bb2:	f001 fb2b 	bl	803a20c <HAL_FLASH_GetError>
              e_ret_status = HAL_ERROR;
 8038bb6:	2601      	movs	r6, #1
            /* Refresh Watchdog */
#if 0
            WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
#endif
          }
          while (nb_pages > 0);
 8038bb8:	2c00      	cmp	r4, #0
 8038bba:	d1ed      	bne.n	8038b98 <FLASH_If_Erase_Size+0x58>
        }
      }
      while (erase_command == 0);
      /* Lock the Flash to disable the flash control register access (recommended
      to protect the FLASH memory against possible unwanted operation) *********/
      HAL_FLASH_Lock();
 8038bbc:	f001 fb1a 	bl	803a1f4 <HAL_FLASH_Lock>
    {
      e_ret_status = HAL_ERROR;
    }
  }

  return e_ret_status;
 8038bc0:	e032      	b.n	8038c28 <FLASH_If_Erase_Size+0xe8>
    return  FLASH_BASE + (FLASH_BANK_SIZE);
 8038bc2:	f64f 71fd 	movw	r1, #65533	; 0xfffd
 8038bc6:	4b1a      	ldr	r3, [pc, #104]	; (8038c30 <FLASH_If_Erase_Size+0xf0>)
 8038bc8:	881b      	ldrh	r3, [r3, #0]
 8038bca:	1e5a      	subs	r2, r3, #1
 8038bcc:	b292      	uxth	r2, r2
 8038bce:	428a      	cmp	r2, r1
 8038bd0:	bf8e      	itee	hi
 8038bd2:	f8df a064 	ldrhi.w	sl, [pc, #100]	; 8038c38 <FLASH_If_Erase_Size+0xf8>
 8038bd6:	ea0b 2343 	andls.w	r3, fp, r3, lsl #9
 8038bda:	f103 6a00 	addls.w	sl, r3, #134217728	; 0x8000000
          nb_pages = GetPage(startbank2 - 1U) - first_page + 1U;
 8038bde:	f10a 30ff 	add.w	r0, sl, #4294967295
 8038be2:	f7ff ff5b 	bl	8038a9c <GetPage>
          x_erase_init.TypeErase   = FLASH_TYPEERASE_PAGES;
 8038be6:	2102      	movs	r1, #2
          uLength = uLength  - (startbank2 - uStart);
 8038be8:	eba4 040a 	sub.w	r4, r4, sl
 8038bec:	4427      	add	r7, r4
          uStart = startbank2;
 8038bee:	4654      	mov	r4, sl
          x_erase_init.Banks       = bank_number;
 8038bf0:	e9cd 1802 	strd	r1, r8, [sp, #8]
          nb_pages = GetPage(startbank2 - 1U) - first_page + 1U;
 8038bf4:	f1c5 0201 	rsb	r2, r5, #1
 8038bf8:	eb02 0900 	add.w	r9, r2, r0
            chunk_nb_pages = (nb_pages >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_pages;
 8038bfc:	464b      	mov	r3, r9
 8038bfe:	2b02      	cmp	r3, #2
 8038c00:	bf28      	it	cs
 8038c02:	2302      	movcs	r3, #2
            if (HAL_FLASHEx_Erase(&x_erase_init, &page_error) != HAL_OK)
 8038c04:	a901      	add	r1, sp, #4
 8038c06:	a802      	add	r0, sp, #8
            x_erase_init.NbPages = chunk_nb_pages;
 8038c08:	e9cd 5304 	strd	r5, r3, [sp, #16]
            nb_pages -= chunk_nb_pages;
 8038c0c:	eba9 0903 	sub.w	r9, r9, r3
            first_page += chunk_nb_pages;
 8038c10:	441d      	add	r5, r3
            if (HAL_FLASHEx_Erase(&x_erase_init, &page_error) != HAL_OK)
 8038c12:	f001 fbab 	bl	803a36c <HAL_FLASHEx_Erase>
 8038c16:	b110      	cbz	r0, 8038c1e <FLASH_If_Erase_Size+0xde>
              HAL_FLASH_GetError();
 8038c18:	f001 faf8 	bl	803a20c <HAL_FLASH_GetError>
              e_ret_status = HAL_ERROR;
 8038c1c:	2601      	movs	r6, #1
          while (nb_pages > 0);
 8038c1e:	f1b9 0f00 	cmp.w	r9, #0
 8038c22:	d1eb      	bne.n	8038bfc <FLASH_If_Erase_Size+0xbc>
 8038c24:	e79f      	b.n	8038b66 <FLASH_If_Erase_Size+0x26>
      e_ret_status = HAL_ERROR;
 8038c26:	2601      	movs	r6, #1
}
 8038c28:	4630      	mov	r0, r6
 8038c2a:	b007      	add	sp, #28
 8038c2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8038c30:	0bfa05e0 	.word	0x0bfa05e0
 8038c34:	001ffe00 	.word	0x001ffe00
 8038c38:	08040000 	.word	0x08040000

08038c3c <FLASH_If_Write>:
#ifdef USE_SVC
static HAL_StatusTypeDef FLASH_If_Write_svc(void *pDestination, const void *pSource, uint32_t uLength)
#else
HAL_StatusTypeDef FLASH_If_Write(void *pDestination, const void *pSource, uint32_t uLength)
#endif
{
 8038c3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8038c40:	4606      	mov	r6, r0
 8038c42:	460f      	mov	r7, r1
 8038c44:	4690      	mov	r8, r2
  uint32_t pdata = (uint32_t)pSource;
  /* Initialize Flash */
	#ifdef USE_SVC
  e_ret_status = FLASH_If_Init_svc();
  #else
	e_ret_status = FLASH_If_Init();
 8038c46:	f7ff ff5f 	bl	8038b08 <FLASH_If_Init>
	#endif
  if (e_ret_status == HAL_OK)
 8038c4a:	4604      	mov	r4, r0
 8038c4c:	b948      	cbnz	r0, 8038c62 <FLASH_If_Write+0x26>
  {
    /* Unlock the Flash to enable the flash control register access *************/
    if (HAL_FLASH_Unlock() != HAL_OK)
 8038c4e:	f001 fabf 	bl	803a1d0 <HAL_FLASH_Unlock>
 8038c52:	4604      	mov	r4, r0
 8038c54:	b9e0      	cbnz	r0, 8038c90 <FLASH_If_Write+0x54>
 8038c56:	463d      	mov	r5, r7

    }
    else
    {
      /* DataLength must be a multiple of 64 bit */
      for (i = 0U; i < uLength; i += 8U)
 8038c58:	1beb      	subs	r3, r5, r7
 8038c5a:	4598      	cmp	r8, r3
 8038c5c:	d804      	bhi.n	8038c68 <FLASH_If_Write+0x2c>
          break;
        }
      }
      /* Lock the Flash to disable the flash control register access (recommended
      to protect the FLASH memory against possible unwanted operation) *********/
      HAL_FLASH_Lock();
 8038c5e:	f001 fac9 	bl	803a1f4 <HAL_FLASH_Lock>
    }
  }
  return e_ret_status;
}
 8038c62:	4620      	mov	r0, r4
 8038c64:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, (uint32_t)pDestination,  *((uint64_t *)(pdata + i))) == HAL_OK)
 8038c68:	e9d5 2300 	ldrd	r2, r3, [r5]
 8038c6c:	4631      	mov	r1, r6
 8038c6e:	2001      	movs	r0, #1
 8038c70:	46a9      	mov	r9, r5
 8038c72:	f001 fafd 	bl	803a270 <HAL_FLASH_Program>
 8038c76:	b948      	cbnz	r0, 8038c8c <FLASH_If_Write+0x50>
          if (*(uint64_t *)pDestination != *(uint64_t *)(pdata + i))
 8038c78:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 8038c7c:	e9d9 2300 	ldrd	r2, r3, [r9]
 8038c80:	4299      	cmp	r1, r3
 8038c82:	bf08      	it	eq
 8038c84:	4290      	cmpeq	r0, r2
 8038c86:	f105 0508 	add.w	r5, r5, #8
 8038c8a:	d0e5      	beq.n	8038c58 <FLASH_If_Write+0x1c>
          e_ret_status = HAL_ERROR;
 8038c8c:	2401      	movs	r4, #1
 8038c8e:	e7e6      	b.n	8038c5e <FLASH_If_Write+0x22>
      return HAL_ERROR;
 8038c90:	2401      	movs	r4, #1
 8038c92:	e7e6      	b.n	8038c62 <FLASH_If_Write+0x26>

08038c94 <FW_UPDATE_PrintWelcome>:
  * @brief  Display the FW_UPDATE Main Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
static void FW_UPDATE_PrintWelcome(void)
{
 8038c94:	b508      	push	{r3, lr}
  printf("\r\n================ New Fw Download =========================\r\n\n");
 8038c96:	4808      	ldr	r0, [pc, #32]	; (8038cb8 <FW_UPDATE_PrintWelcome+0x24>)
 8038c98:	f003 fd3e 	bl	803c718 <puts>
  printf("  Download Secure Image --------------------------------- 1\r\n\n");
 8038c9c:	4807      	ldr	r0, [pc, #28]	; (8038cbc <FW_UPDATE_PrintWelcome+0x28>)
 8038c9e:	f003 fd3b 	bl	803c718 <puts>
  printf("  Download NonSecure Image------------------------------- 2\r\n\n");
 8038ca2:	4807      	ldr	r0, [pc, #28]	; (8038cc0 <FW_UPDATE_PrintWelcome+0x2c>)
 8038ca4:	f003 fd38 	bl	803c718 <puts>
  printf("  Reset to trigger Installation-------------------------- 3\r\n\n");
 8038ca8:	4806      	ldr	r0, [pc, #24]	; (8038cc4 <FW_UPDATE_PrintWelcome+0x30>)
 8038caa:	f003 fd35 	bl	803c718 <puts>
  printf("  Exit New FW Download Menu ----------------------------- x\r\n\n");
}
 8038cae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("  Exit New FW Download Menu ----------------------------- x\r\n\n");
 8038cb2:	4805      	ldr	r0, [pc, #20]	; (8038cc8 <FW_UPDATE_PrintWelcome+0x34>)
 8038cb4:	f003 bd30 	b.w	803c718 <puts>
 8038cb8:	0803db00 	.word	0x0803db00
 8038cbc:	0803db3f 	.word	0x0803db3f
 8038cc0:	0803db7d 	.word	0x0803db7d
 8038cc4:	0803dbbb 	.word	0x0803dbbb
 8038cc8:	0803dbf9 	.word	0x0803dbf9

08038ccc <FW_UPDATE_DownloadNewFirmware.constprop.1>:
/**
  * @brief Download a new Firmware from the host.
  * @retval HAL status
  */
static HAL_StatusTypeDef FW_UPDATE_DownloadNewFirmware(SFU_FwImageFlashTypeDef *pFwImageDwlArea)
 8038ccc:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8038cce:	4605      	mov	r5, r0
{
  HAL_StatusTypeDef ret = HAL_ERROR;
  COM_StatusTypeDef e_result;
  uint32_t u_fw_size = pFwImageDwlArea->MaxSizeInBytes ;
 8038cd0:	6803      	ldr	r3, [r0, #0]
 8038cd2:	ac02      	add	r4, sp, #8

  printf("  -- Send Firmware \r\n\n");
 8038cd4:	4816      	ldr	r0, [pc, #88]	; (8038d30 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x64>)
  uint32_t u_fw_size = pFwImageDwlArea->MaxSizeInBytes ;
 8038cd6:	f844 3d04 	str.w	r3, [r4, #-4]!
  printf("  -- Send Firmware \r\n\n");
 8038cda:	f003 fd1d 	bl	803c718 <puts>
  /* Download binary */
  printf("  -- -- File> Transfer> YMODEM> Send \t\n");
 8038cde:	4815      	ldr	r0, [pc, #84]	; (8038d34 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x68>)
 8038ce0:	f003 fd1a 	bl	803c718 <puts>

  /*Init of Ymodem*/
  Ymodem_Init();
 8038ce4:	f000 ff1c 	bl	8039b20 <Ymodem_Init>

  /*Receive through Ymodem*/
  e_result = Ymodem_Receive(&u_fw_size, pFwImageDwlArea->DownloadAddr);
 8038ce8:	4620      	mov	r0, r4
 8038cea:	6869      	ldr	r1, [r5, #4]
 8038cec:	f000 ff42 	bl	8039b74 <Ymodem_Receive>
 8038cf0:	4604      	mov	r4, r0
  printf("\r\n\n");
 8038cf2:	4811      	ldr	r0, [pc, #68]	; (8038d38 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x6c>)
 8038cf4:	f003 fd10 	bl	803c718 <puts>

  if ((e_result == COM_OK))
 8038cf8:	b94c      	cbnz	r4, 8038d0e <FW_UPDATE_DownloadNewFirmware.constprop.1+0x42>
  {
    printf("  -- -- Programming Completed Successfully!\r\n\n");
 8038cfa:	4810      	ldr	r0, [pc, #64]	; (8038d3c <FW_UPDATE_DownloadNewFirmware.constprop.1+0x70>)
 8038cfc:	f003 fd0c 	bl	803c718 <puts>
#if defined(__ARMCC_VERSION)
    printf("  -- -- Bytes: %u\r\n\n", u_fw_size);
#else
    printf("  -- -- Bytes: %lu\r\n\n", u_fw_size);
 8038d00:	9901      	ldr	r1, [sp, #4]
 8038d02:	480f      	ldr	r0, [pc, #60]	; (8038d40 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x74>)
 8038d04:	f003 fc94 	bl	803c630 <iprintf>
#endif /*  __ARMCC_VERSION */
    ret = HAL_OK;
 8038d08:	4620      	mov	r0, r4
    HAL_Delay(500U);
    COM_Flush();
  }

  return ret;
}
 8038d0a:	b003      	add	sp, #12
 8038d0c:	bd30      	pop	{r4, r5, pc}
  else if (e_result == COM_ABORT)
 8038d0e:	2c02      	cmp	r4, #2
 8038d10:	d106      	bne.n	8038d20 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x54>
    printf("  -- -- !!Aborted by user!!\r\n\n");
 8038d12:	480c      	ldr	r0, [pc, #48]	; (8038d44 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x78>)
 8038d14:	f003 fd00 	bl	803c718 <puts>
    COM_Flush();
 8038d18:	f7ff fe58 	bl	80389cc <COM_Flush>
    ret = HAL_ERROR;
 8038d1c:	2001      	movs	r0, #1
 8038d1e:	e7f4      	b.n	8038d0a <FW_UPDATE_DownloadNewFirmware.constprop.1+0x3e>
    printf("  -- -- !!Error during file download!!\r\n\n");
 8038d20:	4809      	ldr	r0, [pc, #36]	; (8038d48 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x7c>)
 8038d22:	f003 fcf9 	bl	803c718 <puts>
    HAL_Delay(500U);
 8038d26:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8038d2a:	f001 f8b9 	bl	8039ea0 <HAL_Delay>
 8038d2e:	e7f3      	b.n	8038d18 <FW_UPDATE_DownloadNewFirmware.constprop.1+0x4c>
 8038d30:	0803da38 	.word	0x0803da38
 8038d34:	0803da4e 	.word	0x0803da4e
 8038d38:	0803dc75 	.word	0x0803dc75
 8038d3c:	0803da75 	.word	0x0803da75
 8038d40:	0803daa3 	.word	0x0803daa3
 8038d44:	0803dab9 	.word	0x0803dab9
 8038d48:	0803dad7 	.word	0x0803dad7

08038d4c <FW_UPDATE_Run>:
  uint8_t key = 0U;
 8038d4c:	2300      	movs	r3, #0
{
 8038d4e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8038d52:	b086      	sub	sp, #24
  uint8_t key = 0U;
 8038d54:	f88d 3007 	strb.w	r3, [sp, #7]
  FW_UPDATE_PrintWelcome();
 8038d58:	f7ff ff9c 	bl	8038c94 <FW_UPDATE_PrintWelcome>
  printf("Download NonSecure Image\r\n");
 8038d5c:	4d2e      	ldr	r5, [pc, #184]	; (8038e18 <FW_UPDATE_Run+0xcc>)
  fw_image_dwl_area.DownloadAddr =  FLASH_AREA_3_OFFSET + FLASH_BASE;
 8038d5e:	4e2f      	ldr	r6, [pc, #188]	; (8038e1c <FW_UPDATE_Run+0xd0>)
    printf("  -- NonSecure Image correctly downloaded \r\n\n");
 8038d60:	4f2f      	ldr	r7, [pc, #188]	; (8038e20 <FW_UPDATE_Run+0xd4>)
    key = 0U;
 8038d62:	f04f 0800 	mov.w	r8, #0
 8038d66:	f88d 8007 	strb.w	r8, [sp, #7]
    COM_Flush();
 8038d6a:	f7ff fe2f 	bl	80389cc <COM_Flush>
    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
 8038d6e:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8038d72:	2101      	movs	r1, #1
 8038d74:	f10d 0007 	add.w	r0, sp, #7
 8038d78:	f7ff fe20 	bl	80389bc <COM_Receive>
 8038d7c:	4604      	mov	r4, r0
 8038d7e:	2800      	cmp	r0, #0
 8038d80:	d1f1      	bne.n	8038d66 <FW_UPDATE_Run+0x1a>
      switch (key)
 8038d82:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8038d86:	2b32      	cmp	r3, #50	; 0x32
 8038d88:	d026      	beq.n	8038dd8 <FW_UPDATE_Run+0x8c>
 8038d8a:	d805      	bhi.n	8038d98 <FW_UPDATE_Run+0x4c>
 8038d8c:	2b31      	cmp	r3, #49	; 0x31
 8038d8e:	d00c      	beq.n	8038daa <FW_UPDATE_Run+0x5e>
          printf("Invalid Number !\r");
 8038d90:	4824      	ldr	r0, [pc, #144]	; (8038e24 <FW_UPDATE_Run+0xd8>)
 8038d92:	f003 fc4d 	bl	803c630 <iprintf>
          break;
 8038d96:	e01c      	b.n	8038dd2 <FW_UPDATE_Run+0x86>
      switch (key)
 8038d98:	2b33      	cmp	r3, #51	; 0x33
 8038d9a:	d02c      	beq.n	8038df6 <FW_UPDATE_Run+0xaa>
 8038d9c:	2b78      	cmp	r3, #120	; 0x78
 8038d9e:	d1f7      	bne.n	8038d90 <FW_UPDATE_Run+0x44>
      FW_UPDATE_PrintWelcome();
 8038da0:	f7ff ff78 	bl	8038c94 <FW_UPDATE_PrintWelcome>
}
 8038da4:	b006      	add	sp, #24
 8038da6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  printf("Download Secure Image\r\n");
 8038daa:	481f      	ldr	r0, [pc, #124]	; (8038e28 <FW_UPDATE_Run+0xdc>)
 8038dac:	f003 fcb4 	bl	803c718 <puts>
  fw_image_dwl_area.MaxSizeInBytes = FLASH_S_PARTITION_SIZE;
 8038db0:	f44f 3310 	mov.w	r3, #147456	; 0x24000
 8038db4:	4a1d      	ldr	r2, [pc, #116]	; (8038e2c <FW_UPDATE_Run+0xe0>)
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 8038db6:	a802      	add	r0, sp, #8
  fw_image_dwl_area.MaxSizeInBytes = FLASH_S_PARTITION_SIZE;
 8038db8:	e9cd 3202 	strd	r3, r2, [sp, #8]
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 8038dbc:	9404      	str	r4, [sp, #16]
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 8038dbe:	f7ff ff85 	bl	8038ccc <FW_UPDATE_DownloadNewFirmware.constprop.1>
  if (HAL_OK == ret)
 8038dc2:	b930      	cbnz	r0, 8038dd2 <FW_UPDATE_Run+0x86>
    printf("  -- Secure Image correctly downloaded \r\n\n");
 8038dc4:	481a      	ldr	r0, [pc, #104]	; (8038e30 <FW_UPDATE_Run+0xe4>)
    printf("  -- NonSecure Image correctly downloaded \r\n\n");
 8038dc6:	f003 fca7 	bl	803c718 <puts>
    HAL_Delay(1000U);
 8038dca:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8038dce:	f001 f867 	bl	8039ea0 <HAL_Delay>
      FW_UPDATE_PrintWelcome();
 8038dd2:	f7ff ff5f 	bl	8038c94 <FW_UPDATE_PrintWelcome>
 8038dd6:	e7c4      	b.n	8038d62 <FW_UPDATE_Run+0x16>
  printf("Download NonSecure Image\r\n");
 8038dd8:	4628      	mov	r0, r5
 8038dda:	f003 fc9d 	bl	803c718 <puts>
  fw_image_dwl_area.MaxSizeInBytes = FLASH_NS_PARTITION_SIZE;
 8038dde:	f44f 3390 	mov.w	r3, #73728	; 0x12000
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 8038de2:	a802      	add	r0, sp, #8
  fw_image_dwl_area.DownloadAddr =  FLASH_AREA_3_OFFSET + FLASH_BASE;
 8038de4:	9603      	str	r6, [sp, #12]
  fw_image_dwl_area.MaxSizeInBytes = FLASH_NS_PARTITION_SIZE;
 8038de6:	9302      	str	r3, [sp, #8]
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 8038de8:	9404      	str	r4, [sp, #16]
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 8038dea:	f7ff ff6f 	bl	8038ccc <FW_UPDATE_DownloadNewFirmware.constprop.1>
  if (HAL_OK == ret)
 8038dee:	2800      	cmp	r0, #0
 8038df0:	d1ef      	bne.n	8038dd2 <FW_UPDATE_Run+0x86>
    printf("  -- NonSecure Image correctly downloaded \r\n\n");
 8038df2:	4638      	mov	r0, r7
 8038df4:	e7e7      	b.n	8038dc6 <FW_UPDATE_Run+0x7a>
          printf("  -- Install image : reboot\r\n\n");
 8038df6:	480f      	ldr	r0, [pc, #60]	; (8038e34 <FW_UPDATE_Run+0xe8>)
 8038df8:	f003 fc8e 	bl	803c718 <puts>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8038dfc:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8038e00:	490d      	ldr	r1, [pc, #52]	; (8038e38 <FW_UPDATE_Run+0xec>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8038e02:	4b0e      	ldr	r3, [pc, #56]	; (8038e3c <FW_UPDATE_Run+0xf0>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8038e04:	68ca      	ldr	r2, [r1, #12]
 8038e06:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8038e0a:	4313      	orrs	r3, r2
 8038e0c:	60cb      	str	r3, [r1, #12]
 8038e0e:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8038e12:	bf00      	nop
 8038e14:	e7fd      	b.n	8038e12 <FW_UPDATE_Run+0xc6>
 8038e16:	bf00      	nop
 8038e18:	0803dc78 	.word	0x0803dc78
 8038e1c:	0806e000 	.word	0x0806e000
 8038e20:	0803dc92 	.word	0x0803dc92
 8038e24:	0803dcdd 	.word	0x0803dcdd
 8038e28:	0803dc37 	.word	0x0803dc37
 8038e2c:	0804a000 	.word	0x0804a000
 8038e30:	0803dc4e 	.word	0x0803dc4e
 8038e34:	0803dcbf 	.word	0x0803dcbf
 8038e38:	e000ed00 	.word	0xe000ed00
 8038e3c:	05fa0004 	.word	0x05fa0004

08038e40 <Ymodem_HeaderPktRxCpltCallback>:
  * @brief  Ymodem Header Packet Transfer completed callback.
  * @param  uFileSize Dimension of the file that will be received (Bytes).
  * @retval None
  */
HAL_StatusTypeDef Ymodem_HeaderPktRxCpltCallback(uint32_t uFlashDestination, uint32_t uFileSize)
{
 8038e40:	b510      	push	{r4, lr}
  HAL_StatusTypeDef ret = HAL_ERROR;
  /*Reset of the ymodem variables */
  m_uFileSizeYmodem = 0U;
  m_uPacketsReceived = 0U;
 8038e42:	2400      	movs	r4, #0
 8038e44:	4a0b      	ldr	r2, [pc, #44]	; (8038e74 <Ymodem_HeaderPktRxCpltCallback+0x34>)

  /*Filesize information is stored*/
  m_uFileSizeYmodem = uFileSize;

  /* compute the number of 1K blocks */
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (PACKET_1K_SIZE - 1U)) / PACKET_1K_SIZE;
 8038e46:	f201 33ff 	addw	r3, r1, #1023	; 0x3ff
  m_uPacketsReceived = 0U;
 8038e4a:	6014      	str	r4, [r2, #0]
  m_uFileSizeYmodem = uFileSize;
 8038e4c:	4a0a      	ldr	r2, [pc, #40]	; (8038e78 <Ymodem_HeaderPktRxCpltCallback+0x38>)
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (PACKET_1K_SIZE - 1U)) / PACKET_1K_SIZE;
 8038e4e:	0a9b      	lsrs	r3, r3, #10
  m_uFileSizeYmodem = uFileSize;
 8038e50:	6011      	str	r1, [r2, #0]
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (PACKET_1K_SIZE - 1U)) / PACKET_1K_SIZE;
 8038e52:	4a0a      	ldr	r2, [pc, #40]	; (8038e7c <Ymodem_HeaderPktRxCpltCallback+0x3c>)
 8038e54:	6013      	str	r3, [r2, #0]
  if ((uFlashDestination >= 0x8000000) && (uFlashDestination < 0x8080000))
 8038e56:	f100 4378 	add.w	r3, r0, #4160749568	; 0xf8000000
 8038e5a:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8038e5e:	d300      	bcc.n	8038e62 <Ymodem_HeaderPktRxCpltCallback+0x22>
 8038e60:	e7fe      	b.n	8038e60 <Ymodem_HeaderPktRxCpltCallback+0x20>
  {
    ret = FLASH_If_Erase_Size((void *)(uFlashDestination), uFileSize);
 8038e62:	f7ff fe6d 	bl	8038b40 <FLASH_If_Erase_Size>
 8038e66:	4604      	mov	r4, r0
  }
  else while (1);
  /* NOTE : delay inserted for Ymodem protocol*/
  HAL_Delay(1000);
 8038e68:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8038e6c:	f001 f818 	bl	8039ea0 <HAL_Delay>
  return ret;
}
 8038e70:	4620      	mov	r0, r4
 8038e72:	bd10      	pop	{r4, pc}
 8038e74:	20000244 	.word	0x20000244
 8038e78:	2000023c 	.word	0x2000023c
 8038e7c:	20000240 	.word	0x20000240

08038e80 <Ymodem_DataPktRxCpltCallback>:
  * @param  pData Pointer to the buffer.
  * @param  uSize Packet dimension (Bytes).
  * @retval None
  */
HAL_StatusTypeDef Ymodem_DataPktRxCpltCallback(uint8_t *pData, uint32_t uFlashDestination, uint32_t uSize)
{
 8038e80:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef e_ret_status = HAL_ERROR;

  m_uPacketsReceived++;
 8038e82:	4c17      	ldr	r4, [pc, #92]	; (8038ee0 <Ymodem_DataPktRxCpltCallback+0x60>)

  /*Increase the number of received packets*/
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 8038e84:	4e17      	ldr	r6, [pc, #92]	; (8038ee4 <Ymodem_DataPktRxCpltCallback+0x64>)
  m_uPacketsReceived++;
 8038e86:	6823      	ldr	r3, [r4, #0]
{
 8038e88:	4605      	mov	r5, r0
 8038e8a:	4608      	mov	r0, r1
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 8038e8c:	6831      	ldr	r1, [r6, #0]
  m_uPacketsReceived++;
 8038e8e:	3301      	adds	r3, #1
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 8038e90:	428b      	cmp	r3, r1
  m_uPacketsReceived++;
 8038e92:	6023      	str	r3, [r4, #0]
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 8038e94:	d109      	bne.n	8038eaa <Ymodem_DataPktRxCpltCallback+0x2a>
  {
    /*Extracting actual payload from last packet*/
    if (0 == (m_uFileSizeYmodem % PACKET_1K_SIZE))
 8038e96:	4b14      	ldr	r3, [pc, #80]	; (8038ee8 <Ymodem_DataPktRxCpltCallback+0x68>)
 8038e98:	681a      	ldr	r2, [r3, #0]
    {
      /* The last packet is not full, drop the extra bytes */
      uSize = m_uFileSizeYmodem - ((uint32_t)(m_uFileSizeYmodem / PACKET_1K_SIZE) * PACKET_1K_SIZE);
    }

    m_uPacketsReceived = 0U;
 8038e9a:	2300      	movs	r3, #0
    if (0 == (m_uFileSizeYmodem % PACKET_1K_SIZE))
 8038e9c:	f3c2 0209 	ubfx	r2, r2, #0, #10
      uSize = PACKET_1K_SIZE;
 8038ea0:	2a00      	cmp	r2, #0
 8038ea2:	bf08      	it	eq
 8038ea4:	f44f 6280 	moveq.w	r2, #1024	; 0x400
    m_uPacketsReceived = 0U;
 8038ea8:	6023      	str	r3, [r4, #0]
  }
  if ((uFlashDestination >= 0x8000000) && (uFlashDestination < 0x8080000))
 8038eaa:	f100 4378 	add.w	r3, r0, #4160749568	; 0xf8000000
 8038eae:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8038eb2:	d20f      	bcs.n	8038ed4 <Ymodem_DataPktRxCpltCallback+0x54>
  {
    /*Adjust dimension to 64-bit length */
    if (uSize % FLASH_IF_MIN_WRITE_LEN != 0U)
 8038eb4:	0753      	lsls	r3, r2, #29
    {
      uSize += (FLASH_IF_MIN_WRITE_LEN - (uSize % FLASH_IF_MIN_WRITE_LEN));
 8038eb6:	bf1c      	itt	ne
 8038eb8:	f022 0207 	bicne.w	r2, r2, #7
 8038ebc:	3208      	addne	r2, #8
    }

    /* Write Data in Flash - size has to be 64-bit aligned */
    if (FLASH_If_Write((void *)uFlashDestination, pData, uSize) == HAL_OK)
 8038ebe:	4629      	mov	r1, r5
 8038ec0:	f7ff febc 	bl	8038c3c <FLASH_If_Write>
 8038ec4:	b128      	cbz	r0, 8038ed2 <Ymodem_DataPktRxCpltCallback+0x52>
  }
  if (e_ret_status == HAL_ERROR)
  {

    /*Reset of the ymodem variables */
    m_uFileSizeYmodem = 0U;
 8038ec6:	2300      	movs	r3, #0
      e_ret_status = HAL_ERROR;
 8038ec8:	2001      	movs	r0, #1
    m_uFileSizeYmodem = 0U;
 8038eca:	4a07      	ldr	r2, [pc, #28]	; (8038ee8 <Ymodem_DataPktRxCpltCallback+0x68>)
    m_uPacketsReceived = 0U;
 8038ecc:	6023      	str	r3, [r4, #0]
    m_uFileSizeYmodem = 0U;
 8038ece:	6013      	str	r3, [r2, #0]
    m_uNbrBlocksYmodem = 0U;
 8038ed0:	6033      	str	r3, [r6, #0]
  }
  return e_ret_status;
}
 8038ed2:	bd70      	pop	{r4, r5, r6, pc}
    memcpy((void *)uFlashDestination, pData, uSize);
 8038ed4:	4629      	mov	r1, r5
 8038ed6:	f003 fb98 	bl	803c60a <memcpy>
    e_ret_status = HAL_OK;
 8038eda:	2000      	movs	r0, #0
 8038edc:	e7f9      	b.n	8038ed2 <Ymodem_DataPktRxCpltCallback+0x52>
 8038ede:	bf00      	nop
 8038ee0:	20000244 	.word	0x20000244
 8038ee4:	20000240 	.word	0x20000240
 8038ee8:	2000023c 	.word	0x2000023c

08038eec <_write>:
  return ch;
}
#elif defined(__GNUC__)
/* Redirects printf to TFM_DRIVER_STDIO in case of GNUARM */
int _write(int fd, char *str, int len)
{
 8038eec:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8038eee:	460e      	mov	r6, r1
 8038ef0:	4615      	mov	r5, r2
  int i;

  for (i = 0; i < len; i++)
 8038ef2:	460c      	mov	r4, r1
 8038ef4:	1ba3      	subs	r3, r4, r6
 8038ef6:	429d      	cmp	r5, r3
 8038ef8:	dc02      	bgt.n	8038f00 <_write+0x14>
    uart_putc(str[i]);
  }

  /* Return the number of characters written */
  return len;
}
 8038efa:	4628      	mov	r0, r5
 8038efc:	b002      	add	sp, #8
 8038efe:	bd70      	pop	{r4, r5, r6, pc}
    uart_putc(str[i]);
 8038f00:	f814 3b01 	ldrb.w	r3, [r4], #1
  COM_Transmit(&c, 1, 1000U);
 8038f04:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8038f08:	2101      	movs	r1, #1
 8038f0a:	f10d 0007 	add.w	r0, sp, #7
 8038f0e:	f88d 3007 	strb.w	r3, [sp, #7]
 8038f12:	f7ff fd4b 	bl	80389ac <COM_Transmit>
 8038f16:	e7ed      	b.n	8038ef4 <_write+0x8>

08038f18 <FW_APP_PrintMainMenu>:
  * @brief  Display the TEST Main Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
void FW_APP_PrintMainMenu(void)
{
 8038f18:	b508      	push	{r3, lr}
  printf("\r\n=================== Main Menu ============================\r\n\n");
 8038f1a:	4808      	ldr	r0, [pc, #32]	; (8038f3c <FW_APP_PrintMainMenu+0x24>)
 8038f1c:	f003 fbfc 	bl	803c718 <puts>
  printf("  Download a new Fw Image ------------------------------- 1\r\n\n");
 8038f20:	4807      	ldr	r0, [pc, #28]	; (8038f40 <FW_APP_PrintMainMenu+0x28>)
 8038f22:	f003 fbf9 	bl	803c718 <puts>
  printf("  Test Protections -------------------------------------- 2\r\n\n");
 8038f26:	4807      	ldr	r0, [pc, #28]	; (8038f44 <FW_APP_PrintMainMenu+0x2c>)
 8038f28:	f003 fbf6 	bl	803c718 <puts>
  printf("  Test TFM ---------------------------------------------- 3\r\n\n");
 8038f2c:	4806      	ldr	r0, [pc, #24]	; (8038f48 <FW_APP_PrintMainMenu+0x30>)
 8038f2e:	f003 fbf3 	bl	803c718 <puts>
  printf("  Selection :\r\n\n");
}
 8038f32:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("  Selection :\r\n\n");
 8038f36:	4805      	ldr	r0, [pc, #20]	; (8038f4c <FW_APP_PrintMainMenu+0x34>)
 8038f38:	f003 bbee 	b.w	803c718 <puts>
 8038f3c:	0803dcef 	.word	0x0803dcef
 8038f40:	0803dd2e 	.word	0x0803dd2e
 8038f44:	0803dd6c 	.word	0x0803dd6c
 8038f48:	0803ddaa 	.word	0x0803ddaa
 8038f4c:	0803dde8 	.word	0x0803dde8

08038f50 <FW_APP_Run>:
  * @param  None.
  * @retval None.
  */
void FW_APP_Run(void)
{
  uint8_t key = 0U;
 8038f50:	2300      	movs	r3, #0
{
 8038f52:	b507      	push	{r0, r1, r2, lr}
  uint8_t key = 0U;
 8038f54:	ac02      	add	r4, sp, #8
 8038f56:	f804 3d01 	strb.w	r3, [r4, #-1]!

  /*##1- Print Main Menu message*/
  FW_APP_PrintMainMenu();
 8038f5a:	f7ff ffdd 	bl	8038f18 <FW_APP_PrintMainMenu>
        break;
      case '3' :
        tfm_app_menu();
        break;
      default:
        printf("Invalid Number !\r");
 8038f5e:	4d11      	ldr	r5, [pc, #68]	; (8038fa4 <FW_APP_Run+0x54>)
  COM_Flush();
 8038f60:	f7ff fd34 	bl	80389cc <COM_Flush>
  if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
 8038f64:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8038f68:	2101      	movs	r1, #1
 8038f6a:	4620      	mov	r0, r4
 8038f6c:	f7ff fd26 	bl	80389bc <COM_Receive>
 8038f70:	2800      	cmp	r0, #0
 8038f72:	d1f5      	bne.n	8038f60 <FW_APP_Run+0x10>
    switch (key)
 8038f74:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8038f78:	2b32      	cmp	r3, #50	; 0x32
 8038f7a:	d008      	beq.n	8038f8e <FW_APP_Run+0x3e>
 8038f7c:	2b33      	cmp	r3, #51	; 0x33
 8038f7e:	d009      	beq.n	8038f94 <FW_APP_Run+0x44>
 8038f80:	2b31      	cmp	r3, #49	; 0x31
 8038f82:	d10a      	bne.n	8038f9a <FW_APP_Run+0x4a>
        FW_UPDATE_Run();
 8038f84:	f7ff fee2 	bl	8038d4c <FW_UPDATE_Run>
        break;
    }

    /*Print Main Menu message*/
    FW_APP_PrintMainMenu();
 8038f88:	f7ff ffc6 	bl	8038f18 <FW_APP_PrintMainMenu>
 8038f8c:	e7e8      	b.n	8038f60 <FW_APP_Run+0x10>
        TEST_PROTECTIONS_Run();
 8038f8e:	f000 f9cf 	bl	8039330 <TEST_PROTECTIONS_Run>
        break;
 8038f92:	e7f9      	b.n	8038f88 <FW_APP_Run+0x38>
        tfm_app_menu();
 8038f94:	f000 fbc2 	bl	803971c <tfm_app_menu>
        break;
 8038f98:	e7f6      	b.n	8038f88 <FW_APP_Run+0x38>
        printf("Invalid Number !\r");
 8038f9a:	4628      	mov	r0, r5
 8038f9c:	f003 fb48 	bl	803c630 <iprintf>
        break;
 8038fa0:	e7f2      	b.n	8038f88 <FW_APP_Run+0x38>
 8038fa2:	bf00      	nop
 8038fa4:	0803dcdd 	.word	0x0803dcdd

08038fa8 <main>:
{
 8038fa8:	b508      	push	{r3, lr}
  pUserAppId = (uint8_t *)&UserAppId;
 8038faa:	4c12      	ldr	r4, [pc, #72]	; (8038ff4 <main+0x4c>)
 8038fac:	4b12      	ldr	r3, [pc, #72]	; (8038ff8 <main+0x50>)
 8038fae:	6023      	str	r3, [r4, #0]
  HAL_Init();
 8038fb0:	f000 ff52 	bl	8039e58 <HAL_Init>
  COM_Init();
 8038fb4:	f7ff fc84 	bl	80388c0 <COM_Init>
  if (TestNumber & TEST_PROTECTION_MASK)
 8038fb8:	4b10      	ldr	r3, [pc, #64]	; (8038ffc <main+0x54>)
 8038fba:	681a      	ldr	r2, [r3, #0]
 8038fbc:	4b10      	ldr	r3, [pc, #64]	; (8039000 <main+0x58>)
 8038fbe:	421a      	tst	r2, r3
 8038fc0:	d001      	beq.n	8038fc6 <main+0x1e>
    TEST_PROTECTIONS_Run_SecUserMem();
 8038fc2:	f000 f8d7 	bl	8039174 <TEST_PROTECTIONS_Run_SecUserMem>
  printf("\r\n======================================================================");
 8038fc6:	480f      	ldr	r0, [pc, #60]	; (8039004 <main+0x5c>)
 8038fc8:	f003 fb32 	bl	803c630 <iprintf>
  printf("\r\n=              (C) COPYRIGHT 2019 STMicroelectronics                 =");
 8038fcc:	480e      	ldr	r0, [pc, #56]	; (8039008 <main+0x60>)
 8038fce:	f003 fb2f 	bl	803c630 <iprintf>
  printf("\r\n=                                                                    =");
 8038fd2:	480e      	ldr	r0, [pc, #56]	; (803900c <main+0x64>)
 8038fd4:	f003 fb2c 	bl	803c630 <iprintf>
  printf("\r\n=                          User App #%c                               =", *pUserAppId);
 8038fd8:	6823      	ldr	r3, [r4, #0]
 8038fda:	480d      	ldr	r0, [pc, #52]	; (8039010 <main+0x68>)
 8038fdc:	7819      	ldrb	r1, [r3, #0]
 8038fde:	f003 fb27 	bl	803c630 <iprintf>
  printf("\r\n======================================================================");
 8038fe2:	4808      	ldr	r0, [pc, #32]	; (8039004 <main+0x5c>)
 8038fe4:	f003 fb24 	bl	803c630 <iprintf>
  printf("\r\n\r\n");
 8038fe8:	480a      	ldr	r0, [pc, #40]	; (8039014 <main+0x6c>)
 8038fea:	f003 fb95 	bl	803c718 <puts>
  FW_APP_Run();
 8038fee:	f7ff ffaf 	bl	8038f50 <FW_APP_Run>
 8038ff2:	bf00      	nop
 8038ff4:	20000684 	.word	0x20000684
 8038ff8:	0803ddf8 	.word	0x0803ddf8
 8038ffc:	20000000 	.word	0x20000000
 8039000:	dead0000 	.word	0xdead0000
 8039004:	0803ddf9 	.word	0x0803ddf9
 8039008:	0803de42 	.word	0x0803de42
 803900c:	0803de8b 	.word	0x0803de8b
 8039010:	0803ded4 	.word	0x0803ded4
 8039014:	0803df1e 	.word	0x0803df1e

08039018 <mpu_armv8m_region_enable>:
  uint32_t ctrl_before;
  uint32_t base_cfg;
  uint32_t limit_cfg;

  /*FIXME : Add complete error checking*/
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 8039018:	684a      	ldr	r2, [r1, #4]
{
 803901a:	b530      	push	{r4, r5, lr}
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 803901c:	f012 051f 	ands.w	r5, r2, #31
 8039020:	d128      	bne.n	8039074 <mpu_armv8m_region_enable+0x5c>
  MPU_Type *mpu = (MPU_Type *)dev->base;
 8039022:	6804      	ldr	r4, [r0, #0]
   */

  ctrl_before = mpu->CTRL;
  mpu->CTRL = 0;

  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 8039024:	780b      	ldrb	r3, [r1, #0]
  ctrl_before = mpu->CTRL;
 8039026:	6860      	ldr	r0, [r4, #4]
  mpu->CTRL = 0;
 8039028:	6065      	str	r5, [r4, #4]
  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 803902a:	60a3      	str	r3, [r4, #8]

  /* This 0s the lower bits of the base address */
  base_cfg = region_cfg->region_base & MPU_RBAR_BASE_Msk;
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 803902c:	7c0b      	ldrb	r3, [r1, #16]
  base_cfg = region_cfg->region_base & MPU_RBAR_BASE_Msk;
 803902e:	f022 021f 	bic.w	r2, r2, #31
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 8039032:	f003 0301 	and.w	r3, r3, #1
 8039036:	4313      	orrs	r3, r2
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
 8039038:	7c8a      	ldrb	r2, [r1, #18]
 803903a:	00d2      	lsls	r2, r2, #3
 803903c:	f002 0218 	and.w	r2, r2, #24
 8039040:	431a      	orrs	r2, r3
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
 8039042:	7c4b      	ldrb	r3, [r1, #17]
 8039044:	005b      	lsls	r3, r3, #1
 8039046:	f003 0306 	and.w	r3, r3, #6
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 803904a:	4313      	orrs	r3, r2

  mpu->RBAR = base_cfg;
 803904c:	60e3      	str	r3, [r4, #12]

  /*This 0s the lower bits of base address but they are treated as 1 */
  limit_cfg = (region_cfg->region_limit - 1) & MPU_RLAR_LIMIT_Msk;
 803904e:	688b      	ldr	r3, [r1, #8]
 8039050:	3b01      	subs	r3, #1
 8039052:	f023 021f 	bic.w	r2, r3, #31

  limit_cfg |= (region_cfg->region_attridx << MPU_RLAR_AttrIndx_Pos) &
 8039056:	68cb      	ldr	r3, [r1, #12]
 8039058:	005b      	lsls	r3, r3, #1
 803905a:	f003 030e 	and.w	r3, r3, #14
 803905e:	4313      	orrs	r3, r2
               MPU_RLAR_AttrIndx_Msk;

  limit_cfg |= MPU_RLAR_EN_Msk;
 8039060:	f043 0301 	orr.w	r3, r3, #1

  mpu->RLAR = limit_cfg;
 8039064:	6123      	str	r3, [r4, #16]

  /*Restore main MPU control*/
  mpu->CTRL = ctrl_before;
 8039066:	6060      	str	r0, [r4, #4]
 8039068:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 803906c:	f3bf 8f6f 	isb	sy

  /* Enable MPU before the next instruction */
  __DSB();
  __ISB();

  return ret_val;
 8039070:	4628      	mov	r0, r5
}
 8039072:	bd30      	pop	{r4, r5, pc}
    return MPU_ARMV8M_ERROR;
 8039074:	2001      	movs	r0, #1
 8039076:	e7fc      	b.n	8039072 <mpu_armv8m_region_enable+0x5a>

08039078 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 8039078:	4770      	bx	lr

0803907a <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 803907a:	e7fe      	b.n	803907a <HardFault_Handler>

0803907c <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 803907c:	e7fe      	b.n	803907c <MemManage_Handler>

0803907e <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 803907e:	e7fe      	b.n	803907e <BusFault_Handler>

08039080 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8039080:	e7fe      	b.n	8039080 <UsageFault_Handler>

08039082 <DebugMon_Handler>:
 8039082:	4770      	bx	lr

08039084 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
 8039084:	f000 befa 	b.w	8039e7c <HAL_IncTick>

08039088 <FLASH_IRQHandler>:
  * @param  None
  * @retval None
  */
void FLASH_IRQHandler(void)
{
  HAL_FLASH_IRQHandler();
 8039088:	f001 b848 	b.w	803a11c <HAL_FLASH_IRQHandler>

0803908c <SystemInit>:

void SystemInit(void)
{
#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
extern uint32_t __Vectors;
  SCB->VTOR = (uint32_t) &__Vectors;
 803908c:	4b04      	ldr	r3, [pc, #16]	; (80390a0 <SystemInit+0x14>)
 803908e:	4a05      	ldr	r2, [pc, #20]	; (80390a4 <SystemInit+0x18>)
 8039090:	609a      	str	r2, [r3, #8]
#endif
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 8039092:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8039096:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 803909a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif
}
 803909e:	4770      	bx	lr
 80390a0:	e000ed00 	.word	0xe000ed00
 80390a4:	08038400 	.word	0x08038400

080390a8 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
  uint32_t tmp, msirange, pllvco, pllsource, pllm, pllr;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 80390a8:	4a21      	ldr	r2, [pc, #132]	; (8039130 <SystemCoreClockUpdate+0x88>)
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];
 80390aa:	4922      	ldr	r1, [pc, #136]	; (8039134 <SystemCoreClockUpdate+0x8c>)
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 80390ac:	6813      	ldr	r3, [r2, #0]
{
 80390ae:	b510      	push	{r4, lr}
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 80390b0:	071b      	lsls	r3, r3, #28
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 80390b2:	bf55      	itete	pl
 80390b4:	f8d2 3094 	ldrpl.w	r3, [r2, #148]	; 0x94
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 80390b8:	6813      	ldrmi	r3, [r2, #0]
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 80390ba:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 80390be:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
  msirange = MSIRangeTable[msirange];
 80390c2:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80390c6:	6891      	ldr	r1, [r2, #8]
 80390c8:	481b      	ldr	r0, [pc, #108]	; (8039138 <SystemCoreClockUpdate+0x90>)
 80390ca:	f001 010c 	and.w	r1, r1, #12
 80390ce:	2908      	cmp	r1, #8
 80390d0:	d003      	beq.n	80390da <SystemCoreClockUpdate+0x32>
 80390d2:	290c      	cmp	r1, #12
 80390d4:	d00c      	beq.n	80390f0 <SystemCoreClockUpdate+0x48>
 80390d6:	2904      	cmp	r1, #4
 80390d8:	d127      	bne.n	803912a <SystemCoreClockUpdate+0x82>
    case 0x00:  /* MSI used as system clock source */
      SystemCoreClock = msirange;
      break;

    case 0x04:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
 80390da:	4b18      	ldr	r3, [pc, #96]	; (803913c <SystemCoreClockUpdate+0x94>)
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
      SystemCoreClock = pllvco/pllr;
 80390dc:	6003      	str	r3, [r0, #0]
      SystemCoreClock = msirange;
      break;
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
 80390de:	6893      	ldr	r3, [r2, #8]
 80390e0:	4a17      	ldr	r2, [pc, #92]	; (8039140 <SystemCoreClockUpdate+0x98>)
 80390e2:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80390e6:	5cd2      	ldrb	r2, [r2, r3]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 80390e8:	6803      	ldr	r3, [r0, #0]
 80390ea:	40d3      	lsrs	r3, r2
 80390ec:	6003      	str	r3, [r0, #0]
}
 80390ee:	bd10      	pop	{r4, pc}
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80390f0:	68d1      	ldr	r1, [r2, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 80390f2:	68d3      	ldr	r3, [r2, #12]
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80390f4:	f001 0103 	and.w	r1, r1, #3
      switch (pllsource)
 80390f8:	3902      	subs	r1, #2
 80390fa:	2901      	cmp	r1, #1
          pllvco = (HSE_VALUE / pllm);
 80390fc:	bf98      	it	ls
 80390fe:	490f      	ldrls	r1, [pc, #60]	; (803913c <SystemCoreClockUpdate+0x94>)
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 8039100:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8039104:	f103 0301 	add.w	r3, r3, #1
          pllvco = (HSE_VALUE / pllm);
 8039108:	bf94      	ite	ls
 803910a:	fbb1 f3f3 	udivls	r3, r1, r3
          pllvco = (msirange / pllm);
 803910e:	fbb4 f3f3 	udivhi	r3, r4, r3
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 8039112:	68d4      	ldr	r4, [r2, #12]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 8039114:	68d1      	ldr	r1, [r2, #12]
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 8039116:	f3c4 2406 	ubfx	r4, r4, #8, #7
 803911a:	4363      	muls	r3, r4
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 803911c:	f3c1 6141 	ubfx	r1, r1, #25, #2
 8039120:	3101      	adds	r1, #1
 8039122:	0049      	lsls	r1, r1, #1
      SystemCoreClock = pllvco/pllr;
 8039124:	fbb3 f3f1 	udiv	r3, r3, r1
 8039128:	e7d8      	b.n	80390dc <SystemCoreClockUpdate+0x34>
      SystemCoreClock = msirange;
 803912a:	6004      	str	r4, [r0, #0]
      break;
 803912c:	e7d7      	b.n	80390de <SystemCoreClockUpdate+0x36>
 803912e:	bf00      	nop
 8039130:	40021000 	.word	0x40021000
 8039134:	0803df3c 	.word	0x0803df3c
 8039138:	20000100 	.word	0x20000100
 803913c:	00f42400 	.word	0x00f42400
 8039140:	0803df22 	.word	0x0803df22

08039144 <TEST_PROTECTIONS_PrintTestingMenu>:
  * @brief  Display the TEST Main Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
static void TEST_PROTECTIONS_PrintTestingMenu(void)
{
 8039144:	b508      	push	{r3, lr}
  printf("\r\n=================== Test Menu ============================\r\n\n");
 8039146:	4807      	ldr	r0, [pc, #28]	; (8039164 <TEST_PROTECTIONS_PrintTestingMenu+0x20>)
 8039148:	f003 fae6 	bl	803c718 <puts>
  printf("  Test Protection : NonSecure try to access to Secure --- 1\r\n\n");
 803914c:	4806      	ldr	r0, [pc, #24]	; (8039168 <TEST_PROTECTIONS_PrintTestingMenu+0x24>)
 803914e:	f003 fae3 	bl	803c718 <puts>
  printf("  RDP Regression ---------------------------------------- 2\r\n\n");
 8039152:	4806      	ldr	r0, [pc, #24]	; (803916c <TEST_PROTECTIONS_PrintTestingMenu+0x28>)
 8039154:	f003 fae0 	bl	803c718 <puts>
  printf("  Previous Menu ----------------------------------------- x\r\n\n");
}
 8039158:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("  Previous Menu ----------------------------------------- x\r\n\n");
 803915c:	4804      	ldr	r0, [pc, #16]	; (8039170 <TEST_PROTECTIONS_PrintTestingMenu+0x2c>)
 803915e:	f003 badb 	b.w	803c718 <puts>
 8039162:	bf00      	nop
 8039164:	0803df7c 	.word	0x0803df7c
 8039168:	0803dfbb 	.word	0x0803dfbb
 803916c:	0803dff9 	.word	0x0803dff9
 8039170:	0803e037 	.word	0x0803e037

08039174 <TEST_PROTECTIONS_Run_SecUserMem>:
  uint32_t page_error = 0U;
 8039174:	2300      	movs	r3, #0
{
 8039176:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if ((TestNumber & TEST_PROTECTION_MASK) == 0)
 803917a:	4d5f      	ldr	r5, [pc, #380]	; (80392f8 <TEST_PROTECTIONS_Run_SecUserMem+0x184>)
{
 803917c:	b089      	sub	sp, #36	; 0x24
  if ((TestNumber & TEST_PROTECTION_MASK) == 0)
 803917e:	682a      	ldr	r2, [r5, #0]
  uint32_t page_error = 0U;
 8039180:	9301      	str	r3, [sp, #4]
  if ((TestNumber & TEST_PROTECTION_MASK) == 0)
 8039182:	4b5e      	ldr	r3, [pc, #376]	; (80392fc <TEST_PROTECTIONS_Run_SecUserMem+0x188>)
           aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg, (int)aProtectTests[test_idx].address);
 8039184:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 803932c <TEST_PROTECTIONS_Run_SecUserMem+0x1b8>
  if ((TestNumber & TEST_PROTECTION_MASK) == 0)
 8039188:	4213      	tst	r3, r2
      if (on)
      {
        __HAL_RCC_RNG_CLK_ENABLE();
      }
      else
        __HAL_RCC_RNG_CLK_DISABLE();
 803918a:	4f5d      	ldr	r7, [pc, #372]	; (8039300 <TEST_PROTECTIONS_Run_SecUserMem+0x18c>)
    TestNumber = TEST_PROTECTION_MASK;
 803918c:	bf08      	it	eq
 803918e:	602b      	streq	r3, [r5, #0]
    HAL_Delay(100);
 8039190:	2064      	movs	r0, #100	; 0x64
 8039192:	f000 fe85 	bl	8039ea0 <HAL_Delay>
    test_idx = TestNumber & 0xffff;
 8039196:	882e      	ldrh	r6, [r5, #0]
    if (test_idx > (sizeof(aProtectTests) / sizeof(TestProtection_t) -1))
 8039198:	2e08      	cmp	r6, #8
 803919a:	d902      	bls.n	80391a2 <TEST_PROTECTIONS_Run_SecUserMem+0x2e>
    TestNumber = 0;            /* no more test in progress */
 803919c:	2300      	movs	r3, #0
 803919e:	602b      	str	r3, [r5, #0]
 80391a0:	e045      	b.n	803922e <TEST_PROTECTIONS_Run_SecUserMem+0xba>
           aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg, (int)aProtectTests[test_idx].address);
 80391a2:	f04f 0a28 	mov.w	sl, #40	; 0x28
    printf("\r\n= [TEST] %s @ %s %08x", \
 80391a6:	2014      	movs	r0, #20
    TestNumber = TEST_PROTECTION_MASK | ((test_idx + 1) & 0xffff);
 80391a8:	1c73      	adds	r3, r6, #1
 80391aa:	f043 435e 	orr.w	r3, r3, #3724541952	; 0xde000000
 80391ae:	f443 032d 	orr.w	r3, r3, #11337728	; 0xad0000
 80391b2:	602b      	str	r3, [r5, #0]
           aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg, (int)aProtectTests[test_idx].address);
 80391b4:	fb0a f306 	mul.w	r3, sl, r6
 80391b8:	eb09 0203 	add.w	r2, r9, r3
 80391bc:	f892 b024 	ldrb.w	fp, [r2, #36]	; 0x24
 80391c0:	f103 0804 	add.w	r8, r3, #4
 80391c4:	f859 4003 	ldr.w	r4, [r9, r3]
    printf("\r\n= [TEST] %s @ %s %08x", \
 80391c8:	494e      	ldr	r1, [pc, #312]	; (8039304 <TEST_PROTECTIONS_Run_SecUserMem+0x190>)
           aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg, (int)aProtectTests[test_idx].address);
 80391ca:	44c8      	add	r8, r9
    printf("\r\n= [TEST] %s @ %s %08x", \
 80391cc:	4623      	mov	r3, r4
 80391ce:	fb00 110b 	mla	r1, r0, fp, r1
 80391d2:	4642      	mov	r2, r8
 80391d4:	484c      	ldr	r0, [pc, #304]	; (8039308 <TEST_PROTECTIONS_Run_SecUserMem+0x194>)
 80391d6:	f003 fa2b 	bl	803c630 <iprintf>
    switch (aProtectTests[test_idx].type)
 80391da:	f1bb 0f07 	cmp.w	fp, #7
 80391de:	d8d7      	bhi.n	8039190 <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
 80391e0:	e8df f00b 	tbb	[pc, fp]
 80391e4:	4a362804 	.word	0x4a362804
 80391e8:	7f58564d 	.word	0x7f58564d
        HAL_FLASH_Unlock();
 80391ec:	f000 fff0 	bl	803a1d0 <HAL_FLASH_Unlock>
        HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, aProtectTests[test_idx].address, pattern);
 80391f0:	2200      	movs	r2, #0
 80391f2:	4621      	mov	r1, r4
 80391f4:	2300      	movs	r3, #0
 80391f6:	2001      	movs	r0, #1
 80391f8:	f001 f83a 	bl	803a270 <HAL_FLASH_Program>
        HAL_FLASH_Lock();
 80391fc:	f000 fffa 	bl	803a1f4 <HAL_FLASH_Lock>
        flashErrCode = HAL_FLASH_GetError();
 8039200:	f001 f804 	bl	803a20c <HAL_FLASH_GetError>
 8039204:	4604      	mov	r4, r0
        printf("\r\nflash error code: %x",(int)flashErrCode);
 8039206:	4601      	mov	r1, r0
 8039208:	4840      	ldr	r0, [pc, #256]	; (803930c <TEST_PROTECTIONS_Run_SecUserMem+0x198>)
 803920a:	f003 fa11 	bl	803c630 <iprintf>
          status = TEST_ERROR;
 803920e:	f014 0f10 	tst.w	r4, #16
        if (0 == strncmp("OBs @", (const char *)aProtectTests[test_idx].msg, 5))
 8039212:	f04f 0205 	mov.w	r2, #5
 8039216:	4641      	mov	r1, r8
 8039218:	483d      	ldr	r0, [pc, #244]	; (8039310 <TEST_PROTECTIONS_Run_SecUserMem+0x19c>)
          status = TEST_ERROR;
 803921a:	bf14      	ite	ne
 803921c:	2600      	movne	r6, #0
 803921e:	2602      	moveq	r6, #2
        if (0 == strncmp("OBs @", (const char *)aProtectTests[test_idx].msg, 5))
 8039220:	f003 fb2e 	bl	803c880 <strncmp>
 8039224:	2800      	cmp	r0, #0
 8039226:	d157      	bne.n	80392d8 <TEST_PROTECTIONS_Run_SecUserMem+0x164>
    printf("\r\n TEST_PROTECTIONS_Run_SecUserMem : Failed");
 8039228:	483a      	ldr	r0, [pc, #232]	; (8039314 <TEST_PROTECTIONS_Run_SecUserMem+0x1a0>)
 803922a:	f003 fa01 	bl	803c630 <iprintf>
}
 803922e:	b009      	add	sp, #36	; 0x24
 8039230:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        tmp = *(uint8_t *)(aProtectTests[test_idx].address);
 8039234:	7823      	ldrb	r3, [r4, #0]
        HAL_Delay(1);        /* ensure Flag is set */
 8039236:	2001      	movs	r0, #1
        tmp = *(uint8_t *)(aProtectTests[test_idx].address);
 8039238:	f88d 3003 	strb.w	r3, [sp, #3]
        HAL_Delay(1);        /* ensure Flag is set */
 803923c:	f000 fe30 	bl	8039ea0 <HAL_Delay>
        if (0 == strncmp("Isolated", (const char *)aProtectTests[test_idx].msg, 8))
 8039240:	2208      	movs	r2, #8
 8039242:	4641      	mov	r1, r8
 8039244:	4834      	ldr	r0, [pc, #208]	; (8039318 <TEST_PROTECTIONS_Run_SecUserMem+0x1a4>)
 8039246:	f003 fb1b 	bl	803c880 <strncmp>
 803924a:	2800      	cmp	r0, #0
 803924c:	d1a0      	bne.n	8039190 <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
 803924e:	e7eb      	b.n	8039228 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        HAL_FLASH_Unlock();
 8039250:	f000 ffbe 	bl	803a1d0 <HAL_FLASH_Unlock>
        p_erase_init.TypeErase   = FLASH_TYPEERASE_PAGES;
 8039254:	2301      	movs	r3, #1
 8039256:	2202      	movs	r2, #2
        HAL_FLASHEx_Erase(&p_erase_init, &page_error);
 8039258:	a901      	add	r1, sp, #4
        p_erase_init.Page        = (aProtectTests[test_idx].address) / 0x800;
 803925a:	0ae4      	lsrs	r4, r4, #11
        HAL_FLASHEx_Erase(&p_erase_init, &page_error);
 803925c:	a804      	add	r0, sp, #16
        p_erase_init.TypeErase   = FLASH_TYPEERASE_PAGES;
 803925e:	e9cd 2304 	strd	r2, r3, [sp, #16]
        p_erase_init.NbPages     = 1;
 8039262:	e9cd 4306 	strd	r4, r3, [sp, #24]
        HAL_FLASHEx_Erase(&p_erase_init, &page_error);
 8039266:	f001 f881 	bl	803a36c <HAL_FLASHEx_Erase>
        HAL_FLASH_Lock();
 803926a:	f000 ffc3 	bl	803a1f4 <HAL_FLASH_Lock>
        if ((HAL_FLASH_GetError() & HAL_FLASH_ERROR_WRP) == 0U)
 803926e:	f000 ffcd 	bl	803a20c <HAL_FLASH_GetError>
 8039272:	06c3      	lsls	r3, r0, #27
 8039274:	d48c      	bmi.n	8039190 <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
 8039276:	e7d7      	b.n	8039228 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        *(uint32_t *)aProtectTests[test_idx].address = 0x00000000;
 8039278:	2300      	movs	r3, #0
 803927a:	6023      	str	r3, [r4, #0]
 803927c:	e7d4      	b.n	8039228 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        tmp = *(uint8_t *)aProtectTests[test_idx].address;
 803927e:	7823      	ldrb	r3, [r4, #0]
        printf(" value : %d ", tmp);
 8039280:	4826      	ldr	r0, [pc, #152]	; (803931c <TEST_PROTECTIONS_Run_SecUserMem+0x1a8>)
        tmp = *(uint8_t *)aProtectTests[test_idx].address;
 8039282:	f88d 3003 	strb.w	r3, [sp, #3]
        printf(" value : %d ", tmp);
 8039286:	f89d 1003 	ldrb.w	r1, [sp, #3]
 803928a:	f003 f9d1 	bl	803c630 <iprintf>
 803928e:	e7cb      	b.n	8039228 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        func();
 8039290:	47a0      	blx	r4
 8039292:	e7c9      	b.n	8039228 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        set_periph(aProtectTests[test_idx].periph, 1);
 8039294:	fb0a 9606 	mla	r6, sl, r6, r9
 8039298:	f896 6025 	ldrb.w	r6, [r6, #37]	; 0x25
  switch (periph)
 803929c:	b946      	cbnz	r6, 80392b0 <TEST_PROTECTIONS_Run_SecUserMem+0x13c>
        __HAL_RCC_RNG_CLK_ENABLE();
 803929e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80392a0:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80392a4:	64fb      	str	r3, [r7, #76]	; 0x4c
 80392a6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80392a8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80392ac:	9303      	str	r3, [sp, #12]
 80392ae:	9b03      	ldr	r3, [sp, #12]
          status = TEST_ERROR;
 80392b0:	230a      	movs	r3, #10
          tmp_reg = *((__IO uint32_t *)aProtectTests[test_idx].address);
 80392b2:	6822      	ldr	r2, [r4, #0]
 80392b4:	9202      	str	r2, [sp, #8]
          if (tmp_reg != 0)
 80392b6:	9a02      	ldr	r2, [sp, #8]
 80392b8:	b90a      	cbnz	r2, 80392be <TEST_PROTECTIONS_Run_SecUserMem+0x14a>
        for (i = 0; i < 10; i++)
 80392ba:	3b01      	subs	r3, #1
 80392bc:	d1f9      	bne.n	80392b2 <TEST_PROTECTIONS_Run_SecUserMem+0x13e>
        if (tmp_reg != 0)
 80392be:	9b02      	ldr	r3, [sp, #8]
 80392c0:	b1b3      	cbz	r3, 80392f0 <TEST_PROTECTIONS_Run_SecUserMem+0x17c>
          printf(" value : %x ",(int)tmp_reg);
 80392c2:	9902      	ldr	r1, [sp, #8]
 80392c4:	4816      	ldr	r0, [pc, #88]	; (8039320 <TEST_PROTECTIONS_Run_SecUserMem+0x1ac>)
 80392c6:	f003 f9b3 	bl	803c630 <iprintf>
  switch (periph)
 80392ca:	2e00      	cmp	r6, #0
 80392cc:	d1ac      	bne.n	8039228 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
          status = TEST_ERROR;
 80392ce:	2602      	movs	r6, #2
        __HAL_RCC_RNG_CLK_DISABLE();
 80392d0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80392d2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80392d6:	64fb      	str	r3, [r7, #76]	; 0x4c
  } while (status == TEST_IN_PROGRESS) ;
 80392d8:	2e00      	cmp	r6, #0
 80392da:	f43f af59 	beq.w	8039190 <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
  if (status == TEST_ERROR)
 80392de:	b11e      	cbz	r6, 80392e8 <TEST_PROTECTIONS_Run_SecUserMem+0x174>
 80392e0:	e7a2      	b.n	8039228 <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        printf("\r\n TEST_PROTECTIONS_Run_SecUserMem : Passed");
 80392e2:	4810      	ldr	r0, [pc, #64]	; (8039324 <TEST_PROTECTIONS_Run_SecUserMem+0x1b0>)
 80392e4:	f003 f9a4 	bl	803c630 <iprintf>
    printf("\b\b\b\b\b\b\b\b");
 80392e8:	480f      	ldr	r0, [pc, #60]	; (8039328 <TEST_PROTECTIONS_Run_SecUserMem+0x1b4>)
 80392ea:	f003 f9a1 	bl	803c630 <iprintf>
 80392ee:	e755      	b.n	803919c <TEST_PROTECTIONS_Run_SecUserMem+0x28>
  switch (periph)
 80392f0:	2e00      	cmp	r6, #0
 80392f2:	f47f af4d 	bne.w	8039190 <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
 80392f6:	e7eb      	b.n	80392d0 <TEST_PROTECTIONS_Run_SecUserMem+0x15c>
 80392f8:	20000000 	.word	0x20000000
 80392fc:	dead0000 	.word	0xdead0000
 8039300:	40021000 	.word	0x40021000
 8039304:	0803e308 	.word	0x0803e308
 8039308:	0803e0e7 	.word	0x0803e0e7
 803930c:	0803e0ff 	.word	0x0803e0ff
 8039310:	0803e116 	.word	0x0803e116
 8039314:	0803e16b 	.word	0x0803e16b
 8039318:	0803e11c 	.word	0x0803e11c
 803931c:	0803e125 	.word	0x0803e125
 8039320:	0803e132 	.word	0x0803e132
 8039324:	0803e13f 	.word	0x0803e13f
 8039328:	0803e197 	.word	0x0803e197
 803932c:	0803e1a0 	.word	0x0803e1a0

08039330 <TEST_PROTECTIONS_Run>:
{
 8039330:	b570      	push	{r4, r5, r6, lr}
  uint8_t key = 0U;
 8039332:	2400      	movs	r4, #0
{
 8039334:	b088      	sub	sp, #32
  uint8_t key = 0U;
 8039336:	ad08      	add	r5, sp, #32
 8039338:	f805 4d19 	strb.w	r4, [r5, #-25]!
  TEST_PROTECTIONS_PrintTestingMenu();
 803933c:	f7ff ff02 	bl	8039144 <TEST_PROTECTIONS_PrintTestingMenu>
          printf("Invalid Number !\r");
 8039340:	4e26      	ldr	r6, [pc, #152]	; (80393dc <TEST_PROTECTIONS_Run+0xac>)
    key = 0U;
 8039342:	f88d 4007 	strb.w	r4, [sp, #7]
    COM_Flush();
 8039346:	f7ff fb41 	bl	80389cc <COM_Flush>
    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
 803934a:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 803934e:	2101      	movs	r1, #1
 8039350:	4628      	mov	r0, r5
 8039352:	f7ff fb33 	bl	80389bc <COM_Receive>
 8039356:	2800      	cmp	r0, #0
 8039358:	d1f3      	bne.n	8039342 <TEST_PROTECTIONS_Run+0x12>
      switch (key)
 803935a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 803935e:	2b32      	cmp	r3, #50	; 0x32
 8039360:	d008      	beq.n	8039374 <TEST_PROTECTIONS_Run+0x44>
 8039362:	2b78      	cmp	r3, #120	; 0x78
 8039364:	d031      	beq.n	80393ca <TEST_PROTECTIONS_Run+0x9a>
 8039366:	2b31      	cmp	r3, #49	; 0x31
 8039368:	d133      	bne.n	80393d2 <TEST_PROTECTIONS_Run+0xa2>
          TEST_PROTECTIONS_Run_SecUserMem();
 803936a:	f7ff ff03 	bl	8039174 <TEST_PROTECTIONS_Run_SecUserMem>
      TEST_PROTECTIONS_PrintTestingMenu();
 803936e:	f7ff fee9 	bl	8039144 <TEST_PROTECTIONS_PrintTestingMenu>
 8039372:	e7e6      	b.n	8039342 <TEST_PROTECTIONS_Run+0x12>
  region_cfg.region_nr = 2U;
 8039374:	2302      	movs	r3, #2
 8039376:	4a1a      	ldr	r2, [pc, #104]	; (80393e0 <TEST_PROTECTIONS_Run+0xb0>)
  region_cfg.region_limit = NS_DATA_LIMIT;
 8039378:	491a      	ldr	r1, [pc, #104]	; (80393e4 <TEST_PROTECTIONS_Run+0xb4>)
  region_cfg.region_nr = 2U;
 803937a:	e9cd 2302 	strd	r2, r3, [sp, #8]
  region_cfg.region_limit = NS_DATA_LIMIT;
 803937e:	4a1a      	ldr	r2, [pc, #104]	; (80393e8 <TEST_PROTECTIONS_Run+0xb8>)
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 8039380:	f88d 001d 	strb.w	r0, [sp, #29]
  region_cfg.region_limit = NS_DATA_LIMIT;
 8039384:	e9cd 1204 	strd	r1, r2, [sp, #16]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 8039388:	f88d 001e 	strb.w	r0, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_OK;
 803938c:	f88d 001c 	strb.w	r0, [sp, #28]
  mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg);
 8039390:	a903      	add	r1, sp, #12
 8039392:	a802      	add	r0, sp, #8
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 8039394:	9306      	str	r3, [sp, #24]
  mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg);
 8039396:	f7ff fe3f 	bl	8039018 <mpu_armv8m_region_enable>
  __ASM volatile ("cpsid i" : : : "memory");
 803939a:	b672      	cpsid	i
    *pt = WHILE_1_OPCODE;
 803939c:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80393a0:	f24e 72fe 	movw	r2, #59390	; 0xe7fe
 80393a4:	801a      	strh	r2, [r3, #0]
  __ASM volatile ("dsb 0xF":::"memory");
 80393a6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80393aa:	f3bf 8f6f 	isb	sy
    printf("\r\n Device ready for regression : \r\n");
 80393ae:	480f      	ldr	r0, [pc, #60]	; (80393ec <TEST_PROTECTIONS_Run+0xbc>)
 80393b0:	f003 f9b2 	bl	803c718 <puts>
    printf("\r\n - Connect STM32CubeProgrammer mode=HotPlug");
 80393b4:	480e      	ldr	r0, [pc, #56]	; (80393f0 <TEST_PROTECTIONS_Run+0xc0>)
 80393b6:	f003 f93b 	bl	803c630 <iprintf>
    printf("\r\n - Perform RDP Regression ");
 80393ba:	480e      	ldr	r0, [pc, #56]	; (80393f4 <TEST_PROTECTIONS_Run+0xc4>)
 80393bc:	f003 f938 	bl	803c630 <iprintf>
    printf("\r\n ");
 80393c0:	480d      	ldr	r0, [pc, #52]	; (80393f8 <TEST_PROTECTIONS_Run+0xc8>)
 80393c2:	f003 f935 	bl	803c630 <iprintf>
    nsfptr();
 80393c6:	4b0d      	ldr	r3, [pc, #52]	; (80393fc <TEST_PROTECTIONS_Run+0xcc>)
 80393c8:	4798      	blx	r3
      TEST_PROTECTIONS_PrintTestingMenu();
 80393ca:	f7ff febb 	bl	8039144 <TEST_PROTECTIONS_PrintTestingMenu>
}
 80393ce:	b008      	add	sp, #32
 80393d0:	bd70      	pop	{r4, r5, r6, pc}
          printf("Invalid Number !\r");
 80393d2:	4630      	mov	r0, r6
 80393d4:	f003 f92c 	bl	803c630 <iprintf>
          break;
 80393d8:	e7c9      	b.n	803936e <TEST_PROTECTIONS_Run+0x3e>
 80393da:	bf00      	nop
 80393dc:	0803dcdd 	.word	0x0803dcdd
 80393e0:	e000ed90 	.word	0xe000ed90
 80393e4:	20000020 	.word	0x20000020
 80393e8:	2002ffff 	.word	0x2002ffff
 80393ec:	0803e075 	.word	0x0803e075
 80393f0:	0803e098 	.word	0x0803e098
 80393f4:	0803e0c6 	.word	0x0803e0c6
 80393f8:	0803e0e3 	.word	0x0803e0e3
 80393fc:	20000001 	.word	0x20000001

08039400 <tfm_app_print_menu>:
  * @brief  Display the TEST TFM App Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
static void tfm_app_print_menu(void)
{
 8039400:	b508      	push	{r3, lr}
  printf("\r\n======================= TFM Examples Menu ===========================\r\n\n");
 8039402:	4816      	ldr	r0, [pc, #88]	; (803945c <tfm_app_print_menu+0x5c>)
 8039404:	f003 f988 	bl	803c718 <puts>
  printf("  TFM - Test All                                   --------------------- 0\r\n\n");
 8039408:	4815      	ldr	r0, [pc, #84]	; (8039460 <tfm_app_print_menu+0x60>)
 803940a:	f003 f985 	bl	803c718 <puts>
  printf("  TFM - Test AES-GCM                               --------------------- 1\r\n\n");
 803940e:	4815      	ldr	r0, [pc, #84]	; (8039464 <tfm_app_print_menu+0x64>)
 8039410:	f003 f982 	bl	803c718 <puts>
  printf("  TFM - Test AES-CBC                               --------------------- 2\r\n\n");
 8039414:	4814      	ldr	r0, [pc, #80]	; (8039468 <tfm_app_print_menu+0x68>)
 8039416:	f003 f97f 	bl	803c718 <puts>
  printf("  TFM - Test SST set UID                           --------------------- 3\r\n\n");
 803941a:	4814      	ldr	r0, [pc, #80]	; (803946c <tfm_app_print_menu+0x6c>)
 803941c:	f003 f97c 	bl	803c718 <puts>
  printf("  TFM - Test SST read / check UID                  --------------------- 4\r\n\n");
 8039420:	4813      	ldr	r0, [pc, #76]	; (8039470 <tfm_app_print_menu+0x70>)
 8039422:	f003 f979 	bl	803c718 <puts>
  printf("  TFM - Test SST remove UID                        --------------------- 5\r\n\n");
 8039426:	4813      	ldr	r0, [pc, #76]	; (8039474 <tfm_app_print_menu+0x74>)
 8039428:	f003 f976 	bl	803c718 <puts>
  printf("  TFM - Test EAT                                   --------------------- 6\r\n\n");
 803942c:	4812      	ldr	r0, [pc, #72]	; (8039478 <tfm_app_print_menu+0x78>)
 803942e:	f003 f973 	bl	803c718 <puts>
  printf("  TFM - Test ITS set UID                           --------------------- 7\r\n\n");
 8039432:	4812      	ldr	r0, [pc, #72]	; (803947c <tfm_app_print_menu+0x7c>)
 8039434:	f003 f970 	bl	803c718 <puts>
  printf("  TFM - Test ITS read / check UID                  --------------------- 8\r\n\n");
 8039438:	4811      	ldr	r0, [pc, #68]	; (8039480 <tfm_app_print_menu+0x80>)
 803943a:	f003 f96d 	bl	803c718 <puts>
  printf("  TFM - Test ITS remove UID                        --------------------- 9\r\n\n");
 803943e:	4811      	ldr	r0, [pc, #68]	; (8039484 <tfm_app_print_menu+0x84>)
 8039440:	f003 f96a 	bl	803c718 <puts>
  printf("  TFM - Test SHA224                                --------------------- a\r\n\n");
 8039444:	4810      	ldr	r0, [pc, #64]	; (8039488 <tfm_app_print_menu+0x88>)
 8039446:	f003 f967 	bl	803c718 <puts>
  printf("  TFM - Test SHA256                                --------------------- b\r\n\n");
 803944a:	4810      	ldr	r0, [pc, #64]	; (803948c <tfm_app_print_menu+0x8c>)
 803944c:	f003 f964 	bl	803c718 <puts>
  printf("  Exit TFM Examples Menu                           --------------------- x\r\n\n");
}
 8039450:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("  Exit TFM Examples Menu                           --------------------- x\r\n\n");
 8039454:	480e      	ldr	r0, [pc, #56]	; (8039490 <tfm_app_print_menu+0x90>)
 8039456:	f003 b95f 	b.w	803c718 <puts>
 803945a:	bf00      	nop
 803945c:	0803e4e7 	.word	0x0803e4e7
 8039460:	0803e531 	.word	0x0803e531
 8039464:	0803e57e 	.word	0x0803e57e
 8039468:	0803e5cb 	.word	0x0803e5cb
 803946c:	0803e618 	.word	0x0803e618
 8039470:	0803e665 	.word	0x0803e665
 8039474:	0803e6b2 	.word	0x0803e6b2
 8039478:	0803e6ff 	.word	0x0803e6ff
 803947c:	0803e74c 	.word	0x0803e74c
 8039480:	0803e799 	.word	0x0803e799
 8039484:	0803e7e6 	.word	0x0803e7e6
 8039488:	0803e833 	.word	0x0803e833
 803948c:	0803e880 	.word	0x0803e880
 8039490:	0803e8cd 	.word	0x0803e8cd

08039494 <tfm_sst_set_uid.isra.0>:
/**
  * @brief  Write in SST a TEST UID
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_sst_set_uid(struct test_result_t *ret)
 8039494:	b5f0      	push	{r4, r5, r6, r7, lr}
 8039496:	b08b      	sub	sp, #44	; 0x2c
{
  psa_ps_status_t status;
  const psa_ps_uid_t uid = TEST_UID;
  const psa_ps_create_flags_t flags = PSA_PS_FLAG_NONE;
  const uint32_t write_len = TEST_DATA_SIZE;
  const uint8_t write_data[] = TEST_DATA;
 8039498:	ac03      	add	r4, sp, #12
static void tfm_sst_set_uid(struct test_result_t *ret)
 803949a:	4606      	mov	r6, r0
 803949c:	4623      	mov	r3, r4
  const uint8_t write_data[] = TEST_DATA;
 803949e:	4a0d      	ldr	r2, [pc, #52]	; (80394d4 <tfm_sst_set_uid.isra.0+0x40>)
 80394a0:	f102 0718 	add.w	r7, r2, #24
 80394a4:	4625      	mov	r5, r4
 80394a6:	6810      	ldr	r0, [r2, #0]
 80394a8:	6851      	ldr	r1, [r2, #4]
 80394aa:	3208      	adds	r2, #8
 80394ac:	c503      	stmia	r5!, {r0, r1}
 80394ae:	42ba      	cmp	r2, r7
 80394b0:	462c      	mov	r4, r5
 80394b2:	d1f7      	bne.n	80394a4 <tfm_sst_set_uid.isra.0+0x10>
 80394b4:	8812      	ldrh	r2, [r2, #0]
  /* Set a UIDtime */
  status = psa_ps_set(uid, write_len, write_data, flags);
 80394b6:	2100      	movs	r1, #0
  const uint8_t write_data[] = TEST_DATA;
 80394b8:	802a      	strh	r2, [r5, #0]
  status = psa_ps_set(uid, write_len, write_data, flags);
 80394ba:	2200      	movs	r2, #0
 80394bc:	2002      	movs	r0, #2
 80394be:	9200      	str	r2, [sp, #0]
 80394c0:	2219      	movs	r2, #25
 80394c2:	f002 fc01 	bl	803bcc8 <psa_ps_set>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 80394c6:	3000      	adds	r0, #0
 80394c8:	bf18      	it	ne
 80394ca:	2001      	movne	r0, #1
 80394cc:	7030      	strb	r0, [r6, #0]
  return;
}
 80394ce:	b00b      	add	sp, #44	; 0x2c
 80394d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80394d2:	bf00      	nop
 80394d4:	0803e989 	.word	0x0803e989

080394d8 <tfm_sst_read_uid.isra.1>:
/**
  * @brief  Read ITS TEST UID and compare its value
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_sst_read_uid(struct test_result_t *ret)
 80394d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80394da:	b097      	sub	sp, #92	; 0x5c
{
  psa_ps_status_t status;
  const psa_ps_uid_t uid = TEST_UID;
  uint8_t read_data[] = TEST_READ_DATA ;
 80394dc:	aa0a      	add	r2, sp, #40	; 0x28
static void tfm_sst_read_uid(struct test_result_t *ret)
 80394de:	4605      	mov	r5, r0
 80394e0:	4616      	mov	r6, r2
  uint8_t read_data[] = TEST_READ_DATA ;
 80394e2:	4b19      	ldr	r3, [pc, #100]	; (8039548 <tfm_sst_read_uid.isra.1+0x70>)
 80394e4:	f103 0728 	add.w	r7, r3, #40	; 0x28
 80394e8:	4614      	mov	r4, r2
 80394ea:	6818      	ldr	r0, [r3, #0]
 80394ec:	6859      	ldr	r1, [r3, #4]
 80394ee:	3308      	adds	r3, #8
 80394f0:	c403      	stmia	r4!, {r0, r1}
 80394f2:	42bb      	cmp	r3, r7
 80394f4:	4622      	mov	r2, r4
 80394f6:	d1f7      	bne.n	80394e8 <tfm_sst_read_uid.isra.1+0x10>
  uint8_t expected_data[] = TEST_DATA;
 80394f8:	aa03      	add	r2, sp, #12
 80394fa:	4617      	mov	r7, r2
  uint8_t read_data[] = TEST_READ_DATA ;
 80394fc:	6818      	ldr	r0, [r3, #0]
 80394fe:	791b      	ldrb	r3, [r3, #4]
 8039500:	6020      	str	r0, [r4, #0]
 8039502:	7123      	strb	r3, [r4, #4]
  uint8_t expected_data[] = TEST_DATA;
 8039504:	4b11      	ldr	r3, [pc, #68]	; (803954c <tfm_sst_read_uid.isra.1+0x74>)
 8039506:	f103 0c18 	add.w	ip, r3, #24
 803950a:	4614      	mov	r4, r2
 803950c:	6818      	ldr	r0, [r3, #0]
 803950e:	6859      	ldr	r1, [r3, #4]
 8039510:	3308      	adds	r3, #8
 8039512:	c403      	stmia	r4!, {r0, r1}
 8039514:	4563      	cmp	r3, ip
 8039516:	4622      	mov	r2, r4
 8039518:	d1f7      	bne.n	803950a <tfm_sst_read_uid.isra.1+0x32>
 803951a:	881b      	ldrh	r3, [r3, #0]
  /* read UID */
  status = psa_ps_get(uid, 0, TEST_DATA_SIZE, read_data);
 803951c:	2200      	movs	r2, #0
  uint8_t expected_data[] = TEST_DATA;
 803951e:	8023      	strh	r3, [r4, #0]
  status = psa_ps_get(uid, 0, TEST_DATA_SIZE, read_data);
 8039520:	2002      	movs	r0, #2
 8039522:	9600      	str	r6, [sp, #0]
 8039524:	2319      	movs	r3, #25
 8039526:	2100      	movs	r1, #0
 8039528:	f002 fbf9 	bl	803bd1e <psa_ps_get>
  if ((status == PSA_SUCCESS) && (!memcmp(read_data, expected_data, TEST_DATA_SIZE)))
 803952c:	b940      	cbnz	r0, 8039540 <tfm_sst_read_uid.isra.1+0x68>
 803952e:	2219      	movs	r2, #25
 8039530:	4639      	mov	r1, r7
 8039532:	4630      	mov	r0, r6
 8039534:	f003 f85a 	bl	803c5ec <memcmp>
 8039538:	b910      	cbnz	r0, 8039540 <tfm_sst_read_uid.isra.1+0x68>
  {
    ret->val = TEST_PASSED;
 803953a:	7028      	strb	r0, [r5, #0]
  else
  {
    ret->val = TEST_FAILED;
  }
  return;
}
 803953c:	b017      	add	sp, #92	; 0x5c
 803953e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret->val = TEST_FAILED;
 8039540:	2301      	movs	r3, #1
 8039542:	702b      	strb	r3, [r5, #0]
 8039544:	e7fa      	b.n	803953c <tfm_sst_read_uid.isra.1+0x64>
 8039546:	bf00      	nop
 8039548:	0803e95c 	.word	0x0803e95c
 803954c:	0803e989 	.word	0x0803e989

08039550 <tfm_its_set_uid.isra.3>:
/**
  * @brief  Write in ITS a TEST UID
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_its_set_uid(struct test_result_t *ret)
 8039550:	b5f0      	push	{r4, r5, r6, r7, lr}
 8039552:	b08b      	sub	sp, #44	; 0x2c
{
  psa_ps_status_t status;
  const psa_ps_uid_t uid = TEST_UID;
  const psa_ps_create_flags_t flags = PSA_PS_FLAG_NONE;
  const uint32_t write_len = TEST_DATA_SIZE;
  const uint8_t write_data[] = TEST_DATA;
 8039554:	ac03      	add	r4, sp, #12
static void tfm_its_set_uid(struct test_result_t *ret)
 8039556:	4606      	mov	r6, r0
 8039558:	4623      	mov	r3, r4
  const uint8_t write_data[] = TEST_DATA;
 803955a:	4a0d      	ldr	r2, [pc, #52]	; (8039590 <tfm_its_set_uid.isra.3+0x40>)
 803955c:	f102 0718 	add.w	r7, r2, #24
 8039560:	4625      	mov	r5, r4
 8039562:	6810      	ldr	r0, [r2, #0]
 8039564:	6851      	ldr	r1, [r2, #4]
 8039566:	3208      	adds	r2, #8
 8039568:	c503      	stmia	r5!, {r0, r1}
 803956a:	42ba      	cmp	r2, r7
 803956c:	462c      	mov	r4, r5
 803956e:	d1f7      	bne.n	8039560 <tfm_its_set_uid.isra.3+0x10>
 8039570:	8812      	ldrh	r2, [r2, #0]
  /* Set a UIDtime */
  status = psa_its_set(uid, write_len, write_data, flags);
 8039572:	2100      	movs	r1, #0
  const uint8_t write_data[] = TEST_DATA;
 8039574:	802a      	strh	r2, [r5, #0]
  status = psa_its_set(uid, write_len, write_data, flags);
 8039576:	2200      	movs	r2, #0
 8039578:	2002      	movs	r0, #2
 803957a:	9200      	str	r2, [sp, #0]
 803957c:	2219      	movs	r2, #25
 803957e:	f002 faf8 	bl	803bb72 <psa_its_set>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 8039582:	3000      	adds	r0, #0
 8039584:	bf18      	it	ne
 8039586:	2001      	movne	r0, #1
 8039588:	7030      	strb	r0, [r6, #0]
  return;
}
 803958a:	b00b      	add	sp, #44	; 0x2c
 803958c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 803958e:	bf00      	nop
 8039590:	0803e989 	.word	0x0803e989

08039594 <tfm_its_read_uid.isra.4>:
/**
  * @brief  Read TEST UID and compare its value
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_its_read_uid(struct test_result_t *ret)
 8039594:	b5f0      	push	{r4, r5, r6, r7, lr}
 8039596:	b097      	sub	sp, #92	; 0x5c
{
  psa_ps_status_t status;
  const psa_ps_uid_t uid = TEST_UID;
  size_t data_len;
  uint8_t read_data[] = TEST_READ_DATA ;
 8039598:	aa0a      	add	r2, sp, #40	; 0x28
static void tfm_its_read_uid(struct test_result_t *ret)
 803959a:	4605      	mov	r5, r0
 803959c:	4616      	mov	r6, r2
  uint8_t read_data[] = TEST_READ_DATA ;
 803959e:	4b1b      	ldr	r3, [pc, #108]	; (803960c <tfm_its_read_uid.isra.4+0x78>)
 80395a0:	f103 0728 	add.w	r7, r3, #40	; 0x28
 80395a4:	4614      	mov	r4, r2
 80395a6:	6818      	ldr	r0, [r3, #0]
 80395a8:	6859      	ldr	r1, [r3, #4]
 80395aa:	3308      	adds	r3, #8
 80395ac:	c403      	stmia	r4!, {r0, r1}
 80395ae:	42bb      	cmp	r3, r7
 80395b0:	4622      	mov	r2, r4
 80395b2:	d1f7      	bne.n	80395a4 <tfm_its_read_uid.isra.4+0x10>
  uint8_t expected_data[] = TEST_DATA;
 80395b4:	aa03      	add	r2, sp, #12
 80395b6:	4617      	mov	r7, r2
  uint8_t read_data[] = TEST_READ_DATA ;
 80395b8:	6818      	ldr	r0, [r3, #0]
 80395ba:	791b      	ldrb	r3, [r3, #4]
 80395bc:	6020      	str	r0, [r4, #0]
 80395be:	7123      	strb	r3, [r4, #4]
  uint8_t expected_data[] = TEST_DATA;
 80395c0:	4b13      	ldr	r3, [pc, #76]	; (8039610 <tfm_its_read_uid.isra.4+0x7c>)
 80395c2:	f103 0c18 	add.w	ip, r3, #24
 80395c6:	4614      	mov	r4, r2
 80395c8:	6818      	ldr	r0, [r3, #0]
 80395ca:	6859      	ldr	r1, [r3, #4]
 80395cc:	3308      	adds	r3, #8
 80395ce:	c403      	stmia	r4!, {r0, r1}
 80395d0:	4563      	cmp	r3, ip
 80395d2:	4622      	mov	r2, r4
 80395d4:	d1f7      	bne.n	80395c6 <tfm_its_read_uid.isra.4+0x32>
 80395d6:	881b      	ldrh	r3, [r3, #0]
  /* read UID */
  status = psa_its_get(uid, 0, TEST_DATA_SIZE, read_data, &data_len);
 80395d8:	2200      	movs	r2, #0
  uint8_t expected_data[] = TEST_DATA;
 80395da:	8023      	strh	r3, [r4, #0]
  status = psa_its_get(uid, 0, TEST_DATA_SIZE, read_data, &data_len);
 80395dc:	ab02      	add	r3, sp, #8
 80395de:	e9cd 6300 	strd	r6, r3, [sp]
 80395e2:	2002      	movs	r0, #2
 80395e4:	2319      	movs	r3, #25
 80395e6:	2100      	movs	r1, #0
 80395e8:	f002 faec 	bl	803bbc4 <psa_its_get>
  if ((status == PSA_SUCCESS) && (data_len == TEST_DATA_SIZE)
 80395ec:	b950      	cbnz	r0, 8039604 <tfm_its_read_uid.isra.4+0x70>
 80395ee:	9a02      	ldr	r2, [sp, #8]
 80395f0:	2a19      	cmp	r2, #25
 80395f2:	d107      	bne.n	8039604 <tfm_its_read_uid.isra.4+0x70>
      && (!memcmp(read_data, expected_data, TEST_DATA_SIZE)))
 80395f4:	4639      	mov	r1, r7
 80395f6:	4630      	mov	r0, r6
 80395f8:	f002 fff8 	bl	803c5ec <memcmp>
 80395fc:	b910      	cbnz	r0, 8039604 <tfm_its_read_uid.isra.4+0x70>
  {
    ret->val = TEST_PASSED;
 80395fe:	7028      	strb	r0, [r5, #0]
  else
  {
    ret->val = TEST_FAILED;
  }
  return;
}
 8039600:	b017      	add	sp, #92	; 0x5c
 8039602:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret->val = TEST_FAILED;
 8039604:	2301      	movs	r3, #1
 8039606:	702b      	strb	r3, [r5, #0]
 8039608:	e7fa      	b.n	8039600 <tfm_its_read_uid.isra.4+0x6c>
 803960a:	bf00      	nop
 803960c:	0803e95c 	.word	0x0803e95c
 8039610:	0803e989 	.word	0x0803e989

08039614 <dump_eat_token>:
void dump_eat_token(struct q_useful_buf_c *token)
{
 8039614:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int32_t len = token->len;
  int32_t n_item_per_line;
  int32_t i, index = 0;
  uint8_t *byte = (uint8_t *)token->ptr;
 8039618:	e9d0 8700 	ldrd	r8, r7, [r0]
  int32_t i, index = 0;
 803961c:	2400      	movs	r4, #0
  while (index < len)
  {
    n_item_per_line = (len-index) >= 20 ? 20 : (len-index);
    for (i = 0; i < n_item_per_line; i++)
    {
      printf("%2.2x", byte[index + i]);
 803961e:	f8df 9044 	ldr.w	r9, [pc, #68]	; 8039664 <dump_eat_token+0x50>
    }
    printf("\r\n");
 8039622:	f8df a03c 	ldr.w	sl, [pc, #60]	; 8039660 <dump_eat_token+0x4c>
  while (index < len)
 8039626:	42bc      	cmp	r4, r7
 8039628:	db04      	blt.n	8039634 <dump_eat_token+0x20>
    index += n_item_per_line;

  }
  printf("\r\n");

}
 803962a:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  printf("\r\n");
 803962e:	480c      	ldr	r0, [pc, #48]	; (8039660 <dump_eat_token+0x4c>)
 8039630:	f003 b872 	b.w	803c718 <puts>
    n_item_per_line = (len-index) >= 20 ? 20 : (len-index);
 8039634:	1b3d      	subs	r5, r7, r4
 8039636:	2d14      	cmp	r5, #20
 8039638:	eb08 0604 	add.w	r6, r8, r4
 803963c:	bfa8      	it	ge
 803963e:	2514      	movge	r5, #20
 8039640:	46b3      	mov	fp, r6
    for (i = 0; i < n_item_per_line; i++)
 8039642:	eba6 030b 	sub.w	r3, r6, fp
 8039646:	429d      	cmp	r5, r3
 8039648:	dc04      	bgt.n	8039654 <dump_eat_token+0x40>
    printf("\r\n");
 803964a:	4650      	mov	r0, sl
 803964c:	f003 f864 	bl	803c718 <puts>
    index += n_item_per_line;
 8039650:	442c      	add	r4, r5
 8039652:	e7e8      	b.n	8039626 <dump_eat_token+0x12>
      printf("%2.2x", byte[index + i]);
 8039654:	f816 1b01 	ldrb.w	r1, [r6], #1
 8039658:	4648      	mov	r0, r9
 803965a:	f002 ffe9 	bl	803c630 <iprintf>
 803965e:	e7f0      	b.n	8039642 <dump_eat_token+0x2e>
 8039660:	0803df20 	.word	0x0803df20
 8039664:	0803e3a8 	.word	0x0803e3a8

08039668 <tfm_eat_test_circuit_sig.isra.6.constprop.7>:
  * @brief  request eat short cicuit, check result and
  * display response result buffer.
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_eat_test_circuit_sig(uint32_t encode_options, struct test_result_t *ret)
 8039668:	b5f0      	push	{r4, r5, r6, r7, lr}
  Q_USEFUL_BUF_MAKE_STACK_UB(token_storage, ATTEST_TOKEN_MAX_SIZE);
  struct q_useful_buf_c completed_token;
  struct q_useful_buf_c tmp;

  /* -- Make a token with all the claims -- */
  tmp = TOKEN_TEST_VALUE_NONCE;
 803966a:	2440      	movs	r4, #64	; 0x40
static void tfm_eat_test_circuit_sig(uint32_t encode_options, struct test_result_t *ret)
 803966c:	f5ad 7d31 	sub.w	sp, sp, #708	; 0x2c4
  tmp = TOKEN_TEST_VALUE_NONCE;
 8039670:	ab10      	add	r3, sp, #64	; 0x40
 8039672:	4622      	mov	r2, r4
 8039674:	2100      	movs	r1, #0
static void tfm_eat_test_circuit_sig(uint32_t encode_options, struct test_result_t *ret)
 8039676:	4606      	mov	r6, r0
  tmp = TOKEN_TEST_VALUE_NONCE;
 8039678:	4618      	mov	r0, r3
 803967a:	f002 ffd1 	bl	803c620 <memset>
 803967e:	e9cd 0406 	strd	r0, r4, [sp, #24]
  printf("token request value :\r\n");
 8039682:	4823      	ldr	r0, [pc, #140]	; (8039710 <tfm_eat_test_circuit_sig.isra.6.constprop.7+0xa8>)
 8039684:	f003 f848 	bl	803c718 <puts>
  dump_eat_token(&tmp);
 8039688:	a806      	add	r0, sp, #24
 803968a:	f7ff ffc3 	bl	8039614 <dump_eat_token>
 803968e:	e9dd 5406 	ldrd	r5, r4, [sp, #24]
  enum psa_attest_err_t return_value;
  uint32_t completed_token_len;
  struct q_useful_buf_c        actual_nonce;
  Q_USEFUL_BUF_MAKE_STACK_UB(actual_nonce_storage, 64);

  if (nonce.len == 64 && q_useful_buf_is_value(nonce, 0))
 8039692:	2c40      	cmp	r4, #64	; 0x40
 8039694:	d11c      	bne.n	80396d0 <tfm_eat_test_circuit_sig.isra.6.constprop.7+0x68>
 8039696:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
 803969a:	ab0a      	add	r3, sp, #40	; 0x28
}

static inline size_t q_useful_buf_is_value(const struct q_useful_buf_c buf,
                                           uint8_t uValue)
{
    return UsefulBuf_IsValue(buf, uValue);
 803969c:	2200      	movs	r2, #0
 803969e:	e893 0003 	ldmia.w	r3, {r0, r1}
 80396a2:	f001 feeb 	bl	803b47c <UsefulBuf_IsValue>
 80396a6:	b198      	cbz	r0, 80396d0 <tfm_eat_test_circuit_sig.isra.6.constprop.7+0x68>
 80396a8:	e9cd 540e 	strd	r5, r4, [sp, #56]	; 0x38
 80396ac:	af20      	add	r7, sp, #128	; 0x80
 80396ae:	ab0e      	add	r3, sp, #56	; 0x38
}


static inline UsefulBufC UsefulBuf_Copy(UsefulBuf Dest, const UsefulBufC Src)
{
   return UsefulBuf_CopyOffset(Dest, 0, Src);
 80396b0:	e893 0003 	ldmia.w	r3, {r0, r1}
 80396b4:	e9cd 740c 	strd	r7, r4, [sp, #48]	; 0x30
 80396b8:	e88d 0003 	stmia.w	sp, {r0, r1}
 80396bc:	aa0c      	add	r2, sp, #48	; 0x30
 80396be:	2300      	movs	r3, #0
 80396c0:	ca06      	ldmia	r2, {r1, r2}
 80396c2:	a808      	add	r0, sp, #32
 80396c4:	f001 febd 	bl	803b442 <UsefulBuf_CopyOffset>
    return UsefulBuf_Copy(dest, src);
 80396c8:	e9dd 5408 	ldrd	r5, r4, [sp, #32]
  {
    /* Go into special option-packed nonce mode */
    actual_nonce = q_useful_buf_copy(actual_nonce_storage, nonce);
    /* Use memcpy as it always works and avoids type punning */
    memcpy((uint8_t *)actual_nonce_storage.ptr,
 80396cc:	2300      	movs	r3, #0
 80396ce:	603b      	str	r3, [r7, #0]
  else
  {
    actual_nonce = nonce;
  }

  completed_token_len = (uint32_t)buffer.len;
 80396d0:	f44f 7300 	mov.w	r3, #512	; 0x200
  return_value = psa_initial_attest_get_token(actual_nonce.ptr,
 80396d4:	af30      	add	r7, sp, #192	; 0xc0
  completed_token_len = (uint32_t)buffer.len;
 80396d6:	9303      	str	r3, [sp, #12]
  return_value = psa_initial_attest_get_token(actual_nonce.ptr,
 80396d8:	4621      	mov	r1, r4
 80396da:	ab03      	add	r3, sp, #12
 80396dc:	463a      	mov	r2, r7
 80396de:	4628      	mov	r0, r5
 80396e0:	f002 fa22 	bl	803bb28 <psa_initial_attest_get_token>
                                              (uint32_t)actual_nonce.len,
                                              buffer.ptr,
                                              &completed_token_len);

  *completed_token = (struct q_useful_buf_c)
 80396e4:	9b03      	ldr	r3, [sp, #12]
  if (status == PSA_ATTEST_ERR_SUCCESS)
 80396e6:	4601      	mov	r1, r0
  *completed_token = (struct q_useful_buf_c)
 80396e8:	e9cd 7304 	strd	r7, r3, [sp, #16]
  if (status == PSA_ATTEST_ERR_SUCCESS)
 80396ec:	b948      	cbnz	r0, 8039702 <tfm_eat_test_circuit_sig.isra.6.constprop.7+0x9a>
    ret->val = TEST_PASSED;
 80396ee:	7030      	strb	r0, [r6, #0]
    printf("token response value :\r\n");
 80396f0:	4808      	ldr	r0, [pc, #32]	; (8039714 <tfm_eat_test_circuit_sig.isra.6.constprop.7+0xac>)
 80396f2:	f003 f811 	bl	803c718 <puts>
    dump_eat_token(&completed_token);
 80396f6:	a804      	add	r0, sp, #16
 80396f8:	f7ff ff8c 	bl	8039614 <dump_eat_token>
}
 80396fc:	f50d 7d31 	add.w	sp, sp, #708	; 0x2c4
 8039700:	bdf0      	pop	{r4, r5, r6, r7, pc}
    printf("failed status %d\r\n", status);
 8039702:	4805      	ldr	r0, [pc, #20]	; (8039718 <tfm_eat_test_circuit_sig.isra.6.constprop.7+0xb0>)
 8039704:	f002 ff94 	bl	803c630 <iprintf>
    ret->val = TEST_FAILED;
 8039708:	2301      	movs	r3, #1
 803970a:	7033      	strb	r3, [r6, #0]
 803970c:	e7f6      	b.n	80396fc <tfm_eat_test_circuit_sig.isra.6.constprop.7+0x94>
 803970e:	bf00      	nop
 8039710:	0803e91a 	.word	0x0803e91a
 8039714:	0803e931 	.word	0x0803e931
 8039718:	0803e949 	.word	0x0803e949

0803971c <tfm_app_menu>:
  uint8_t key = 0;
 803971c:	2300      	movs	r3, #0
{
 803971e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8039722:	b087      	sub	sp, #28
  uint8_t key = 0;
 8039724:	f88d 3007 	strb.w	r3, [sp, #7]
  tfm_app_print_menu();
 8039728:	f7ff fe6a 	bl	8039400 <tfm_app_print_menu>
          printf("EAT normal circuit sig test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 803972c:	4db2      	ldr	r5, [pc, #712]	; (80399f8 <tfm_app_menu+0x2dc>)
 803972e:	4eb3      	ldr	r6, [pc, #716]	; (80399fc <tfm_app_menu+0x2e0>)
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_GCM, &ret);
 8039730:	f8df 9310 	ldr.w	r9, [pc, #784]	; 8039a44 <tfm_app_menu+0x328>
    key = 0U;
 8039734:	2400      	movs	r4, #0
 8039736:	f88d 4007 	strb.w	r4, [sp, #7]
    COM_Flush();
 803973a:	f7ff f947 	bl	80389cc <COM_Flush>
    if (COM_Receive(&key, 1U, COM_UART_TIMEOUT_MAX) == HAL_OK)
 803973e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8039742:	2101      	movs	r1, #1
 8039744:	f10d 0007 	add.w	r0, sp, #7
 8039748:	f7ff f938 	bl	80389bc <COM_Receive>
 803974c:	2800      	cmp	r0, #0
 803974e:	d1f2      	bne.n	8039736 <tfm_app_menu+0x1a>
      switch (key)
 8039750:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8039754:	2b36      	cmp	r3, #54	; 0x36
 8039756:	f000 8191 	beq.w	8039a7c <tfm_app_menu+0x360>
 803975a:	d824      	bhi.n	80397a6 <tfm_app_menu+0x8a>
 803975c:	2b32      	cmp	r3, #50	; 0x32
 803975e:	f000 813a 	beq.w	80399d6 <tfm_app_menu+0x2ba>
 8039762:	d808      	bhi.n	8039776 <tfm_app_menu+0x5a>
 8039764:	2b30      	cmp	r3, #48	; 0x30
 8039766:	d045      	beq.n	80397f4 <tfm_app_menu+0xd8>
 8039768:	2b31      	cmp	r3, #49	; 0x31
 803976a:	f000 8122 	beq.w	80399b2 <tfm_app_menu+0x296>
          printf("Invalid Number !\r");
 803976e:	48a4      	ldr	r0, [pc, #656]	; (8039a00 <tfm_app_menu+0x2e4>)
 8039770:	f002 ff5e 	bl	803c630 <iprintf>
 8039774:	e11a      	b.n	80399ac <tfm_app_menu+0x290>
      switch (key)
 8039776:	2b34      	cmp	r3, #52	; 0x34
 8039778:	f04f 0301 	mov.w	r3, #1
 803977c:	f000 8171 	beq.w	8039a62 <tfm_app_menu+0x346>
 8039780:	f240 8162 	bls.w	8039a48 <tfm_app_menu+0x32c>
  status = psa_ps_remove(uid);
 8039784:	2002      	movs	r0, #2
 8039786:	2100      	movs	r1, #0
          ret.val = TEST_FAILED;
 8039788:	f88d 3008 	strb.w	r3, [sp, #8]
  status = psa_ps_remove(uid);
 803978c:	f002 faf3 	bl	803bd76 <psa_ps_remove>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 8039790:	2800      	cmp	r0, #0
 8039792:	bf12      	itee	ne
 8039794:	2301      	movne	r3, #1
 8039796:	2300      	moveq	r3, #0
          printf("SST remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039798:	4629      	moveq	r1, r5
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 803979a:	f88d 3008 	strb.w	r3, [sp, #8]
          printf("SST remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 803979e:	bf18      	it	ne
 80397a0:	4631      	movne	r1, r6
 80397a2:	4898      	ldr	r0, [pc, #608]	; (8039a04 <tfm_app_menu+0x2e8>)
 80397a4:	e114      	b.n	80399d0 <tfm_app_menu+0x2b4>
      switch (key)
 80397a6:	2b39      	cmp	r3, #57	; 0x39
 80397a8:	f000 817d 	beq.w	8039aa6 <tfm_app_menu+0x38a>
 80397ac:	d80b      	bhi.n	80397c6 <tfm_app_menu+0xaa>
 80397ae:	2b37      	cmp	r3, #55	; 0x37
 80397b0:	f000 8172 	beq.w	8039a98 <tfm_app_menu+0x37c>
 80397b4:	2b38      	cmp	r3, #56	; 0x38
 80397b6:	d1da      	bne.n	803976e <tfm_app_menu+0x52>
          ret.val = TEST_FAILED;
 80397b8:	2301      	movs	r3, #1
 80397ba:	a806      	add	r0, sp, #24
 80397bc:	f800 3d10 	strb.w	r3, [r0, #-16]!
          tfm_its_read_uid(&ret);
 80397c0:	f7ff fee8 	bl	8039594 <tfm_its_read_uid.isra.4>
 80397c4:	e152      	b.n	8039a6c <tfm_app_menu+0x350>
      switch (key)
 80397c6:	2b62      	cmp	r3, #98	; 0x62
 80397c8:	f000 8175 	beq.w	8039ab6 <tfm_app_menu+0x39a>
 80397cc:	2b78      	cmp	r3, #120	; 0x78
 80397ce:	f000 8181 	beq.w	8039ad4 <tfm_app_menu+0x3b8>
 80397d2:	2b61      	cmp	r3, #97	; 0x61
 80397d4:	d1cb      	bne.n	803976e <tfm_app_menu+0x52>
          ret.val = TEST_FAILED;
 80397d6:	2301      	movs	r3, #1
 80397d8:	a906      	add	r1, sp, #24
 80397da:	f801 3d10 	strb.w	r3, [r1, #-16]!
          psa_hash_test(PSA_ALG_SHA_224, &ret);
 80397de:	488a      	ldr	r0, [pc, #552]	; (8039a08 <tfm_app_menu+0x2ec>)
 80397e0:	f002 fcd2 	bl	803c188 <psa_hash_test>
          printf("SHA224 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80397e4:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80397e8:	4888      	ldr	r0, [pc, #544]	; (8039a0c <tfm_app_menu+0x2f0>)
 80397ea:	2900      	cmp	r1, #0
 80397ec:	bf0c      	ite	eq
 80397ee:	4629      	moveq	r1, r5
 80397f0:	4631      	movne	r1, r6
 80397f2:	e0ed      	b.n	80399d0 <tfm_app_menu+0x2b4>
          ret.val = TEST_FAILED;
 80397f4:	f04f 0801 	mov.w	r8, #1
 80397f8:	af06      	add	r7, sp, #24
 80397fa:	f807 8d10 	strb.w	r8, [r7, #-16]!
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_GCM, &ret);
 80397fe:	463a      	mov	r2, r7
 8039800:	4649      	mov	r1, r9
 8039802:	4883      	ldr	r0, [pc, #524]	; (8039a10 <tfm_app_menu+0x2f4>)
 8039804:	f002 fd64 	bl	803c2d0 <psa_aead_test>
          printf("AES GCM test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039808:	f89d 1008 	ldrb.w	r1, [sp, #8]
 803980c:	4881      	ldr	r0, [pc, #516]	; (8039a14 <tfm_app_menu+0x2f8>)
 803980e:	2900      	cmp	r1, #0
 8039810:	bf0c      	ite	eq
 8039812:	4629      	moveq	r1, r5
 8039814:	4631      	movne	r1, r6
 8039816:	f002 ff0b 	bl	803c630 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 803981a:	f89d 4008 	ldrb.w	r4, [sp, #8]
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
 803981e:	463a      	mov	r2, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039820:	fab4 f484 	clz	r4, r4
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
 8039824:	497c      	ldr	r1, [pc, #496]	; (8039a18 <tfm_app_menu+0x2fc>)
 8039826:	487a      	ldr	r0, [pc, #488]	; (8039a10 <tfm_app_menu+0x2f4>)
          ret.val = TEST_FAILED;
 8039828:	f88d 8008 	strb.w	r8, [sp, #8]
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
 803982c:	f002 fac8 	bl	803bdc0 <psa_cipher_test>
          printf("AES CBC test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039830:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039834:	4879      	ldr	r0, [pc, #484]	; (8039a1c <tfm_app_menu+0x300>)
 8039836:	2900      	cmp	r1, #0
 8039838:	bf0c      	ite	eq
 803983a:	4629      	moveq	r1, r5
 803983c:	4631      	movne	r1, r6
 803983e:	f002 fef7 	bl	803c630 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039842:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039846:	0964      	lsrs	r4, r4, #5
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039848:	2b00      	cmp	r3, #0
 803984a:	bf08      	it	eq
 803984c:	3401      	addeq	r4, #1
          tfm_sst_set_uid(&ret);
 803984e:	4638      	mov	r0, r7
 8039850:	f7ff fe20 	bl	8039494 <tfm_sst_set_uid.isra.0>
          printf("SST set UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039854:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039858:	4871      	ldr	r0, [pc, #452]	; (8039a20 <tfm_app_menu+0x304>)
 803985a:	2900      	cmp	r1, #0
 803985c:	bf0c      	ite	eq
 803985e:	4629      	moveq	r1, r5
 8039860:	4631      	movne	r1, r6
 8039862:	f002 fee5 	bl	803c630 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039866:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tfm_sst_read_uid(&ret);
 803986a:	4638      	mov	r0, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 803986c:	2b00      	cmp	r3, #0
 803986e:	bf08      	it	eq
 8039870:	3401      	addeq	r4, #1
          tfm_sst_read_uid(&ret);
 8039872:	f7ff fe31 	bl	80394d8 <tfm_sst_read_uid.isra.1>
          printf("SST read / check UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039876:	f89d 1008 	ldrb.w	r1, [sp, #8]
 803987a:	486a      	ldr	r0, [pc, #424]	; (8039a24 <tfm_app_menu+0x308>)
 803987c:	2900      	cmp	r1, #0
 803987e:	bf0c      	ite	eq
 8039880:	4629      	moveq	r1, r5
 8039882:	4631      	movne	r1, r6
 8039884:	f002 fed4 	bl	803c630 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039888:	f89d 3008 	ldrb.w	r3, [sp, #8]
  status = psa_ps_remove(uid);
 803988c:	2100      	movs	r1, #0
 803988e:	2002      	movs	r0, #2
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039890:	2b00      	cmp	r3, #0
 8039892:	bf08      	it	eq
 8039894:	3401      	addeq	r4, #1
  status = psa_ps_remove(uid);
 8039896:	f002 fa6e 	bl	803bd76 <psa_ps_remove>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 803989a:	2800      	cmp	r0, #0
 803989c:	bf13      	iteet	ne
 803989e:	4643      	movne	r3, r8
 80398a0:	2300      	moveq	r3, #0
          printf("SST remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80398a2:	4629      	moveq	r1, r5
 80398a4:	4631      	movne	r1, r6
 80398a6:	4857      	ldr	r0, [pc, #348]	; (8039a04 <tfm_app_menu+0x2e8>)
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 80398a8:	f88d 3008 	strb.w	r3, [sp, #8]
          printf("SST remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80398ac:	f002 fec0 	bl	803c630 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80398b0:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tfm_eat_test_circuit_sig(TOKEN_OPT_NORMAL_CIRCUIT_SIGN, &ret);
 80398b4:	4638      	mov	r0, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80398b6:	2b00      	cmp	r3, #0
 80398b8:	bf08      	it	eq
 80398ba:	3401      	addeq	r4, #1
          ret.val = TEST_FAILED;
 80398bc:	f88d 8008 	strb.w	r8, [sp, #8]
          tfm_eat_test_circuit_sig(TOKEN_OPT_NORMAL_CIRCUIT_SIGN, &ret);
 80398c0:	f7ff fed2 	bl	8039668 <tfm_eat_test_circuit_sig.isra.6.constprop.7>
          printf("EAT normal circuit sig test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80398c4:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80398c8:	4857      	ldr	r0, [pc, #348]	; (8039a28 <tfm_app_menu+0x30c>)
 80398ca:	2900      	cmp	r1, #0
 80398cc:	bf0c      	ite	eq
 80398ce:	4629      	moveq	r1, r5
 80398d0:	4631      	movne	r1, r6
 80398d2:	f002 fead 	bl	803c630 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80398d6:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tfm_its_set_uid(&ret);
 80398da:	4638      	mov	r0, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80398dc:	2b00      	cmp	r3, #0
 80398de:	bf08      	it	eq
 80398e0:	3401      	addeq	r4, #1
          tfm_its_set_uid(&ret);
 80398e2:	f7ff fe35 	bl	8039550 <tfm_its_set_uid.isra.3>
          printf("ITS set UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80398e6:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80398ea:	4850      	ldr	r0, [pc, #320]	; (8039a2c <tfm_app_menu+0x310>)
 80398ec:	2900      	cmp	r1, #0
 80398ee:	bf0c      	ite	eq
 80398f0:	4629      	moveq	r1, r5
 80398f2:	4631      	movne	r1, r6
 80398f4:	f002 fe9c 	bl	803c630 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80398f8:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tfm_its_read_uid(&ret);
 80398fc:	4638      	mov	r0, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 80398fe:	2b00      	cmp	r3, #0
 8039900:	bf08      	it	eq
 8039902:	3401      	addeq	r4, #1
          tfm_its_read_uid(&ret);
 8039904:	f7ff fe46 	bl	8039594 <tfm_its_read_uid.isra.4>
          printf("ITS read / check UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039908:	f89d 1008 	ldrb.w	r1, [sp, #8]
 803990c:	4848      	ldr	r0, [pc, #288]	; (8039a30 <tfm_app_menu+0x314>)
 803990e:	2900      	cmp	r1, #0
 8039910:	bf0c      	ite	eq
 8039912:	4629      	moveq	r1, r5
 8039914:	4631      	movne	r1, r6
 8039916:	f002 fe8b 	bl	803c630 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 803991a:	f89d 3008 	ldrb.w	r3, [sp, #8]
  status = psa_its_remove(uid);
 803991e:	2100      	movs	r1, #0
 8039920:	2002      	movs	r0, #2
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039922:	2b00      	cmp	r3, #0
 8039924:	bf08      	it	eq
 8039926:	3401      	addeq	r4, #1
  status = psa_its_remove(uid);
 8039928:	f002 f97e 	bl	803bc28 <psa_its_remove>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 803992c:	2800      	cmp	r0, #0
 803992e:	bf13      	iteet	ne
 8039930:	4643      	movne	r3, r8
 8039932:	2300      	moveq	r3, #0
          printf("ITS remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039934:	4629      	moveq	r1, r5
 8039936:	4631      	movne	r1, r6
 8039938:	483e      	ldr	r0, [pc, #248]	; (8039a34 <tfm_app_menu+0x318>)
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
 803993a:	f88d 3008 	strb.w	r3, [sp, #8]
          printf("ITS remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 803993e:	f002 fe77 	bl	803c630 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039942:	f89d 3008 	ldrb.w	r3, [sp, #8]
          psa_hash_test(PSA_ALG_SHA_224, &ret);
 8039946:	4639      	mov	r1, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039948:	2b00      	cmp	r3, #0
 803994a:	bf08      	it	eq
 803994c:	3401      	addeq	r4, #1
          psa_hash_test(PSA_ALG_SHA_224, &ret);
 803994e:	482e      	ldr	r0, [pc, #184]	; (8039a08 <tfm_app_menu+0x2ec>)
          ret.val = TEST_FAILED;
 8039950:	f88d 8008 	strb.w	r8, [sp, #8]
          psa_hash_test(PSA_ALG_SHA_224, &ret);
 8039954:	f002 fc18 	bl	803c188 <psa_hash_test>
          printf("SHA224 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039958:	f89d 1008 	ldrb.w	r1, [sp, #8]
 803995c:	482b      	ldr	r0, [pc, #172]	; (8039a0c <tfm_app_menu+0x2f0>)
 803995e:	2900      	cmp	r1, #0
 8039960:	bf0c      	ite	eq
 8039962:	4629      	moveq	r1, r5
 8039964:	4631      	movne	r1, r6
 8039966:	f002 fe63 	bl	803c630 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 803996a:	f89d 1008 	ldrb.w	r1, [sp, #8]
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 803996e:	b2e4      	uxtb	r4, r4
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039970:	2900      	cmp	r1, #0
 8039972:	bf08      	it	eq
 8039974:	3401      	addeq	r4, #1
          psa_hash_test(PSA_ALG_SHA_256, &ret);
 8039976:	4830      	ldr	r0, [pc, #192]	; (8039a38 <tfm_app_menu+0x31c>)
 8039978:	4639      	mov	r1, r7
          ret.val = TEST_FAILED;
 803997a:	f88d 8008 	strb.w	r8, [sp, #8]
          psa_hash_test(PSA_ALG_SHA_256, &ret);
 803997e:	f002 fc03 	bl	803c188 <psa_hash_test>
          printf("SHA256 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039982:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039986:	482d      	ldr	r0, [pc, #180]	; (8039a3c <tfm_app_menu+0x320>)
 8039988:	2900      	cmp	r1, #0
 803998a:	bf0c      	ite	eq
 803998c:	4629      	moveq	r1, r5
 803998e:	4631      	movne	r1, r6
 8039990:	f002 fe4e 	bl	803c630 <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039994:	f89d 1008 	ldrb.w	r1, [sp, #8]
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 8039998:	b2e4      	uxtb	r4, r4
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
 803999a:	2900      	cmp	r1, #0
 803999c:	bf14      	ite	ne
 803999e:	4621      	movne	r1, r4
 80399a0:	1c61      	addeq	r1, r4, #1
          printf("CUMULATIVE RESULT: %d/%d success\r\n", tests_success, tests_executed);
 80399a2:	220b      	movs	r2, #11
 80399a4:	b2c9      	uxtb	r1, r1
 80399a6:	4826      	ldr	r0, [pc, #152]	; (8039a40 <tfm_app_menu+0x324>)
 80399a8:	f002 fe42 	bl	803c630 <iprintf>
          tfm_app_print_menu();
 80399ac:	f7ff fd28 	bl	8039400 <tfm_app_print_menu>
          break;
 80399b0:	e6c0      	b.n	8039734 <tfm_app_menu+0x18>
          ret.val = TEST_FAILED;
 80399b2:	2301      	movs	r3, #1
 80399b4:	aa06      	add	r2, sp, #24
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_GCM, &ret);
 80399b6:	4649      	mov	r1, r9
 80399b8:	4815      	ldr	r0, [pc, #84]	; (8039a10 <tfm_app_menu+0x2f4>)
          ret.val = TEST_FAILED;
 80399ba:	f802 3d10 	strb.w	r3, [r2, #-16]!
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_GCM, &ret);
 80399be:	f002 fc87 	bl	803c2d0 <psa_aead_test>
          printf("AES GCM test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80399c2:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80399c6:	4813      	ldr	r0, [pc, #76]	; (8039a14 <tfm_app_menu+0x2f8>)
 80399c8:	2900      	cmp	r1, #0
 80399ca:	bf0c      	ite	eq
 80399cc:	4629      	moveq	r1, r5
 80399ce:	4631      	movne	r1, r6
          printf("SHA256 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80399d0:	f002 fe2e 	bl	803c630 <iprintf>
 80399d4:	e7ea      	b.n	80399ac <tfm_app_menu+0x290>
          ret.val = TEST_FAILED;
 80399d6:	2301      	movs	r3, #1
 80399d8:	aa06      	add	r2, sp, #24
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
 80399da:	490f      	ldr	r1, [pc, #60]	; (8039a18 <tfm_app_menu+0x2fc>)
 80399dc:	480c      	ldr	r0, [pc, #48]	; (8039a10 <tfm_app_menu+0x2f4>)
          ret.val = TEST_FAILED;
 80399de:	f802 3d10 	strb.w	r3, [r2, #-16]!
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
 80399e2:	f002 f9ed 	bl	803bdc0 <psa_cipher_test>
          printf("AES CBC test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 80399e6:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80399ea:	480c      	ldr	r0, [pc, #48]	; (8039a1c <tfm_app_menu+0x300>)
 80399ec:	2900      	cmp	r1, #0
 80399ee:	bf0c      	ite	eq
 80399f0:	4629      	moveq	r1, r5
 80399f2:	4631      	movne	r1, r6
 80399f4:	e7ec      	b.n	80399d0 <tfm_app_menu+0x2b4>
 80399f6:	bf00      	nop
 80399f8:	0803e3ae 	.word	0x0803e3ae
 80399fc:	0803e3ba 	.word	0x0803e3ba
 8039a00:	0803dcdd 	.word	0x0803dcdd
 8039a04:	0803e41a 	.word	0x0803e41a
 8039a08:	01000008 	.word	0x01000008
 8039a0c:	0803e4a2 	.word	0x0803e4a2
 8039a10:	40000001 	.word	0x40000001
 8039a14:	0803e3c1 	.word	0x0803e3c1
 8039a18:	04600100 	.word	0x04600100
 8039a1c:	0803e3d3 	.word	0x0803e3d3
 8039a20:	0803e3e5 	.word	0x0803e3e5
 8039a24:	0803e3fb 	.word	0x0803e3fb
 8039a28:	0803e433 	.word	0x0803e433
 8039a2c:	0803e454 	.word	0x0803e454
 8039a30:	0803e46a 	.word	0x0803e46a
 8039a34:	0803e489 	.word	0x0803e489
 8039a38:	01000009 	.word	0x01000009
 8039a3c:	0803e4b3 	.word	0x0803e4b3
 8039a40:	0803e4c4 	.word	0x0803e4c4
 8039a44:	06001002 	.word	0x06001002
          ret.val = TEST_FAILED;
 8039a48:	a806      	add	r0, sp, #24
 8039a4a:	f800 3d10 	strb.w	r3, [r0, #-16]!
          tfm_sst_set_uid(&ret);
 8039a4e:	f7ff fd21 	bl	8039494 <tfm_sst_set_uid.isra.0>
          printf("SST set UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039a52:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039a56:	4821      	ldr	r0, [pc, #132]	; (8039adc <tfm_app_menu+0x3c0>)
 8039a58:	2900      	cmp	r1, #0
 8039a5a:	bf0c      	ite	eq
 8039a5c:	4629      	moveq	r1, r5
 8039a5e:	4631      	movne	r1, r6
 8039a60:	e7b6      	b.n	80399d0 <tfm_app_menu+0x2b4>
          ret.val = TEST_FAILED;
 8039a62:	a806      	add	r0, sp, #24
 8039a64:	f800 3d10 	strb.w	r3, [r0, #-16]!
          tfm_sst_read_uid(&ret);
 8039a68:	f7ff fd36 	bl	80394d8 <tfm_sst_read_uid.isra.1>
          printf("SST read / check UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039a6c:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039a70:	481b      	ldr	r0, [pc, #108]	; (8039ae0 <tfm_app_menu+0x3c4>)
 8039a72:	2900      	cmp	r1, #0
 8039a74:	bf0c      	ite	eq
 8039a76:	4629      	moveq	r1, r5
 8039a78:	4631      	movne	r1, r6
 8039a7a:	e7a9      	b.n	80399d0 <tfm_app_menu+0x2b4>
          ret.val = TEST_FAILED;
 8039a7c:	2301      	movs	r3, #1
 8039a7e:	a806      	add	r0, sp, #24
 8039a80:	f800 3d10 	strb.w	r3, [r0, #-16]!
          tfm_eat_test_circuit_sig(TOKEN_OPT_NORMAL_CIRCUIT_SIGN, &ret);
 8039a84:	f7ff fdf0 	bl	8039668 <tfm_eat_test_circuit_sig.isra.6.constprop.7>
          printf("EAT normal circuit sig test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039a88:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039a8c:	4815      	ldr	r0, [pc, #84]	; (8039ae4 <tfm_app_menu+0x3c8>)
 8039a8e:	2900      	cmp	r1, #0
 8039a90:	bf0c      	ite	eq
 8039a92:	4629      	moveq	r1, r5
 8039a94:	4631      	movne	r1, r6
 8039a96:	e79b      	b.n	80399d0 <tfm_app_menu+0x2b4>
          ret.val = TEST_FAILED;
 8039a98:	2301      	movs	r3, #1
 8039a9a:	a806      	add	r0, sp, #24
 8039a9c:	f800 3d10 	strb.w	r3, [r0, #-16]!
          tfm_its_set_uid(&ret);
 8039aa0:	f7ff fd56 	bl	8039550 <tfm_its_set_uid.isra.3>
 8039aa4:	e7d5      	b.n	8039a52 <tfm_app_menu+0x336>
          ret.val = TEST_FAILED;
 8039aa6:	2301      	movs	r3, #1
  status = psa_its_remove(uid);
 8039aa8:	2100      	movs	r1, #0
 8039aaa:	2002      	movs	r0, #2
          ret.val = TEST_FAILED;
 8039aac:	f88d 3008 	strb.w	r3, [sp, #8]
  status = psa_its_remove(uid);
 8039ab0:	f002 f8ba 	bl	803bc28 <psa_its_remove>
 8039ab4:	e66c      	b.n	8039790 <tfm_app_menu+0x74>
          ret.val = TEST_FAILED;
 8039ab6:	2301      	movs	r3, #1
 8039ab8:	a906      	add	r1, sp, #24
 8039aba:	f801 3d10 	strb.w	r3, [r1, #-16]!
          psa_hash_test(PSA_ALG_SHA_256, &ret);
 8039abe:	480a      	ldr	r0, [pc, #40]	; (8039ae8 <tfm_app_menu+0x3cc>)
 8039ac0:	f002 fb62 	bl	803c188 <psa_hash_test>
          printf("SHA256 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFULL" : "FAILED");
 8039ac4:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8039ac8:	4808      	ldr	r0, [pc, #32]	; (8039aec <tfm_app_menu+0x3d0>)
 8039aca:	2900      	cmp	r1, #0
 8039acc:	bf0c      	ite	eq
 8039ace:	4629      	moveq	r1, r5
 8039ad0:	4631      	movne	r1, r6
 8039ad2:	e77d      	b.n	80399d0 <tfm_app_menu+0x2b4>
}
 8039ad4:	b007      	add	sp, #28
 8039ad6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8039ada:	bf00      	nop
 8039adc:	0803e3e5 	.word	0x0803e3e5
 8039ae0:	0803e3fb 	.word	0x0803e3fb
 8039ae4:	0803e433 	.word	0x0803e433
 8039ae8:	01000009 	.word	0x01000009
 8039aec:	0803e4b3 	.word	0x0803e4b3

08039af0 <tfm_ns_interface_dispatch>:
  * \brief NS world, NS lock based dispatcher
  */
int32_t tfm_ns_interface_dispatch(veneer_fn fn,
                                  uint32_t arg0, uint32_t arg1,
                                  uint32_t arg2, uint32_t arg3)
{
 8039af0:	b570      	push	{r4, r5, r6, lr}
 8039af2:	4606      	mov	r6, r0
 8039af4:	4608      	mov	r0, r1
 8039af6:	4611      	mov	r1, r2
 8039af8:	461a      	mov	r2, r3
__STATIC_FORCEINLINE uint8_t __LDREXB(volatile uint8_t *addr)
{
    uint32_t result;

#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
 8039afa:	4c08      	ldr	r4, [pc, #32]	; (8039b1c <tfm_ns_interface_dispatch+0x2c>)
 8039afc:	e8d4 3f4f 	ldrexb	r3, [r4]
    newValue = __LDREXB(valuePtr) + delta;
 8039b00:	3301      	adds	r3, #1
 8039b02:	b2db      	uxtb	r3, r3
 */
__STATIC_FORCEINLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
{
   uint32_t result;

   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
 8039b04:	e8c4 3f45 	strexb	r5, r3, [r4]
  } while (__STREXB(newValue, valuePtr));
 8039b08:	2d00      	cmp	r5, #0
 8039b0a:	d1f7      	bne.n	8039afc <tfm_ns_interface_dispatch+0xc>
  uint32_t ret;
  /*  We're only supporting a single user of RNG */
  if (core_util_atomic_incr_u8(&users, 1) > 1)
 8039b0c:	2b01      	cmp	r3, #1
 8039b0e:	d900      	bls.n	8039b12 <tfm_ns_interface_dispatch+0x22>
 8039b10:	e7fe      	b.n	8039b10 <tfm_ns_interface_dispatch+0x20>
  {
    while (1);
  }
  ret = (uint32_t)fn(arg0, arg1, arg2, arg3);
 8039b12:	9b04      	ldr	r3, [sp, #16]
 8039b14:	47b0      	blx	r6
  users = 0;
 8039b16:	7025      	strb	r5, [r4, #0]
  return ret;
}
 8039b18:	bd70      	pop	{r4, r5, r6, pc}
 8039b1a:	bf00      	nop
 8039b1c:	20000248 	.word	0x20000248

08039b20 <Ymodem_Init>:
  * @param None.
  * @retval None.
  */
void Ymodem_Init(void)
{
  __HAL_RCC_CRC_CLK_ENABLE();
 8039b20:	4b11      	ldr	r3, [pc, #68]	; (8039b68 <Ymodem_Init+0x48>)
{
 8039b22:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_CRC_CLK_ENABLE();
 8039b24:	6c9a      	ldr	r2, [r3, #72]	; 0x48
  /*-1- Configure the CRC peripheral */
  CrcHandle.Instance = CRC;

  /* The CRC-16-CCIT polynomial is used */
  CrcHandle.Init.DefaultPolynomialUse    = DEFAULT_POLYNOMIAL_DISABLE;
  CrcHandle.Init.GeneratingPolynomial    = 0x1021U;
 8039b26:	4811      	ldr	r0, [pc, #68]	; (8039b6c <Ymodem_Init+0x4c>)
  __HAL_RCC_CRC_CLK_ENABLE();
 8039b28:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8039b2c:	649a      	str	r2, [r3, #72]	; 0x48
 8039b2e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
 8039b30:	f241 0221 	movw	r2, #4129	; 0x1021
  __HAL_RCC_CRC_CLK_ENABLE();
 8039b34:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8039b38:	9301      	str	r3, [sp, #4]
 8039b3a:	9b01      	ldr	r3, [sp, #4]
  CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
 8039b3c:	2308      	movs	r3, #8
 8039b3e:	e9c0 2302 	strd	r2, r3, [r0, #8]
  CrcHandle.Instance = CRC;
 8039b42:	4b0b      	ldr	r3, [pc, #44]	; (8039b70 <Ymodem_Init+0x50>)
 8039b44:	6003      	str	r3, [r0, #0]
 8039b46:	f240 1301 	movw	r3, #257	; 0x101
 8039b4a:	8083      	strh	r3, [r0, #4]

  /* The zero init value is used */
  CrcHandle.Init.DefaultInitValueUse     = DEFAULT_INIT_VALUE_DISABLE;
  CrcHandle.Init.InitValue               = 0U;
 8039b4c:	2300      	movs	r3, #0

  /* The input data are not inverted */
  CrcHandle.Init.InputDataInversionMode  = CRC_INPUTDATA_INVERSION_NONE;
 8039b4e:	e9c0 3304 	strd	r3, r3, [r0, #16]

  /* The output data are not inverted */
  CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 8039b52:	6183      	str	r3, [r0, #24]

  /* The input data are 32-bit long words */
  CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT_BYTES;
 8039b54:	2301      	movs	r3, #1
 8039b56:	6203      	str	r3, [r0, #32]

  if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
 8039b58:	f000 fa5e 	bl	803a018 <HAL_CRC_Init>
 8039b5c:	b100      	cbz	r0, 8039b60 <Ymodem_Init+0x40>
 8039b5e:	e7fe      	b.n	8039b5e <Ymodem_Init+0x3e>
  {
    /* Initialization Error */
    while (1);
  }
}
 8039b60:	b003      	add	sp, #12
 8039b62:	f85d fb04 	ldr.w	pc, [sp], #4
 8039b66:	bf00      	nop
 8039b68:	40021000 	.word	0x40021000
 8039b6c:	2000024c 	.word	0x2000024c
 8039b70:	40023000 	.word	0x40023000

08039b74 <Ymodem_Receive>:
  * @param  puSize The uSize of the file.
  * @param  uFlashDestination where the file has to be downloaded.
  * @retval COM_StatusTypeDef result of reception/programming
  */
COM_StatusTypeDef Ymodem_Receive(uint32_t *puSize, uint32_t uFlashDestination)
{
 8039b74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t ramsource, filesize;
  uint8_t *file_ptr;
  uint8_t file_size[FILE_SIZE_LENGTH + 1U], tmp;
  uint32_t packets_received;
  COM_StatusTypeDef e_result = COM_OK;
  uint32_t cause = 0;
 8039b78:	2500      	movs	r5, #0
{
 8039b7a:	4681      	mov	r9, r0
 8039b7c:	468a      	mov	sl, r1
  uint32_t i, packet_length, session_done = 0U, file_done, errors = 0U, session_begin = 0U;
 8039b7e:	46ab      	mov	fp, r5
    *pData = char1;
 8039b80:	4f9a      	ldr	r7, [pc, #616]	; (8039dec <Ymodem_Receive+0x278>)
{
 8039b82:	b08b      	sub	sp, #44	; 0x2c
 8039b84:	2600      	movs	r6, #0
 8039b86:	e0e2      	b.n	8039d4e <Ymodem_Receive+0x1da>
    switch (char1)
 8039b88:	2a61      	cmp	r2, #97	; 0x61
 8039b8a:	d003      	beq.n	8039b94 <Ymodem_Receive+0x20>
 8039b8c:	2a72      	cmp	r2, #114	; 0x72
 8039b8e:	d053      	beq.n	8039c38 <Ymodem_Receive+0xc4>
 8039b90:	2a41      	cmp	r2, #65	; 0x41
 8039b92:	d163      	bne.n	8039c5c <Ymodem_Receive+0xe8>
        status = HAL_BUSY;
 8039b94:	2302      	movs	r3, #2
  uint32_t packet_size = 0U;
 8039b96:	2400      	movs	r4, #0
 8039b98:	e001      	b.n	8039b9e <Ymodem_Receive+0x2a>
        packet_size = PACKET_1K_SIZE;
 8039b9a:	f44f 6480 	mov.w	r4, #1024	; 0x400
    *pData = char1;
 8039b9e:	f89d 200f 	ldrb.w	r2, [sp, #15]
    if (packet_size >= PACKET_SIZE)
 8039ba2:	2c7f      	cmp	r4, #127	; 0x7f
    *pData = char1;
 8039ba4:	703a      	strb	r2, [r7, #0]
    if (packet_size >= PACKET_SIZE)
 8039ba6:	d95d      	bls.n	8039c64 <Ymodem_Receive+0xf0>
      status = COM_Receive(&pData[PACKET_NUMBER_INDEX], packet_size + PACKET_OVERHEAD_SIZE, uTimeout);
 8039ba8:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8039bac:	1d21      	adds	r1, r4, #4
 8039bae:	4890      	ldr	r0, [pc, #576]	; (8039df0 <Ymodem_Receive+0x27c>)
 8039bb0:	f7fe ff04 	bl	80389bc <COM_Receive>
      if (status == HAL_OK)
 8039bb4:	4603      	mov	r3, r0
 8039bb6:	2800      	cmp	r0, #0
 8039bb8:	d155      	bne.n	8039c66 <Ymodem_Receive+0xf2>
        if (pData[PACKET_NUMBER_INDEX] != ((pData[PACKET_CNUMBER_INDEX]) ^ NEGATIVE_BYTE))
 8039bba:	78fb      	ldrb	r3, [r7, #3]
 8039bbc:	78ba      	ldrb	r2, [r7, #2]
 8039bbe:	43db      	mvns	r3, r3
 8039bc0:	b2db      	uxtb	r3, r3
 8039bc2:	429a      	cmp	r2, r3
 8039bc4:	d152      	bne.n	8039c6c <Ymodem_Receive+0xf8>
          crc = pData[ packet_size + PACKET_DATA_INDEX ] << 8U;
 8039bc6:	193a      	adds	r2, r7, r4
 8039bc8:	7911      	ldrb	r1, [r2, #4]
          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
 8039bca:	7953      	ldrb	r3, [r2, #5]
          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
 8039bcc:	4889      	ldr	r0, [pc, #548]	; (8039df4 <Ymodem_Receive+0x280>)
          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
 8039bce:	eb03 2301 	add.w	r3, r3, r1, lsl #8
          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
 8039bd2:	4622      	mov	r2, r4
 8039bd4:	4988      	ldr	r1, [pc, #544]	; (8039df8 <Ymodem_Receive+0x284>)
          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
 8039bd6:	9301      	str	r3, [sp, #4]
          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
 8039bd8:	f000 fa58 	bl	803a08c <HAL_CRC_Calculate>
 8039bdc:	9b01      	ldr	r3, [sp, #4]
 8039bde:	4283      	cmp	r3, r0
 8039be0:	d144      	bne.n	8039c6c <Ymodem_Receive+0xf8>
              *puSize = filesize;
              file_done = 1U;
              break;
            default:
              /* Normal packet */
              if (m_aPacketData[PACKET_NUMBER_INDEX] != (packets_received & 0xff))
 8039be2:	78ba      	ldrb	r2, [r7, #2]
 8039be4:	b2f3      	uxtb	r3, r6
 8039be6:	429a      	cmp	r2, r3
 8039be8:	f040 80b1 	bne.w	8039d4e <Ymodem_Receive+0x1da>
              {
                /*             Serial_PutByte(NAK);*/
              }
              else
              {
                if (packets_received == 0U)
 8039bec:	2e00      	cmp	r6, #0
 8039bee:	f040 80ce 	bne.w	8039d8e <Ymodem_Receive+0x21a>
                {
                  /* File name packet */
                  if (m_aPacketData[PACKET_DATA_INDEX] != 0U)
 8039bf2:	793b      	ldrb	r3, [r7, #4]
 8039bf4:	2b00      	cmp	r3, #0
 8039bf6:	f040 8091 	bne.w	8039d1c <Ymodem_Receive+0x1a8>

                  }
                  /* File header packet is empty, end session */
                  else
                  {
                    Serial_PutByte(ACK);
 8039bfa:	2006      	movs	r0, #6
 8039bfc:	f7fe ff42 	bl	8038a84 <Serial_PutByte>
 8039c00:	4634      	mov	r4, r6
                    file_done = 1;
                    session_done = 1;
                    cause = 3;
 8039c02:	2503      	movs	r5, #3
    }
  }
#if defined(__ARMCC_VERSION)
  printf("e_result = %x , %u\n", e_result, cause);
#else
  printf("e_result = %x , %lu\n", e_result, cause);
 8039c04:	462a      	mov	r2, r5
 8039c06:	4621      	mov	r1, r4
 8039c08:	487c      	ldr	r0, [pc, #496]	; (8039dfc <Ymodem_Receive+0x288>)
 8039c0a:	f002 fd11 	bl	803c630 <iprintf>
#endif /* __ARMCC_VERSION */
  return e_result;
}
 8039c0e:	4620      	mov	r0, r4
 8039c10:	b00b      	add	sp, #44	; 0x2c
 8039c12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((COM_Receive(&char1, 1U, uTimeout) == HAL_OK) && (char1 == CA))
 8039c16:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8039c1a:	2101      	movs	r1, #1
 8039c1c:	f10d 000f 	add.w	r0, sp, #15
 8039c20:	f7fe fecc 	bl	80389bc <COM_Receive>
 8039c24:	4603      	mov	r3, r0
 8039c26:	b9d8      	cbnz	r0, 8039c60 <Ymodem_Receive+0xec>
 8039c28:	f89d 200f 	ldrb.w	r2, [sp, #15]
          packet_size = 2U;
 8039c2c:	2a18      	cmp	r2, #24
 8039c2e:	bf16      	itet	ne
 8039c30:	2400      	movne	r4, #0
 8039c32:	2402      	moveq	r4, #2
 8039c34:	2301      	movne	r3, #1
 8039c36:	e7b2      	b.n	8039b9e <Ymodem_Receive+0x2a>
 8039c38:	9001      	str	r0, [sp, #4]
        COM_Receive(&char1, 1U, uTimeout);                /* Ymodem starup sequence : rb ==> 0x72 + 0x62 + 0x0D */
 8039c3a:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8039c3e:	2101      	movs	r1, #1
 8039c40:	f10d 000f 	add.w	r0, sp, #15
 8039c44:	f7fe feba 	bl	80389bc <COM_Receive>
        COM_Receive(&char1, 1U, uTimeout);
 8039c48:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8039c4c:	2101      	movs	r1, #1
 8039c4e:	f10d 000f 	add.w	r0, sp, #15
 8039c52:	f7fe feb3 	bl	80389bc <COM_Receive>
        packet_size = 3U;
 8039c56:	2403      	movs	r4, #3
 8039c58:	9b01      	ldr	r3, [sp, #4]
 8039c5a:	e7a0      	b.n	8039b9e <Ymodem_Receive+0x2a>
        status = HAL_ERROR;
 8039c5c:	2301      	movs	r3, #1
 8039c5e:	e79a      	b.n	8039b96 <Ymodem_Receive+0x22>
          status = HAL_ERROR;
 8039c60:	2301      	movs	r3, #1
 8039c62:	e79c      	b.n	8039b9e <Ymodem_Receive+0x2a>
      switch (ReceivePacket(m_aPacketData, &packet_length, DOWNLOAD_TIMEOUT))
 8039c64:	b193      	cbz	r3, 8039c8c <Ymodem_Receive+0x118>
 8039c66:	2b02      	cmp	r3, #2
 8039c68:	f000 80b0 	beq.w	8039dcc <Ymodem_Receive+0x258>
          if (session_begin > 0U)
 8039c6c:	f1bb 0f00 	cmp.w	fp, #0
 8039c70:	d001      	beq.n	8039c76 <Ymodem_Receive+0x102>
            errors ++;
 8039c72:	f108 0801 	add.w	r8, r8, #1
          if (errors > MAX_ERRORS)
 8039c76:	f1b8 0f05 	cmp.w	r8, #5
 8039c7a:	f240 80af 	bls.w	8039ddc <Ymodem_Receive+0x268>
            Serial_PutByte(CA);
 8039c7e:	2018      	movs	r0, #24
 8039c80:	f7fe ff00 	bl	8038a84 <Serial_PutByte>
            Serial_PutByte(CA);
 8039c84:	2018      	movs	r0, #24
 8039c86:	f7fe fefd 	bl	8038a84 <Serial_PutByte>
 8039c8a:	e062      	b.n	8039d52 <Ymodem_Receive+0x1de>
          switch (packet_length)
 8039c8c:	2c02      	cmp	r4, #2
 8039c8e:	d00a      	beq.n	8039ca6 <Ymodem_Receive+0x132>
 8039c90:	2c03      	cmp	r4, #3
 8039c92:	d05c      	beq.n	8039d4e <Ymodem_Receive+0x1da>
 8039c94:	2c00      	cmp	r4, #0
 8039c96:	d1a4      	bne.n	8039be2 <Ymodem_Receive+0x6e>
              Serial_PutByte(ACK);
 8039c98:	2006      	movs	r0, #6
 8039c9a:	f7fe fef3 	bl	8038a84 <Serial_PutByte>
              *puSize = filesize;
 8039c9e:	9b04      	ldr	r3, [sp, #16]
 8039ca0:	f8c9 3000 	str.w	r3, [r9]
 8039ca4:	e76e      	b.n	8039b84 <Ymodem_Receive+0x10>
              Serial_PutByte(ACK);
 8039ca6:	2006      	movs	r0, #6
 8039ca8:	f7fe feec 	bl	8038a84 <Serial_PutByte>
          switch (packet_length)
 8039cac:	2402      	movs	r4, #2
 8039cae:	e7a9      	b.n	8039c04 <Ymodem_Receive+0x90>
                      m_aFileName[i++] = *file_ptr++;
 8039cb0:	5483      	strb	r3, [r0, r2]
 8039cb2:	3201      	adds	r2, #1
                    while ((*file_ptr != 0U) && (i < FILE_NAME_LENGTH))
 8039cb4:	f811 3b01 	ldrb.w	r3, [r1], #1
 8039cb8:	b10b      	cbz	r3, 8039cbe <Ymodem_Receive+0x14a>
 8039cba:	2a40      	cmp	r2, #64	; 0x40
 8039cbc:	d1f8      	bne.n	8039cb0 <Ymodem_Receive+0x13c>
                    m_aFileName[i++] = '\0';
 8039cbe:	2300      	movs	r3, #0
 8039cc0:	5483      	strb	r3, [r0, r2]
 8039cc2:	a805      	add	r0, sp, #20
                    while ((*file_ptr != ' ') && (i < FILE_SIZE_LENGTH))
 8039cc4:	5cca      	ldrb	r2, [r1, r3]
 8039cc6:	2a20      	cmp	r2, #32
 8039cc8:	d001      	beq.n	8039cce <Ymodem_Receive+0x15a>
 8039cca:	2b10      	cmp	r3, #16
 8039ccc:	d12a      	bne.n	8039d24 <Ymodem_Receive+0x1b0>
                    file_size[i++] = '\0';
 8039cce:	2400      	movs	r4, #0
 8039cd0:	aa0a      	add	r2, sp, #40	; 0x28
 8039cd2:	4413      	add	r3, r2
                    Str2Int(file_size, &filesize);
 8039cd4:	a904      	add	r1, sp, #16
                    file_size[i++] = '\0';
 8039cd6:	f803 4c14 	strb.w	r4, [r3, #-20]
                    Str2Int(file_size, &filesize);
 8039cda:	f7fe fe85 	bl	80389e8 <Str2Int>
                    if ((uint32_t)filesize > *puSize)
 8039cde:	9904      	ldr	r1, [sp, #16]
 8039ce0:	f8d9 3000 	ldr.w	r3, [r9]
 8039ce4:	428b      	cmp	r3, r1
 8039ce6:	d206      	bcs.n	8039cf6 <Ymodem_Receive+0x182>
                      tmp = CA;
 8039ce8:	2318      	movs	r3, #24
                      *puSize = 0;
 8039cea:	f8c9 4000 	str.w	r4, [r9]
                      cause = 1;
 8039cee:	2501      	movs	r5, #1
                      e_result = COM_ABORT;
 8039cf0:	2402      	movs	r4, #2
                      tmp = CA;
 8039cf2:	f88d 300e 	strb.w	r3, [sp, #14]
                    if ((*puSize) && (Ymodem_HeaderPktRxCpltCallback(uFlashDestination, (uint32_t) filesize) == HAL_OK))
 8039cf6:	f8d9 3000 	ldr.w	r3, [r9]
 8039cfa:	b1b3      	cbz	r3, 8039d2a <Ymodem_Receive+0x1b6>
 8039cfc:	4650      	mov	r0, sl
 8039cfe:	f7ff f89f 	bl	8038e40 <Ymodem_HeaderPktRxCpltCallback>
 8039d02:	b990      	cbnz	r0, 8039d2a <Ymodem_Receive+0x1b6>
                      Serial_PutByte(ACK);
 8039d04:	2006      	movs	r0, #6
 8039d06:	f7fe febd 	bl	8038a84 <Serial_PutByte>
                      COM_Flush();
 8039d0a:	f7fe fe5f 	bl	80389cc <COM_Flush>
                      Serial_PutByte(CRC16);
 8039d0e:	2043      	movs	r0, #67	; 0x43
 8039d10:	f7fe feb8 	bl	8038a84 <Serial_PutByte>
                packets_received ++;
 8039d14:	3601      	adds	r6, #1
                session_begin = 1U;
 8039d16:	f04f 0b01 	mov.w	fp, #1
 8039d1a:	e015      	b.n	8039d48 <Ymodem_Receive+0x1d4>
 8039d1c:	4632      	mov	r2, r6
                    file_ptr = m_aPacketData + PACKET_DATA_INDEX;
 8039d1e:	4936      	ldr	r1, [pc, #216]	; (8039df8 <Ymodem_Receive+0x284>)
 8039d20:	4837      	ldr	r0, [pc, #220]	; (8039e00 <Ymodem_Receive+0x28c>)
 8039d22:	e7c7      	b.n	8039cb4 <Ymodem_Receive+0x140>
                      file_size[i++] = *file_ptr++;
 8039d24:	54c2      	strb	r2, [r0, r3]
 8039d26:	3301      	adds	r3, #1
 8039d28:	e7cc      	b.n	8039cc4 <Ymodem_Receive+0x150>
                      COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 8039d2a:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8039d2e:	2101      	movs	r1, #1
 8039d30:	f10d 000e 	add.w	r0, sp, #14
 8039d34:	f7fe fe3a 	bl	80389ac <COM_Transmit>
                      COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 8039d38:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8039d3c:	2101      	movs	r1, #1
 8039d3e:	f10d 000e 	add.w	r0, sp, #14
 8039d42:	f7fe fe33 	bl	80389ac <COM_Transmit>
                      cause = 2;
 8039d46:	2502      	movs	r5, #2
    while ((file_done == 0U) && (e_result == COM_OK))
 8039d48:	2c00      	cmp	r4, #0
 8039d4a:	f47f af5b 	bne.w	8039c04 <Ymodem_Receive+0x90>
 8039d4e:	f04f 0800 	mov.w	r8, #0
  status = (HAL_StatusTypeDef)COM_Receive(&char1, 1, uTimeout);
 8039d52:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8039d56:	2101      	movs	r1, #1
 8039d58:	f10d 000f 	add.w	r0, sp, #15
 8039d5c:	f7fe fe2e 	bl	80389bc <COM_Receive>
 8039d60:	4603      	mov	r3, r0
 8039d62:	4604      	mov	r4, r0
  if (status == HAL_OK)
 8039d64:	2800      	cmp	r0, #0
 8039d66:	f47f af7e 	bne.w	8039c66 <Ymodem_Receive+0xf2>
    switch (char1)
 8039d6a:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8039d6e:	2a18      	cmp	r2, #24
 8039d70:	f43f af51 	beq.w	8039c16 <Ymodem_Receive+0xa2>
 8039d74:	f63f af08 	bhi.w	8039b88 <Ymodem_Receive+0x14>
 8039d78:	2a02      	cmp	r2, #2
 8039d7a:	f43f af0e 	beq.w	8039b9a <Ymodem_Receive+0x26>
 8039d7e:	2a04      	cmp	r2, #4
 8039d80:	f43f af09 	beq.w	8039b96 <Ymodem_Receive+0x22>
 8039d84:	2a01      	cmp	r2, #1
 8039d86:	f47f af69 	bne.w	8039c5c <Ymodem_Receive+0xe8>
        packet_size = PACKET_SIZE;
 8039d8a:	2480      	movs	r4, #128	; 0x80
 8039d8c:	e707      	b.n	8039b9e <Ymodem_Receive+0x2a>
                  if ((*puSize) && (Ymodem_DataPktRxCpltCallback((uint8_t *)
 8039d8e:	f8d9 3000 	ldr.w	r3, [r9]
 8039d92:	b15b      	cbz	r3, 8039dac <Ymodem_Receive+0x238>
 8039d94:	4622      	mov	r2, r4
 8039d96:	4651      	mov	r1, sl
 8039d98:	4817      	ldr	r0, [pc, #92]	; (8039df8 <Ymodem_Receive+0x284>)
 8039d9a:	f7ff f871 	bl	8038e80 <Ymodem_DataPktRxCpltCallback>
 8039d9e:	b928      	cbnz	r0, 8039dac <Ymodem_Receive+0x238>
                    Serial_PutByte(ACK);
 8039da0:	2006      	movs	r0, #6
                    uFlashDestination += (packet_length);
 8039da2:	44a2      	add	sl, r4
                    Serial_PutByte(ACK);
 8039da4:	f7fe fe6e 	bl	8038a84 <Serial_PutByte>
                    COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 8039da8:	2400      	movs	r4, #0
 8039daa:	e7b3      	b.n	8039d14 <Ymodem_Receive+0x1a0>
                    COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 8039dac:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8039db0:	2101      	movs	r1, #1
 8039db2:	f10d 000e 	add.w	r0, sp, #14
 8039db6:	f7fe fdf9 	bl	80389ac <COM_Transmit>
                    COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 8039dba:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8039dbe:	2101      	movs	r1, #1
 8039dc0:	f10d 000e 	add.w	r0, sp, #14
 8039dc4:	f7fe fdf2 	bl	80389ac <COM_Transmit>
                    cause = 4;
 8039dc8:	2504      	movs	r5, #4
 8039dca:	e7ed      	b.n	8039da8 <Ymodem_Receive+0x234>
          Serial_PutByte(CA);
 8039dcc:	2018      	movs	r0, #24
 8039dce:	f7fe fe59 	bl	8038a84 <Serial_PutByte>
          Serial_PutByte(CA);
 8039dd2:	2018      	movs	r0, #24
 8039dd4:	f7fe fe56 	bl	8038a84 <Serial_PutByte>
          cause  = 5;
 8039dd8:	2505      	movs	r5, #5
          break;
 8039dda:	e767      	b.n	8039cac <Ymodem_Receive+0x138>
            Serial_PutByte(CRC16); /* Ask for a packet */
 8039ddc:	2043      	movs	r0, #67	; 0x43
 8039dde:	f7fe fe51 	bl	8038a84 <Serial_PutByte>
            printf("\b.");         /* Replace C char by . on display console */
 8039de2:	4808      	ldr	r0, [pc, #32]	; (8039e04 <Ymodem_Receive+0x290>)
 8039de4:	f002 fc24 	bl	803c630 <iprintf>
 8039de8:	e7b3      	b.n	8039d52 <Ymodem_Receive+0x1de>
 8039dea:	bf00      	nop
 8039dec:	20000270 	.word	0x20000270
 8039df0:	20000272 	.word	0x20000272
 8039df4:	2000024c 	.word	0x2000024c
 8039df8:	20000274 	.word	0x20000274
 8039dfc:	0803e9a6 	.word	0x0803e9a6
 8039e00:	20000688 	.word	0x20000688
 8039e04:	0803e9a3 	.word	0x0803e9a3

08039e08 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 8039e08:	4770      	bx	lr
	...

08039e0c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8039e0c:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  if (uwTickFreq != 0U)
 8039e0e:	4b0f      	ldr	r3, [pc, #60]	; (8039e4c <HAL_InitTick+0x40>)
{
 8039e10:	4605      	mov	r5, r0
  if (uwTickFreq != 0U)
 8039e12:	6818      	ldr	r0, [r3, #0]
 8039e14:	b908      	cbnz	r0, 8039e1a <HAL_InitTick+0xe>
      status = HAL_ERROR;
    }
  }
  else
  {
    status = HAL_ERROR;
 8039e16:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 8039e18:	bd38      	pop	{r3, r4, r5, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) == 0U)
 8039e1a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8039e1e:	fbb3 f3f0 	udiv	r3, r3, r0
 8039e22:	4a0b      	ldr	r2, [pc, #44]	; (8039e50 <HAL_InitTick+0x44>)
 8039e24:	6810      	ldr	r0, [r2, #0]
 8039e26:	fbb0 f0f3 	udiv	r0, r0, r3
 8039e2a:	f000 f891 	bl	8039f50 <HAL_SYSTICK_Config>
 8039e2e:	4604      	mov	r4, r0
 8039e30:	2800      	cmp	r0, #0
 8039e32:	d1f0      	bne.n	8039e16 <HAL_InitTick+0xa>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8039e34:	2d07      	cmp	r5, #7
 8039e36:	d8ee      	bhi.n	8039e16 <HAL_InitTick+0xa>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8039e38:	4602      	mov	r2, r0
 8039e3a:	4629      	mov	r1, r5
 8039e3c:	f04f 30ff 	mov.w	r0, #4294967295
 8039e40:	f000 f852 	bl	8039ee8 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8039e44:	4b03      	ldr	r3, [pc, #12]	; (8039e54 <HAL_InitTick+0x48>)
 8039e46:	4620      	mov	r0, r4
 8039e48:	601d      	str	r5, [r3, #0]
 8039e4a:	e7e5      	b.n	8039e18 <HAL_InitTick+0xc>
 8039e4c:	20000104 	.word	0x20000104
 8039e50:	20000100 	.word	0x20000100
 8039e54:	20000108 	.word	0x20000108

08039e58 <HAL_Init>:
{
 8039e58:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 8039e5a:	2004      	movs	r0, #4
 8039e5c:	f000 f832 	bl	8039ec4 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
 8039e60:	f7ff f922 	bl	80390a8 <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8039e64:	2007      	movs	r0, #7
 8039e66:	f7ff ffd1 	bl	8039e0c <HAL_InitTick>
 8039e6a:	4604      	mov	r4, r0
 8039e6c:	b918      	cbnz	r0, 8039e76 <HAL_Init+0x1e>
    HAL_MspInit();
 8039e6e:	f7ff ffcb 	bl	8039e08 <HAL_MspInit>
}
 8039e72:	4620      	mov	r0, r4
 8039e74:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 8039e76:	2401      	movs	r4, #1
 8039e78:	e7fb      	b.n	8039e72 <HAL_Init+0x1a>
	...

08039e7c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8039e7c:	4a03      	ldr	r2, [pc, #12]	; (8039e8c <HAL_IncTick+0x10>)
 8039e7e:	4904      	ldr	r1, [pc, #16]	; (8039e90 <HAL_IncTick+0x14>)
 8039e80:	6813      	ldr	r3, [r2, #0]
 8039e82:	6809      	ldr	r1, [r1, #0]
 8039e84:	440b      	add	r3, r1
 8039e86:	6013      	str	r3, [r2, #0]
}
 8039e88:	4770      	bx	lr
 8039e8a:	bf00      	nop
 8039e8c:	200006cc 	.word	0x200006cc
 8039e90:	20000104 	.word	0x20000104

08039e94 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8039e94:	4b01      	ldr	r3, [pc, #4]	; (8039e9c <HAL_GetTick+0x8>)
 8039e96:	6818      	ldr	r0, [r3, #0]
}
 8039e98:	4770      	bx	lr
 8039e9a:	bf00      	nop
 8039e9c:	200006cc 	.word	0x200006cc

08039ea0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8039ea0:	b538      	push	{r3, r4, r5, lr}
 8039ea2:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8039ea4:	f7ff fff6 	bl	8039e94 <HAL_GetTick>
 8039ea8:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 8039eaa:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 8039eac:	bf1e      	ittt	ne
 8039eae:	4b04      	ldrne	r3, [pc, #16]	; (8039ec0 <HAL_Delay+0x20>)
 8039eb0:	681b      	ldrne	r3, [r3, #0]
 8039eb2:	18e4      	addne	r4, r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 8039eb4:	f7ff ffee 	bl	8039e94 <HAL_GetTick>
 8039eb8:	1b40      	subs	r0, r0, r5
 8039eba:	42a0      	cmp	r0, r4
 8039ebc:	d3fa      	bcc.n	8039eb4 <HAL_Delay+0x14>
  {
  }
}
 8039ebe:	bd38      	pop	{r3, r4, r5, pc}
 8039ec0:	20000104 	.word	0x20000104

08039ec4 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8039ec4:	4a07      	ldr	r2, [pc, #28]	; (8039ee4 <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priority group */
 8039ec6:	0200      	lsls	r0, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8039ec8:	68d3      	ldr	r3, [r2, #12]
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priority group */
 8039eca:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8039ece:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8039ed2:	041b      	lsls	r3, r3, #16
 8039ed4:	0c1b      	lsrs	r3, r3, #16
 8039ed6:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8039eda:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 8039ede:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8039ee0:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8039ee2:	4770      	bx	lr
 8039ee4:	e000ed00 	.word	0xe000ed00

08039ee8 <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8039ee8:	4b17      	ldr	r3, [pc, #92]	; (8039f48 <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 7
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8039eea:	b570      	push	{r4, r5, r6, lr}
 8039eec:	68dc      	ldr	r4, [r3, #12]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8039eee:	f04f 36ff 	mov.w	r6, #4294967295
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8039ef2:	f3c4 2402 	ubfx	r4, r4, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8039ef6:	f1c4 0507 	rsb	r5, r4, #7
 8039efa:	2d03      	cmp	r5, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8039efc:	f104 0303 	add.w	r3, r4, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8039f00:	bf28      	it	cs
 8039f02:	2503      	movcs	r5, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8039f04:	2b06      	cmp	r3, #6
 8039f06:	bf98      	it	ls
 8039f08:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8039f0a:	fa06 f305 	lsl.w	r3, r6, r5
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8039f0e:	bf88      	it	hi
 8039f10:	3c04      	subhi	r4, #4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8039f12:	ea21 0303 	bic.w	r3, r1, r3
 8039f16:	40a3      	lsls	r3, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8039f18:	fa06 f404 	lsl.w	r4, r6, r4
 8039f1c:	ea22 0404 	bic.w	r4, r2, r4
  if ((int32_t)(IRQn) >= 0)
 8039f20:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8039f22:	ea43 0304 	orr.w	r3, r3, r4
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039f26:	bfa8      	it	ge
 8039f28:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 8039f2c:	ea4f 1343 	mov.w	r3, r3, lsl #5
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039f30:	bfb8      	it	lt
 8039f32:	4a06      	ldrlt	r2, [pc, #24]	; (8039f4c <HAL_NVIC_SetPriority+0x64>)
 8039f34:	b2db      	uxtb	r3, r3
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039f36:	bfab      	itete	ge
 8039f38:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039f3c:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039f40:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039f44:	5413      	strblt	r3, [r2, r0]
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8039f46:	bd70      	pop	{r4, r5, r6, pc}
 8039f48:	e000ed00 	.word	0xe000ed00
 8039f4c:	e000ed14 	.word	0xe000ed14

08039f50 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8039f50:	3801      	subs	r0, #1
 8039f52:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8039f56:	d20a      	bcs.n	8039f6e <HAL_SYSTICK_Config+0x1e>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039f58:	21e0      	movs	r1, #224	; 0xe0
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8039f5a:	4b06      	ldr	r3, [pc, #24]	; (8039f74 <HAL_SYSTICK_Config+0x24>)
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039f5c:	4a06      	ldr	r2, [pc, #24]	; (8039f78 <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8039f5e:	6058      	str	r0, [r3, #4]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8039f60:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8039f64:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8039f66:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8039f68:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8039f6a:	601a      	str	r2, [r3, #0]
 8039f6c:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8039f6e:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
  return SysTick_Config(TicksNumb);
}
 8039f70:	4770      	bx	lr
 8039f72:	bf00      	nop
 8039f74:	e000e010 	.word	0xe000e010
 8039f78:	e000ed00 	.word	0xe000ed00

08039f7c <CRC_Handle_8>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 8039f7c:	460b      	mov	r3, r1
 8039f7e:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint16_t *pReg;

  /* Processing time optimization: 4 bytes are entered in a row with a single word write,
   * last bytes must be carefully fed to the CRC calculator to ensure a correct type
   * handling by the peripheral */
  for (i = 0U; i < (BufferLength / 4U); i++)
 8039f80:	0896      	lsrs	r6, r2, #2
 8039f82:	6805      	ldr	r5, [r0, #0]
 8039f84:	eb01 0786 	add.w	r7, r1, r6, lsl #2
 8039f88:	42bb      	cmp	r3, r7
 8039f8a:	d108      	bne.n	8039f9e <CRC_Handle_8+0x22>
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
                         (uint32_t)pBuffer[(4U * i) + 3U];
  }
  /* last bytes specific handling */
  if ((BufferLength % 4U) != 0U)
 8039f8c:	f012 0203 	ands.w	r2, r2, #3
 8039f90:	d01e      	beq.n	8039fd0 <CRC_Handle_8+0x54>
  {
    if ((BufferLength % 4U) == 1U)
 8039f92:	2a01      	cmp	r2, #1
 8039f94:	d114      	bne.n	8039fc0 <CRC_Handle_8+0x44>
    {
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];         /* Derogation MisraC2012 R.11.5 */
 8039f96:	f811 3026 	ldrb.w	r3, [r1, r6, lsl #2]
    {
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
      pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                    /* Derogation MisraC2012 R.11.5 */
      *pReg = data;

      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 8039f9a:	702b      	strb	r3, [r5, #0]
 8039f9c:	e018      	b.n	8039fd0 <CRC_Handle_8+0x54>
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 8039f9e:	785c      	ldrb	r4, [r3, #1]
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 8039fa0:	f893 c000 	ldrb.w	ip, [r3]
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 8039fa4:	0424      	lsls	r4, r4, #16
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 8039fa6:	ea44 640c 	orr.w	r4, r4, ip, lsl #24
                         (uint32_t)pBuffer[(4U * i) + 3U];
 8039faa:	f893 c003 	ldrb.w	ip, [r3, #3]
 8039fae:	3304      	adds	r3, #4
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 8039fb0:	ea44 040c 	orr.w	r4, r4, ip
 8039fb4:	f813 cc02 	ldrb.w	ip, [r3, #-2]
 8039fb8:	ea44 240c 	orr.w	r4, r4, ip, lsl #8
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 8039fbc:	602c      	str	r4, [r5, #0]
 8039fbe:	e7e3      	b.n	8039f88 <CRC_Handle_8+0xc>
    if ((BufferLength % 4U) == 2U)
 8039fc0:	2a02      	cmp	r2, #2
 8039fc2:	d108      	bne.n	8039fd6 <CRC_Handle_8+0x5a>
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 8039fc4:	f811 2026 	ldrb.w	r2, [r1, r6, lsl #2]
 8039fc8:	785b      	ldrb	r3, [r3, #1]
 8039fca:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
      *pReg = data;
 8039fce:	802b      	strh	r3, [r5, #0]
    }
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 8039fd0:	6803      	ldr	r3, [r0, #0]
 8039fd2:	6818      	ldr	r0, [r3, #0]
}
 8039fd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 8039fd6:	785a      	ldrb	r2, [r3, #1]
 8039fd8:	f811 1026 	ldrb.w	r1, [r1, r6, lsl #2]
 8039fdc:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
      *pReg = data;
 8039fe0:	802a      	strh	r2, [r5, #0]
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 8039fe2:	789b      	ldrb	r3, [r3, #2]
 8039fe4:	e7d9      	b.n	8039f9a <CRC_Handle_8+0x1e>

08039fe6 <CRC_Handle_16>:
  __IO uint16_t *pReg;

  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure
   * a correct type handling by the peripheral */
  for (i = 0U; i < (BufferLength / 2U); i++)
 8039fe6:	2300      	movs	r3, #0
 8039fe8:	6800      	ldr	r0, [r0, #0]
{
 8039fea:	b570      	push	{r4, r5, r6, lr}
  for (i = 0U; i < (BufferLength / 2U); i++)
 8039fec:	0855      	lsrs	r5, r2, #1
 8039fee:	429d      	cmp	r5, r3
 8039ff0:	d106      	bne.n	803a000 <CRC_Handle_16+0x1a>
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
  }
  if ((BufferLength % 2U) != 0U)
 8039ff2:	07d3      	lsls	r3, r2, #31
  {
    pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                 /* Derogation MisraC2012 R.11.5 */
    *pReg = pBuffer[2U * i];
 8039ff4:	bf44      	itt	mi
 8039ff6:	f831 3025 	ldrhmi.w	r3, [r1, r5, lsl #2]
 8039ffa:	8003      	strhmi	r3, [r0, #0]
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 8039ffc:	6800      	ldr	r0, [r0, #0]
}
 8039ffe:	bd70      	pop	{r4, r5, r6, pc}
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 803a000:	eb01 0483 	add.w	r4, r1, r3, lsl #2
 803a004:	f831 6023 	ldrh.w	r6, [r1, r3, lsl #2]
 803a008:	8864      	ldrh	r4, [r4, #2]
  for (i = 0U; i < (BufferLength / 2U); i++)
 803a00a:	3301      	adds	r3, #1
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 803a00c:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
 803a010:	6004      	str	r4, [r0, #0]
 803a012:	e7ec      	b.n	8039fee <CRC_Handle_16+0x8>

0803a014 <HAL_CRC_MspInit>:
}
 803a014:	4770      	bx	lr
	...

0803a018 <HAL_CRC_Init>:
{
 803a018:	b510      	push	{r4, lr}
  if (hcrc == NULL)
 803a01a:	4604      	mov	r4, r0
 803a01c:	b908      	cbnz	r0, 803a022 <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 803a01e:	2001      	movs	r0, #1
}
 803a020:	bd10      	pop	{r4, pc}
  if (hcrc->State == HAL_CRC_STATE_RESET)
 803a022:	7f43      	ldrb	r3, [r0, #29]
 803a024:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 803a028:	b913      	cbnz	r3, 803a030 <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 803a02a:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 803a02c:	f7ff fff2 	bl	803a014 <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY;
 803a030:	2302      	movs	r3, #2
 803a032:	7763      	strb	r3, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 803a034:	7923      	ldrb	r3, [r4, #4]
 803a036:	b9e3      	cbnz	r3, 803a072 <HAL_CRC_Init+0x5a>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 803a038:	6823      	ldr	r3, [r4, #0]
 803a03a:	4a13      	ldr	r2, [pc, #76]	; (803a088 <HAL_CRC_Init+0x70>)
 803a03c:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 803a03e:	689a      	ldr	r2, [r3, #8]
 803a040:	f022 0218 	bic.w	r2, r2, #24
 803a044:	609a      	str	r2, [r3, #8]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 803a046:	7962      	ldrb	r2, [r4, #5]
 803a048:	6823      	ldr	r3, [r4, #0]
 803a04a:	b9d2      	cbnz	r2, 803a082 <HAL_CRC_Init+0x6a>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 803a04c:	f04f 32ff 	mov.w	r2, #4294967295
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 803a050:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 803a052:	689a      	ldr	r2, [r3, #8]
 803a054:	6961      	ldr	r1, [r4, #20]
 803a056:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 803a05a:	430a      	orrs	r2, r1
 803a05c:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 803a05e:	689a      	ldr	r2, [r3, #8]
 803a060:	69a1      	ldr	r1, [r4, #24]
 803a062:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 803a066:	430a      	orrs	r2, r1
 803a068:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 803a06a:	2301      	movs	r3, #1
  return HAL_OK;
 803a06c:	2000      	movs	r0, #0
  hcrc->State = HAL_CRC_STATE_READY;
 803a06e:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 803a070:	e7d6      	b.n	803a020 <HAL_CRC_Init+0x8>
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 803a072:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 803a076:	4620      	mov	r0, r4
 803a078:	f000 f82c 	bl	803a0d4 <HAL_CRCEx_Polynomial_Set>
 803a07c:	2800      	cmp	r0, #0
 803a07e:	d0e2      	beq.n	803a046 <HAL_CRC_Init+0x2e>
 803a080:	e7cd      	b.n	803a01e <HAL_CRC_Init+0x6>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 803a082:	6922      	ldr	r2, [r4, #16]
 803a084:	e7e4      	b.n	803a050 <HAL_CRC_Init+0x38>
 803a086:	bf00      	nop
 803a088:	04c11db7 	.word	0x04c11db7

0803a08c <HAL_CRC_Calculate>:
{
 803a08c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  hcrc->State = HAL_CRC_STATE_BUSY;
 803a08e:	2502      	movs	r5, #2
 803a090:	7745      	strb	r5, [r0, #29]
  __HAL_CRC_DR_RESET(hcrc);
 803a092:	6805      	ldr	r5, [r0, #0]
{
 803a094:	4604      	mov	r4, r0
  __HAL_CRC_DR_RESET(hcrc);
 803a096:	68af      	ldr	r7, [r5, #8]
 803a098:	f047 0701 	orr.w	r7, r7, #1
 803a09c:	60af      	str	r7, [r5, #8]
  switch (hcrc->InputDataFormat)
 803a09e:	6a07      	ldr	r7, [r0, #32]
 803a0a0:	2f02      	cmp	r7, #2
 803a0a2:	d012      	beq.n	803a0ca <HAL_CRC_Calculate+0x3e>
 803a0a4:	2f03      	cmp	r7, #3
 803a0a6:	d004      	beq.n	803a0b2 <HAL_CRC_Calculate+0x26>
 803a0a8:	2f01      	cmp	r7, #1
 803a0aa:	d111      	bne.n	803a0d0 <HAL_CRC_Calculate+0x44>
      temp = CRC_Handle_8(hcrc, (uint8_t *)pBuffer, BufferLength);
 803a0ac:	f7ff ff66 	bl	8039f7c <CRC_Handle_8>
      break;
 803a0b0:	e004      	b.n	803a0bc <HAL_CRC_Calculate+0x30>
 803a0b2:	eb01 0682 	add.w	r6, r1, r2, lsl #2
      for (index = 0U; index < BufferLength; index++)
 803a0b6:	42b1      	cmp	r1, r6
 803a0b8:	d103      	bne.n	803a0c2 <HAL_CRC_Calculate+0x36>
      temp = hcrc->Instance->DR;
 803a0ba:	6828      	ldr	r0, [r5, #0]
  hcrc->State = HAL_CRC_STATE_READY;
 803a0bc:	2301      	movs	r3, #1
 803a0be:	7763      	strb	r3, [r4, #29]
}
 803a0c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        hcrc->Instance->DR = pBuffer[index];
 803a0c2:	f851 3b04 	ldr.w	r3, [r1], #4
 803a0c6:	602b      	str	r3, [r5, #0]
 803a0c8:	e7f5      	b.n	803a0b6 <HAL_CRC_Calculate+0x2a>
      temp = CRC_Handle_16(hcrc, (uint16_t *)(void *)pBuffer, BufferLength);    /* Derogation MisraC2012 R.11.5 */
 803a0ca:	f7ff ff8c 	bl	8039fe6 <CRC_Handle_16>
      break;
 803a0ce:	e7f5      	b.n	803a0bc <HAL_CRC_Calculate+0x30>
  uint32_t temp = 0U;  /* CRC output (read from hcrc->Instance->DR register) */
 803a0d0:	2000      	movs	r0, #0
 803a0d2:	e7f3      	b.n	803a0bc <HAL_CRC_Calculate+0x30>

0803a0d4 <HAL_CRCEx_Polynomial_Set>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 803a0d4:	231f      	movs	r3, #31
{
 803a0d6:	b510      	push	{r4, lr}
   * definition. HAL_ERROR is reported if Pol degree is
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 803a0d8:	f113 33ff 	adds.w	r3, r3, #4294967295
 803a0dc:	d306      	bcc.n	803a0ec <HAL_CRCEx_Polynomial_Set+0x18>
 803a0de:	fa21 f403 	lsr.w	r4, r1, r3
 803a0e2:	07e4      	lsls	r4, r4, #31
 803a0e4:	d5f8      	bpl.n	803a0d8 <HAL_CRCEx_Polynomial_Set+0x4>
  {
  }

  switch (PolyLength)
 803a0e6:	2a08      	cmp	r2, #8
 803a0e8:	d014      	beq.n	803a114 <HAL_CRCEx_Polynomial_Set+0x40>
 803a0ea:	d802      	bhi.n	803a0f2 <HAL_CRCEx_Polynomial_Set+0x1e>
 803a0ec:	b13a      	cbz	r2, 803a0fe <HAL_CRCEx_Polynomial_Set+0x2a>

    case CRC_POLYLENGTH_32B:
      /* no polynomial definition vs. polynomial length issue possible */
      break;
    default:
      status =  HAL_ERROR;
 803a0ee:	2001      	movs	r0, #1

    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
  }
  /* Return function status */
  return status;
 803a0f0:	e00d      	b.n	803a10e <HAL_CRCEx_Polynomial_Set+0x3a>
  switch (PolyLength)
 803a0f2:	2a10      	cmp	r2, #16
 803a0f4:	d00c      	beq.n	803a110 <HAL_CRCEx_Polynomial_Set+0x3c>
 803a0f6:	2a18      	cmp	r2, #24
 803a0f8:	d1f9      	bne.n	803a0ee <HAL_CRCEx_Polynomial_Set+0x1a>
      if (msb >= HAL_CRC_LENGTH_7B)
 803a0fa:	2b06      	cmp	r3, #6
      if (msb >= HAL_CRC_LENGTH_16B)
 803a0fc:	d8f7      	bhi.n	803a0ee <HAL_CRCEx_Polynomial_Set+0x1a>
    WRITE_REG(hcrc->Instance->POL, Pol);
 803a0fe:	6800      	ldr	r0, [r0, #0]
 803a100:	6141      	str	r1, [r0, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 803a102:	6883      	ldr	r3, [r0, #8]
 803a104:	f023 0318 	bic.w	r3, r3, #24
 803a108:	431a      	orrs	r2, r3
 803a10a:	6082      	str	r2, [r0, #8]
 803a10c:	2000      	movs	r0, #0
}
 803a10e:	bd10      	pop	{r4, pc}
      if (msb >= HAL_CRC_LENGTH_8B)
 803a110:	2b07      	cmp	r3, #7
 803a112:	e7f3      	b.n	803a0fc <HAL_CRCEx_Polynomial_Set+0x28>
      if (msb >= HAL_CRC_LENGTH_16B)
 803a114:	2b0f      	cmp	r3, #15
 803a116:	e7f1      	b.n	803a0fc <HAL_CRCEx_Polynomial_Set+0x28>

0803a118 <HAL_FLASH_EndOfOperationCallback>:
  UNUSED(ReturnValue);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
   */
}
 803a118:	4770      	bx	lr

0803a11a <HAL_FLASH_OperationErrorCallback>:
 803a11a:	4770      	bx	lr

0803a11c <HAL_FLASH_IRQHandler>:
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
 803a11c:	4a29      	ldr	r2, [pc, #164]	; (803a1c4 <HAL_FLASH_IRQHandler+0xa8>)
{
 803a11e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  type = (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK));
 803a122:	4c29      	ldr	r4, [pc, #164]	; (803a1c8 <HAL_FLASH_IRQHandler+0xac>)
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
 803a124:	6813      	ldr	r3, [r2, #0]
  type = (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK));
 803a126:	68a5      	ldr	r5, [r4, #8]
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
 803a128:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
  type = (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK));
 803a12c:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
 803a130:	f023 0305 	bic.w	r3, r3, #5
 803a134:	049b      	lsls	r3, r3, #18
  if(type == FLASH_TYPEERASE_PAGES)
 803a136:	2d02      	cmp	r5, #2
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
 803a138:	ea4f 4393 	mov.w	r3, r3, lsr #18
 803a13c:	4690      	mov	r8, r2
  if(type == FLASH_TYPEERASE_PAGES)
 803a13e:	d12f      	bne.n	803a1a0 <HAL_FLASH_IRQHandler+0x84>
    param = pFlash.Page;
 803a140:	6967      	ldr	r7, [r4, #20]
  CLEAR_BIT((*reg), type);
 803a142:	4e22      	ldr	r6, [pc, #136]	; (803a1cc <HAL_FLASH_IRQHandler+0xb0>)
 803a144:	6832      	ldr	r2, [r6, #0]
 803a146:	ea22 0205 	bic.w	r2, r2, r5
 803a14a:	6032      	str	r2, [r6, #0]
  if(error != 0U)
 803a14c:	b14b      	cbz	r3, 803a162 <HAL_FLASH_IRQHandler+0x46>
    pFlash.ErrorCode |= error;
 803a14e:	6862      	ldr	r2, [r4, #4]
    HAL_FLASH_OperationErrorCallback(param);
 803a150:	4638      	mov	r0, r7
    pFlash.ErrorCode |= error;
 803a152:	431a      	orrs	r2, r3
 803a154:	6062      	str	r2, [r4, #4]
    (*reg_sr) = error;
 803a156:	f8c8 3000 	str.w	r3, [r8]
    pFlash.ProcedureOnGoing = 0U;
 803a15a:	2300      	movs	r3, #0
 803a15c:	60a3      	str	r3, [r4, #8]
    HAL_FLASH_OperationErrorCallback(param);
 803a15e:	f7ff ffdc 	bl	803a11a <HAL_FLASH_OperationErrorCallback>
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
 803a162:	f8d8 3000 	ldr.w	r3, [r8]
 803a166:	07db      	lsls	r3, r3, #31
 803a168:	d511      	bpl.n	803a18e <HAL_FLASH_IRQHandler+0x72>
    (*reg_sr) = FLASH_FLAG_EOP;
 803a16a:	2301      	movs	r3, #1
    if(type == FLASH_TYPEERASE_PAGES)
 803a16c:	2d02      	cmp	r5, #2
    (*reg_sr) = FLASH_FLAG_EOP;
 803a16e:	f8c8 3000 	str.w	r3, [r8]
    if(type == FLASH_TYPEERASE_PAGES)
 803a172:	d124      	bne.n	803a1be <HAL_FLASH_IRQHandler+0xa2>
      pFlash.NbPagesToErase--;
 803a174:	69a3      	ldr	r3, [r4, #24]
 803a176:	3b01      	subs	r3, #1
 803a178:	61a3      	str	r3, [r4, #24]
      if(pFlash.NbPagesToErase != 0U)
 803a17a:	b1e3      	cbz	r3, 803a1b6 <HAL_FLASH_IRQHandler+0x9a>
        pFlash.Page++;
 803a17c:	6960      	ldr	r0, [r4, #20]
        FLASH_PageErase(pFlash.Page, pFlash.Bank);
 803a17e:	6921      	ldr	r1, [r4, #16]
        pFlash.Page++;
 803a180:	3001      	adds	r0, #1
 803a182:	6160      	str	r0, [r4, #20]
        FLASH_PageErase(pFlash.Page, pFlash.Bank);
 803a184:	f000 f8ce 	bl	803a324 <FLASH_PageErase>
    HAL_FLASH_EndOfOperationCallback(param);
 803a188:	4638      	mov	r0, r7
 803a18a:	f7ff ffc5 	bl	803a118 <HAL_FLASH_EndOfOperationCallback>
  if(pFlash.ProcedureOnGoing == 0U)
 803a18e:	68a2      	ldr	r2, [r4, #8]
 803a190:	b922      	cbnz	r2, 803a19c <HAL_FLASH_IRQHandler+0x80>
    (*reg) &= ~(FLASH_IT_EOP | FLASH_IT_OPERR);
 803a192:	6833      	ldr	r3, [r6, #0]
 803a194:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 803a198:	6033      	str	r3, [r6, #0]
    __HAL_UNLOCK(&pFlash);
 803a19a:	7022      	strb	r2, [r4, #0]
}
 803a19c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if(type == FLASH_TYPEERASE_MASSERASE)
 803a1a0:	f248 0204 	movw	r2, #32772	; 0x8004
 803a1a4:	4295      	cmp	r5, r2
 803a1a6:	d101      	bne.n	803a1ac <HAL_FLASH_IRQHandler+0x90>
    param = pFlash.Bank;
 803a1a8:	6927      	ldr	r7, [r4, #16]
 803a1aa:	e7ca      	b.n	803a142 <HAL_FLASH_IRQHandler+0x26>
  else if(type == FLASH_TYPEPROGRAM_DOUBLEWORD)
 803a1ac:	2d01      	cmp	r5, #1
    param = pFlash.Address;
 803a1ae:	bf0c      	ite	eq
 803a1b0:	68e7      	ldreq	r7, [r4, #12]
  uint32_t param = 0U;
 803a1b2:	2700      	movne	r7, #0
 803a1b4:	e7c5      	b.n	803a142 <HAL_FLASH_IRQHandler+0x26>
        pFlash.ProcedureOnGoing = 0U;
 803a1b6:	60a3      	str	r3, [r4, #8]
        param = 0xFFFFFFFFU;
 803a1b8:	f04f 37ff 	mov.w	r7, #4294967295
 803a1bc:	e7e4      	b.n	803a188 <HAL_FLASH_IRQHandler+0x6c>
      pFlash.ProcedureOnGoing = 0U;
 803a1be:	2300      	movs	r3, #0
 803a1c0:	60a3      	str	r3, [r4, #8]
 803a1c2:	e7e1      	b.n	803a188 <HAL_FLASH_IRQHandler+0x6c>
 803a1c4:	40022020 	.word	0x40022020
 803a1c8:	2000010c 	.word	0x2000010c
 803a1cc:	40022028 	.word	0x40022028

0803a1d0 <HAL_FLASH_Unlock>:
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  HAL_StatusTypeDef status = HAL_OK;

  if(READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 803a1d0:	4b06      	ldr	r3, [pc, #24]	; (803a1ec <HAL_FLASH_Unlock+0x1c>)
 803a1d2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 803a1d4:	2a00      	cmp	r2, #0
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY1);
 803a1d6:	bfbf      	itttt	lt
 803a1d8:	4a05      	ldrlt	r2, [pc, #20]	; (803a1f0 <HAL_FLASH_Unlock+0x20>)
 803a1da:	609a      	strlt	r2, [r3, #8]
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY2);
 803a1dc:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
 803a1e0:	609a      	strlt	r2, [r3, #8]

    /* verify Flash is unlocked */
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 803a1e2:	bfba      	itte	lt
 803a1e4:	6a98      	ldrlt	r0, [r3, #40]	; 0x28
  HAL_StatusTypeDef status = HAL_OK;
 803a1e6:	0fc0      	lsrlt	r0, r0, #31
 803a1e8:	2000      	movge	r0, #0
    }
  }
#endif

  return status;
}
 803a1ea:	4770      	bx	lr
 803a1ec:	40022000 	.word	0x40022000
 803a1f0:	45670123 	.word	0x45670123

0803a1f4 <HAL_FLASH_Lock>:
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
  HAL_StatusTypeDef status = HAL_ERROR;

  /* Set the LOCK Bit to lock the FLASH Registers access */
  SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
 803a1f4:	4b04      	ldr	r3, [pc, #16]	; (803a208 <HAL_FLASH_Lock+0x14>)
 803a1f6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 803a1f8:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 803a1fc:	629a      	str	r2, [r3, #40]	; 0x28

  /* verify Flash is locked */
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 803a1fe:	6a98      	ldr	r0, [r3, #40]	; 0x28
    }
  }
#endif

  return status;
}
 803a200:	43c0      	mvns	r0, r0
 803a202:	0fc0      	lsrs	r0, r0, #31
 803a204:	4770      	bx	lr
 803a206:	bf00      	nop
 803a208:	40022000 	.word	0x40022000

0803a20c <HAL_FLASH_GetError>:
  *            @arg HAL_FLASH_ERROR_OPTW: FLASH Option modification error
  */
uint32_t HAL_FLASH_GetError(void)
{
   return pFlash.ErrorCode;
}
 803a20c:	4b01      	ldr	r3, [pc, #4]	; (803a214 <HAL_FLASH_GetError+0x8>)
 803a20e:	6858      	ldr	r0, [r3, #4]
 803a210:	4770      	bx	lr
 803a212:	bf00      	nop
 803a214:	2000010c 	.word	0x2000010c

0803a218 <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
 803a218:	b570      	push	{r4, r5, r6, lr}
 803a21a:	4604      	mov	r4, r0
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */

  uint32_t timeout = HAL_GetTick() + Timeout;
 803a21c:	f7ff fe3a 	bl	8039e94 <HAL_GetTick>
  uint32_t error;
  __IO uint32_t *reg_sr;

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 803a220:	4d10      	ldr	r5, [pc, #64]	; (803a264 <FLASH_WaitForLastOperation+0x4c>)
  uint32_t timeout = HAL_GetTick() + Timeout;
 803a222:	1906      	adds	r6, r0, r4
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 803a224:	6a2b      	ldr	r3, [r5, #32]
 803a226:	03db      	lsls	r3, r3, #15
 803a228:	d40c      	bmi.n	803a244 <FLASH_WaitForLastOperation+0x2c>
  
  /* Access to SECSR or NSSR registers depends on operation type */
  reg_sr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECSR) : &(FLASH_NS->NSSR);

  /* Check FLASH operation error flags */
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 803a22a:	f242 02fa 	movw	r2, #8442	; 0x20fa
 803a22e:	490e      	ldr	r1, [pc, #56]	; (803a268 <FLASH_WaitForLastOperation+0x50>)
 803a230:	6808      	ldr	r0, [r1, #0]
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
#endif /* __ARM_FEATURE_CMSE */ 

  if(error != 0u)
 803a232:	4002      	ands	r2, r0
 803a234:	d00e      	beq.n	803a254 <FLASH_WaitForLastOperation+0x3c>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= error;
 803a236:	480d      	ldr	r0, [pc, #52]	; (803a26c <FLASH_WaitForLastOperation+0x54>)
 803a238:	6843      	ldr	r3, [r0, #4]
 803a23a:	4313      	orrs	r3, r2
 803a23c:	6043      	str	r3, [r0, #4]
    {
      FLASH->NSSR = FLASH_FLAG_OPTWERR;
    }
#endif /* __ARM_FEATURE_CMSE */

    return HAL_ERROR;
 803a23e:	2001      	movs	r0, #1
    (*reg_sr) = error;
 803a240:	600a      	str	r2, [r1, #0]
    (*reg_sr) = FLASH_FLAG_EOP;
  }

  /* If there is an error flag set */
  return HAL_OK;
}
 803a242:	bd70      	pop	{r4, r5, r6, pc}
    if(Timeout != HAL_MAX_DELAY)
 803a244:	1c62      	adds	r2, r4, #1
 803a246:	d0ed      	beq.n	803a224 <FLASH_WaitForLastOperation+0xc>
      if(HAL_GetTick() >= timeout)
 803a248:	f7ff fe24 	bl	8039e94 <HAL_GetTick>
 803a24c:	42b0      	cmp	r0, r6
 803a24e:	d3e9      	bcc.n	803a224 <FLASH_WaitForLastOperation+0xc>
        return HAL_TIMEOUT;
 803a250:	2003      	movs	r0, #3
 803a252:	e7f6      	b.n	803a242 <FLASH_WaitForLastOperation+0x2a>
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
 803a254:	6808      	ldr	r0, [r1, #0]
 803a256:	f010 0001 	ands.w	r0, r0, #1
 803a25a:	d0f2      	beq.n	803a242 <FLASH_WaitForLastOperation+0x2a>
    (*reg_sr) = FLASH_FLAG_EOP;
 803a25c:	2301      	movs	r3, #1
 803a25e:	4610      	mov	r0, r2
 803a260:	600b      	str	r3, [r1, #0]
 803a262:	e7ee      	b.n	803a242 <FLASH_WaitForLastOperation+0x2a>
 803a264:	40022000 	.word	0x40022000
 803a268:	40022020 	.word	0x40022020
 803a26c:	2000010c 	.word	0x2000010c

0803a270 <HAL_FLASH_Program>:
{
 803a270:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 803a274:	4c18      	ldr	r4, [pc, #96]	; (803a2d8 <HAL_FLASH_Program+0x68>)
{
 803a276:	461f      	mov	r7, r3
  __HAL_LOCK(&pFlash);
 803a278:	7823      	ldrb	r3, [r4, #0]
{
 803a27a:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 803a27c:	2b01      	cmp	r3, #1
{
 803a27e:	460e      	mov	r6, r1
 803a280:	4690      	mov	r8, r2
  __HAL_LOCK(&pFlash);
 803a282:	d027      	beq.n	803a2d4 <HAL_FLASH_Program+0x64>
 803a284:	2301      	movs	r3, #1
 803a286:	7023      	strb	r3, [r4, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 803a288:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 803a28a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 803a28e:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 803a290:	f7ff ffc2 	bl	803a218 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 803a294:	b9d0      	cbnz	r0, 803a2cc <HAL_FLASH_Program+0x5c>
    pFlash.ProcedureOnGoing = TypeProgram;
 803a296:	60a5      	str	r5, [r4, #8]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a298:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a29c:	b672      	cpsid	i
  /* Disable interrupts to avoid any interruption during the double word programming */
  primask_bit = __get_PRIMASK();
  __disable_irq();

  /* Set PG bit */
  SET_BIT((*reg), FLASH_NSCR_NSPG);
 803a29e:	4d0f      	ldr	r5, [pc, #60]	; (803a2dc <HAL_FLASH_Program+0x6c>)
 803a2a0:	6828      	ldr	r0, [r5, #0]
 803a2a2:	f040 0001 	orr.w	r0, r0, #1
 803a2a6:	6028      	str	r0, [r5, #0]

  /* Program first word */
  *(uint32_t*)Address = (uint32_t)Data;
 803a2a8:	f8c6 8000 	str.w	r8, [r6]
  __ASM volatile ("isb 0xF":::"memory");
 803a2ac:	f3bf 8f6f 	isb	sy
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(uint32_t*)(Address+4U) = (uint32_t)(Data >> 32U);
 803a2b0:	6077      	str	r7, [r6, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a2b2:	f381 8810 	msr	PRIMASK, r1
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 803a2b6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 803a2ba:	f7ff ffad 	bl	803a218 <FLASH_WaitForLastOperation>
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 803a2be:	68a2      	ldr	r2, [r4, #8]
 803a2c0:	682b      	ldr	r3, [r5, #0]
 803a2c2:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 803a2c6:	ea23 0302 	bic.w	r3, r3, r2
 803a2ca:	602b      	str	r3, [r5, #0]
  __HAL_UNLOCK(&pFlash);
 803a2cc:	2300      	movs	r3, #0
 803a2ce:	7023      	strb	r3, [r4, #0]
}
 803a2d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  __HAL_LOCK(&pFlash);
 803a2d4:	2002      	movs	r0, #2
 803a2d6:	e7fb      	b.n	803a2d0 <HAL_FLASH_Program+0x60>
 803a2d8:	2000010c 	.word	0x2000010c
 803a2dc:	40022028 	.word	0x40022028

0803a2e0 <FLASH_MassErase>:
#endif
  
  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);

  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) != 0U)
 803a2e0:	4b0e      	ldr	r3, [pc, #56]	; (803a31c <FLASH_MassErase+0x3c>)
 803a2e2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 803a2e4:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 803a2e8:	4b0d      	ldr	r3, [pc, #52]	; (803a320 <FLASH_MassErase+0x40>)
 803a2ea:	d010      	beq.n	803a30e <FLASH_MassErase+0x2e>
  {
    /* Check the parameters */
    assert_param(IS_FLASH_BANK(Banks));

    /* Set the Mass Erase Bit for the bank 1 if requested */
    if((Banks & FLASH_BANK_1) != 0U)
 803a2ec:	07c1      	lsls	r1, r0, #31
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER1);
 803a2ee:	bf42      	ittt	mi
 803a2f0:	681a      	ldrmi	r2, [r3, #0]
 803a2f2:	f042 0204 	orrmi.w	r2, r2, #4
 803a2f6:	601a      	strmi	r2, [r3, #0]
    }

    /* Set the Mass Erase Bit for the bank 2 if requested */
    if((Banks & FLASH_BANK_2) != 0U)
 803a2f8:	0782      	lsls	r2, r0, #30
 803a2fa:	d503      	bpl.n	803a304 <FLASH_MassErase+0x24>
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER2);
 803a2fc:	681a      	ldr	r2, [r3, #0]
 803a2fe:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    }
  }
  else
  {
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
 803a302:	601a      	str	r2, [r3, #0]
  }

  /* Proceed to erase all sectors */
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 803a304:	681a      	ldr	r2, [r3, #0]
 803a306:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 803a30a:	601a      	str	r2, [r3, #0]

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
#endif
}
 803a30c:	4770      	bx	lr
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
 803a30e:	681a      	ldr	r2, [r3, #0]
 803a310:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 803a314:	f042 0204 	orr.w	r2, r2, #4
 803a318:	e7f3      	b.n	803a302 <FLASH_MassErase+0x22>
 803a31a:	bf00      	nop
 803a31c:	40022000 	.word	0x40022000
 803a320:	40022028 	.word	0x40022028

0803a324 <FLASH_PageErase>:
#endif

  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);

  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
 803a324:	4b0f      	ldr	r3, [pc, #60]	; (803a364 <FLASH_PageErase+0x40>)
 803a326:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 803a328:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 803a32c:	4b0e      	ldr	r3, [pc, #56]	; (803a368 <FLASH_PageErase+0x44>)
 803a32e:	d112      	bne.n	803a356 <FLASH_PageErase+0x32>
  {
    CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 803a330:	6819      	ldr	r1, [r3, #0]
  {
    assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

    if((Banks & FLASH_BANK_1) != 0U)
    {
      CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 803a332:	f421 6100 	bic.w	r1, r1, #2048	; 0x800
    }
    else
    {
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
 803a336:	6019      	str	r1, [r3, #0]
    }
  }

  /* Proceed to erase the page */
  MODIFY_REG((*reg), (FLASH_NSCR_NSPNB | FLASH_NSCR_NSPER), ((Page << FLASH_NSCR_NSPNB_Pos) | FLASH_NSCR_NSPER));
 803a338:	681a      	ldr	r2, [r3, #0]
 803a33a:	f422 727e 	bic.w	r2, r2, #1016	; 0x3f8
 803a33e:	f022 0202 	bic.w	r2, r2, #2
 803a342:	f042 0202 	orr.w	r2, r2, #2
 803a346:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
 803a34a:	6018      	str	r0, [r3, #0]
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 803a34c:	681a      	ldr	r2, [r3, #0]
 803a34e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 803a352:	601a      	str	r2, [r3, #0]

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
#endif
}
 803a354:	4770      	bx	lr
    if((Banks & FLASH_BANK_1) != 0U)
 803a356:	f011 0f01 	tst.w	r1, #1
      CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 803a35a:	6819      	ldr	r1, [r3, #0]
    if((Banks & FLASH_BANK_1) != 0U)
 803a35c:	d1e9      	bne.n	803a332 <FLASH_PageErase+0xe>
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
 803a35e:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 803a362:	e7e8      	b.n	803a336 <FLASH_PageErase+0x12>
 803a364:	40022000 	.word	0x40022000
 803a368:	40022028 	.word	0x40022028

0803a36c <HAL_FLASHEx_Erase>:
{
 803a36c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 803a370:	4c23      	ldr	r4, [pc, #140]	; (803a400 <HAL_FLASHEx_Erase+0x94>)
{
 803a372:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 803a374:	7823      	ldrb	r3, [r4, #0]
{
 803a376:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 803a378:	2b01      	cmp	r3, #1
 803a37a:	d03e      	beq.n	803a3fa <HAL_FLASHEx_Erase+0x8e>
 803a37c:	2301      	movs	r3, #1
 803a37e:	7023      	strb	r3, [r4, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 803a380:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 803a382:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 803a386:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 803a388:	f7ff ff46 	bl	803a218 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 803a38c:	4606      	mov	r6, r0
 803a38e:	b9b8      	cbnz	r0, 803a3c0 <HAL_FLASHEx_Erase+0x54>
    if ((pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
 803a390:	f248 0204 	movw	r2, #32772	; 0x8004
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 803a394:	682b      	ldr	r3, [r5, #0]
 803a396:	60a3      	str	r3, [r4, #8]
    if ((pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
 803a398:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 803a39c:	4293      	cmp	r3, r2
 803a39e:	d114      	bne.n	803a3ca <HAL_FLASHEx_Erase+0x5e>
      FLASH_MassErase(pEraseInit->Banks);
 803a3a0:	6868      	ldr	r0, [r5, #4]
 803a3a2:	f7ff ff9d 	bl	803a2e0 <FLASH_MassErase>
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 803a3a6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 803a3aa:	f7ff ff35 	bl	803a218 <FLASH_WaitForLastOperation>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 803a3ae:	4606      	mov	r6, r0
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 803a3b0:	4914      	ldr	r1, [pc, #80]	; (803a404 <HAL_FLASHEx_Erase+0x98>)
 803a3b2:	68a2      	ldr	r2, [r4, #8]
 803a3b4:	680b      	ldr	r3, [r1, #0]
 803a3b6:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 803a3ba:	ea23 0302 	bic.w	r3, r3, r2
 803a3be:	600b      	str	r3, [r1, #0]
  __HAL_UNLOCK(&pFlash);
 803a3c0:	2300      	movs	r3, #0
 803a3c2:	7023      	strb	r3, [r4, #0]
}
 803a3c4:	4630      	mov	r0, r6
 803a3c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *PageError = 0xFFFFFFFFU;
 803a3ca:	f04f 33ff 	mov.w	r3, #4294967295
 803a3ce:	f8c8 3000 	str.w	r3, [r8]
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 803a3d2:	68af      	ldr	r7, [r5, #8]
 803a3d4:	e9d5 3202 	ldrd	r3, r2, [r5, #8]
 803a3d8:	4413      	add	r3, r2
 803a3da:	42bb      	cmp	r3, r7
 803a3dc:	d9e8      	bls.n	803a3b0 <HAL_FLASHEx_Erase+0x44>
        FLASH_PageErase(page_index, pEraseInit->Banks);
 803a3de:	4638      	mov	r0, r7
 803a3e0:	6869      	ldr	r1, [r5, #4]
 803a3e2:	f7ff ff9f 	bl	803a324 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 803a3e6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 803a3ea:	f7ff ff15 	bl	803a218 <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 803a3ee:	b110      	cbz	r0, 803a3f6 <HAL_FLASHEx_Erase+0x8a>
          *PageError = page_index;
 803a3f0:	f8c8 7000 	str.w	r7, [r8]
 803a3f4:	e7db      	b.n	803a3ae <HAL_FLASHEx_Erase+0x42>
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 803a3f6:	3701      	adds	r7, #1
 803a3f8:	e7ec      	b.n	803a3d4 <HAL_FLASHEx_Erase+0x68>
  __HAL_LOCK(&pFlash);
 803a3fa:	2602      	movs	r6, #2
 803a3fc:	e7e2      	b.n	803a3c4 <HAL_FLASHEx_Erase+0x58>
 803a3fe:	bf00      	nop
 803a400:	2000010c 	.word	0x2000010c
 803a404:	40022028 	.word	0x40022028

0803a408 <HAL_GPIO_Init>:
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0U;
 803a408:	2300      	movs	r3, #0
{
 803a40a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
        EXTI->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 803a40e:	4a5f      	ldr	r2, [pc, #380]	; (803a58c <HAL_GPIO_Init+0x184>)
  while (((GPIO_Init->Pin) >> position) != 0U)
 803a410:	f8d1 8000 	ldr.w	r8, [r1]
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 803a414:	f8df 917c 	ldr.w	r9, [pc, #380]	; 803a594 <HAL_GPIO_Init+0x18c>
  while (((GPIO_Init->Pin) >> position) != 0U)
 803a418:	fa38 f403 	lsrs.w	r4, r8, r3
 803a41c:	d101      	bne.n	803a422 <HAL_GPIO_Init+0x1a>
      }
    }

    position++;
  }
}
 803a41e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 803a422:	f04f 0c01 	mov.w	ip, #1
 803a426:	fa0c fc03 	lsl.w	ip, ip, r3
    if(iocurrent != 0U)
 803a42a:	ea1c 0608 	ands.w	r6, ip, r8
 803a42e:	f000 809f 	beq.w	803a570 <HAL_GPIO_Init+0x168>
 803a432:	2503      	movs	r5, #3
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 803a434:	684c      	ldr	r4, [r1, #4]
 803a436:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 803a43a:	f024 0a10 	bic.w	sl, r4, #16
 803a43e:	f10a 37ff 	add.w	r7, sl, #4294967295
 803a442:	fa05 f50e 	lsl.w	r5, r5, lr
 803a446:	2f01      	cmp	r7, #1
 803a448:	ea6f 0505 	mvn.w	r5, r5
 803a44c:	d811      	bhi.n	803a472 <HAL_GPIO_Init+0x6a>
        temp = GPIOx->OSPEEDR;
 803a44e:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 803a450:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
 803a454:	68cf      	ldr	r7, [r1, #12]
 803a456:	fa07 f70e 	lsl.w	r7, r7, lr
 803a45a:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->OSPEEDR = temp;
 803a45e:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 803a460:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 803a462:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 803a466:	f3c4 1700 	ubfx	r7, r4, #4, #1
 803a46a:	409f      	lsls	r7, r3
 803a46c:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->OTYPER = temp;
 803a470:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 803a472:	68c7      	ldr	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 803a474:	f1ba 0f02 	cmp.w	sl, #2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 803a478:	ea07 0c05 	and.w	ip, r7, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 803a47c:	688f      	ldr	r7, [r1, #8]
 803a47e:	fa07 f70e 	lsl.w	r7, r7, lr
 803a482:	ea47 070c 	orr.w	r7, r7, ip
      GPIOx->PUPDR = temp;
 803a486:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 803a488:	d116      	bne.n	803a4b8 <HAL_GPIO_Init+0xb0>
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 803a48a:	f04f 0c0f 	mov.w	ip, #15
        temp = GPIOx->AFR[position >> 3U];
 803a48e:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 803a492:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 803a496:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 803a49a:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 803a49e:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 803a4a2:	fa0c fc0b 	lsl.w	ip, ip, fp
 803a4a6:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 803a4aa:	690f      	ldr	r7, [r1, #16]
 803a4ac:	fa07 f70b 	lsl.w	r7, r7, fp
 803a4b0:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->AFR[position >> 3U] = temp;
 803a4b4:	f8ca 7020 	str.w	r7, [sl, #32]
      temp = GPIOx->MODER;
 803a4b8:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 803a4ba:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 803a4bc:	f004 0703 	and.w	r7, r4, #3
 803a4c0:	fa07 fe0e 	lsl.w	lr, r7, lr
 803a4c4:	ea4e 0505 	orr.w	r5, lr, r5
      GPIOx->MODER = temp;
 803a4c8:	6005      	str	r5, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 803a4ca:	00e5      	lsls	r5, r4, #3
 803a4cc:	d550      	bpl.n	803a570 <HAL_GPIO_Init+0x168>
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 803a4ce:	f04f 0c0f 	mov.w	ip, #15
 803a4d2:	f023 0703 	bic.w	r7, r3, #3
 803a4d6:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 803a4da:	f507 373d 	add.w	r7, r7, #193536	; 0x2f400
 803a4de:	f003 0e03 	and.w	lr, r3, #3
        temp = EXTI->EXTICR[position >> 2U];
 803a4e2:	6e3d      	ldr	r5, [r7, #96]	; 0x60
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 803a4e4:	ea4f 0ece 	mov.w	lr, lr, lsl #3
 803a4e8:	fa0c fc0e 	lsl.w	ip, ip, lr
 803a4ec:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 803a4f0:	4d27      	ldr	r5, [pc, #156]	; (803a590 <HAL_GPIO_Init+0x188>)
 803a4f2:	42a8      	cmp	r0, r5
 803a4f4:	d03e      	beq.n	803a574 <HAL_GPIO_Init+0x16c>
 803a4f6:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 803a4fa:	42a8      	cmp	r0, r5
 803a4fc:	d03c      	beq.n	803a578 <HAL_GPIO_Init+0x170>
 803a4fe:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 803a502:	42a8      	cmp	r0, r5
 803a504:	d03a      	beq.n	803a57c <HAL_GPIO_Init+0x174>
 803a506:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 803a50a:	42a8      	cmp	r0, r5
 803a50c:	d038      	beq.n	803a580 <HAL_GPIO_Init+0x178>
 803a50e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 803a512:	42a8      	cmp	r0, r5
 803a514:	d036      	beq.n	803a584 <HAL_GPIO_Init+0x17c>
 803a516:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 803a51a:	42a8      	cmp	r0, r5
 803a51c:	d034      	beq.n	803a588 <HAL_GPIO_Init+0x180>
 803a51e:	4548      	cmp	r0, r9
 803a520:	bf14      	ite	ne
 803a522:	2507      	movne	r5, #7
 803a524:	2506      	moveq	r5, #6
 803a526:	fa05 f50e 	lsl.w	r5, r5, lr
 803a52a:	ea45 050c 	orr.w	r5, r5, ip
        EXTI->EXTICR[position >> 2U] = temp;
 803a52e:	663d      	str	r5, [r7, #96]	; 0x60
        temp &= ~(iocurrent);
 803a530:	43f7      	mvns	r7, r6
        temp = EXTI->IMR1;
 803a532:	f8d2 5080 	ldr.w	r5, [r2, #128]	; 0x80
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 803a536:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~(iocurrent);
 803a53a:	bf0c      	ite	eq
 803a53c:	403d      	andeq	r5, r7
          temp |= iocurrent;
 803a53e:	4335      	orrne	r5, r6
        EXTI->IMR1 = temp;
 803a540:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
        temp = EXTI->EMR1;
 803a544:	f8d2 5084 	ldr.w	r5, [r2, #132]	; 0x84
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 803a548:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~(iocurrent);
 803a54c:	bf0c      	ite	eq
 803a54e:	403d      	andeq	r5, r7
          temp |= iocurrent;
 803a550:	4335      	orrne	r5, r6
        EXTI->EMR1 = temp;
 803a552:	f8c2 5084 	str.w	r5, [r2, #132]	; 0x84
        temp = EXTI->RTSR1;
 803a556:	6815      	ldr	r5, [r2, #0]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 803a558:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~(iocurrent);
 803a55c:	bf0c      	ite	eq
 803a55e:	403d      	andeq	r5, r7
          temp |= iocurrent;
 803a560:	4335      	orrne	r5, r6
        EXTI->RTSR1 = temp;
 803a562:	6015      	str	r5, [r2, #0]
        temp = EXTI->FTSR1;
 803a564:	6855      	ldr	r5, [r2, #4]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 803a566:	02a4      	lsls	r4, r4, #10
        temp &= ~(iocurrent);
 803a568:	bf54      	ite	pl
 803a56a:	403d      	andpl	r5, r7
          temp |= iocurrent;
 803a56c:	4335      	orrmi	r5, r6
        EXTI->FTSR1 = temp;
 803a56e:	6055      	str	r5, [r2, #4]
    position++;
 803a570:	3301      	adds	r3, #1
 803a572:	e751      	b.n	803a418 <HAL_GPIO_Init+0x10>
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 803a574:	2500      	movs	r5, #0
 803a576:	e7d6      	b.n	803a526 <HAL_GPIO_Init+0x11e>
 803a578:	2501      	movs	r5, #1
 803a57a:	e7d4      	b.n	803a526 <HAL_GPIO_Init+0x11e>
 803a57c:	2502      	movs	r5, #2
 803a57e:	e7d2      	b.n	803a526 <HAL_GPIO_Init+0x11e>
 803a580:	2503      	movs	r5, #3
 803a582:	e7d0      	b.n	803a526 <HAL_GPIO_Init+0x11e>
 803a584:	2504      	movs	r5, #4
 803a586:	e7ce      	b.n	803a526 <HAL_GPIO_Init+0x11e>
 803a588:	2505      	movs	r5, #5
 803a58a:	e7cc      	b.n	803a526 <HAL_GPIO_Init+0x11e>
 803a58c:	4002f400 	.word	0x4002f400
 803a590:	42020000 	.word	0x42020000
 803a594:	42021800 	.word	0x42021800

0803a598 <HAL_PWREx_EnableVddIO2>:
  * @note  Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply is present.
  * @retval None
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_IOSV);
 803a598:	4a02      	ldr	r2, [pc, #8]	; (803a5a4 <HAL_PWREx_EnableVddIO2+0xc>)
 803a59a:	6853      	ldr	r3, [r2, #4]
 803a59c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 803a5a0:	6053      	str	r3, [r2, #4]
}
 803a5a2:	4770      	bx	lr
 803a5a4:	40007000 	.word	0x40007000

0803a5a8 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t msirange = 0U, sysclockfreq = 0U;
  uint32_t pllvco, pllsource, pllr, pllm;    /* no init needed */
  uint32_t sysclk_source, pll_oscsource;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 803a5a8:	4b23      	ldr	r3, [pc, #140]	; (803a638 <HAL_RCC_GetSysClockFreq+0x90>)
 803a5aa:	689a      	ldr	r2, [r3, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 803a5ac:	68d9      	ldr	r1, [r3, #12]

  if ((sysclk_source == RCC_CFGR_SWS_MSI) ||
 803a5ae:	f012 020c 	ands.w	r2, r2, #12
 803a5b2:	d005      	beq.n	803a5c0 <HAL_RCC_GetSysClockFreq+0x18>
 803a5b4:	2a0c      	cmp	r2, #12
 803a5b6:	d115      	bne.n	803a5e4 <HAL_RCC_GetSysClockFreq+0x3c>
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 803a5b8:	f001 0103 	and.w	r1, r1, #3
      ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 803a5bc:	2901      	cmp	r1, #1
 803a5be:	d118      	bne.n	803a5f2 <HAL_RCC_GetSysClockFreq+0x4a>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 803a5c0:	6819      	ldr	r1, [r3, #0]
    {
      /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
    }
    /*MSI frequency range in Hz*/
    msirange = MSIRangeTable[msirange];
 803a5c2:	481e      	ldr	r0, [pc, #120]	; (803a63c <HAL_RCC_GetSysClockFreq+0x94>)
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 803a5c4:	0709      	lsls	r1, r1, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 803a5c6:	bf55      	itete	pl
 803a5c8:	f8d3 1094 	ldrpl.w	r1, [r3, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 803a5cc:	6819      	ldrmi	r1, [r3, #0]
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 803a5ce:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 803a5d2:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
    msirange = MSIRangeTable[msirange];
 803a5d6:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]

    if (sysclk_source == RCC_CFGR_SWS_MSI)
 803a5da:	b112      	cbz	r2, 803a5e2 <HAL_RCC_GetSysClockFreq+0x3a>
  else
  {
    /* unexpected case: sysclockfreq at 0 */
  }

  if (sysclk_source == RCC_CFGR_SWS_PLL)
 803a5dc:	2a0c      	cmp	r2, #12
 803a5de:	d009      	beq.n	803a5f4 <HAL_RCC_GetSysClockFreq+0x4c>
 803a5e0:	2000      	movs	r0, #0
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
    sysclockfreq = pllvco / pllr;
  }

  return sysclockfreq;
}
 803a5e2:	4770      	bx	lr
  else if (sysclk_source == RCC_CFGR_SWS_HSI)
 803a5e4:	2a04      	cmp	r2, #4
 803a5e6:	d024      	beq.n	803a632 <HAL_RCC_GetSysClockFreq+0x8a>
  else if (sysclk_source == RCC_CFGR_SWS_HSE)
 803a5e8:	2a08      	cmp	r2, #8
 803a5ea:	4815      	ldr	r0, [pc, #84]	; (803a640 <HAL_RCC_GetSysClockFreq+0x98>)
 803a5ec:	bf18      	it	ne
 803a5ee:	2000      	movne	r0, #0
 803a5f0:	4770      	bx	lr
  uint32_t msirange = 0U, sysclockfreq = 0U;
 803a5f2:	2000      	movs	r0, #0
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 803a5f4:	68d9      	ldr	r1, [r3, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 803a5f6:	68da      	ldr	r2, [r3, #12]
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 803a5f8:	f001 0103 	and.w	r1, r1, #3
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 803a5fc:	f3c2 1203 	ubfx	r2, r2, #4, #4
    switch (pllsource)
 803a600:	2902      	cmp	r1, #2
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 803a602:	f102 0201 	add.w	r2, r2, #1
    switch (pllsource)
 803a606:	d005      	beq.n	803a614 <HAL_RCC_GetSysClockFreq+0x6c>
 803a608:	2903      	cmp	r1, #3
 803a60a:	d003      	beq.n	803a614 <HAL_RCC_GetSysClockFreq+0x6c>
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 803a60c:	68d9      	ldr	r1, [r3, #12]
 803a60e:	f3c1 2106 	ubfx	r1, r1, #8, #7
 803a612:	e003      	b.n	803a61c <HAL_RCC_GetSysClockFreq+0x74>
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 803a614:	68d9      	ldr	r1, [r3, #12]
 803a616:	480a      	ldr	r0, [pc, #40]	; (803a640 <HAL_RCC_GetSysClockFreq+0x98>)
 803a618:	f3c1 2106 	ubfx	r1, r1, #8, #7
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 803a61c:	fbb0 f0f2 	udiv	r0, r0, r2
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 803a620:	68db      	ldr	r3, [r3, #12]
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 803a622:	4348      	muls	r0, r1
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 803a624:	f3c3 6341 	ubfx	r3, r3, #25, #2
 803a628:	3301      	adds	r3, #1
 803a62a:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco / pllr;
 803a62c:	fbb0 f0f3 	udiv	r0, r0, r3
 803a630:	4770      	bx	lr
 803a632:	4803      	ldr	r0, [pc, #12]	; (803a640 <HAL_RCC_GetSysClockFreq+0x98>)
 803a634:	4770      	bx	lr
 803a636:	bf00      	nop
 803a638:	40021000 	.word	0x40021000
 803a63c:	0803df3c 	.word	0x0803df3c
 803a640:	00f42400 	.word	0x00f42400

0803a644 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 803a644:	b508      	push	{r3, lr}
  SystemCoreClockUpdate();
 803a646:	f7fe fd2f 	bl	80390a8 <SystemCoreClockUpdate>
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 803a64a:	4b05      	ldr	r3, [pc, #20]	; (803a660 <HAL_RCC_GetPCLK1Freq+0x1c>)
 803a64c:	4a05      	ldr	r2, [pc, #20]	; (803a664 <HAL_RCC_GetPCLK1Freq+0x20>)
 803a64e:	689b      	ldr	r3, [r3, #8]
 803a650:	f3c3 2302 	ubfx	r3, r3, #8, #3
 803a654:	5cd3      	ldrb	r3, [r2, r3]
 803a656:	4a04      	ldr	r2, [pc, #16]	; (803a668 <HAL_RCC_GetPCLK1Freq+0x24>)
 803a658:	6810      	ldr	r0, [r2, #0]
}
 803a65a:	40d8      	lsrs	r0, r3
 803a65c:	bd08      	pop	{r3, pc}
 803a65e:	bf00      	nop
 803a660:	40021000 	.word	0x40021000
 803a664:	0803df32 	.word	0x0803df32
 803a668:	20000100 	.word	0x20000100

0803a66c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 803a66c:	b508      	push	{r3, lr}
  SystemCoreClockUpdate();
 803a66e:	f7fe fd1b 	bl	80390a8 <SystemCoreClockUpdate>
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 803a672:	4b05      	ldr	r3, [pc, #20]	; (803a688 <HAL_RCC_GetPCLK2Freq+0x1c>)
 803a674:	4a05      	ldr	r2, [pc, #20]	; (803a68c <HAL_RCC_GetPCLK2Freq+0x20>)
 803a676:	689b      	ldr	r3, [r3, #8]
 803a678:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 803a67c:	5cd3      	ldrb	r3, [r2, r3]
 803a67e:	4a04      	ldr	r2, [pc, #16]	; (803a690 <HAL_RCC_GetPCLK2Freq+0x24>)
 803a680:	6810      	ldr	r0, [r2, #0]
}
 803a682:	40d8      	lsrs	r0, r3
 803a684:	bd08      	pop	{r3, pc}
 803a686:	bf00      	nop
 803a688:	40021000 	.word	0x40021000
 803a68c:	0803df32 	.word	0x0803df32
 803a690:	20000100 	.word	0x20000100
 803a694:	00000000 	.word	0x00000000

0803a698 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 803a698:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
 803a69c:	4604      	mov	r4, r0
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 803a69e:	6803      	ldr	r3, [r0, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 803a6a0:	69c1      	ldr	r1, [r0, #28]
 803a6a2:	6882      	ldr	r2, [r0, #8]
 803a6a4:	6900      	ldr	r0, [r0, #16]
  tmpreg |= (uint32_t)huart->FifoMode;
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 803a6a6:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 803a6a8:	4302      	orrs	r2, r0
 803a6aa:	6960      	ldr	r0, [r4, #20]
 803a6ac:	4302      	orrs	r2, r0
  tmpreg |= (uint32_t)huart->FifoMode;
 803a6ae:	6e60      	ldr	r0, [r4, #100]	; 0x64
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 803a6b0:	430a      	orrs	r2, r1
  tmpreg |= (uint32_t)huart->FifoMode;
 803a6b2:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 803a6b4:	48ad      	ldr	r0, [pc, #692]	; (803a96c <UART_SetConfig+0x2d4>)
 803a6b6:	4028      	ands	r0, r5
 803a6b8:	4302      	orrs	r2, r0
 803a6ba:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 803a6bc:	685a      	ldr	r2, [r3, #4]
 803a6be:	68e0      	ldr	r0, [r4, #12]
 803a6c0:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 803a6c4:	4302      	orrs	r2, r0
 803a6c6:	605a      	str	r2, [r3, #4]
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 803a6c8:	4aa9      	ldr	r2, [pc, #676]	; (803a970 <UART_SetConfig+0x2d8>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 803a6ca:	69a0      	ldr	r0, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 803a6cc:	4293      	cmp	r3, r2
  {
    tmpreg |= huart->Init.OneBitSampling;
 803a6ce:	bf1c      	itt	ne
 803a6d0:	6a22      	ldrne	r2, [r4, #32]
 803a6d2:	4310      	orrne	r0, r2
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 803a6d4:	689a      	ldr	r2, [r3, #8]
 803a6d6:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 803a6da:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 803a6de:	4302      	orrs	r2, r0
 803a6e0:	609a      	str	r2, [r3, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 803a6e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 803a6e4:	6a60      	ldr	r0, [r4, #36]	; 0x24
 803a6e6:	f022 020f 	bic.w	r2, r2, #15
 803a6ea:	4302      	orrs	r2, r0
 803a6ec:	62da      	str	r2, [r3, #44]	; 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 803a6ee:	4aa1      	ldr	r2, [pc, #644]	; (803a974 <UART_SetConfig+0x2dc>)
 803a6f0:	4293      	cmp	r3, r2
 803a6f2:	d118      	bne.n	803a726 <UART_SetConfig+0x8e>
 803a6f4:	4ba0      	ldr	r3, [pc, #640]	; (803a978 <UART_SetConfig+0x2e0>)
 803a6f6:	4aa1      	ldr	r2, [pc, #644]	; (803a97c <UART_SetConfig+0x2e4>)
 803a6f8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 803a6fc:	f003 0303 	and.w	r3, r3, #3
        }
      } /*   if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) || (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (lpuart_ker_ck_pres != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803a700:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 803a704:	5cd3      	ldrb	r3, [r2, r3]
 803a706:	f040 8498 	bne.w	803b03a <UART_SetConfig+0x9a2>
  {
    switch (clocksource)
 803a70a:	2b08      	cmp	r3, #8
 803a70c:	f200 82a7 	bhi.w	803ac5e <UART_SetConfig+0x5c6>
 803a710:	e8df f013 	tbh	[pc, r3, lsl #1]
 803a714:	02550461 	.word	0x02550461
 803a718:	02a503b9 	.word	0x02a503b9
 803a71c:	02a50429 	.word	0x02a50429
 803a720:	02a502a5 	.word	0x02a502a5
 803a724:	0430      	.short	0x0430
  UART_GETCLOCKSOURCE(huart, clocksource);
 803a726:	4a96      	ldr	r2, [pc, #600]	; (803a980 <UART_SetConfig+0x2e8>)
 803a728:	4293      	cmp	r3, r2
 803a72a:	d106      	bne.n	803a73a <UART_SetConfig+0xa2>
 803a72c:	4b92      	ldr	r3, [pc, #584]	; (803a978 <UART_SetConfig+0x2e0>)
 803a72e:	4a95      	ldr	r2, [pc, #596]	; (803a984 <UART_SetConfig+0x2ec>)
 803a730:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 803a734:	f003 030c 	and.w	r3, r3, #12
 803a738:	e7e2      	b.n	803a700 <UART_SetConfig+0x68>
 803a73a:	4a93      	ldr	r2, [pc, #588]	; (803a988 <UART_SetConfig+0x2f0>)
 803a73c:	4293      	cmp	r3, r2
 803a73e:	d144      	bne.n	803a7ca <UART_SetConfig+0x132>
 803a740:	f502 32e4 	add.w	r2, r2, #116736	; 0x1c800
 803a744:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 803a748:	f002 0230 	and.w	r2, r2, #48	; 0x30
 803a74c:	2a10      	cmp	r2, #16
 803a74e:	f000 8402 	beq.w	803af56 <UART_SetConfig+0x8be>
 803a752:	d82a      	bhi.n	803a7aa <UART_SetConfig+0x112>
 803a754:	bb7a      	cbnz	r2, 803a7b6 <UART_SetConfig+0x11e>
  if (UART_INSTANCE_LOWPOWER(huart))
 803a756:	4a86      	ldr	r2, [pc, #536]	; (803a970 <UART_SetConfig+0x2d8>)
 803a758:	4293      	cmp	r3, r2
 803a75a:	f040 8438 	bne.w	803afce <UART_SetConfig+0x936>
        lpuart_ker_ck_pres = (HAL_RCC_GetPCLK1Freq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803a75e:	f7ff ff71 	bl	803a644 <HAL_RCC_GetPCLK1Freq>
 803a762:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803a764:	2b00      	cmp	r3, #0
 803a766:	d06c      	beq.n	803a842 <UART_SetConfig+0x1aa>
 803a768:	2b01      	cmp	r3, #1
 803a76a:	d06c      	beq.n	803a846 <UART_SetConfig+0x1ae>
 803a76c:	2b02      	cmp	r3, #2
 803a76e:	d06c      	beq.n	803a84a <UART_SetConfig+0x1b2>
 803a770:	2b03      	cmp	r3, #3
 803a772:	d06c      	beq.n	803a84e <UART_SetConfig+0x1b6>
 803a774:	2b04      	cmp	r3, #4
 803a776:	d06c      	beq.n	803a852 <UART_SetConfig+0x1ba>
 803a778:	2b05      	cmp	r3, #5
 803a77a:	d06c      	beq.n	803a856 <UART_SetConfig+0x1be>
 803a77c:	2b06      	cmp	r3, #6
 803a77e:	d06c      	beq.n	803a85a <UART_SetConfig+0x1c2>
 803a780:	2b07      	cmp	r3, #7
 803a782:	d06c      	beq.n	803a85e <UART_SetConfig+0x1c6>
 803a784:	2b08      	cmp	r3, #8
 803a786:	d06c      	beq.n	803a862 <UART_SetConfig+0x1ca>
 803a788:	2b09      	cmp	r3, #9
 803a78a:	d06c      	beq.n	803a866 <UART_SetConfig+0x1ce>
 803a78c:	2b0a      	cmp	r3, #10
 803a78e:	d06c      	beq.n	803a86a <UART_SetConfig+0x1d2>
 803a790:	2b0b      	cmp	r3, #11
 803a792:	bf14      	ite	ne
 803a794:	2301      	movne	r3, #1
 803a796:	f44f 7380 	moveq.w	r3, #256	; 0x100
 803a79a:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 803a79e:	2100      	movs	r1, #0
    if (lpuart_ker_ck_pres != 0U)
 803a7a0:	2800      	cmp	r0, #0
 803a7a2:	f040 8083 	bne.w	803a8ac <UART_SetConfig+0x214>
 803a7a6:	4602      	mov	r2, r0
 803a7a8:	e087      	b.n	803a8ba <UART_SetConfig+0x222>
  UART_GETCLOCKSOURCE(huart, clocksource);
 803a7aa:	2a20      	cmp	r2, #32
 803a7ac:	f000 8363 	beq.w	803ae76 <UART_SetConfig+0x7de>
 803a7b0:	2a30      	cmp	r2, #48	; 0x30
 803a7b2:	f000 83a5 	beq.w	803af00 <UART_SetConfig+0x868>
  if (UART_INSTANCE_LOWPOWER(huart))
 803a7b6:	4a6e      	ldr	r2, [pc, #440]	; (803a970 <UART_SetConfig+0x2d8>)
 803a7b8:	4293      	cmp	r3, r2
 803a7ba:	d07d      	beq.n	803a8b8 <UART_SetConfig+0x220>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803a7bc:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 803a7c0:	f000 824d 	beq.w	803ac5e <UART_SetConfig+0x5c6>
        break;
      case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
        break;
      default:
        ret = HAL_ERROR;
 803a7c4:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 803a7c6:	2300      	movs	r3, #0
 803a7c8:	e2db      	b.n	803ad82 <UART_SetConfig+0x6ea>
  UART_GETCLOCKSOURCE(huart, clocksource);
 803a7ca:	4a70      	ldr	r2, [pc, #448]	; (803a98c <UART_SetConfig+0x2f4>)
 803a7cc:	4293      	cmp	r3, r2
 803a7ce:	d10e      	bne.n	803a7ee <UART_SetConfig+0x156>
 803a7d0:	f502 32e2 	add.w	r2, r2, #115712	; 0x1c400
 803a7d4:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 803a7d8:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 803a7dc:	2a40      	cmp	r2, #64	; 0x40
 803a7de:	f000 83ba 	beq.w	803af56 <UART_SetConfig+0x8be>
 803a7e2:	d9b7      	bls.n	803a754 <UART_SetConfig+0xbc>
 803a7e4:	2a80      	cmp	r2, #128	; 0x80
 803a7e6:	f000 8346 	beq.w	803ae76 <UART_SetConfig+0x7de>
 803a7ea:	2ac0      	cmp	r2, #192	; 0xc0
 803a7ec:	e7e1      	b.n	803a7b2 <UART_SetConfig+0x11a>
 803a7ee:	4a68      	ldr	r2, [pc, #416]	; (803a990 <UART_SetConfig+0x2f8>)
 803a7f0:	4293      	cmp	r3, r2
 803a7f2:	d111      	bne.n	803a818 <UART_SetConfig+0x180>
 803a7f4:	f502 32e0 	add.w	r2, r2, #114688	; 0x1c000
 803a7f8:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 803a7fc:	f402 7240 	and.w	r2, r2, #768	; 0x300
 803a800:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 803a804:	f000 83a7 	beq.w	803af56 <UART_SetConfig+0x8be>
 803a808:	d9a4      	bls.n	803a754 <UART_SetConfig+0xbc>
 803a80a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 803a80e:	f000 8332 	beq.w	803ae76 <UART_SetConfig+0x7de>
 803a812:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 803a816:	e7cc      	b.n	803a7b2 <UART_SetConfig+0x11a>
 803a818:	4a55      	ldr	r2, [pc, #340]	; (803a970 <UART_SetConfig+0x2d8>)
 803a81a:	4293      	cmp	r3, r2
 803a81c:	d1ce      	bne.n	803a7bc <UART_SetConfig+0x124>
 803a81e:	f502 32c8 	add.w	r2, r2, #102400	; 0x19000
 803a822:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 803a826:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 803a82a:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 803a82e:	f000 8392 	beq.w	803af56 <UART_SetConfig+0x8be>
 803a832:	d98f      	bls.n	803a754 <UART_SetConfig+0xbc>
 803a834:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 803a838:	f000 831d 	beq.w	803ae76 <UART_SetConfig+0x7de>
 803a83c:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 803a840:	e7b7      	b.n	803a7b2 <UART_SetConfig+0x11a>
        lpuart_ker_ck_pres = (HAL_RCC_GetPCLK1Freq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803a842:	2301      	movs	r3, #1
 803a844:	e7a9      	b.n	803a79a <UART_SetConfig+0x102>
 803a846:	2302      	movs	r3, #2
 803a848:	e7a7      	b.n	803a79a <UART_SetConfig+0x102>
 803a84a:	2304      	movs	r3, #4
 803a84c:	e7a5      	b.n	803a79a <UART_SetConfig+0x102>
 803a84e:	2306      	movs	r3, #6
 803a850:	e7a3      	b.n	803a79a <UART_SetConfig+0x102>
 803a852:	2308      	movs	r3, #8
 803a854:	e7a1      	b.n	803a79a <UART_SetConfig+0x102>
 803a856:	230a      	movs	r3, #10
 803a858:	e79f      	b.n	803a79a <UART_SetConfig+0x102>
 803a85a:	230c      	movs	r3, #12
 803a85c:	e79d      	b.n	803a79a <UART_SetConfig+0x102>
 803a85e:	2310      	movs	r3, #16
 803a860:	e79b      	b.n	803a79a <UART_SetConfig+0x102>
 803a862:	2320      	movs	r3, #32
 803a864:	e799      	b.n	803a79a <UART_SetConfig+0x102>
 803a866:	2340      	movs	r3, #64	; 0x40
 803a868:	e797      	b.n	803a79a <UART_SetConfig+0x102>
 803a86a:	2380      	movs	r3, #128	; 0x80
 803a86c:	e795      	b.n	803a79a <UART_SetConfig+0x102>
        lpuart_ker_ck_pres = ((uint32_t)HSI_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803a86e:	2800      	cmp	r0, #0
 803a870:	d063      	beq.n	803a93a <UART_SetConfig+0x2a2>
 803a872:	2801      	cmp	r0, #1
 803a874:	d064      	beq.n	803a940 <UART_SetConfig+0x2a8>
 803a876:	2802      	cmp	r0, #2
 803a878:	d065      	beq.n	803a946 <UART_SetConfig+0x2ae>
 803a87a:	2803      	cmp	r0, #3
 803a87c:	f04f 0102 	mov.w	r1, #2
 803a880:	d064      	beq.n	803a94c <UART_SetConfig+0x2b4>
 803a882:	2804      	cmp	r0, #4
 803a884:	d064      	beq.n	803a950 <UART_SetConfig+0x2b8>
 803a886:	2805      	cmp	r0, #5
 803a888:	d064      	beq.n	803a954 <UART_SetConfig+0x2bc>
 803a88a:	2806      	cmp	r0, #6
 803a88c:	d064      	beq.n	803a958 <UART_SetConfig+0x2c0>
 803a88e:	2807      	cmp	r0, #7
 803a890:	d064      	beq.n	803a95c <UART_SetConfig+0x2c4>
 803a892:	2808      	cmp	r0, #8
 803a894:	d064      	beq.n	803a960 <UART_SetConfig+0x2c8>
 803a896:	2809      	cmp	r0, #9
 803a898:	d064      	beq.n	803a964 <UART_SetConfig+0x2cc>
 803a89a:	280a      	cmp	r0, #10
 803a89c:	d064      	beq.n	803a968 <UART_SetConfig+0x2d0>
 803a89e:	f24f 4224 	movw	r2, #62500	; 0xf424
 803a8a2:	4b3c      	ldr	r3, [pc, #240]	; (803a994 <UART_SetConfig+0x2fc>)
 803a8a4:	280b      	cmp	r0, #11
 803a8a6:	bf14      	ite	ne
 803a8a8:	4618      	movne	r0, r3
 803a8aa:	4610      	moveq	r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 803a8ac:	6862      	ldr	r2, [r4, #4]
 803a8ae:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 803a8b2:	4283      	cmp	r3, r0
 803a8b4:	f240 80a5 	bls.w	803aa02 <UART_SetConfig+0x36a>
        ret = HAL_ERROR;
 803a8b8:	2201      	movs	r2, #1
      ret = HAL_ERROR;
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 803a8ba:	2300      	movs	r3, #0
 803a8bc:	f04f 1101 	mov.w	r1, #65537	; 0x10001
  huart->NbRxDataToProcess = 1;

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 803a8c0:	6723      	str	r3, [r4, #112]	; 0x70
  huart->NbTxDataToProcess = 1;
 803a8c2:	e9c4 131a 	strd	r1, r3, [r4, #104]	; 0x68
  huart->TxISR = NULL;

  return ret;
}
 803a8c6:	4610      	mov	r0, r2
 803a8c8:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
        lpuart_ker_ck_pres = (HAL_RCC_GetSysClockFreq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803a8cc:	f7ff fe6c 	bl	803a5a8 <HAL_RCC_GetSysClockFreq>
 803a8d0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803a8d2:	b1e3      	cbz	r3, 803a90e <UART_SetConfig+0x276>
 803a8d4:	2b01      	cmp	r3, #1
 803a8d6:	d01c      	beq.n	803a912 <UART_SetConfig+0x27a>
 803a8d8:	2b02      	cmp	r3, #2
 803a8da:	d01c      	beq.n	803a916 <UART_SetConfig+0x27e>
 803a8dc:	2b03      	cmp	r3, #3
 803a8de:	d01c      	beq.n	803a91a <UART_SetConfig+0x282>
 803a8e0:	2b04      	cmp	r3, #4
 803a8e2:	d01c      	beq.n	803a91e <UART_SetConfig+0x286>
 803a8e4:	2b05      	cmp	r3, #5
 803a8e6:	d01c      	beq.n	803a922 <UART_SetConfig+0x28a>
 803a8e8:	2b06      	cmp	r3, #6
 803a8ea:	d01c      	beq.n	803a926 <UART_SetConfig+0x28e>
 803a8ec:	2b07      	cmp	r3, #7
 803a8ee:	d01c      	beq.n	803a92a <UART_SetConfig+0x292>
 803a8f0:	2b08      	cmp	r3, #8
 803a8f2:	d01c      	beq.n	803a92e <UART_SetConfig+0x296>
 803a8f4:	2b09      	cmp	r3, #9
 803a8f6:	d01c      	beq.n	803a932 <UART_SetConfig+0x29a>
 803a8f8:	2b0a      	cmp	r3, #10
 803a8fa:	d01c      	beq.n	803a936 <UART_SetConfig+0x29e>
 803a8fc:	2b0b      	cmp	r3, #11
 803a8fe:	bf14      	ite	ne
 803a900:	2301      	movne	r3, #1
 803a902:	f44f 7380 	moveq.w	r3, #256	; 0x100
 803a906:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 803a90a:	2104      	movs	r1, #4
 803a90c:	e748      	b.n	803a7a0 <UART_SetConfig+0x108>
        lpuart_ker_ck_pres = (HAL_RCC_GetSysClockFreq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803a90e:	2301      	movs	r3, #1
 803a910:	e7f9      	b.n	803a906 <UART_SetConfig+0x26e>
 803a912:	2302      	movs	r3, #2
 803a914:	e7f7      	b.n	803a906 <UART_SetConfig+0x26e>
 803a916:	2304      	movs	r3, #4
 803a918:	e7f5      	b.n	803a906 <UART_SetConfig+0x26e>
 803a91a:	2306      	movs	r3, #6
 803a91c:	e7f3      	b.n	803a906 <UART_SetConfig+0x26e>
 803a91e:	2308      	movs	r3, #8
 803a920:	e7f1      	b.n	803a906 <UART_SetConfig+0x26e>
 803a922:	230a      	movs	r3, #10
 803a924:	e7ef      	b.n	803a906 <UART_SetConfig+0x26e>
 803a926:	230c      	movs	r3, #12
 803a928:	e7ed      	b.n	803a906 <UART_SetConfig+0x26e>
 803a92a:	2310      	movs	r3, #16
 803a92c:	e7eb      	b.n	803a906 <UART_SetConfig+0x26e>
 803a92e:	2320      	movs	r3, #32
 803a930:	e7e9      	b.n	803a906 <UART_SetConfig+0x26e>
 803a932:	2340      	movs	r3, #64	; 0x40
 803a934:	e7e7      	b.n	803a906 <UART_SetConfig+0x26e>
 803a936:	2380      	movs	r3, #128	; 0x80
 803a938:	e7e5      	b.n	803a906 <UART_SetConfig+0x26e>
 803a93a:	2102      	movs	r1, #2
        lpuart_ker_ck_pres = ((uint32_t)HSI_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803a93c:	4815      	ldr	r0, [pc, #84]	; (803a994 <UART_SetConfig+0x2fc>)
 803a93e:	e7b5      	b.n	803a8ac <UART_SetConfig+0x214>
 803a940:	2102      	movs	r1, #2
 803a942:	4815      	ldr	r0, [pc, #84]	; (803a998 <UART_SetConfig+0x300>)
 803a944:	e7b2      	b.n	803a8ac <UART_SetConfig+0x214>
 803a946:	4601      	mov	r1, r0
 803a948:	4814      	ldr	r0, [pc, #80]	; (803a99c <UART_SetConfig+0x304>)
 803a94a:	e7af      	b.n	803a8ac <UART_SetConfig+0x214>
 803a94c:	4814      	ldr	r0, [pc, #80]	; (803a9a0 <UART_SetConfig+0x308>)
 803a94e:	e7ad      	b.n	803a8ac <UART_SetConfig+0x214>
 803a950:	4814      	ldr	r0, [pc, #80]	; (803a9a4 <UART_SetConfig+0x30c>)
 803a952:	e7ab      	b.n	803a8ac <UART_SetConfig+0x214>
 803a954:	4814      	ldr	r0, [pc, #80]	; (803a9a8 <UART_SetConfig+0x310>)
 803a956:	e7a9      	b.n	803a8ac <UART_SetConfig+0x214>
 803a958:	4814      	ldr	r0, [pc, #80]	; (803a9ac <UART_SetConfig+0x314>)
 803a95a:	e7a7      	b.n	803a8ac <UART_SetConfig+0x214>
 803a95c:	4814      	ldr	r0, [pc, #80]	; (803a9b0 <UART_SetConfig+0x318>)
 803a95e:	e7a5      	b.n	803a8ac <UART_SetConfig+0x214>
 803a960:	4814      	ldr	r0, [pc, #80]	; (803a9b4 <UART_SetConfig+0x31c>)
 803a962:	e7a3      	b.n	803a8ac <UART_SetConfig+0x214>
 803a964:	4814      	ldr	r0, [pc, #80]	; (803a9b8 <UART_SetConfig+0x320>)
 803a966:	e7a1      	b.n	803a8ac <UART_SetConfig+0x214>
 803a968:	4814      	ldr	r0, [pc, #80]	; (803a9bc <UART_SetConfig+0x324>)
 803a96a:	e79f      	b.n	803a8ac <UART_SetConfig+0x214>
 803a96c:	cfff69f3 	.word	0xcfff69f3
 803a970:	40008000 	.word	0x40008000
 803a974:	40013800 	.word	0x40013800
 803a978:	40021000 	.word	0x40021000
 803a97c:	0803e9bb 	.word	0x0803e9bb
 803a980:	40004400 	.word	0x40004400
 803a984:	0803e9bf 	.word	0x0803e9bf
 803a988:	40004800 	.word	0x40004800
 803a98c:	40004c00 	.word	0x40004c00
 803a990:	40005000 	.word	0x40005000
 803a994:	00f42400 	.word	0x00f42400
 803a998:	007a1200 	.word	0x007a1200
 803a99c:	003d0900 	.word	0x003d0900
 803a9a0:	0028b0aa 	.word	0x0028b0aa
 803a9a4:	001e8480 	.word	0x001e8480
 803a9a8:	00186a00 	.word	0x00186a00
 803a9ac:	00145855 	.word	0x00145855
 803a9b0:	000f4240 	.word	0x000f4240
 803a9b4:	0007a120 	.word	0x0007a120
 803a9b8:	0003d090 	.word	0x0003d090
 803a9bc:	0001e848 	.word	0x0001e848
        lpuart_ker_ck_pres = ((uint32_t)LSE_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803a9c0:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 803a9c4:	e772      	b.n	803a8ac <UART_SetConfig+0x214>
 803a9c6:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 803a9ca:	e76f      	b.n	803a8ac <UART_SetConfig+0x214>
 803a9cc:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 803a9d0:	e76c      	b.n	803a8ac <UART_SetConfig+0x214>
 803a9d2:	f241 5055 	movw	r0, #5461	; 0x1555
 803a9d6:	e769      	b.n	803a8ac <UART_SetConfig+0x214>
 803a9d8:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 803a9dc:	e766      	b.n	803a8ac <UART_SetConfig+0x214>
 803a9de:	f640 40cc 	movw	r0, #3276	; 0xccc
 803a9e2:	e763      	b.n	803a8ac <UART_SetConfig+0x214>
 803a9e4:	f640 20aa 	movw	r0, #2730	; 0xaaa
 803a9e8:	e760      	b.n	803a8ac <UART_SetConfig+0x214>
 803a9ea:	f44f 6000 	mov.w	r0, #2048	; 0x800
 803a9ee:	e75d      	b.n	803a8ac <UART_SetConfig+0x214>
 803a9f0:	f44f 6080 	mov.w	r0, #1024	; 0x400
 803a9f4:	e75a      	b.n	803a8ac <UART_SetConfig+0x214>
 803a9f6:	f44f 7000 	mov.w	r0, #512	; 0x200
 803a9fa:	e757      	b.n	803a8ac <UART_SetConfig+0x214>
 803a9fc:	f44f 7080 	mov.w	r0, #256	; 0x100
 803aa00:	e754      	b.n	803a8ac <UART_SetConfig+0x214>
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 803aa02:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
 803aa06:	f63f af57 	bhi.w	803a8b8 <UART_SetConfig+0x220>
        switch (clocksource)
 803aa0a:	2908      	cmp	r1, #8
 803aa0c:	f200 80d4 	bhi.w	803abb8 <UART_SetConfig+0x520>
 803aa10:	e8df f001 	tbb	[pc, r1]
 803aa14:	d2444105 	.word	0xd2444105
 803aa18:	d2d2d280 	.word	0xd2d2d280
 803aa1c:	99          	.byte	0x99
 803aa1d:	00          	.byte	0x00
            pclk = HAL_RCC_GetPCLK1Freq();
 803aa1e:	f7ff fe11 	bl	803a644 <HAL_RCC_GetPCLK1Freq>
            usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803aa22:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803aa24:	2b00      	cmp	r3, #0
 803aa26:	f000 808c 	beq.w	803ab42 <UART_SetConfig+0x4aa>
 803aa2a:	2b01      	cmp	r3, #1
 803aa2c:	d075      	beq.n	803ab1a <UART_SetConfig+0x482>
 803aa2e:	2b02      	cmp	r3, #2
 803aa30:	d075      	beq.n	803ab1e <UART_SetConfig+0x486>
 803aa32:	2b03      	cmp	r3, #3
 803aa34:	d075      	beq.n	803ab22 <UART_SetConfig+0x48a>
 803aa36:	2b04      	cmp	r3, #4
 803aa38:	d075      	beq.n	803ab26 <UART_SetConfig+0x48e>
 803aa3a:	2b05      	cmp	r3, #5
 803aa3c:	d075      	beq.n	803ab2a <UART_SetConfig+0x492>
 803aa3e:	2b06      	cmp	r3, #6
 803aa40:	d075      	beq.n	803ab2e <UART_SetConfig+0x496>
 803aa42:	2b07      	cmp	r3, #7
 803aa44:	d075      	beq.n	803ab32 <UART_SetConfig+0x49a>
 803aa46:	2b08      	cmp	r3, #8
 803aa48:	d075      	beq.n	803ab36 <UART_SetConfig+0x49e>
 803aa4a:	2b09      	cmp	r3, #9
 803aa4c:	d075      	beq.n	803ab3a <UART_SetConfig+0x4a2>
 803aa4e:	2b0a      	cmp	r3, #10
 803aa50:	d075      	beq.n	803ab3e <UART_SetConfig+0x4a6>
 803aa52:	2b0b      	cmp	r3, #11
 803aa54:	d175      	bne.n	803ab42 <UART_SetConfig+0x4aa>
 803aa56:	f44f 7280 	mov.w	r2, #256	; 0x100
 803aa5a:	2300      	movs	r3, #0
 803aa5c:	2100      	movs	r1, #0
 803aa5e:	f002 fe03 	bl	803d668 <__aeabi_uldivmod>
 803aa62:	6865      	ldr	r5, [r4, #4]
 803aa64:	020f      	lsls	r7, r1, #8
 803aa66:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 803aa6a:	0206      	lsls	r6, r0, #8
 803aa6c:	0868      	lsrs	r0, r5, #1
 803aa6e:	eb16 0b00 	adds.w	fp, r6, r0
 803aa72:	f147 0c00 	adc.w	ip, r7, #0
 803aa76:	462a      	mov	r2, r5
 803aa78:	2300      	movs	r3, #0
 803aa7a:	4658      	mov	r0, fp
 803aa7c:	4661      	mov	r1, ip
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803aa7e:	f002 fdf3 	bl	803d668 <__aeabi_uldivmod>
            break;
 803aa82:	2200      	movs	r2, #0
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 803aa84:	4b96      	ldr	r3, [pc, #600]	; (803ace0 <UART_SetConfig+0x648>)
 803aa86:	f5a0 7140 	sub.w	r1, r0, #768	; 0x300
 803aa8a:	4299      	cmp	r1, r3
 803aa8c:	f63f af14 	bhi.w	803a8b8 <UART_SetConfig+0x220>
          huart->Instance->BRR = usartdiv;
 803aa90:	6823      	ldr	r3, [r4, #0]
 803aa92:	60d8      	str	r0, [r3, #12]
 803aa94:	e711      	b.n	803a8ba <UART_SetConfig+0x222>
            pclk = HAL_RCC_GetPCLK2Freq();
 803aa96:	f7ff fde9 	bl	803a66c <HAL_RCC_GetPCLK2Freq>
 803aa9a:	e7c2      	b.n	803aa22 <UART_SetConfig+0x38a>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803aa9c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803aa9e:	2b00      	cmp	r3, #0
 803aaa0:	d036      	beq.n	803ab10 <UART_SetConfig+0x478>
 803aaa2:	2b01      	cmp	r3, #1
 803aaa4:	d016      	beq.n	803aad4 <UART_SetConfig+0x43c>
 803aaa6:	2b02      	cmp	r3, #2
 803aaa8:	d016      	beq.n	803aad8 <UART_SetConfig+0x440>
 803aaaa:	2b03      	cmp	r3, #3
 803aaac:	d016      	beq.n	803aadc <UART_SetConfig+0x444>
 803aaae:	2b04      	cmp	r3, #4
 803aab0:	d01e      	beq.n	803aaf0 <UART_SetConfig+0x458>
 803aab2:	2b05      	cmp	r3, #5
 803aab4:	d01e      	beq.n	803aaf4 <UART_SetConfig+0x45c>
 803aab6:	2b06      	cmp	r3, #6
 803aab8:	d01e      	beq.n	803aaf8 <UART_SetConfig+0x460>
 803aaba:	2b07      	cmp	r3, #7
 803aabc:	d020      	beq.n	803ab00 <UART_SetConfig+0x468>
 803aabe:	2b08      	cmp	r3, #8
 803aac0:	d020      	beq.n	803ab04 <UART_SetConfig+0x46c>
 803aac2:	2b09      	cmp	r3, #9
 803aac4:	d020      	beq.n	803ab08 <UART_SetConfig+0x470>
 803aac6:	2b0a      	cmp	r3, #10
 803aac8:	d020      	beq.n	803ab0c <UART_SetConfig+0x474>
 803aaca:	2b0b      	cmp	r3, #11
 803aacc:	d120      	bne.n	803ab10 <UART_SetConfig+0x478>
 803aace:	4e85      	ldr	r6, [pc, #532]	; (803ace4 <UART_SetConfig+0x64c>)
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803aad0:	2700      	movs	r7, #0
 803aad2:	e006      	b.n	803aae2 <UART_SetConfig+0x44a>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803aad4:	4e84      	ldr	r6, [pc, #528]	; (803ace8 <UART_SetConfig+0x650>)
 803aad6:	e7fb      	b.n	803aad0 <UART_SetConfig+0x438>
 803aad8:	4e84      	ldr	r6, [pc, #528]	; (803acec <UART_SetConfig+0x654>)
 803aada:	e7f9      	b.n	803aad0 <UART_SetConfig+0x438>
 803aadc:	a77c      	add	r7, pc, #496	; (adr r7, 803acd0 <UART_SetConfig+0x638>)
 803aade:	e9d7 6700 	ldrd	r6, r7, [r7]
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803aae2:	0855      	lsrs	r5, r2, #1
 803aae4:	1970      	adds	r0, r6, r5
 803aae6:	f04f 0300 	mov.w	r3, #0
 803aaea:	f147 0100 	adc.w	r1, r7, #0
 803aaee:	e7c6      	b.n	803aa7e <UART_SetConfig+0x3e6>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803aaf0:	4e7f      	ldr	r6, [pc, #508]	; (803acf0 <UART_SetConfig+0x658>)
 803aaf2:	e7ed      	b.n	803aad0 <UART_SetConfig+0x438>
 803aaf4:	4e7f      	ldr	r6, [pc, #508]	; (803acf4 <UART_SetConfig+0x65c>)
 803aaf6:	e7eb      	b.n	803aad0 <UART_SetConfig+0x438>
 803aaf8:	a777      	add	r7, pc, #476	; (adr r7, 803acd8 <UART_SetConfig+0x640>)
 803aafa:	e9d7 6700 	ldrd	r6, r7, [r7]
 803aafe:	e7f0      	b.n	803aae2 <UART_SetConfig+0x44a>
 803ab00:	4e7d      	ldr	r6, [pc, #500]	; (803acf8 <UART_SetConfig+0x660>)
 803ab02:	e7e5      	b.n	803aad0 <UART_SetConfig+0x438>
 803ab04:	4e7d      	ldr	r6, [pc, #500]	; (803acfc <UART_SetConfig+0x664>)
 803ab06:	e7e3      	b.n	803aad0 <UART_SetConfig+0x438>
 803ab08:	4e7d      	ldr	r6, [pc, #500]	; (803ad00 <UART_SetConfig+0x668>)
 803ab0a:	e7e1      	b.n	803aad0 <UART_SetConfig+0x438>
 803ab0c:	4e7d      	ldr	r6, [pc, #500]	; (803ad04 <UART_SetConfig+0x66c>)
 803ab0e:	e7df      	b.n	803aad0 <UART_SetConfig+0x438>
 803ab10:	4e7d      	ldr	r6, [pc, #500]	; (803ad08 <UART_SetConfig+0x670>)
 803ab12:	e7dd      	b.n	803aad0 <UART_SetConfig+0x438>
            pclk = HAL_RCC_GetSysClockFreq();
 803ab14:	f7ff fd48 	bl	803a5a8 <HAL_RCC_GetSysClockFreq>
 803ab18:	e783      	b.n	803aa22 <UART_SetConfig+0x38a>
            usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ab1a:	2202      	movs	r2, #2
 803ab1c:	e79d      	b.n	803aa5a <UART_SetConfig+0x3c2>
 803ab1e:	2204      	movs	r2, #4
 803ab20:	e79b      	b.n	803aa5a <UART_SetConfig+0x3c2>
 803ab22:	2206      	movs	r2, #6
 803ab24:	e799      	b.n	803aa5a <UART_SetConfig+0x3c2>
 803ab26:	2208      	movs	r2, #8
 803ab28:	e797      	b.n	803aa5a <UART_SetConfig+0x3c2>
 803ab2a:	220a      	movs	r2, #10
 803ab2c:	e795      	b.n	803aa5a <UART_SetConfig+0x3c2>
 803ab2e:	220c      	movs	r2, #12
 803ab30:	e793      	b.n	803aa5a <UART_SetConfig+0x3c2>
 803ab32:	2210      	movs	r2, #16
 803ab34:	e791      	b.n	803aa5a <UART_SetConfig+0x3c2>
 803ab36:	2220      	movs	r2, #32
 803ab38:	e78f      	b.n	803aa5a <UART_SetConfig+0x3c2>
 803ab3a:	2240      	movs	r2, #64	; 0x40
 803ab3c:	e78d      	b.n	803aa5a <UART_SetConfig+0x3c2>
 803ab3e:	2280      	movs	r2, #128	; 0x80
 803ab40:	e78b      	b.n	803aa5a <UART_SetConfig+0x3c2>
 803ab42:	2201      	movs	r2, #1
 803ab44:	e789      	b.n	803aa5a <UART_SetConfig+0x3c2>
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ab46:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803ab48:	b39b      	cbz	r3, 803abb2 <UART_SetConfig+0x51a>
 803ab4a:	2b01      	cmp	r3, #1
 803ab4c:	d016      	beq.n	803ab7c <UART_SetConfig+0x4e4>
 803ab4e:	2b02      	cmp	r3, #2
 803ab50:	d017      	beq.n	803ab82 <UART_SetConfig+0x4ea>
 803ab52:	2b03      	cmp	r3, #3
 803ab54:	d018      	beq.n	803ab88 <UART_SetConfig+0x4f0>
 803ab56:	2b04      	cmp	r3, #4
 803ab58:	d018      	beq.n	803ab8c <UART_SetConfig+0x4f4>
 803ab5a:	2b05      	cmp	r3, #5
 803ab5c:	d019      	beq.n	803ab92 <UART_SetConfig+0x4fa>
 803ab5e:	2b06      	cmp	r3, #6
 803ab60:	d019      	beq.n	803ab96 <UART_SetConfig+0x4fe>
 803ab62:	2b07      	cmp	r3, #7
 803ab64:	d019      	beq.n	803ab9a <UART_SetConfig+0x502>
 803ab66:	2b08      	cmp	r3, #8
 803ab68:	d01a      	beq.n	803aba0 <UART_SetConfig+0x508>
 803ab6a:	2b09      	cmp	r3, #9
 803ab6c:	d01b      	beq.n	803aba6 <UART_SetConfig+0x50e>
 803ab6e:	2b0a      	cmp	r3, #10
 803ab70:	d01c      	beq.n	803abac <UART_SetConfig+0x514>
 803ab72:	2b0b      	cmp	r3, #11
 803ab74:	d11d      	bne.n	803abb2 <UART_SetConfig+0x51a>
 803ab76:	f44f 4600 	mov.w	r6, #32768	; 0x8000
 803ab7a:	e7a9      	b.n	803aad0 <UART_SetConfig+0x438>
 803ab7c:	f44f 0680 	mov.w	r6, #4194304	; 0x400000
 803ab80:	e7a6      	b.n	803aad0 <UART_SetConfig+0x438>
 803ab82:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
 803ab86:	e7a3      	b.n	803aad0 <UART_SetConfig+0x438>
 803ab88:	4e60      	ldr	r6, [pc, #384]	; (803ad0c <UART_SetConfig+0x674>)
 803ab8a:	e7a1      	b.n	803aad0 <UART_SetConfig+0x438>
 803ab8c:	f44f 1680 	mov.w	r6, #1048576	; 0x100000
 803ab90:	e79e      	b.n	803aad0 <UART_SetConfig+0x438>
 803ab92:	4e5f      	ldr	r6, [pc, #380]	; (803ad10 <UART_SetConfig+0x678>)
 803ab94:	e79c      	b.n	803aad0 <UART_SetConfig+0x438>
 803ab96:	4e5f      	ldr	r6, [pc, #380]	; (803ad14 <UART_SetConfig+0x67c>)
 803ab98:	e79a      	b.n	803aad0 <UART_SetConfig+0x438>
 803ab9a:	f44f 2600 	mov.w	r6, #524288	; 0x80000
 803ab9e:	e797      	b.n	803aad0 <UART_SetConfig+0x438>
 803aba0:	f44f 2680 	mov.w	r6, #262144	; 0x40000
 803aba4:	e794      	b.n	803aad0 <UART_SetConfig+0x438>
 803aba6:	f44f 3600 	mov.w	r6, #131072	; 0x20000
 803abaa:	e791      	b.n	803aad0 <UART_SetConfig+0x438>
 803abac:	f44f 3680 	mov.w	r6, #65536	; 0x10000
 803abb0:	e78e      	b.n	803aad0 <UART_SetConfig+0x438>
 803abb2:	f44f 0600 	mov.w	r6, #8388608	; 0x800000
 803abb6:	e78b      	b.n	803aad0 <UART_SetConfig+0x438>
            ret = HAL_ERROR;
 803abb8:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 803abba:	2000      	movs	r0, #0
 803abbc:	e762      	b.n	803aa84 <UART_SetConfig+0x3ec>
        pclk = HAL_RCC_GetPCLK2Freq();
 803abbe:	f7ff fd55 	bl	803a66c <HAL_RCC_GetPCLK2Freq>
 803abc2:	e20a      	b.n	803afda <UART_SetConfig+0x942>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803abc4:	484f      	ldr	r0, [pc, #316]	; (803ad04 <UART_SetConfig+0x66c>)
 803abc6:	e185      	b.n	803aed4 <UART_SetConfig+0x83c>
 803abc8:	4846      	ldr	r0, [pc, #280]	; (803ace4 <UART_SetConfig+0x64c>)
 803abca:	e183      	b.n	803aed4 <UART_SetConfig+0x83c>
 803abcc:	4852      	ldr	r0, [pc, #328]	; (803ad18 <UART_SetConfig+0x680>)
 803abce:	e181      	b.n	803aed4 <UART_SetConfig+0x83c>
 803abd0:	4852      	ldr	r0, [pc, #328]	; (803ad1c <UART_SetConfig+0x684>)
 803abd2:	e17f      	b.n	803aed4 <UART_SetConfig+0x83c>
 803abd4:	4852      	ldr	r0, [pc, #328]	; (803ad20 <UART_SetConfig+0x688>)
 803abd6:	e17d      	b.n	803aed4 <UART_SetConfig+0x83c>
 803abd8:	4852      	ldr	r0, [pc, #328]	; (803ad24 <UART_SetConfig+0x68c>)
 803abda:	e17b      	b.n	803aed4 <UART_SetConfig+0x83c>
 803abdc:	4852      	ldr	r0, [pc, #328]	; (803ad28 <UART_SetConfig+0x690>)
 803abde:	e179      	b.n	803aed4 <UART_SetConfig+0x83c>
 803abe0:	4852      	ldr	r0, [pc, #328]	; (803ad2c <UART_SetConfig+0x694>)
 803abe2:	e177      	b.n	803aed4 <UART_SetConfig+0x83c>
 803abe4:	4852      	ldr	r0, [pc, #328]	; (803ad30 <UART_SetConfig+0x698>)
 803abe6:	e175      	b.n	803aed4 <UART_SetConfig+0x83c>
 803abe8:	4852      	ldr	r0, [pc, #328]	; (803ad34 <UART_SetConfig+0x69c>)
 803abea:	e173      	b.n	803aed4 <UART_SetConfig+0x83c>
 803abec:	4852      	ldr	r0, [pc, #328]	; (803ad38 <UART_SetConfig+0x6a0>)
 803abee:	e171      	b.n	803aed4 <UART_SetConfig+0x83c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803abf0:	2201      	movs	r2, #1
 803abf2:	e219      	b.n	803b028 <UART_SetConfig+0x990>
 803abf4:	2202      	movs	r2, #2
 803abf6:	e217      	b.n	803b028 <UART_SetConfig+0x990>
 803abf8:	2204      	movs	r2, #4
 803abfa:	e215      	b.n	803b028 <UART_SetConfig+0x990>
 803abfc:	2206      	movs	r2, #6
 803abfe:	e213      	b.n	803b028 <UART_SetConfig+0x990>
 803ac00:	2208      	movs	r2, #8
 803ac02:	e211      	b.n	803b028 <UART_SetConfig+0x990>
 803ac04:	220a      	movs	r2, #10
 803ac06:	e20f      	b.n	803b028 <UART_SetConfig+0x990>
 803ac08:	220c      	movs	r2, #12
 803ac0a:	e20d      	b.n	803b028 <UART_SetConfig+0x990>
 803ac0c:	2210      	movs	r2, #16
 803ac0e:	e20b      	b.n	803b028 <UART_SetConfig+0x990>
 803ac10:	2220      	movs	r2, #32
 803ac12:	e209      	b.n	803b028 <UART_SetConfig+0x990>
 803ac14:	2240      	movs	r2, #64	; 0x40
 803ac16:	e207      	b.n	803b028 <UART_SetConfig+0x990>
 803ac18:	2280      	movs	r2, #128	; 0x80
 803ac1a:	e205      	b.n	803b028 <UART_SetConfig+0x990>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ac1c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 803ac20:	e1cf      	b.n	803afc2 <UART_SetConfig+0x92a>
 803ac22:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 803ac26:	e1cc      	b.n	803afc2 <UART_SetConfig+0x92a>
 803ac28:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 803ac2c:	e1c9      	b.n	803afc2 <UART_SetConfig+0x92a>
 803ac2e:	f642 23aa 	movw	r3, #10922	; 0x2aaa
 803ac32:	e1c6      	b.n	803afc2 <UART_SetConfig+0x92a>
 803ac34:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 803ac38:	e1c3      	b.n	803afc2 <UART_SetConfig+0x92a>
 803ac3a:	f641 1398 	movw	r3, #6552	; 0x1998
 803ac3e:	e1c0      	b.n	803afc2 <UART_SetConfig+0x92a>
 803ac40:	f241 5354 	movw	r3, #5460	; 0x1554
 803ac44:	e1bd      	b.n	803afc2 <UART_SetConfig+0x92a>
 803ac46:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 803ac4a:	e1ba      	b.n	803afc2 <UART_SetConfig+0x92a>
 803ac4c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 803ac50:	e1b7      	b.n	803afc2 <UART_SetConfig+0x92a>
 803ac52:	f44f 6380 	mov.w	r3, #1024	; 0x400
 803ac56:	e1b4      	b.n	803afc2 <UART_SetConfig+0x92a>
 803ac58:	f44f 7300 	mov.w	r3, #512	; 0x200
 803ac5c:	e1b1      	b.n	803afc2 <UART_SetConfig+0x92a>
        ret = HAL_ERROR;
 803ac5e:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 803ac60:	2300      	movs	r3, #0
 803ac62:	e13e      	b.n	803aee2 <UART_SetConfig+0x84a>
        pclk = HAL_RCC_GetPCLK1Freq();
 803ac64:	f7ff fcee 	bl	803a644 <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ac68:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803ac6a:	2b00      	cmp	r3, #0
 803ac6c:	f000 80ac 	beq.w	803adc8 <UART_SetConfig+0x730>
 803ac70:	2b01      	cmp	r3, #1
 803ac72:	f000 80ab 	beq.w	803adcc <UART_SetConfig+0x734>
 803ac76:	2b02      	cmp	r3, #2
 803ac78:	f000 80aa 	beq.w	803add0 <UART_SetConfig+0x738>
 803ac7c:	2b03      	cmp	r3, #3
 803ac7e:	f000 80a9 	beq.w	803add4 <UART_SetConfig+0x73c>
 803ac82:	2b04      	cmp	r3, #4
 803ac84:	f000 80a8 	beq.w	803add8 <UART_SetConfig+0x740>
 803ac88:	2b05      	cmp	r3, #5
 803ac8a:	f000 80a7 	beq.w	803addc <UART_SetConfig+0x744>
 803ac8e:	2b06      	cmp	r3, #6
 803ac90:	f000 80a6 	beq.w	803ade0 <UART_SetConfig+0x748>
 803ac94:	2b07      	cmp	r3, #7
 803ac96:	f000 80a5 	beq.w	803ade4 <UART_SetConfig+0x74c>
 803ac9a:	2b08      	cmp	r3, #8
 803ac9c:	f000 80a4 	beq.w	803ade8 <UART_SetConfig+0x750>
 803aca0:	2b09      	cmp	r3, #9
 803aca2:	f000 80a3 	beq.w	803adec <UART_SetConfig+0x754>
 803aca6:	2b0a      	cmp	r3, #10
 803aca8:	f000 80a2 	beq.w	803adf0 <UART_SetConfig+0x758>
 803acac:	2b0b      	cmp	r3, #11
 803acae:	bf14      	ite	ne
 803acb0:	2301      	movne	r3, #1
 803acb2:	f44f 7380 	moveq.w	r3, #256	; 0x100
 803acb6:	fbb0 f3f3 	udiv	r3, r0, r3
 803acba:	6862      	ldr	r2, [r4, #4]
 803acbc:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 803acc0:	fbb3 f3f2 	udiv	r3, r3, r2
 803acc4:	e05b      	b.n	803ad7e <UART_SetConfig+0x6e6>
        pclk = HAL_RCC_GetPCLK2Freq();
 803acc6:	f7ff fcd1 	bl	803a66c <HAL_RCC_GetPCLK2Freq>
 803acca:	e7cd      	b.n	803ac68 <UART_SetConfig+0x5d0>
 803accc:	f3af 8000 	nop.w
 803acd0:	28b0aa00 	.word	0x28b0aa00
 803acd4:	00000000 	.word	0x00000000
 803acd8:	14585500 	.word	0x14585500
 803acdc:	00000000 	.word	0x00000000
 803ace0:	000ffcff 	.word	0x000ffcff
 803ace4:	00f42400 	.word	0x00f42400
 803ace8:	7a120000 	.word	0x7a120000
 803acec:	3d090000 	.word	0x3d090000
 803acf0:	1e848000 	.word	0x1e848000
 803acf4:	186a0000 	.word	0x186a0000
 803acf8:	0f424000 	.word	0x0f424000
 803acfc:	07a12000 	.word	0x07a12000
 803ad00:	03d09000 	.word	0x03d09000
 803ad04:	01e84800 	.word	0x01e84800
 803ad08:	f4240000 	.word	0xf4240000
 803ad0c:	00155500 	.word	0x00155500
 803ad10:	000ccc00 	.word	0x000ccc00
 803ad14:	000aaa00 	.word	0x000aaa00
 803ad18:	007a1200 	.word	0x007a1200
 803ad1c:	00516154 	.word	0x00516154
 803ad20:	003d0900 	.word	0x003d0900
 803ad24:	0030d400 	.word	0x0030d400
 803ad28:	0028b0aa 	.word	0x0028b0aa
 803ad2c:	001e8480 	.word	0x001e8480
 803ad30:	000f4240 	.word	0x000f4240
 803ad34:	0007a120 	.word	0x0007a120
 803ad38:	0003d090 	.word	0x0003d090
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ad3c:	b358      	cbz	r0, 803ad96 <UART_SetConfig+0x6fe>
 803ad3e:	2801      	cmp	r0, #1
 803ad40:	d02b      	beq.n	803ad9a <UART_SetConfig+0x702>
 803ad42:	2802      	cmp	r0, #2
 803ad44:	d02b      	beq.n	803ad9e <UART_SetConfig+0x706>
 803ad46:	2803      	cmp	r0, #3
 803ad48:	d02b      	beq.n	803ada2 <UART_SetConfig+0x70a>
 803ad4a:	2804      	cmp	r0, #4
 803ad4c:	d02b      	beq.n	803ada6 <UART_SetConfig+0x70e>
 803ad4e:	2805      	cmp	r0, #5
 803ad50:	d02b      	beq.n	803adaa <UART_SetConfig+0x712>
 803ad52:	2806      	cmp	r0, #6
 803ad54:	d02b      	beq.n	803adae <UART_SetConfig+0x716>
 803ad56:	2807      	cmp	r0, #7
 803ad58:	d02b      	beq.n	803adb2 <UART_SetConfig+0x71a>
 803ad5a:	2808      	cmp	r0, #8
 803ad5c:	d02b      	beq.n	803adb6 <UART_SetConfig+0x71e>
 803ad5e:	2809      	cmp	r0, #9
 803ad60:	d02b      	beq.n	803adba <UART_SetConfig+0x722>
 803ad62:	280a      	cmp	r0, #10
 803ad64:	d02b      	beq.n	803adbe <UART_SetConfig+0x726>
 803ad66:	f24f 4224 	movw	r2, #62500	; 0xf424
 803ad6a:	4bc0      	ldr	r3, [pc, #768]	; (803b06c <UART_SetConfig+0x9d4>)
 803ad6c:	280b      	cmp	r0, #11
 803ad6e:	bf14      	ite	ne
 803ad70:	4618      	movne	r0, r3
 803ad72:	4610      	moveq	r0, r2
 803ad74:	6863      	ldr	r3, [r4, #4]
 803ad76:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 803ad7a:	fbb0 f3f3 	udiv	r3, r0, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 803ad7e:	2200      	movs	r2, #0
 803ad80:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 803ad82:	f64f 71ef 	movw	r1, #65519	; 0xffef
 803ad86:	f1a3 0010 	sub.w	r0, r3, #16
 803ad8a:	4288      	cmp	r0, r1
 803ad8c:	f63f ad94 	bhi.w	803a8b8 <UART_SetConfig+0x220>
      huart->Instance->BRR = usartdiv;
 803ad90:	6821      	ldr	r1, [r4, #0]
 803ad92:	60cb      	str	r3, [r1, #12]
 803ad94:	e591      	b.n	803a8ba <UART_SetConfig+0x222>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ad96:	48b5      	ldr	r0, [pc, #724]	; (803b06c <UART_SetConfig+0x9d4>)
 803ad98:	e7ec      	b.n	803ad74 <UART_SetConfig+0x6dc>
 803ad9a:	48b5      	ldr	r0, [pc, #724]	; (803b070 <UART_SetConfig+0x9d8>)
 803ad9c:	e7ea      	b.n	803ad74 <UART_SetConfig+0x6dc>
 803ad9e:	48b5      	ldr	r0, [pc, #724]	; (803b074 <UART_SetConfig+0x9dc>)
 803ada0:	e7e8      	b.n	803ad74 <UART_SetConfig+0x6dc>
 803ada2:	48b5      	ldr	r0, [pc, #724]	; (803b078 <UART_SetConfig+0x9e0>)
 803ada4:	e7e6      	b.n	803ad74 <UART_SetConfig+0x6dc>
 803ada6:	48b5      	ldr	r0, [pc, #724]	; (803b07c <UART_SetConfig+0x9e4>)
 803ada8:	e7e4      	b.n	803ad74 <UART_SetConfig+0x6dc>
 803adaa:	48b5      	ldr	r0, [pc, #724]	; (803b080 <UART_SetConfig+0x9e8>)
 803adac:	e7e2      	b.n	803ad74 <UART_SetConfig+0x6dc>
 803adae:	48b5      	ldr	r0, [pc, #724]	; (803b084 <UART_SetConfig+0x9ec>)
 803adb0:	e7e0      	b.n	803ad74 <UART_SetConfig+0x6dc>
 803adb2:	48b5      	ldr	r0, [pc, #724]	; (803b088 <UART_SetConfig+0x9f0>)
 803adb4:	e7de      	b.n	803ad74 <UART_SetConfig+0x6dc>
 803adb6:	48b5      	ldr	r0, [pc, #724]	; (803b08c <UART_SetConfig+0x9f4>)
 803adb8:	e7dc      	b.n	803ad74 <UART_SetConfig+0x6dc>
 803adba:	48b5      	ldr	r0, [pc, #724]	; (803b090 <UART_SetConfig+0x9f8>)
 803adbc:	e7da      	b.n	803ad74 <UART_SetConfig+0x6dc>
 803adbe:	48b5      	ldr	r0, [pc, #724]	; (803b094 <UART_SetConfig+0x9fc>)
 803adc0:	e7d8      	b.n	803ad74 <UART_SetConfig+0x6dc>
        pclk = HAL_RCC_GetSysClockFreq();
 803adc2:	f7ff fbf1 	bl	803a5a8 <HAL_RCC_GetSysClockFreq>
 803adc6:	e74f      	b.n	803ac68 <UART_SetConfig+0x5d0>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803adc8:	2301      	movs	r3, #1
 803adca:	e774      	b.n	803acb6 <UART_SetConfig+0x61e>
 803adcc:	2302      	movs	r3, #2
 803adce:	e772      	b.n	803acb6 <UART_SetConfig+0x61e>
 803add0:	2304      	movs	r3, #4
 803add2:	e770      	b.n	803acb6 <UART_SetConfig+0x61e>
 803add4:	2306      	movs	r3, #6
 803add6:	e76e      	b.n	803acb6 <UART_SetConfig+0x61e>
 803add8:	2308      	movs	r3, #8
 803adda:	e76c      	b.n	803acb6 <UART_SetConfig+0x61e>
 803addc:	230a      	movs	r3, #10
 803adde:	e76a      	b.n	803acb6 <UART_SetConfig+0x61e>
 803ade0:	230c      	movs	r3, #12
 803ade2:	e768      	b.n	803acb6 <UART_SetConfig+0x61e>
 803ade4:	2310      	movs	r3, #16
 803ade6:	e766      	b.n	803acb6 <UART_SetConfig+0x61e>
 803ade8:	2320      	movs	r3, #32
 803adea:	e764      	b.n	803acb6 <UART_SetConfig+0x61e>
 803adec:	2340      	movs	r3, #64	; 0x40
 803adee:	e762      	b.n	803acb6 <UART_SetConfig+0x61e>
 803adf0:	2380      	movs	r3, #128	; 0x80
 803adf2:	e760      	b.n	803acb6 <UART_SetConfig+0x61e>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803adf4:	b1f0      	cbz	r0, 803ae34 <UART_SetConfig+0x79c>
 803adf6:	2801      	cmp	r0, #1
 803adf8:	d01f      	beq.n	803ae3a <UART_SetConfig+0x7a2>
 803adfa:	2802      	cmp	r0, #2
 803adfc:	d020      	beq.n	803ae40 <UART_SetConfig+0x7a8>
 803adfe:	2803      	cmp	r0, #3
 803ae00:	d021      	beq.n	803ae46 <UART_SetConfig+0x7ae>
 803ae02:	2804      	cmp	r0, #4
 803ae04:	d022      	beq.n	803ae4c <UART_SetConfig+0x7b4>
 803ae06:	2805      	cmp	r0, #5
 803ae08:	d023      	beq.n	803ae52 <UART_SetConfig+0x7ba>
 803ae0a:	2806      	cmp	r0, #6
 803ae0c:	d024      	beq.n	803ae58 <UART_SetConfig+0x7c0>
 803ae0e:	2807      	cmp	r0, #7
 803ae10:	d025      	beq.n	803ae5e <UART_SetConfig+0x7c6>
 803ae12:	2808      	cmp	r0, #8
 803ae14:	d026      	beq.n	803ae64 <UART_SetConfig+0x7cc>
 803ae16:	2809      	cmp	r0, #9
 803ae18:	d027      	beq.n	803ae6a <UART_SetConfig+0x7d2>
 803ae1a:	280a      	cmp	r0, #10
 803ae1c:	d028      	beq.n	803ae70 <UART_SetConfig+0x7d8>
 803ae1e:	280b      	cmp	r0, #11
 803ae20:	bf14      	ite	ne
 803ae22:	f44f 4300 	movne.w	r3, #32768	; 0x8000
 803ae26:	2380      	moveq	r3, #128	; 0x80
 803ae28:	6860      	ldr	r0, [r4, #4]
 803ae2a:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 803ae2e:	fbb3 f3f0 	udiv	r3, r3, r0
 803ae32:	e7a4      	b.n	803ad7e <UART_SetConfig+0x6e6>
 803ae34:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 803ae38:	e7f6      	b.n	803ae28 <UART_SetConfig+0x790>
 803ae3a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 803ae3e:	e7f3      	b.n	803ae28 <UART_SetConfig+0x790>
 803ae40:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 803ae44:	e7f0      	b.n	803ae28 <UART_SetConfig+0x790>
 803ae46:	f241 5355 	movw	r3, #5461	; 0x1555
 803ae4a:	e7ed      	b.n	803ae28 <UART_SetConfig+0x790>
 803ae4c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 803ae50:	e7ea      	b.n	803ae28 <UART_SetConfig+0x790>
 803ae52:	f640 43cc 	movw	r3, #3276	; 0xccc
 803ae56:	e7e7      	b.n	803ae28 <UART_SetConfig+0x790>
 803ae58:	f640 23aa 	movw	r3, #2730	; 0xaaa
 803ae5c:	e7e4      	b.n	803ae28 <UART_SetConfig+0x790>
 803ae5e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 803ae62:	e7e1      	b.n	803ae28 <UART_SetConfig+0x790>
 803ae64:	f44f 6380 	mov.w	r3, #1024	; 0x400
 803ae68:	e7de      	b.n	803ae28 <UART_SetConfig+0x790>
 803ae6a:	f44f 7300 	mov.w	r3, #512	; 0x200
 803ae6e:	e7db      	b.n	803ae28 <UART_SetConfig+0x790>
 803ae70:	f44f 7380 	mov.w	r3, #256	; 0x100
 803ae74:	e7d8      	b.n	803ae28 <UART_SetConfig+0x790>
  if (UART_INSTANCE_LOWPOWER(huart))
 803ae76:	4a88      	ldr	r2, [pc, #544]	; (803b098 <UART_SetConfig+0xa00>)
 803ae78:	4293      	cmp	r3, r2
 803ae7a:	f43f acf8 	beq.w	803a86e <UART_SetConfig+0x1d6>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803ae7e:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 803ae82:	f47f af5b 	bne.w	803ad3c <UART_SetConfig+0x6a4>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803ae86:	2800      	cmp	r0, #0
 803ae88:	f43f ae9c 	beq.w	803abc4 <UART_SetConfig+0x52c>
 803ae8c:	2801      	cmp	r0, #1
 803ae8e:	f43f ae9b 	beq.w	803abc8 <UART_SetConfig+0x530>
 803ae92:	2802      	cmp	r0, #2
 803ae94:	f43f ae9a 	beq.w	803abcc <UART_SetConfig+0x534>
 803ae98:	2803      	cmp	r0, #3
 803ae9a:	f43f ae99 	beq.w	803abd0 <UART_SetConfig+0x538>
 803ae9e:	2804      	cmp	r0, #4
 803aea0:	f43f ae98 	beq.w	803abd4 <UART_SetConfig+0x53c>
 803aea4:	2805      	cmp	r0, #5
 803aea6:	f43f ae97 	beq.w	803abd8 <UART_SetConfig+0x540>
 803aeaa:	2806      	cmp	r0, #6
 803aeac:	f43f ae96 	beq.w	803abdc <UART_SetConfig+0x544>
 803aeb0:	2807      	cmp	r0, #7
 803aeb2:	f43f ae95 	beq.w	803abe0 <UART_SetConfig+0x548>
 803aeb6:	2808      	cmp	r0, #8
 803aeb8:	f43f ae94 	beq.w	803abe4 <UART_SetConfig+0x54c>
 803aebc:	2809      	cmp	r0, #9
 803aebe:	f43f ae93 	beq.w	803abe8 <UART_SetConfig+0x550>
 803aec2:	280a      	cmp	r0, #10
 803aec4:	f43f ae92 	beq.w	803abec <UART_SetConfig+0x554>
 803aec8:	4b74      	ldr	r3, [pc, #464]	; (803b09c <UART_SetConfig+0xa04>)
 803aeca:	4a72      	ldr	r2, [pc, #456]	; (803b094 <UART_SetConfig+0x9fc>)
 803aecc:	280b      	cmp	r0, #11
 803aece:	bf14      	ite	ne
 803aed0:	4618      	movne	r0, r3
 803aed2:	4610      	moveq	r0, r2
 803aed4:	6863      	ldr	r3, [r4, #4]
 803aed6:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 803aeda:	fbb0 f3f3 	udiv	r3, r0, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 803aede:	2200      	movs	r2, #0
 803aee0:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 803aee2:	f64f 71ef 	movw	r1, #65519	; 0xffef
 803aee6:	f1a3 0010 	sub.w	r0, r3, #16
 803aeea:	4288      	cmp	r0, r1
 803aeec:	f63f ace4 	bhi.w	803a8b8 <UART_SetConfig+0x220>
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 803aef0:	f023 010f 	bic.w	r1, r3, #15
      huart->Instance->BRR = brrtemp;
 803aef4:	6820      	ldr	r0, [r4, #0]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 803aef6:	f3c3 0342 	ubfx	r3, r3, #1, #3
      huart->Instance->BRR = brrtemp;
 803aefa:	430b      	orrs	r3, r1
 803aefc:	60c3      	str	r3, [r0, #12]
 803aefe:	e4dc      	b.n	803a8ba <UART_SetConfig+0x222>
  if (UART_INSTANCE_LOWPOWER(huart))
 803af00:	4a65      	ldr	r2, [pc, #404]	; (803b098 <UART_SetConfig+0xa00>)
 803af02:	4293      	cmp	r3, r2
 803af04:	d132      	bne.n	803af6c <UART_SetConfig+0x8d4>
        lpuart_ker_ck_pres = ((uint32_t)LSE_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 803af06:	2108      	movs	r1, #8
 803af08:	2800      	cmp	r0, #0
 803af0a:	f43f ad59 	beq.w	803a9c0 <UART_SetConfig+0x328>
 803af0e:	2801      	cmp	r0, #1
 803af10:	f43f ad59 	beq.w	803a9c6 <UART_SetConfig+0x32e>
 803af14:	2802      	cmp	r0, #2
 803af16:	f43f ad59 	beq.w	803a9cc <UART_SetConfig+0x334>
 803af1a:	2803      	cmp	r0, #3
 803af1c:	f43f ad59 	beq.w	803a9d2 <UART_SetConfig+0x33a>
 803af20:	2804      	cmp	r0, #4
 803af22:	f43f ad59 	beq.w	803a9d8 <UART_SetConfig+0x340>
 803af26:	2805      	cmp	r0, #5
 803af28:	f43f ad59 	beq.w	803a9de <UART_SetConfig+0x346>
 803af2c:	2806      	cmp	r0, #6
 803af2e:	f43f ad59 	beq.w	803a9e4 <UART_SetConfig+0x34c>
 803af32:	2807      	cmp	r0, #7
 803af34:	f43f ad59 	beq.w	803a9ea <UART_SetConfig+0x352>
 803af38:	2808      	cmp	r0, #8
 803af3a:	f43f ad59 	beq.w	803a9f0 <UART_SetConfig+0x358>
 803af3e:	2809      	cmp	r0, #9
 803af40:	f43f ad59 	beq.w	803a9f6 <UART_SetConfig+0x35e>
 803af44:	280a      	cmp	r0, #10
 803af46:	f43f ad59 	beq.w	803a9fc <UART_SetConfig+0x364>
 803af4a:	280b      	cmp	r0, #11
 803af4c:	bf0c      	ite	eq
 803af4e:	2080      	moveq	r0, #128	; 0x80
 803af50:	f44f 4000 	movne.w	r0, #32768	; 0x8000
 803af54:	e4aa      	b.n	803a8ac <UART_SetConfig+0x214>
  if (UART_INSTANCE_LOWPOWER(huart))
 803af56:	4a50      	ldr	r2, [pc, #320]	; (803b098 <UART_SetConfig+0xa00>)
 803af58:	4293      	cmp	r3, r2
 803af5a:	f43f acb7 	beq.w	803a8cc <UART_SetConfig+0x234>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803af5e:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 803af62:	f47f af2e 	bne.w	803adc2 <UART_SetConfig+0x72a>
        pclk = HAL_RCC_GetSysClockFreq();
 803af66:	f7ff fb1f 	bl	803a5a8 <HAL_RCC_GetSysClockFreq>
 803af6a:	e036      	b.n	803afda <UART_SetConfig+0x942>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803af6c:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 803af70:	f47f af40 	bne.w	803adf4 <UART_SetConfig+0x75c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803af74:	2800      	cmp	r0, #0
 803af76:	f43f ae51 	beq.w	803ac1c <UART_SetConfig+0x584>
 803af7a:	2801      	cmp	r0, #1
 803af7c:	f43f ae51 	beq.w	803ac22 <UART_SetConfig+0x58a>
 803af80:	2802      	cmp	r0, #2
 803af82:	f43f ae51 	beq.w	803ac28 <UART_SetConfig+0x590>
 803af86:	2803      	cmp	r0, #3
 803af88:	f43f ae51 	beq.w	803ac2e <UART_SetConfig+0x596>
 803af8c:	2804      	cmp	r0, #4
 803af8e:	f43f ae51 	beq.w	803ac34 <UART_SetConfig+0x59c>
 803af92:	2805      	cmp	r0, #5
 803af94:	f43f ae51 	beq.w	803ac3a <UART_SetConfig+0x5a2>
 803af98:	2806      	cmp	r0, #6
 803af9a:	f43f ae51 	beq.w	803ac40 <UART_SetConfig+0x5a8>
 803af9e:	2807      	cmp	r0, #7
 803afa0:	f43f ae51 	beq.w	803ac46 <UART_SetConfig+0x5ae>
 803afa4:	2808      	cmp	r0, #8
 803afa6:	f43f ae51 	beq.w	803ac4c <UART_SetConfig+0x5b4>
 803afaa:	2809      	cmp	r0, #9
 803afac:	f43f ae51 	beq.w	803ac52 <UART_SetConfig+0x5ba>
 803afb0:	280a      	cmp	r0, #10
 803afb2:	f43f ae51 	beq.w	803ac58 <UART_SetConfig+0x5c0>
 803afb6:	280b      	cmp	r0, #11
 803afb8:	bf14      	ite	ne
 803afba:	f44f 3380 	movne.w	r3, #65536	; 0x10000
 803afbe:	f44f 7380 	moveq.w	r3, #256	; 0x100
 803afc2:	6860      	ldr	r0, [r4, #4]
 803afc4:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 803afc8:	fbb3 f3f0 	udiv	r3, r3, r0
 803afcc:	e787      	b.n	803aede <UART_SetConfig+0x846>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803afce:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 803afd2:	f47f ae47 	bne.w	803ac64 <UART_SetConfig+0x5cc>
        pclk = HAL_RCC_GetPCLK1Freq();
 803afd6:	f7ff fb35 	bl	803a644 <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803afda:	6a61      	ldr	r1, [r4, #36]	; 0x24
 803afdc:	2900      	cmp	r1, #0
 803afde:	f43f ae07 	beq.w	803abf0 <UART_SetConfig+0x558>
 803afe2:	2901      	cmp	r1, #1
 803afe4:	f43f ae06 	beq.w	803abf4 <UART_SetConfig+0x55c>
 803afe8:	2902      	cmp	r1, #2
 803afea:	f43f ae05 	beq.w	803abf8 <UART_SetConfig+0x560>
 803afee:	2903      	cmp	r1, #3
 803aff0:	f43f ae04 	beq.w	803abfc <UART_SetConfig+0x564>
 803aff4:	2904      	cmp	r1, #4
 803aff6:	f43f ae03 	beq.w	803ac00 <UART_SetConfig+0x568>
 803affa:	2905      	cmp	r1, #5
 803affc:	f43f ae02 	beq.w	803ac04 <UART_SetConfig+0x56c>
 803b000:	2906      	cmp	r1, #6
 803b002:	f43f ae01 	beq.w	803ac08 <UART_SetConfig+0x570>
 803b006:	2907      	cmp	r1, #7
 803b008:	f43f ae00 	beq.w	803ac0c <UART_SetConfig+0x574>
 803b00c:	2908      	cmp	r1, #8
 803b00e:	f43f adff 	beq.w	803ac10 <UART_SetConfig+0x578>
 803b012:	2909      	cmp	r1, #9
 803b014:	f43f adfe 	beq.w	803ac14 <UART_SetConfig+0x57c>
 803b018:	290a      	cmp	r1, #10
 803b01a:	f43f adfd 	beq.w	803ac18 <UART_SetConfig+0x580>
 803b01e:	290b      	cmp	r1, #11
 803b020:	bf14      	ite	ne
 803b022:	2201      	movne	r2, #1
 803b024:	f44f 7280 	moveq.w	r2, #256	; 0x100
 803b028:	fbb0 f2f2 	udiv	r2, r0, r2
 803b02c:	6861      	ldr	r1, [r4, #4]
 803b02e:	084b      	lsrs	r3, r1, #1
 803b030:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 803b034:	fbb3 f3f1 	udiv	r3, r3, r1
 803b038:	e751      	b.n	803aede <UART_SetConfig+0x846>
    switch (clocksource)
 803b03a:	2b08      	cmp	r3, #8
 803b03c:	f63f ac3c 	bhi.w	803a8b8 <UART_SetConfig+0x220>
 803b040:	a201      	add	r2, pc, #4	; (adr r2, 803b048 <UART_SetConfig+0x9b0>)
 803b042:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 803b046:	bf00      	nop
 803b048:	0803ac65 	.word	0x0803ac65
 803b04c:	0803acc7 	.word	0x0803acc7
 803b050:	0803ad3d 	.word	0x0803ad3d
 803b054:	0803a8b9 	.word	0x0803a8b9
 803b058:	0803adc3 	.word	0x0803adc3
 803b05c:	0803a8b9 	.word	0x0803a8b9
 803b060:	0803a8b9 	.word	0x0803a8b9
 803b064:	0803a8b9 	.word	0x0803a8b9
 803b068:	0803adf5 	.word	0x0803adf5
 803b06c:	00f42400 	.word	0x00f42400
 803b070:	007a1200 	.word	0x007a1200
 803b074:	003d0900 	.word	0x003d0900
 803b078:	0028b0aa 	.word	0x0028b0aa
 803b07c:	001e8480 	.word	0x001e8480
 803b080:	00186a00 	.word	0x00186a00
 803b084:	00145855 	.word	0x00145855
 803b088:	000f4240 	.word	0x000f4240
 803b08c:	0007a120 	.word	0x0007a120
 803b090:	0003d090 	.word	0x0003d090
 803b094:	0001e848 	.word	0x0001e848
 803b098:	40008000 	.word	0x40008000
 803b09c:	01e84800 	.word	0x01e84800

0803b0a0 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 803b0a0:	6a83      	ldr	r3, [r0, #40]	; 0x28
{
 803b0a2:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 803b0a4:	07da      	lsls	r2, r3, #31
 803b0a6:	d506      	bpl.n	803b0b6 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 803b0a8:	6801      	ldr	r1, [r0, #0]
 803b0aa:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 803b0ac:	684a      	ldr	r2, [r1, #4]
 803b0ae:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 803b0b2:	4322      	orrs	r2, r4
 803b0b4:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 803b0b6:	079c      	lsls	r4, r3, #30
 803b0b8:	d506      	bpl.n	803b0c8 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 803b0ba:	6801      	ldr	r1, [r0, #0]
 803b0bc:	6b04      	ldr	r4, [r0, #48]	; 0x30
 803b0be:	684a      	ldr	r2, [r1, #4]
 803b0c0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 803b0c4:	4322      	orrs	r2, r4
 803b0c6:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 803b0c8:	0759      	lsls	r1, r3, #29
 803b0ca:	d506      	bpl.n	803b0da <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 803b0cc:	6801      	ldr	r1, [r0, #0]
 803b0ce:	6b44      	ldr	r4, [r0, #52]	; 0x34
 803b0d0:	684a      	ldr	r2, [r1, #4]
 803b0d2:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 803b0d6:	4322      	orrs	r2, r4
 803b0d8:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 803b0da:	071a      	lsls	r2, r3, #28
 803b0dc:	d506      	bpl.n	803b0ec <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 803b0de:	6801      	ldr	r1, [r0, #0]
 803b0e0:	6b84      	ldr	r4, [r0, #56]	; 0x38
 803b0e2:	684a      	ldr	r2, [r1, #4]
 803b0e4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 803b0e8:	4322      	orrs	r2, r4
 803b0ea:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 803b0ec:	06dc      	lsls	r4, r3, #27
 803b0ee:	d506      	bpl.n	803b0fe <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 803b0f0:	6801      	ldr	r1, [r0, #0]
 803b0f2:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 803b0f4:	688a      	ldr	r2, [r1, #8]
 803b0f6:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 803b0fa:	4322      	orrs	r2, r4
 803b0fc:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 803b0fe:	0699      	lsls	r1, r3, #26
 803b100:	d506      	bpl.n	803b110 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 803b102:	6801      	ldr	r1, [r0, #0]
 803b104:	6c04      	ldr	r4, [r0, #64]	; 0x40
 803b106:	688a      	ldr	r2, [r1, #8]
 803b108:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 803b10c:	4322      	orrs	r2, r4
 803b10e:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 803b110:	065a      	lsls	r2, r3, #25
 803b112:	d510      	bpl.n	803b136 <UART_AdvFeatureConfig+0x96>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 803b114:	6801      	ldr	r1, [r0, #0]
 803b116:	6c44      	ldr	r4, [r0, #68]	; 0x44
 803b118:	684a      	ldr	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 803b11a:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 803b11e:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 803b122:	ea42 0204 	orr.w	r2, r2, r4
 803b126:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 803b128:	d105      	bne.n	803b136 <UART_AdvFeatureConfig+0x96>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 803b12a:	684a      	ldr	r2, [r1, #4]
 803b12c:	6c84      	ldr	r4, [r0, #72]	; 0x48
 803b12e:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 803b132:	4322      	orrs	r2, r4
 803b134:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 803b136:	061b      	lsls	r3, r3, #24
 803b138:	d506      	bpl.n	803b148 <UART_AdvFeatureConfig+0xa8>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 803b13a:	6802      	ldr	r2, [r0, #0]
 803b13c:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 803b13e:	6853      	ldr	r3, [r2, #4]
 803b140:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 803b144:	430b      	orrs	r3, r1
 803b146:	6053      	str	r3, [r2, #4]
  }
}
 803b148:	bd10      	pop	{r4, pc}

0803b14a <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 803b14a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 803b14e:	4604      	mov	r4, r0
 803b150:	460f      	mov	r7, r1
 803b152:	4616      	mov	r6, r2
 803b154:	4698      	mov	r8, r3
 803b156:	9d06      	ldr	r5, [sp, #24]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 803b158:	6821      	ldr	r1, [r4, #0]
 803b15a:	69ca      	ldr	r2, [r1, #28]
 803b15c:	ea37 0302 	bics.w	r3, r7, r2
 803b160:	bf0c      	ite	eq
 803b162:	2201      	moveq	r2, #1
 803b164:	2200      	movne	r2, #0
 803b166:	42b2      	cmp	r2, r6
 803b168:	d001      	beq.n	803b16e <UART_WaitOnFlagUntilTimeout+0x24>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 803b16a:	2000      	movs	r0, #0
 803b16c:	e01a      	b.n	803b1a4 <UART_WaitOnFlagUntilTimeout+0x5a>
    if (Timeout != HAL_MAX_DELAY)
 803b16e:	1c68      	adds	r0, r5, #1
 803b170:	d0f3      	beq.n	803b15a <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 803b172:	f7fe fe8f 	bl	8039e94 <HAL_GetTick>
 803b176:	eba0 0008 	sub.w	r0, r0, r8
 803b17a:	42a8      	cmp	r0, r5
 803b17c:	6820      	ldr	r0, [r4, #0]
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 803b17e:	6803      	ldr	r3, [r0, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 803b180:	d800      	bhi.n	803b184 <UART_WaitOnFlagUntilTimeout+0x3a>
 803b182:	b98d      	cbnz	r5, 803b1a8 <UART_WaitOnFlagUntilTimeout+0x5e>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 803b184:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 803b188:	6003      	str	r3, [r0, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 803b18a:	6883      	ldr	r3, [r0, #8]
 803b18c:	f023 0301 	bic.w	r3, r3, #1
 803b190:	6083      	str	r3, [r0, #8]
        huart->gState = HAL_UART_STATE_READY;
 803b192:	2320      	movs	r3, #32
 803b194:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
        huart->RxState = HAL_UART_STATE_READY;
 803b198:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          __HAL_UNLOCK(huart);
 803b19c:	2300      	movs	r3, #0
          return HAL_TIMEOUT;
 803b19e:	2003      	movs	r0, #3
          __HAL_UNLOCK(huart);
 803b1a0:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
}
 803b1a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 803b1a8:	075a      	lsls	r2, r3, #29
 803b1aa:	d5d5      	bpl.n	803b158 <UART_WaitOnFlagUntilTimeout+0xe>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 803b1ac:	69c3      	ldr	r3, [r0, #28]
 803b1ae:	051b      	lsls	r3, r3, #20
 803b1b0:	d5d2      	bpl.n	803b158 <UART_WaitOnFlagUntilTimeout+0xe>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 803b1b2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 803b1b6:	6203      	str	r3, [r0, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 803b1b8:	6803      	ldr	r3, [r0, #0]
 803b1ba:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 803b1be:	6003      	str	r3, [r0, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 803b1c0:	6883      	ldr	r3, [r0, #8]
 803b1c2:	f023 0301 	bic.w	r3, r3, #1
 803b1c6:	6083      	str	r3, [r0, #8]
          huart->gState = HAL_UART_STATE_READY;
 803b1c8:	2320      	movs	r3, #32
 803b1ca:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
          huart->RxState = HAL_UART_STATE_READY;
 803b1ce:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 803b1d2:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 803b1d6:	e7e1      	b.n	803b19c <UART_WaitOnFlagUntilTimeout+0x52>

0803b1d8 <HAL_UART_Transmit>:
{
 803b1d8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 803b1dc:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
 803b1de:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
{
 803b1e2:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
 803b1e4:	2b20      	cmp	r3, #32
{
 803b1e6:	460e      	mov	r6, r1
 803b1e8:	4691      	mov	r9, r2
  if (huart->gState == HAL_UART_STATE_READY)
 803b1ea:	d14f      	bne.n	803b28c <HAL_UART_Transmit+0xb4>
    if ((pData == NULL) || (Size == 0U))
 803b1ec:	2900      	cmp	r1, #0
 803b1ee:	d04b      	beq.n	803b288 <HAL_UART_Transmit+0xb0>
 803b1f0:	2a00      	cmp	r2, #0
 803b1f2:	d049      	beq.n	803b288 <HAL_UART_Transmit+0xb0>
    __HAL_LOCK(huart);
 803b1f4:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 803b1f8:	2b01      	cmp	r3, #1
 803b1fa:	d047      	beq.n	803b28c <HAL_UART_Transmit+0xb4>
 803b1fc:	2301      	movs	r3, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 803b1fe:	2500      	movs	r5, #0
    __HAL_LOCK(huart);
 803b200:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 803b204:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 803b206:	f8c0 5088 	str.w	r5, [r0, #136]	; 0x88
    huart->gState = HAL_UART_STATE_BUSY_TX;
 803b20a:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    tickstart = HAL_GetTick();
 803b20e:	f7fe fe41 	bl	8039e94 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 803b212:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 803b214:	4607      	mov	r7, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 803b216:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->TxXferSize  = Size;
 803b21a:	f8a4 9054 	strh.w	r9, [r4, #84]	; 0x54
    huart->TxXferCount = Size;
 803b21e:	f8a4 9056 	strh.w	r9, [r4, #86]	; 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 803b222:	d103      	bne.n	803b22c <HAL_UART_Transmit+0x54>
 803b224:	6923      	ldr	r3, [r4, #16]
 803b226:	b90b      	cbnz	r3, 803b22c <HAL_UART_Transmit+0x54>
 803b228:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 803b22a:	461e      	mov	r6, r3
    __HAL_UNLOCK(huart);
 803b22c:	2300      	movs	r3, #0
 803b22e:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
    while (huart->TxXferCount > 0U)
 803b232:	f8b4 2056 	ldrh.w	r2, [r4, #86]	; 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 803b236:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
 803b23a:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 803b23c:	463b      	mov	r3, r7
    while (huart->TxXferCount > 0U)
 803b23e:	b942      	cbnz	r2, 803b252 <HAL_UART_Transmit+0x7a>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 803b240:	2140      	movs	r1, #64	; 0x40
 803b242:	4620      	mov	r0, r4
 803b244:	f7ff ff81 	bl	803b14a <UART_WaitOnFlagUntilTimeout>
 803b248:	b948      	cbnz	r0, 803b25e <HAL_UART_Transmit+0x86>
    huart->gState = HAL_UART_STATE_READY;
 803b24a:	2320      	movs	r3, #32
 803b24c:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    return HAL_OK;
 803b250:	e006      	b.n	803b260 <HAL_UART_Transmit+0x88>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 803b252:	2200      	movs	r2, #0
 803b254:	2180      	movs	r1, #128	; 0x80
 803b256:	4620      	mov	r0, r4
 803b258:	f7ff ff77 	bl	803b14a <UART_WaitOnFlagUntilTimeout>
 803b25c:	b118      	cbz	r0, 803b266 <HAL_UART_Transmit+0x8e>
        return HAL_TIMEOUT;
 803b25e:	2003      	movs	r0, #3
}
 803b260:	b003      	add	sp, #12
 803b262:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 803b266:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
 803b268:	b95e      	cbnz	r6, 803b282 <HAL_UART_Transmit+0xaa>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 803b26a:	f835 3b02 	ldrh.w	r3, [r5], #2
 803b26e:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 803b272:	6293      	str	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 803b274:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
 803b278:	3b01      	subs	r3, #1
 803b27a:	b29b      	uxth	r3, r3
 803b27c:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
 803b280:	e7d7      	b.n	803b232 <HAL_UART_Transmit+0x5a>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 803b282:	f816 3b01 	ldrb.w	r3, [r6], #1
 803b286:	e7f4      	b.n	803b272 <HAL_UART_Transmit+0x9a>
      return  HAL_ERROR;
 803b288:	2001      	movs	r0, #1
 803b28a:	e7e9      	b.n	803b260 <HAL_UART_Transmit+0x88>
    return HAL_BUSY;
 803b28c:	2002      	movs	r0, #2
 803b28e:	e7e7      	b.n	803b260 <HAL_UART_Transmit+0x88>

0803b290 <HAL_UART_Receive>:
{
 803b290:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 803b294:	4699      	mov	r9, r3
  if (huart->RxState == HAL_UART_STATE_READY)
 803b296:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 803b29a:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_READY)
 803b29c:	2b20      	cmp	r3, #32
{
 803b29e:	460d      	mov	r5, r1
 803b2a0:	4616      	mov	r6, r2
  if (huart->RxState == HAL_UART_STATE_READY)
 803b2a2:	d167      	bne.n	803b374 <HAL_UART_Receive+0xe4>
    if ((pData == NULL) || (Size == 0U))
 803b2a4:	2900      	cmp	r1, #0
 803b2a6:	d063      	beq.n	803b370 <HAL_UART_Receive+0xe0>
 803b2a8:	2a00      	cmp	r2, #0
 803b2aa:	d061      	beq.n	803b370 <HAL_UART_Receive+0xe0>
    __HAL_LOCK(huart);
 803b2ac:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 803b2b0:	2b01      	cmp	r3, #1
 803b2b2:	d05f      	beq.n	803b374 <HAL_UART_Receive+0xe4>
 803b2b4:	2301      	movs	r3, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 803b2b6:	2700      	movs	r7, #0
    __HAL_LOCK(huart);
 803b2b8:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 803b2bc:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 803b2be:	f8c0 7088 	str.w	r7, [r0, #136]	; 0x88
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 803b2c2:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    tickstart = HAL_GetTick();
 803b2c6:	f7fe fde5 	bl	8039e94 <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
 803b2ca:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 803b2cc:	4680      	mov	r8, r0
    UART_MASK_COMPUTATION(huart);
 803b2ce:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->RxXferSize  = Size;
 803b2d2:	f8a4 605c 	strh.w	r6, [r4, #92]	; 0x5c
    huart->RxXferCount = Size;
 803b2d6:	f8a4 605e 	strh.w	r6, [r4, #94]	; 0x5e
    UART_MASK_COMPUTATION(huart);
 803b2da:	d11d      	bne.n	803b318 <HAL_UART_Receive+0x88>
 803b2dc:	6922      	ldr	r2, [r4, #16]
 803b2de:	b9ca      	cbnz	r2, 803b314 <HAL_UART_Receive+0x84>
 803b2e0:	f240 12ff 	movw	r2, #511	; 0x1ff
 803b2e4:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 803b2e8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    uhMask = huart->Mask;
 803b2ec:	f8b4 7060 	ldrh.w	r7, [r4, #96]	; 0x60
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 803b2f0:	d123      	bne.n	803b33a <HAL_UART_Receive+0xaa>
 803b2f2:	6923      	ldr	r3, [r4, #16]
 803b2f4:	bb0b      	cbnz	r3, 803b33a <HAL_UART_Receive+0xaa>
 803b2f6:	462e      	mov	r6, r5
      pdata8bits  = NULL;
 803b2f8:	461d      	mov	r5, r3
    __HAL_UNLOCK(huart);
 803b2fa:	2300      	movs	r3, #0
 803b2fc:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
    while (huart->RxXferCount > 0U)
 803b300:	f8b4 005e 	ldrh.w	r0, [r4, #94]	; 0x5e
 803b304:	b280      	uxth	r0, r0
 803b306:	b9d0      	cbnz	r0, 803b33e <HAL_UART_Receive+0xae>
    huart->RxState = HAL_UART_STATE_READY;
 803b308:	2320      	movs	r3, #32
 803b30a:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
}
 803b30e:	b003      	add	sp, #12
 803b310:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    UART_MASK_COMPUTATION(huart);
 803b314:	22ff      	movs	r2, #255	; 0xff
 803b316:	e7e5      	b.n	803b2e4 <HAL_UART_Receive+0x54>
 803b318:	b923      	cbnz	r3, 803b324 <HAL_UART_Receive+0x94>
 803b31a:	6922      	ldr	r2, [r4, #16]
 803b31c:	2a00      	cmp	r2, #0
 803b31e:	d0f9      	beq.n	803b314 <HAL_UART_Receive+0x84>
 803b320:	227f      	movs	r2, #127	; 0x7f
 803b322:	e7df      	b.n	803b2e4 <HAL_UART_Receive+0x54>
 803b324:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 803b328:	d104      	bne.n	803b334 <HAL_UART_Receive+0xa4>
 803b32a:	6922      	ldr	r2, [r4, #16]
 803b32c:	2a00      	cmp	r2, #0
 803b32e:	d0f7      	beq.n	803b320 <HAL_UART_Receive+0x90>
 803b330:	223f      	movs	r2, #63	; 0x3f
 803b332:	e7d7      	b.n	803b2e4 <HAL_UART_Receive+0x54>
 803b334:	f8a4 7060 	strh.w	r7, [r4, #96]	; 0x60
 803b338:	e7d6      	b.n	803b2e8 <HAL_UART_Receive+0x58>
      pdata16bits = NULL;
 803b33a:	2600      	movs	r6, #0
 803b33c:	e7dd      	b.n	803b2fa <HAL_UART_Receive+0x6a>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 803b33e:	f8cd 9000 	str.w	r9, [sp]
 803b342:	4643      	mov	r3, r8
 803b344:	2200      	movs	r2, #0
 803b346:	2120      	movs	r1, #32
 803b348:	4620      	mov	r0, r4
 803b34a:	f7ff fefe 	bl	803b14a <UART_WaitOnFlagUntilTimeout>
 803b34e:	b998      	cbnz	r0, 803b378 <HAL_UART_Receive+0xe8>
 803b350:	6823      	ldr	r3, [r4, #0]
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 803b352:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 803b354:	403b      	ands	r3, r7
      if (pdata8bits == NULL)
 803b356:	b945      	cbnz	r5, 803b36a <HAL_UART_Receive+0xda>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 803b358:	f826 3b02 	strh.w	r3, [r6], #2
      huart->RxXferCount--;
 803b35c:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 803b360:	3b01      	subs	r3, #1
 803b362:	b29b      	uxth	r3, r3
 803b364:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
 803b368:	e7ca      	b.n	803b300 <HAL_UART_Receive+0x70>
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 803b36a:	f805 3b01 	strb.w	r3, [r5], #1
 803b36e:	e7f5      	b.n	803b35c <HAL_UART_Receive+0xcc>
      return  HAL_ERROR;
 803b370:	2001      	movs	r0, #1
 803b372:	e7cc      	b.n	803b30e <HAL_UART_Receive+0x7e>
    return HAL_BUSY;
 803b374:	2002      	movs	r0, #2
 803b376:	e7ca      	b.n	803b30e <HAL_UART_Receive+0x7e>
        return HAL_TIMEOUT;
 803b378:	2003      	movs	r0, #3
 803b37a:	e7c8      	b.n	803b30e <HAL_UART_Receive+0x7e>

0803b37c <UART_CheckIdleState>:
{
 803b37c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 803b37e:	2600      	movs	r6, #0
{
 803b380:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 803b382:	f8c0 6088 	str.w	r6, [r0, #136]	; 0x88
  tickstart = HAL_GetTick();
 803b386:	f7fe fd85 	bl	8039e94 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 803b38a:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 803b38c:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 803b38e:	681b      	ldr	r3, [r3, #0]
 803b390:	071a      	lsls	r2, r3, #28
 803b392:	d417      	bmi.n	803b3c4 <UART_CheckIdleState+0x48>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 803b394:	6823      	ldr	r3, [r4, #0]
 803b396:	681b      	ldr	r3, [r3, #0]
 803b398:	075b      	lsls	r3, r3, #29
 803b39a:	d50a      	bpl.n	803b3b2 <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 803b39c:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 803b3a0:	2200      	movs	r2, #0
 803b3a2:	9300      	str	r3, [sp, #0]
 803b3a4:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 803b3a8:	462b      	mov	r3, r5
 803b3aa:	4620      	mov	r0, r4
 803b3ac:	f7ff fecd 	bl	803b14a <UART_WaitOnFlagUntilTimeout>
 803b3b0:	b9a0      	cbnz	r0, 803b3dc <UART_CheckIdleState+0x60>
  huart->gState = HAL_UART_STATE_READY;
 803b3b2:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
 803b3b4:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 803b3b6:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  __HAL_UNLOCK(huart);
 803b3ba:	f884 007c 	strb.w	r0, [r4, #124]	; 0x7c
  huart->RxState = HAL_UART_STATE_READY;
 803b3be:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  return HAL_OK;
 803b3c2:	e00c      	b.n	803b3de <UART_CheckIdleState+0x62>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 803b3c4:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 803b3c8:	4632      	mov	r2, r6
 803b3ca:	9300      	str	r3, [sp, #0]
 803b3cc:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 803b3d0:	4603      	mov	r3, r0
 803b3d2:	4620      	mov	r0, r4
 803b3d4:	f7ff feb9 	bl	803b14a <UART_WaitOnFlagUntilTimeout>
 803b3d8:	2800      	cmp	r0, #0
 803b3da:	d0db      	beq.n	803b394 <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 803b3dc:	2003      	movs	r0, #3
}
 803b3de:	b002      	add	sp, #8
 803b3e0:	bd70      	pop	{r4, r5, r6, pc}

0803b3e2 <HAL_UART_Init>:
{
 803b3e2:	b510      	push	{r4, lr}
  if (huart == NULL)
 803b3e4:	4604      	mov	r4, r0
 803b3e6:	b350      	cbz	r0, 803b43e <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 803b3e8:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 803b3ec:	b91b      	cbnz	r3, 803b3f6 <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 803b3ee:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    HAL_UART_MspInit(huart);
 803b3f2:	f7fd fa8d 	bl	8038910 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 803b3f6:	2324      	movs	r3, #36	; 0x24
  __HAL_UART_DISABLE(huart);
 803b3f8:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 803b3fa:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  __HAL_UART_DISABLE(huart);
 803b3fe:	6813      	ldr	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 803b400:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 803b402:	f023 0301 	bic.w	r3, r3, #1
 803b406:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 803b408:	f7ff f946 	bl	803a698 <UART_SetConfig>
 803b40c:	2801      	cmp	r0, #1
 803b40e:	d016      	beq.n	803b43e <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 803b410:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 803b412:	b113      	cbz	r3, 803b41a <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 803b414:	4620      	mov	r0, r4
 803b416:	f7ff fe43 	bl	803b0a0 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 803b41a:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 803b41c:	4620      	mov	r0, r4
}
 803b41e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 803b422:	685a      	ldr	r2, [r3, #4]
 803b424:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 803b428:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 803b42a:	689a      	ldr	r2, [r3, #8]
 803b42c:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 803b430:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 803b432:	681a      	ldr	r2, [r3, #0]
 803b434:	f042 0201 	orr.w	r2, r2, #1
 803b438:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 803b43a:	f7ff bf9f 	b.w	803b37c <UART_CheckIdleState>
}
 803b43e:	2001      	movs	r0, #1
 803b440:	bd10      	pop	{r4, pc}

0803b442 <UsefulBuf_CopyOffset>:

/*
 Public function -- see UsefulBuf.h
 */
UsefulBufC UsefulBuf_CopyOffset(UsefulBuf Dest, size_t uOffset, const UsefulBufC Src)
{
 803b442:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 803b444:	4605      	mov	r5, r0
 803b446:	a802      	add	r0, sp, #8
 803b448:	e900 0006 	stmdb	r0, {r1, r2}
 803b44c:	9a01      	ldr	r2, [sp, #4]
 803b44e:	461c      	mov	r4, r3
   // Do this with subtraction so it doesn't give erroneous result if uOffset + Src.len overflows
   if(uOffset > Dest.len || Src.len > Dest.len - uOffset) { // uOffset + Src.len > Dest.len
 803b450:	4293      	cmp	r3, r2
 803b452:	d803      	bhi.n	803b45c <UsefulBuf_CopyOffset+0x1a>
 803b454:	9e09      	ldr	r6, [sp, #36]	; 0x24
 803b456:	1ad2      	subs	r2, r2, r3
 803b458:	42b2      	cmp	r2, r6
 803b45a:	d205      	bcs.n	803b468 <UsefulBuf_CopyOffset+0x26>
      return NULLUsefulBufC;
 803b45c:	2300      	movs	r3, #0
 803b45e:	e9c5 3300 	strd	r3, r3, [r5]
   }

   memcpy((uint8_t *)Dest.ptr + uOffset, Src.ptr, Src.len);

   return (UsefulBufC){Dest.ptr, Src.len + uOffset};
}
 803b462:	4628      	mov	r0, r5
 803b464:	b003      	add	sp, #12
 803b466:	bdf0      	pop	{r4, r5, r6, r7, pc}
 803b468:	9f00      	ldr	r7, [sp, #0]
   memcpy((uint8_t *)Dest.ptr + uOffset, Src.ptr, Src.len);
 803b46a:	4632      	mov	r2, r6
 803b46c:	9908      	ldr	r1, [sp, #32]
 803b46e:	18f8      	adds	r0, r7, r3
   return (UsefulBufC){Dest.ptr, Src.len + uOffset};
 803b470:	4434      	add	r4, r6
   memcpy((uint8_t *)Dest.ptr + uOffset, Src.ptr, Src.len);
 803b472:	f001 f8ca 	bl	803c60a <memcpy>
   return (UsefulBufC){Dest.ptr, Src.len + uOffset};
 803b476:	602f      	str	r7, [r5, #0]
 803b478:	606c      	str	r4, [r5, #4]
 803b47a:	e7f2      	b.n	803b462 <UsefulBuf_CopyOffset+0x20>

0803b47c <UsefulBuf_IsValue>:

/*
 Public function -- see UsefulBuf.h
 */
size_t UsefulBuf_IsValue(const UsefulBufC UB, uint8_t uValue)
{
 803b47c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 803b47e:	ab02      	add	r3, sp, #8
 803b480:	e903 0003 	stmdb	r3, {r0, r1}
 803b484:	9801      	ldr	r0, [sp, #4]
   return UsefulBuf_IsEmptyC(UB) || UsefulBuf_IsNULLC(UB);
 803b486:	b168      	cbz	r0, 803b4a4 <UsefulBuf_IsValue+0x28>
 803b488:	9b00      	ldr	r3, [sp, #0]
 803b48a:	b17b      	cbz	r3, 803b4ac <UsefulBuf_IsValue+0x30>
   if(UsefulBuf_IsNULLOrEmptyC(UB)) {
      /* Not a match */
      return 0;
   }

   const uint8_t * const pEnd = (uint8_t *)UB.ptr + UB.len;
 803b48c:	1819      	adds	r1, r3, r0
 803b48e:	4618      	mov	r0, r3
   for(const uint8_t *p = UB.ptr; p < pEnd; p++) {
 803b490:	4288      	cmp	r0, r1
 803b492:	d302      	bcc.n	803b49a <UsefulBuf_IsValue+0x1e>
         return p - (uint8_t *)UB.ptr;
      }
   }

   /* Success. All bytes matched */
   return SIZE_MAX;
 803b494:	f04f 30ff 	mov.w	r0, #4294967295
 803b498:	e004      	b.n	803b4a4 <UsefulBuf_IsValue+0x28>
      if(*p != uValue) {
 803b49a:	7805      	ldrb	r5, [r0, #0]
 803b49c:	1c44      	adds	r4, r0, #1
 803b49e:	4295      	cmp	r5, r2
 803b4a0:	d002      	beq.n	803b4a8 <UsefulBuf_IsValue+0x2c>
         return p - (uint8_t *)UB.ptr;
 803b4a2:	1ac0      	subs	r0, r0, r3
}
 803b4a4:	b003      	add	sp, #12
 803b4a6:	bd30      	pop	{r4, r5, pc}
 803b4a8:	4620      	mov	r0, r4
 803b4aa:	e7f1      	b.n	803b490 <UsefulBuf_IsValue+0x14>
      return 0;
 803b4ac:	4618      	mov	r0, r3
 803b4ae:	e7f9      	b.n	803b4a4 <UsefulBuf_IsValue+0x28>

0803b4b0 <psa_allocate_key>:
     */
    return PSA_SUCCESS;
}

psa_status_t psa_allocate_key(psa_key_handle_t *handle)
{
 803b4b0:	b530      	push	{r4, r5, lr}
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    const struct tfm_crypto_pack_iovec iov = {
 803b4b2:	2434      	movs	r4, #52	; 0x34
{
 803b4b4:	b095      	sub	sp, #84	; 0x54
    const struct tfm_crypto_pack_iovec iov = {
 803b4b6:	ab07      	add	r3, sp, #28
{
 803b4b8:	4605      	mov	r5, r0
    const struct tfm_crypto_pack_iovec iov = {
 803b4ba:	4622      	mov	r2, r4
 803b4bc:	2100      	movs	r1, #0
 803b4be:	4618      	mov	r0, r3
 803b4c0:	f001 f8ae 	bl	803c620 <memset>
        .sfn_id = TFM_CRYPTO_ALLOCATE_KEY_SID,
    };
    psa_invec in_vec[] = {
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };
    psa_outvec out_vec[] = {
 803b4c4:	2302      	movs	r3, #2
    psa_invec in_vec[] = {
 803b4c6:	e9cd 0403 	strd	r0, r4, [sp, #12]
        {.base = handle, .len = sizeof(psa_key_handle_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b4ca:	2101      	movs	r1, #1
 803b4cc:	2080      	movs	r0, #128	; 0x80
    psa_outvec out_vec[] = {
 803b4ce:	9505      	str	r5, [sp, #20]
 803b4d0:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b4d2:	f000 fbc9 	bl	803bc68 <psa_connect>
 803b4d6:	1e05      	subs	r5, r0, #0
 803b4d8:	dd0e      	ble.n	803b4f8 <psa_allocate_key+0x48>

    status = API_DISPATCH(tfm_crypto_allocate_key,
 803b4da:	2301      	movs	r3, #1
 803b4dc:	aa05      	add	r2, sp, #20
 803b4de:	9200      	str	r2, [sp, #0]
 803b4e0:	9301      	str	r3, [sp, #4]
 803b4e2:	aa03      	add	r2, sp, #12
 803b4e4:	2100      	movs	r1, #0
 803b4e6:	f000 fbcd 	bl	803bc84 <psa_call>
 803b4ea:	4604      	mov	r4, r0
                          TFM_CRYPTO_ALLOCATE_KEY);

    PSA_CLOSE();
 803b4ec:	4628      	mov	r0, r5
 803b4ee:	f000 fbdd 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 803b4f2:	4620      	mov	r0, r4
 803b4f4:	b015      	add	sp, #84	; 0x54
 803b4f6:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b4f8:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b4fc:	e7f9      	b.n	803b4f2 <psa_allocate_key+0x42>

0803b4fe <psa_import_key>:

psa_status_t psa_import_key(psa_key_handle_t handle,
                            psa_key_type_t type,
                            const uint8_t *data,
                            size_t data_length)
{
 803b4fe:	b5f0      	push	{r4, r5, r6, r7, lr}
 803b500:	b095      	sub	sp, #84	; 0x54
 803b502:	4615      	mov	r5, r2
 803b504:	4607      	mov	r7, r0
 803b506:	460e      	mov	r6, r1
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b508:	222e      	movs	r2, #46	; 0x2e
 803b50a:	2100      	movs	r1, #0
 803b50c:	f10d 0022 	add.w	r0, sp, #34	; 0x22
{
 803b510:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
 803b512:	f001 f885 	bl	803c620 <memset>
        .sfn_id = TFM_CRYPTO_IMPORT_KEY_SID,
        .key_handle = handle,
        .type = type,
    };
    psa_invec in_vec[] = {
 803b516:	ab07      	add	r3, sp, #28
    struct tfm_crypto_pack_iovec iov = {
 803b518:	2101      	movs	r1, #1
    psa_invec in_vec[] = {
 803b51a:	9303      	str	r3, [sp, #12]
 803b51c:	2334      	movs	r3, #52	; 0x34
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = data, .len = data_length}
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b51e:	2080      	movs	r0, #128	; 0x80
    psa_invec in_vec[] = {
 803b520:	e9cd 3504 	strd	r3, r5, [sp, #16]
    struct tfm_crypto_pack_iovec iov = {
 803b524:	9107      	str	r1, [sp, #28]
 803b526:	f8ad 7020 	strh.w	r7, [sp, #32]
 803b52a:	9609      	str	r6, [sp, #36]	; 0x24
    psa_invec in_vec[] = {
 803b52c:	9406      	str	r4, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b52e:	f000 fb9b 	bl	803bc68 <psa_connect>
 803b532:	1e05      	subs	r5, r0, #0
 803b534:	dd0d      	ble.n	803b552 <psa_import_key+0x54>

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_import_key,
 803b536:	2100      	movs	r1, #0
 803b538:	2302      	movs	r3, #2
 803b53a:	e9cd 1100 	strd	r1, r1, [sp]
 803b53e:	aa03      	add	r2, sp, #12
 803b540:	f000 fba0 	bl	803bc84 <psa_call>
 803b544:	4604      	mov	r4, r0
                                    TFM_CRYPTO_IMPORT_KEY);

    PSA_CLOSE();
 803b546:	4628      	mov	r0, r5
 803b548:	f000 fbb0 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 803b54c:	4620      	mov	r0, r4
 803b54e:	b015      	add	sp, #84	; 0x54
 803b550:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b552:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b556:	e7f9      	b.n	803b54c <psa_import_key+0x4e>

0803b558 <psa_destroy_key>:

psa_status_t psa_destroy_key(psa_key_handle_t handle)
{
 803b558:	b530      	push	{r4, r5, lr}
 803b55a:	b093      	sub	sp, #76	; 0x4c
 803b55c:	4604      	mov	r4, r0
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b55e:	222e      	movs	r2, #46	; 0x2e
 803b560:	2100      	movs	r1, #0
 803b562:	f10d 001a 	add.w	r0, sp, #26
 803b566:	f001 f85b 	bl	803c620 <memset>
 803b56a:	2302      	movs	r3, #2
 803b56c:	9305      	str	r3, [sp, #20]
        .sfn_id = TFM_CRYPTO_DESTROY_KEY_SID,
        .key_handle = handle,
    };
    psa_invec in_vec[] = {
 803b56e:	ab05      	add	r3, sp, #20
 803b570:	9303      	str	r3, [sp, #12]
 803b572:	2334      	movs	r3, #52	; 0x34
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b574:	2101      	movs	r1, #1
 803b576:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
 803b578:	f8ad 4018 	strh.w	r4, [sp, #24]
    psa_invec in_vec[] = {
 803b57c:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
 803b57e:	f000 fb73 	bl	803bc68 <psa_connect>
 803b582:	1e05      	subs	r5, r0, #0
 803b584:	dd0d      	ble.n	803b5a2 <psa_destroy_key+0x4a>

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_destroy_key,
 803b586:	2100      	movs	r1, #0
 803b588:	2301      	movs	r3, #1
 803b58a:	e9cd 1100 	strd	r1, r1, [sp]
 803b58e:	aa03      	add	r2, sp, #12
 803b590:	f000 fb78 	bl	803bc84 <psa_call>
 803b594:	4604      	mov	r4, r0
                                    TFM_CRYPTO_DESTROY_KEY);

    PSA_CLOSE();
 803b596:	4628      	mov	r0, r5
 803b598:	f000 fb88 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 803b59c:	4620      	mov	r0, r4
 803b59e:	b013      	add	sp, #76	; 0x4c
 803b5a0:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b5a2:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b5a6:	e7f9      	b.n	803b59c <psa_destroy_key+0x44>

0803b5a8 <psa_get_key_information>:

psa_status_t psa_get_key_information(psa_key_handle_t handle,
                                     psa_key_type_t *type,
                                     size_t *bits)
{
 803b5a8:	b570      	push	{r4, r5, r6, lr}
 803b5aa:	b096      	sub	sp, #88	; 0x58
 803b5ac:	460d      	mov	r5, r1
 803b5ae:	4606      	mov	r6, r0
 803b5b0:	4614      	mov	r4, r2
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b5b2:	2100      	movs	r1, #0
 803b5b4:	222e      	movs	r2, #46	; 0x2e
 803b5b6:	f10d 002a 	add.w	r0, sp, #42	; 0x2a
 803b5ba:	f001 f831 	bl	803c620 <memset>
 803b5be:	2303      	movs	r3, #3
 803b5c0:	9309      	str	r3, [sp, #36]	; 0x24
        .sfn_id = TFM_CRYPTO_GET_KEY_INFORMATION_SID,
        .key_handle = handle,
    };
    psa_invec in_vec[] = {
 803b5c2:	ab09      	add	r3, sp, #36	; 0x24
 803b5c4:	9303      	str	r3, [sp, #12]
 803b5c6:	2334      	movs	r3, #52	; 0x34
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };
    psa_outvec out_vec[] = {
 803b5c8:	e9cd 3504 	strd	r3, r5, [sp, #16]
 803b5cc:	2304      	movs	r3, #4
        {.base = type, .len = sizeof(psa_key_type_t)},
        {.base = bits, .len = sizeof(size_t)}
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b5ce:	2101      	movs	r1, #1
 803b5d0:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
 803b5d2:	f8ad 6028 	strh.w	r6, [sp, #40]	; 0x28
    psa_outvec out_vec[] = {
 803b5d6:	e9cd 3406 	strd	r3, r4, [sp, #24]
 803b5da:	9308      	str	r3, [sp, #32]
    PSA_CONNECT(TFM_CRYPTO);
 803b5dc:	f000 fb44 	bl	803bc68 <psa_connect>
 803b5e0:	1e05      	subs	r5, r0, #0
 803b5e2:	dd0f      	ble.n	803b604 <psa_get_key_information+0x5c>

    status = API_DISPATCH(tfm_crypto_get_key_information,
 803b5e4:	2302      	movs	r3, #2
 803b5e6:	9301      	str	r3, [sp, #4]
 803b5e8:	ab05      	add	r3, sp, #20
 803b5ea:	9300      	str	r3, [sp, #0]
 803b5ec:	aa03      	add	r2, sp, #12
 803b5ee:	2301      	movs	r3, #1
 803b5f0:	2100      	movs	r1, #0
 803b5f2:	f000 fb47 	bl	803bc84 <psa_call>
 803b5f6:	4604      	mov	r4, r0
                          TFM_CRYPTO_GET_KEY_INFORMATION);

    PSA_CLOSE();
 803b5f8:	4628      	mov	r0, r5
 803b5fa:	f000 fb57 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 803b5fe:	4620      	mov	r0, r4
 803b600:	b016      	add	sp, #88	; 0x58
 803b602:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b604:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b608:	e7f9      	b.n	803b5fe <psa_get_key_information+0x56>

0803b60a <psa_key_policy_set_usage>:
void psa_key_policy_set_usage(psa_key_policy_t *policy,
                              psa_key_usage_t usage,
                              psa_algorithm_t alg)
{
    policy->usage = usage;
    policy->alg = alg;
 803b60a:	e9c0 1200 	strd	r1, r2, [r0]
}
 803b60e:	4770      	bx	lr

0803b610 <psa_set_key_policy>:
    return policy->alg;
}

psa_status_t psa_set_key_policy(psa_key_handle_t handle,
                                const psa_key_policy_t *policy)
{
 803b610:	b530      	push	{r4, r5, lr}
 803b612:	b095      	sub	sp, #84	; 0x54
 803b614:	4605      	mov	r5, r0
 803b616:	460c      	mov	r4, r1
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b618:	222e      	movs	r2, #46	; 0x2e
 803b61a:	2100      	movs	r1, #0
 803b61c:	f10d 0022 	add.w	r0, sp, #34	; 0x22
 803b620:	f000 fffe 	bl	803c620 <memset>
 803b624:	2307      	movs	r3, #7
 803b626:	9307      	str	r3, [sp, #28]
        .sfn_id = TFM_CRYPTO_SET_KEY_POLICY_SID,
        .key_handle = handle,
    };

    psa_invec in_vec[] = {
 803b628:	ab07      	add	r3, sp, #28
 803b62a:	9303      	str	r3, [sp, #12]
 803b62c:	2334      	movs	r3, #52	; 0x34
 803b62e:	e9cd 3404 	strd	r3, r4, [sp, #16]
 803b632:	230c      	movs	r3, #12
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = policy, .len = sizeof(psa_key_policy_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b634:	2101      	movs	r1, #1
 803b636:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
 803b638:	f8ad 5020 	strh.w	r5, [sp, #32]
    psa_invec in_vec[] = {
 803b63c:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b63e:	f000 fb13 	bl	803bc68 <psa_connect>
 803b642:	1e05      	subs	r5, r0, #0
 803b644:	dd0d      	ble.n	803b662 <psa_set_key_policy+0x52>

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_set_key_policy,
 803b646:	2100      	movs	r1, #0
 803b648:	2302      	movs	r3, #2
 803b64a:	e9cd 1100 	strd	r1, r1, [sp]
 803b64e:	aa03      	add	r2, sp, #12
 803b650:	f000 fb18 	bl	803bc84 <psa_call>
 803b654:	4604      	mov	r4, r0
                                    TFM_CRYPTO_SET_KEY_POLICY);

    PSA_CLOSE();
 803b656:	4628      	mov	r0, r5
 803b658:	f000 fb28 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 803b65c:	4620      	mov	r0, r4
 803b65e:	b015      	add	sp, #84	; 0x54
 803b660:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b662:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b666:	e7f9      	b.n	803b65c <psa_set_key_policy+0x4c>

0803b668 <psa_cipher_set_iv>:
}

psa_status_t psa_cipher_set_iv(psa_cipher_operation_t *operation,
                               const unsigned char *iv,
                               size_t iv_length)
{
 803b668:	b570      	push	{r4, r5, r6, lr}
 803b66a:	b096      	sub	sp, #88	; 0x58
 803b66c:	4604      	mov	r4, r0
 803b66e:	4615      	mov	r5, r2
 803b670:	460e      	mov	r6, r1
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b672:	2230      	movs	r2, #48	; 0x30
 803b674:	2100      	movs	r1, #0
 803b676:	a80a      	add	r0, sp, #40	; 0x28
 803b678:	f000 ffd2 	bl	803c620 <memset>
 803b67c:	230b      	movs	r3, #11
 803b67e:	9309      	str	r3, [sp, #36]	; 0x24
 803b680:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b682:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b684:	930f      	str	r3, [sp, #60]	; 0x3c
    psa_invec in_vec[] = {
 803b686:	ab09      	add	r3, sp, #36	; 0x24
 803b688:	9305      	str	r3, [sp, #20]
 803b68a:	2334      	movs	r3, #52	; 0x34
 803b68c:	e9cd 3606 	strd	r3, r6, [sp, #24]
    psa_outvec out_vec[] = {
 803b690:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b692:	2080      	movs	r0, #128	; 0x80
    psa_invec in_vec[] = {
 803b694:	9508      	str	r5, [sp, #32]
    psa_outvec out_vec[] = {
 803b696:	9403      	str	r4, [sp, #12]
 803b698:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
 803b69a:	f000 fae5 	bl	803bc68 <psa_connect>
 803b69e:	1e05      	subs	r5, r0, #0
 803b6a0:	dd0f      	ble.n	803b6c2 <psa_cipher_set_iv+0x5a>

    status = API_DISPATCH(tfm_crypto_cipher_set_iv,
 803b6a2:	2301      	movs	r3, #1
 803b6a4:	9301      	str	r3, [sp, #4]
 803b6a6:	ab03      	add	r3, sp, #12
 803b6a8:	9300      	str	r3, [sp, #0]
 803b6aa:	aa05      	add	r2, sp, #20
 803b6ac:	2302      	movs	r3, #2
 803b6ae:	2100      	movs	r1, #0
 803b6b0:	f000 fae8 	bl	803bc84 <psa_call>
 803b6b4:	4604      	mov	r4, r0
                          TFM_CRYPTO_CIPHER_SET_IV);

    PSA_CLOSE();
 803b6b6:	4628      	mov	r0, r5
 803b6b8:	f000 faf8 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 803b6bc:	4620      	mov	r0, r4
 803b6be:	b016      	add	sp, #88	; 0x58
 803b6c0:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b6c2:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b6c6:	e7f9      	b.n	803b6bc <psa_cipher_set_iv+0x54>

0803b6c8 <psa_cipher_encrypt_setup>:

psa_status_t psa_cipher_encrypt_setup(psa_cipher_operation_t *operation,
                                      psa_key_handle_t handle,
                                      psa_algorithm_t alg)
{
 803b6c8:	b570      	push	{r4, r5, r6, lr}
 803b6ca:	b094      	sub	sp, #80	; 0x50
 803b6cc:	4604      	mov	r4, r0
 803b6ce:	4615      	mov	r5, r2
 803b6d0:	460e      	mov	r6, r1
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b6d2:	222e      	movs	r2, #46	; 0x2e
 803b6d4:	2100      	movs	r1, #0
 803b6d6:	f10d 0022 	add.w	r0, sp, #34	; 0x22
 803b6da:	f000 ffa1 	bl	803c620 <memset>
 803b6de:	230c      	movs	r3, #12
 803b6e0:	9307      	str	r3, [sp, #28]
 803b6e2:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b6e4:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b6e6:	930d      	str	r3, [sp, #52]	; 0x34
    psa_invec in_vec[] = {
 803b6e8:	ab07      	add	r3, sp, #28
 803b6ea:	9303      	str	r3, [sp, #12]
 803b6ec:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
 803b6ee:	e9cd 3404 	strd	r3, r4, [sp, #16]
 803b6f2:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b6f4:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
 803b6f6:	950b      	str	r5, [sp, #44]	; 0x2c
 803b6f8:	f8ad 6020 	strh.w	r6, [sp, #32]
    psa_outvec out_vec[] = {
 803b6fc:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b6fe:	f000 fab3 	bl	803bc68 <psa_connect>
 803b702:	1e05      	subs	r5, r0, #0
 803b704:	dd0e      	ble.n	803b724 <psa_cipher_encrypt_setup+0x5c>

    status = API_DISPATCH(tfm_crypto_cipher_encrypt_setup,
 803b706:	2301      	movs	r3, #1
 803b708:	aa05      	add	r2, sp, #20
 803b70a:	9200      	str	r2, [sp, #0]
 803b70c:	9301      	str	r3, [sp, #4]
 803b70e:	aa03      	add	r2, sp, #12
 803b710:	2100      	movs	r1, #0
 803b712:	f000 fab7 	bl	803bc84 <psa_call>
 803b716:	4604      	mov	r4, r0
                          TFM_CRYPTO_CIPHER_ENCRYPT_SETUP);

    PSA_CLOSE();
 803b718:	4628      	mov	r0, r5
 803b71a:	f000 fac7 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 803b71e:	4620      	mov	r0, r4
 803b720:	b014      	add	sp, #80	; 0x50
 803b722:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b724:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b728:	e7f9      	b.n	803b71e <psa_cipher_encrypt_setup+0x56>

0803b72a <psa_cipher_decrypt_setup>:

psa_status_t psa_cipher_decrypt_setup(psa_cipher_operation_t *operation,
                                      psa_key_handle_t handle,
                                      psa_algorithm_t alg)
{
 803b72a:	b570      	push	{r4, r5, r6, lr}
 803b72c:	b094      	sub	sp, #80	; 0x50
 803b72e:	4604      	mov	r4, r0
 803b730:	4615      	mov	r5, r2
 803b732:	460e      	mov	r6, r1
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b734:	222e      	movs	r2, #46	; 0x2e
 803b736:	2100      	movs	r1, #0
 803b738:	f10d 0022 	add.w	r0, sp, #34	; 0x22
 803b73c:	f000 ff70 	bl	803c620 <memset>
 803b740:	230d      	movs	r3, #13
 803b742:	9307      	str	r3, [sp, #28]
 803b744:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b746:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b748:	930d      	str	r3, [sp, #52]	; 0x34
    psa_invec in_vec[] = {
 803b74a:	ab07      	add	r3, sp, #28
 803b74c:	9303      	str	r3, [sp, #12]
 803b74e:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
 803b750:	e9cd 3404 	strd	r3, r4, [sp, #16]
 803b754:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b756:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
 803b758:	950b      	str	r5, [sp, #44]	; 0x2c
 803b75a:	f8ad 6020 	strh.w	r6, [sp, #32]
    psa_outvec out_vec[] = {
 803b75e:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b760:	f000 fa82 	bl	803bc68 <psa_connect>
 803b764:	1e05      	subs	r5, r0, #0
 803b766:	dd0e      	ble.n	803b786 <psa_cipher_decrypt_setup+0x5c>

    status = API_DISPATCH(tfm_crypto_cipher_decrypt_setup,
 803b768:	2301      	movs	r3, #1
 803b76a:	aa05      	add	r2, sp, #20
 803b76c:	9200      	str	r2, [sp, #0]
 803b76e:	9301      	str	r3, [sp, #4]
 803b770:	aa03      	add	r2, sp, #12
 803b772:	2100      	movs	r1, #0
 803b774:	f000 fa86 	bl	803bc84 <psa_call>
 803b778:	4604      	mov	r4, r0
                          TFM_CRYPTO_CIPHER_DECRYPT_SETUP);

    PSA_CLOSE();
 803b77a:	4628      	mov	r0, r5
 803b77c:	f000 fa96 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 803b780:	4620      	mov	r0, r4
 803b782:	b014      	add	sp, #80	; 0x50
 803b784:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b786:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b78a:	e7f9      	b.n	803b780 <psa_cipher_decrypt_setup+0x56>

0803b78c <psa_cipher_update>:
                               const uint8_t *input,
                               size_t input_length,
                               unsigned char *output,
                               size_t output_size,
                               size_t *output_length)
{
 803b78c:	b5f0      	push	{r4, r5, r6, r7, lr}
 803b78e:	4616      	mov	r6, r2
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b790:	2230      	movs	r2, #48	; 0x30
{
 803b792:	b099      	sub	sp, #100	; 0x64
 803b794:	4604      	mov	r4, r0
 803b796:	460f      	mov	r7, r1
    struct tfm_crypto_pack_iovec iov = {
 803b798:	eb0d 0002 	add.w	r0, sp, r2
 803b79c:	2100      	movs	r1, #0
{
 803b79e:	461d      	mov	r5, r3
    struct tfm_crypto_pack_iovec iov = {
 803b7a0:	f000 ff3e 	bl	803c620 <memset>
 803b7a4:	230e      	movs	r3, #14
 803b7a6:	930b      	str	r3, [sp, #44]	; 0x2c
 803b7a8:	6823      	ldr	r3, [r4, #0]
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
        {.base = output, .len = output_size}
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b7aa:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b7ac:	9311      	str	r3, [sp, #68]	; 0x44
    psa_invec in_vec[] = {
 803b7ae:	ab0b      	add	r3, sp, #44	; 0x2c
 803b7b0:	9303      	str	r3, [sp, #12]
 803b7b2:	2334      	movs	r3, #52	; 0x34
 803b7b4:	e9cd 3704 	strd	r3, r7, [sp, #16]
    psa_outvec out_vec[] = {
 803b7b8:	2304      	movs	r3, #4
 803b7ba:	e9cd 3508 	strd	r3, r5, [sp, #32]
 803b7be:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    PSA_CONNECT(TFM_CRYPTO);
 803b7c0:	2080      	movs	r0, #128	; 0x80
    psa_outvec out_vec[] = {
 803b7c2:	e9cd 6406 	strd	r6, r4, [sp, #24]
 803b7c6:	930a      	str	r3, [sp, #40]	; 0x28
    PSA_CONNECT(TFM_CRYPTO);
 803b7c8:	f000 fa4e 	bl	803bc68 <psa_connect>
 803b7cc:	1e05      	subs	r5, r0, #0
 803b7ce:	dd11      	ble.n	803b7f4 <psa_cipher_update+0x68>

    status = API_DISPATCH(tfm_crypto_cipher_update,
 803b7d0:	2302      	movs	r3, #2
 803b7d2:	aa07      	add	r2, sp, #28
 803b7d4:	9301      	str	r3, [sp, #4]
 803b7d6:	9200      	str	r2, [sp, #0]
 803b7d8:	2100      	movs	r1, #0
 803b7da:	aa03      	add	r2, sp, #12
 803b7dc:	f000 fa52 	bl	803bc84 <psa_call>
                          TFM_CRYPTO_CIPHER_UPDATE);

    *output_length = out_vec[1].len;
 803b7e0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 803b7e2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    status = API_DISPATCH(tfm_crypto_cipher_update,
 803b7e4:	4604      	mov	r4, r0
    *output_length = out_vec[1].len;
 803b7e6:	601a      	str	r2, [r3, #0]

    PSA_CLOSE();
 803b7e8:	4628      	mov	r0, r5
 803b7ea:	f000 fa5f 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 803b7ee:	4620      	mov	r0, r4
 803b7f0:	b019      	add	sp, #100	; 0x64
 803b7f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b7f4:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b7f8:	e7f9      	b.n	803b7ee <psa_cipher_update+0x62>

0803b7fa <psa_cipher_abort>:

psa_status_t psa_cipher_abort(psa_cipher_operation_t *operation)
{
 803b7fa:	b530      	push	{r4, r5, lr}
 803b7fc:	b095      	sub	sp, #84	; 0x54
 803b7fe:	4604      	mov	r4, r0
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b800:	2230      	movs	r2, #48	; 0x30
 803b802:	2100      	movs	r1, #0
 803b804:	a808      	add	r0, sp, #32
 803b806:	f000 ff0b 	bl	803c620 <memset>
 803b80a:	230f      	movs	r3, #15
 803b80c:	9307      	str	r3, [sp, #28]
 803b80e:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b810:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b812:	930d      	str	r3, [sp, #52]	; 0x34
    psa_invec in_vec[] = {
 803b814:	ab07      	add	r3, sp, #28
 803b816:	9303      	str	r3, [sp, #12]
 803b818:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
 803b81a:	e9cd 3404 	strd	r3, r4, [sp, #16]
 803b81e:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b820:	2080      	movs	r0, #128	; 0x80
    psa_outvec out_vec[] = {
 803b822:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b824:	f000 fa20 	bl	803bc68 <psa_connect>
 803b828:	1e05      	subs	r5, r0, #0
 803b82a:	dd0e      	ble.n	803b84a <psa_cipher_abort+0x50>

    status = API_DISPATCH(tfm_crypto_cipher_abort,
 803b82c:	2301      	movs	r3, #1
 803b82e:	aa05      	add	r2, sp, #20
 803b830:	9200      	str	r2, [sp, #0]
 803b832:	9301      	str	r3, [sp, #4]
 803b834:	aa03      	add	r2, sp, #12
 803b836:	2100      	movs	r1, #0
 803b838:	f000 fa24 	bl	803bc84 <psa_call>
 803b83c:	4604      	mov	r4, r0
                          TFM_CRYPTO_CIPHER_ABORT);

    PSA_CLOSE();
 803b83e:	4628      	mov	r0, r5
 803b840:	f000 fa34 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 803b844:	4620      	mov	r0, r4
 803b846:	b015      	add	sp, #84	; 0x54
 803b848:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b84a:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b84e:	e7f9      	b.n	803b844 <psa_cipher_abort+0x4a>

0803b850 <psa_cipher_finish>:

psa_status_t psa_cipher_finish(psa_cipher_operation_t *operation,
                               uint8_t *output,
                               size_t output_size,
                               size_t *output_length)
{
 803b850:	b5f0      	push	{r4, r5, r6, r7, lr}
 803b852:	b097      	sub	sp, #92	; 0x5c
 803b854:	4604      	mov	r4, r0
 803b856:	4615      	mov	r5, r2
 803b858:	460f      	mov	r7, r1
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b85a:	2230      	movs	r2, #48	; 0x30
 803b85c:	2100      	movs	r1, #0
 803b85e:	a80a      	add	r0, sp, #40	; 0x28
{
 803b860:	461e      	mov	r6, r3
    struct tfm_crypto_pack_iovec iov = {
 803b862:	f000 fedd 	bl	803c620 <memset>
 803b866:	2310      	movs	r3, #16
 803b868:	9309      	str	r3, [sp, #36]	; 0x24
 803b86a:	6823      	ldr	r3, [r4, #0]
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
        {.base = output, .len = output_size},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b86c:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b86e:	930f      	str	r3, [sp, #60]	; 0x3c
    psa_invec in_vec[] = {
 803b870:	ab09      	add	r3, sp, #36	; 0x24
 803b872:	9303      	str	r3, [sp, #12]
 803b874:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
 803b876:	e9cd 3404 	strd	r3, r4, [sp, #16]
 803b87a:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b87c:	2080      	movs	r0, #128	; 0x80
    psa_outvec out_vec[] = {
 803b87e:	9508      	str	r5, [sp, #32]
 803b880:	e9cd 3706 	strd	r3, r7, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b884:	f000 f9f0 	bl	803bc68 <psa_connect>
 803b888:	1e05      	subs	r5, r0, #0
 803b88a:	dd11      	ble.n	803b8b0 <psa_cipher_finish+0x60>

    status = API_DISPATCH(tfm_crypto_cipher_finish,
 803b88c:	2302      	movs	r3, #2
 803b88e:	9301      	str	r3, [sp, #4]
 803b890:	ab05      	add	r3, sp, #20
 803b892:	9300      	str	r3, [sp, #0]
 803b894:	aa03      	add	r2, sp, #12
 803b896:	2301      	movs	r3, #1
 803b898:	2100      	movs	r1, #0
 803b89a:	f000 f9f3 	bl	803bc84 <psa_call>
                          TFM_CRYPTO_CIPHER_FINISH);

    *output_length = out_vec[1].len;
 803b89e:	9b08      	ldr	r3, [sp, #32]
    status = API_DISPATCH(tfm_crypto_cipher_finish,
 803b8a0:	4604      	mov	r4, r0
    *output_length = out_vec[1].len;
 803b8a2:	6033      	str	r3, [r6, #0]

    PSA_CLOSE();
 803b8a4:	4628      	mov	r0, r5
 803b8a6:	f000 fa01 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 803b8aa:	4620      	mov	r0, r4
 803b8ac:	b017      	add	sp, #92	; 0x5c
 803b8ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b8b0:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b8b4:	e7f9      	b.n	803b8aa <psa_cipher_finish+0x5a>

0803b8b6 <psa_hash_setup>:

psa_status_t psa_hash_setup(psa_hash_operation_t *operation,
                            psa_algorithm_t alg)
{
 803b8b6:	b530      	push	{r4, r5, lr}
 803b8b8:	b095      	sub	sp, #84	; 0x54
 803b8ba:	4604      	mov	r4, r0
 803b8bc:	460d      	mov	r5, r1
#if (TFM_CRYPTO_HASH_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b8be:	2230      	movs	r2, #48	; 0x30
 803b8c0:	2100      	movs	r1, #0
 803b8c2:	a808      	add	r0, sp, #32
 803b8c4:	f000 feac 	bl	803c620 <memset>
 803b8c8:	2311      	movs	r3, #17
 803b8ca:	9307      	str	r3, [sp, #28]
 803b8cc:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b8ce:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b8d0:	930d      	str	r3, [sp, #52]	; 0x34
    psa_invec in_vec[] = {
 803b8d2:	ab07      	add	r3, sp, #28
 803b8d4:	9303      	str	r3, [sp, #12]
 803b8d6:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
 803b8d8:	e9cd 3404 	strd	r3, r4, [sp, #16]
 803b8dc:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b8de:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
 803b8e0:	950b      	str	r5, [sp, #44]	; 0x2c
    psa_outvec out_vec[] = {
 803b8e2:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 803b8e4:	f000 f9c0 	bl	803bc68 <psa_connect>
 803b8e8:	1e05      	subs	r5, r0, #0
 803b8ea:	dd0e      	ble.n	803b90a <psa_hash_setup+0x54>

    status = API_DISPATCH(tfm_crypto_hash_setup,
 803b8ec:	2301      	movs	r3, #1
 803b8ee:	aa05      	add	r2, sp, #20
 803b8f0:	9200      	str	r2, [sp, #0]
 803b8f2:	9301      	str	r3, [sp, #4]
 803b8f4:	aa03      	add	r2, sp, #12
 803b8f6:	2100      	movs	r1, #0
 803b8f8:	f000 f9c4 	bl	803bc84 <psa_call>
 803b8fc:	4604      	mov	r4, r0
                          TFM_CRYPTO_HASH_SETUP);

    PSA_CLOSE();
 803b8fe:	4628      	mov	r0, r5
 803b900:	f000 f9d4 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 803b904:	4620      	mov	r0, r4
 803b906:	b015      	add	sp, #84	; 0x54
 803b908:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b90a:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b90e:	e7f9      	b.n	803b904 <psa_hash_setup+0x4e>

0803b910 <psa_hash_update>:

psa_status_t psa_hash_update(psa_hash_operation_t *operation,
                             const uint8_t *input,
                             size_t input_length)
{
 803b910:	b570      	push	{r4, r5, r6, lr}
 803b912:	b096      	sub	sp, #88	; 0x58
 803b914:	4604      	mov	r4, r0
 803b916:	4615      	mov	r5, r2
 803b918:	460e      	mov	r6, r1
#if (TFM_CRYPTO_HASH_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b91a:	2230      	movs	r2, #48	; 0x30
 803b91c:	2100      	movs	r1, #0
 803b91e:	a80a      	add	r0, sp, #40	; 0x28
 803b920:	f000 fe7e 	bl	803c620 <memset>
 803b924:	2312      	movs	r3, #18
 803b926:	9309      	str	r3, [sp, #36]	; 0x24
 803b928:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b92a:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b92c:	930f      	str	r3, [sp, #60]	; 0x3c
    psa_invec in_vec[] = {
 803b92e:	ab09      	add	r3, sp, #36	; 0x24
 803b930:	9305      	str	r3, [sp, #20]
 803b932:	2334      	movs	r3, #52	; 0x34
 803b934:	e9cd 3606 	strd	r3, r6, [sp, #24]
    psa_outvec out_vec[] = {
 803b938:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b93a:	2080      	movs	r0, #128	; 0x80
    psa_invec in_vec[] = {
 803b93c:	9508      	str	r5, [sp, #32]
    psa_outvec out_vec[] = {
 803b93e:	9403      	str	r4, [sp, #12]
 803b940:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
 803b942:	f000 f991 	bl	803bc68 <psa_connect>
 803b946:	1e05      	subs	r5, r0, #0
 803b948:	dd0f      	ble.n	803b96a <psa_hash_update+0x5a>

    status = API_DISPATCH(tfm_crypto_hash_update,
 803b94a:	2301      	movs	r3, #1
 803b94c:	9301      	str	r3, [sp, #4]
 803b94e:	ab03      	add	r3, sp, #12
 803b950:	9300      	str	r3, [sp, #0]
 803b952:	aa05      	add	r2, sp, #20
 803b954:	2302      	movs	r3, #2
 803b956:	2100      	movs	r1, #0
 803b958:	f000 f994 	bl	803bc84 <psa_call>
 803b95c:	4604      	mov	r4, r0
                          TFM_CRYPTO_HASH_UPDATE);

    PSA_CLOSE();
 803b95e:	4628      	mov	r0, r5
 803b960:	f000 f9a4 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 803b964:	4620      	mov	r0, r4
 803b966:	b016      	add	sp, #88	; 0x58
 803b968:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b96a:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b96e:	e7f9      	b.n	803b964 <psa_hash_update+0x54>

0803b970 <psa_hash_verify>:
}

psa_status_t psa_hash_verify(psa_hash_operation_t *operation,
                             const uint8_t *hash,
                             size_t hash_length)
{
 803b970:	b570      	push	{r4, r5, r6, lr}
 803b972:	b096      	sub	sp, #88	; 0x58
 803b974:	4604      	mov	r4, r0
 803b976:	4615      	mov	r5, r2
 803b978:	460e      	mov	r6, r1
#if (TFM_CRYPTO_HASH_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b97a:	2230      	movs	r2, #48	; 0x30
 803b97c:	2100      	movs	r1, #0
 803b97e:	a80a      	add	r0, sp, #40	; 0x28
 803b980:	f000 fe4e 	bl	803c620 <memset>
 803b984:	2314      	movs	r3, #20
 803b986:	9309      	str	r3, [sp, #36]	; 0x24
 803b988:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
 803b98a:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 803b98c:	930f      	str	r3, [sp, #60]	; 0x3c
    psa_invec in_vec[] = {
 803b98e:	ab09      	add	r3, sp, #36	; 0x24
 803b990:	9305      	str	r3, [sp, #20]
 803b992:	2334      	movs	r3, #52	; 0x34
 803b994:	e9cd 3606 	strd	r3, r6, [sp, #24]
    psa_outvec out_vec[] = {
 803b998:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 803b99a:	2080      	movs	r0, #128	; 0x80
    psa_invec in_vec[] = {
 803b99c:	9508      	str	r5, [sp, #32]
    psa_outvec out_vec[] = {
 803b99e:	9403      	str	r4, [sp, #12]
 803b9a0:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
 803b9a2:	f000 f961 	bl	803bc68 <psa_connect>
 803b9a6:	1e05      	subs	r5, r0, #0
 803b9a8:	dd0f      	ble.n	803b9ca <psa_hash_verify+0x5a>

    status = API_DISPATCH(tfm_crypto_hash_verify,
 803b9aa:	2301      	movs	r3, #1
 803b9ac:	9301      	str	r3, [sp, #4]
 803b9ae:	ab03      	add	r3, sp, #12
 803b9b0:	9300      	str	r3, [sp, #0]
 803b9b2:	aa05      	add	r2, sp, #20
 803b9b4:	2302      	movs	r3, #2
 803b9b6:	2100      	movs	r1, #0
 803b9b8:	f000 f964 	bl	803bc84 <psa_call>
 803b9bc:	4604      	mov	r4, r0
                          TFM_CRYPTO_HASH_VERIFY);

    PSA_CLOSE();
 803b9be:	4628      	mov	r0, r5
 803b9c0:	f000 f974 	bl	803bcac <psa_close>

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 803b9c4:	4620      	mov	r0, r4
 803b9c6:	b016      	add	sp, #88	; 0x58
 803b9c8:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 803b9ca:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803b9ce:	e7f9      	b.n	803b9c4 <psa_hash_verify+0x54>

0803b9d0 <psa_aead_encrypt>:
                              const uint8_t *plaintext,
                              size_t plaintext_length,
                              uint8_t *ciphertext,
                              size_t ciphertext_size,
                              size_t *ciphertext_length)
{
 803b9d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 803b9d4:	b099      	sub	sp, #100	; 0x64
 803b9d6:	4681      	mov	r9, r0
 803b9d8:	e9dd 4720 	ldrd	r4, r7, [sp, #128]	; 0x80
 803b9dc:	4688      	mov	r8, r1
 803b9de:	4616      	mov	r6, r2
#if (TFM_CRYPTO_AEAD_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803b9e0:	2100      	movs	r1, #0
 803b9e2:	222a      	movs	r2, #42	; 0x2a
 803b9e4:	f10d 0032 	add.w	r0, sp, #50	; 0x32
{
 803b9e8:	461d      	mov	r5, r3
    struct tfm_crypto_pack_iovec iov = {
 803b9ea:	f000 fe19 	bl	803c620 <memset>
 803b9ee:	231d      	movs	r3, #29
 803b9f0:	f8ad 9030 	strh.w	r9, [sp, #48]	; 0x30
 803b9f4:	930b      	str	r3, [sp, #44]	; 0x2c
 803b9f6:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 803b9fa:	9517      	str	r5, [sp, #92]	; 0x5c
        .alg = alg,
        .aead_in = {.nonce = {0}, .nonce_length = nonce_length}
    };

    /* Sanitize the optional input */
    if ((additional_data == NULL) && (additional_data_length != 0)) {
 803b9fc:	b934      	cbnz	r4, 803ba0c <psa_aead_encrypt+0x3c>
 803b9fe:	b12f      	cbz	r7, 803ba0c <psa_aead_encrypt+0x3c>
        return PSA_ERROR_INVALID_ARGUMENT;
 803ba00:	f06f 0486 	mvn.w	r4, #134	; 0x86

    PSA_CLOSE();

    return status;
#endif /* TFM_CRYPTO_AEAD_MODULE_DISABLED */
}
 803ba04:	4620      	mov	r0, r4
 803ba06:	b019      	add	sp, #100	; 0x64
 803ba08:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    psa_invec in_vec[] = {
 803ba0c:	2234      	movs	r2, #52	; 0x34
 803ba0e:	9206      	str	r2, [sp, #24]
 803ba10:	9a22      	ldr	r2, [sp, #136]	; 0x88
 803ba12:	ab0b      	add	r3, sp, #44	; 0x2c
 803ba14:	9207      	str	r2, [sp, #28]
 803ba16:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
 803ba18:	2d10      	cmp	r5, #16
    psa_invec in_vec[] = {
 803ba1a:	e9cd 2408 	strd	r2, r4, [sp, #32]
    psa_outvec out_vec[] = {
 803ba1e:	9a24      	ldr	r2, [sp, #144]	; 0x90
    psa_invec in_vec[] = {
 803ba20:	9305      	str	r3, [sp, #20]
    psa_outvec out_vec[] = {
 803ba22:	9203      	str	r2, [sp, #12]
 803ba24:	9a25      	ldr	r2, [sp, #148]	; 0x94
    psa_invec in_vec[] = {
 803ba26:	970a      	str	r7, [sp, #40]	; 0x28
    psa_outvec out_vec[] = {
 803ba28:	9204      	str	r2, [sp, #16]
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
 803ba2a:	d8e9      	bhi.n	803ba00 <psa_aead_encrypt+0x30>
    if (nonce != NULL) {
 803ba2c:	b986      	cbnz	r6, 803ba50 <psa_aead_encrypt+0x80>
    PSA_CONNECT(TFM_CRYPTO);
 803ba2e:	2101      	movs	r1, #1
 803ba30:	2080      	movs	r0, #128	; 0x80
 803ba32:	f000 f919 	bl	803bc68 <psa_connect>
 803ba36:	1e05      	subs	r5, r0, #0
 803ba38:	dc0c      	bgt.n	803ba54 <psa_aead_encrypt+0x84>
 803ba3a:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803ba3e:	e7e1      	b.n	803ba04 <psa_aead_encrypt+0x34>
            iov.aead_in.nonce[idx] = nonce[idx];
 803ba40:	5cb0      	ldrb	r0, [r6, r2]
 803ba42:	1899      	adds	r1, r3, r2
 803ba44:	f881 0020 	strb.w	r0, [r1, #32]
        for (idx = 0; idx < nonce_length; idx++) {
 803ba48:	3201      	adds	r2, #1
 803ba4a:	42aa      	cmp	r2, r5
 803ba4c:	d1f8      	bne.n	803ba40 <psa_aead_encrypt+0x70>
 803ba4e:	e7ee      	b.n	803ba2e <psa_aead_encrypt+0x5e>
 803ba50:	2200      	movs	r2, #0
 803ba52:	e7fa      	b.n	803ba4a <psa_aead_encrypt+0x7a>
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 803ba54:	2301      	movs	r3, #1
        in_len--;
 803ba56:	2c00      	cmp	r4, #0
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 803ba58:	9301      	str	r3, [sp, #4]
 803ba5a:	ab03      	add	r3, sp, #12
 803ba5c:	9300      	str	r3, [sp, #0]
 803ba5e:	aa05      	add	r2, sp, #20
 803ba60:	bf14      	ite	ne
 803ba62:	2303      	movne	r3, #3
 803ba64:	2302      	moveq	r3, #2
 803ba66:	2100      	movs	r1, #0
 803ba68:	f000 f90c 	bl	803bc84 <psa_call>
    *ciphertext_length = out_vec[0].len;
 803ba6c:	9b26      	ldr	r3, [sp, #152]	; 0x98
 803ba6e:	9a04      	ldr	r2, [sp, #16]
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 803ba70:	4604      	mov	r4, r0
    *ciphertext_length = out_vec[0].len;
 803ba72:	601a      	str	r2, [r3, #0]
    PSA_CLOSE();
 803ba74:	4628      	mov	r0, r5
 803ba76:	f000 f919 	bl	803bcac <psa_close>
    return status;
 803ba7a:	e7c3      	b.n	803ba04 <psa_aead_encrypt+0x34>

0803ba7c <psa_aead_decrypt>:
                              const uint8_t *ciphertext,
                              size_t ciphertext_length,
                              uint8_t *plaintext,
                              size_t plaintext_size,
                              size_t *plaintext_length)
{
 803ba7c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 803ba80:	b099      	sub	sp, #100	; 0x64
 803ba82:	4681      	mov	r9, r0
 803ba84:	e9dd 4720 	ldrd	r4, r7, [sp, #128]	; 0x80
 803ba88:	4688      	mov	r8, r1
 803ba8a:	4616      	mov	r6, r2
#if (TFM_CRYPTO_AEAD_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 803ba8c:	2100      	movs	r1, #0
 803ba8e:	222a      	movs	r2, #42	; 0x2a
 803ba90:	f10d 0032 	add.w	r0, sp, #50	; 0x32
{
 803ba94:	461d      	mov	r5, r3
    struct tfm_crypto_pack_iovec iov = {
 803ba96:	f000 fdc3 	bl	803c620 <memset>
 803ba9a:	231e      	movs	r3, #30
 803ba9c:	f8ad 9030 	strh.w	r9, [sp, #48]	; 0x30
 803baa0:	930b      	str	r3, [sp, #44]	; 0x2c
 803baa2:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 803baa6:	9517      	str	r5, [sp, #92]	; 0x5c
        .alg = alg,
        .aead_in = {.nonce = {0}, .nonce_length = nonce_length}
    };

    /* Sanitize the optional input */
    if ((additional_data == NULL) && (additional_data_length != 0)) {
 803baa8:	b934      	cbnz	r4, 803bab8 <psa_aead_decrypt+0x3c>
 803baaa:	b12f      	cbz	r7, 803bab8 <psa_aead_decrypt+0x3c>
        return PSA_ERROR_INVALID_ARGUMENT;
 803baac:	f06f 0486 	mvn.w	r4, #134	; 0x86

    PSA_CLOSE();

    return status;
#endif /* TFM_CRYPTO_AEAD_MODULE_DISABLED */
}
 803bab0:	4620      	mov	r0, r4
 803bab2:	b019      	add	sp, #100	; 0x64
 803bab4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    psa_invec in_vec[] = {
 803bab8:	2234      	movs	r2, #52	; 0x34
 803baba:	9206      	str	r2, [sp, #24]
 803babc:	9a22      	ldr	r2, [sp, #136]	; 0x88
 803babe:	ab0b      	add	r3, sp, #44	; 0x2c
 803bac0:	9207      	str	r2, [sp, #28]
 803bac2:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
 803bac4:	2d10      	cmp	r5, #16
    psa_invec in_vec[] = {
 803bac6:	e9cd 2408 	strd	r2, r4, [sp, #32]
    psa_outvec out_vec[] = {
 803baca:	9a24      	ldr	r2, [sp, #144]	; 0x90
    psa_invec in_vec[] = {
 803bacc:	9305      	str	r3, [sp, #20]
    psa_outvec out_vec[] = {
 803bace:	9203      	str	r2, [sp, #12]
 803bad0:	9a25      	ldr	r2, [sp, #148]	; 0x94
    psa_invec in_vec[] = {
 803bad2:	970a      	str	r7, [sp, #40]	; 0x28
    psa_outvec out_vec[] = {
 803bad4:	9204      	str	r2, [sp, #16]
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
 803bad6:	d8e9      	bhi.n	803baac <psa_aead_decrypt+0x30>
    if (nonce != NULL) {
 803bad8:	b986      	cbnz	r6, 803bafc <psa_aead_decrypt+0x80>
    PSA_CONNECT(TFM_CRYPTO);
 803bada:	2101      	movs	r1, #1
 803badc:	2080      	movs	r0, #128	; 0x80
 803bade:	f000 f8c3 	bl	803bc68 <psa_connect>
 803bae2:	1e05      	subs	r5, r0, #0
 803bae4:	dc0c      	bgt.n	803bb00 <psa_aead_decrypt+0x84>
 803bae6:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803baea:	e7e1      	b.n	803bab0 <psa_aead_decrypt+0x34>
            iov.aead_in.nonce[idx] = nonce[idx];
 803baec:	5cb0      	ldrb	r0, [r6, r2]
 803baee:	1899      	adds	r1, r3, r2
 803baf0:	f881 0020 	strb.w	r0, [r1, #32]
        for (idx = 0; idx < nonce_length; idx++) {
 803baf4:	3201      	adds	r2, #1
 803baf6:	42aa      	cmp	r2, r5
 803baf8:	d1f8      	bne.n	803baec <psa_aead_decrypt+0x70>
 803bafa:	e7ee      	b.n	803bada <psa_aead_decrypt+0x5e>
 803bafc:	2200      	movs	r2, #0
 803bafe:	e7fa      	b.n	803baf6 <psa_aead_decrypt+0x7a>
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 803bb00:	2301      	movs	r3, #1
        in_len--;
 803bb02:	2c00      	cmp	r4, #0
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 803bb04:	9301      	str	r3, [sp, #4]
 803bb06:	ab03      	add	r3, sp, #12
 803bb08:	9300      	str	r3, [sp, #0]
 803bb0a:	aa05      	add	r2, sp, #20
 803bb0c:	bf14      	ite	ne
 803bb0e:	2303      	movne	r3, #3
 803bb10:	2302      	moveq	r3, #2
 803bb12:	2100      	movs	r1, #0
 803bb14:	f000 f8b6 	bl	803bc84 <psa_call>
    *plaintext_length = out_vec[0].len;
 803bb18:	9b26      	ldr	r3, [sp, #152]	; 0x98
 803bb1a:	9a04      	ldr	r2, [sp, #16]
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 803bb1c:	4604      	mov	r4, r0
    *plaintext_length = out_vec[0].len;
 803bb1e:	601a      	str	r2, [r3, #0]
    PSA_CLOSE();
 803bb20:	4628      	mov	r0, r5
 803bb22:	f000 f8c3 	bl	803bcac <psa_close>
    return status;
 803bb26:	e7c3      	b.n	803bab0 <psa_aead_decrypt+0x34>

0803bb28 <psa_initial_attest_get_token>:
enum psa_attest_err_t
psa_initial_attest_get_token(const uint8_t *challenge_obj,
                             uint32_t       challenge_size,
                             uint8_t       *token,
                             uint32_t      *token_size)
{
 803bb28:	b570      	push	{r4, r5, r6, lr}
 803bb2a:	461d      	mov	r5, r3
 803bb2c:	b086      	sub	sp, #24
    psa_status_t status;

    psa_invec in_vec[] = {
        {challenge_obj, challenge_size}
    };
    psa_outvec out_vec[] = {
 803bb2e:	681b      	ldr	r3, [r3, #0]
    psa_invec in_vec[] = {
 803bb30:	e9cd 0102 	strd	r0, r1, [sp, #8]
        {token, *token_size}
    };

    handle = psa_connect(TFM_ATTEST_GET_TOKEN_SID,
 803bb34:	2101      	movs	r1, #1
 803bb36:	2020      	movs	r0, #32
    psa_outvec out_vec[] = {
 803bb38:	9204      	str	r2, [sp, #16]
 803bb3a:	9305      	str	r3, [sp, #20]
    handle = psa_connect(TFM_ATTEST_GET_TOKEN_SID,
 803bb3c:	f000 f894 	bl	803bc68 <psa_connect>
                         TFM_ATTEST_GET_TOKEN_VERSION);
    if (handle <= 0) {
 803bb40:	1e06      	subs	r6, r0, #0
 803bb42:	dc02      	bgt.n	803bb4a <psa_initial_attest_get_token+0x22>
        return PSA_ATTEST_ERR_GENERAL;
 803bb44:	2005      	movs	r0, #5
    if (status == PSA_SUCCESS) {
        *token_size = out_vec[0].len;
    }

    return (enum psa_attest_err_t)status;
}
 803bb46:	b006      	add	sp, #24
 803bb48:	bd70      	pop	{r4, r5, r6, pc}
    status = psa_call(handle, PSA_IPC_CALL,
 803bb4a:	2301      	movs	r3, #1
 803bb4c:	aa04      	add	r2, sp, #16
 803bb4e:	9301      	str	r3, [sp, #4]
 803bb50:	9200      	str	r2, [sp, #0]
 803bb52:	2100      	movs	r1, #0
 803bb54:	aa02      	add	r2, sp, #8
 803bb56:	f000 f895 	bl	803bc84 <psa_call>
 803bb5a:	4604      	mov	r4, r0
    psa_close(handle);
 803bb5c:	4630      	mov	r0, r6
 803bb5e:	f000 f8a5 	bl	803bcac <psa_close>
    if (status < PSA_SUCCESS) {
 803bb62:	2c00      	cmp	r4, #0
 803bb64:	dbee      	blt.n	803bb44 <psa_initial_attest_get_token+0x1c>
        *token_size = out_vec[0].len;
 803bb66:	bf08      	it	eq
 803bb68:	9b05      	ldreq	r3, [sp, #20]
    return (enum psa_attest_err_t)status;
 803bb6a:	4620      	mov	r0, r4
        *token_size = out_vec[0].len;
 803bb6c:	bf08      	it	eq
 803bb6e:	602b      	streq	r3, [r5, #0]
    return (enum psa_attest_err_t)status;
 803bb70:	e7e9      	b.n	803bb46 <psa_initial_attest_get_token+0x1e>

0803bb72 <psa_its_set>:

psa_status_t psa_its_set(psa_storage_uid_t uid,
                         size_t data_length,
                         const void *p_data,
                         psa_storage_create_flags_t create_flags)
{
 803bb72:	b530      	push	{r4, r5, lr}
 803bb74:	b08b      	sub	sp, #44	; 0x2c
 803bb76:	ac0a      	add	r4, sp, #40	; 0x28
 803bb78:	e964 0108 	strd	r0, r1, [r4, #-32]!
    psa_status_t status;
    psa_handle_t handle;

    psa_invec in_vec[] = {
 803bb7c:	2108      	movs	r1, #8
 803bb7e:	e9cd 1305 	strd	r1, r3, [sp, #20]
 803bb82:	ab0e      	add	r3, sp, #56	; 0x38
 803bb84:	9308      	str	r3, [sp, #32]
 803bb86:	2304      	movs	r3, #4
        { .base = &uid, .len = sizeof(uid) },
        { .base = p_data, .len = data_length },
        { .base = &create_flags, .len = sizeof(create_flags) }
    };

    handle = psa_connect(TFM_ITS_SET_SID, TFM_ITS_SET_VERSION);
 803bb88:	2101      	movs	r1, #1
 803bb8a:	2070      	movs	r0, #112	; 0x70
    psa_invec in_vec[] = {
 803bb8c:	9404      	str	r4, [sp, #16]
 803bb8e:	9207      	str	r2, [sp, #28]
 803bb90:	9309      	str	r3, [sp, #36]	; 0x24
    handle = psa_connect(TFM_ITS_SET_SID, TFM_ITS_SET_VERSION);
 803bb92:	f000 f869 	bl	803bc68 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 803bb96:	1e05      	subs	r5, r0, #0
 803bb98:	dd11      	ble.n	803bbbe <psa_its_set+0x4c>
        return PSA_ERROR_GENERIC_ERROR;
    }

    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), NULL, 0);
 803bb9a:	2100      	movs	r1, #0
 803bb9c:	2303      	movs	r3, #3
 803bb9e:	e9cd 1100 	strd	r1, r1, [sp]
 803bba2:	aa04      	add	r2, sp, #16
 803bba4:	f000 f86e 	bl	803bc84 <psa_call>
 803bba8:	4604      	mov	r4, r0

    psa_close(handle);
 803bbaa:	4628      	mov	r0, r5
 803bbac:	f000 f87e 	bl	803bcac <psa_close>

    if (status == (psa_status_t)TFM_ERROR_INVALID_PARAMETER) {
        return PSA_ERROR_INVALID_ARGUMENT;
 803bbb0:	2c03      	cmp	r4, #3
 803bbb2:	bf08      	it	eq
 803bbb4:	f06f 0486 	mvneq.w	r4, #134	; 0x86
    }

    return status;
}
 803bbb8:	4620      	mov	r0, r4
 803bbba:	b00b      	add	sp, #44	; 0x2c
 803bbbc:	bd30      	pop	{r4, r5, pc}
        return PSA_ERROR_GENERIC_ERROR;
 803bbbe:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803bbc2:	e7f9      	b.n	803bbb8 <psa_its_set+0x46>

0803bbc4 <psa_its_get>:
psa_status_t psa_its_get(psa_storage_uid_t uid,
                         size_t data_offset,
                         size_t data_size,
                         void *p_data,
                         size_t *p_data_length)
{
 803bbc4:	b570      	push	{r4, r5, r6, lr}
 803bbc6:	b08c      	sub	sp, #48	; 0x30
 803bbc8:	9203      	str	r2, [sp, #12]
    psa_status_t status;
    psa_handle_t handle;

    psa_invec in_vec[] = {
 803bbca:	aa04      	add	r2, sp, #16
 803bbcc:	9208      	str	r2, [sp, #32]
 803bbce:	2208      	movs	r2, #8
 803bbd0:	9209      	str	r2, [sp, #36]	; 0x24
 803bbd2:	aa03      	add	r2, sp, #12
 803bbd4:	920a      	str	r2, [sp, #40]	; 0x28
 803bbd6:	2204      	movs	r2, #4
{
 803bbd8:	9d11      	ldr	r5, [sp, #68]	; 0x44
    psa_invec in_vec[] = {
 803bbda:	920b      	str	r2, [sp, #44]	; 0x2c
        { .base = &uid, .len = sizeof(uid) },
        { .base = &data_offset, .len = sizeof(data_offset) }
    };

    psa_outvec out_vec[] = {
 803bbdc:	9a10      	ldr	r2, [sp, #64]	; 0x40
{
 803bbde:	e9cd 0104 	strd	r0, r1, [sp, #16]
    psa_outvec out_vec[] = {
 803bbe2:	e9cd 2306 	strd	r2, r3, [sp, #24]
        { .base = p_data, .len = data_size }
    };

    if (p_data_length == NULL) {
 803bbe6:	b925      	cbnz	r5, 803bbf2 <psa_its_get+0x2e>
        return PSA_ERROR_INVALID_ARGUMENT;
 803bbe8:	f06f 0486 	mvn.w	r4, #134	; 0x86
    }

    *p_data_length = out_vec[0].len;

    return status;
}
 803bbec:	4620      	mov	r0, r4
 803bbee:	b00c      	add	sp, #48	; 0x30
 803bbf0:	bd70      	pop	{r4, r5, r6, pc}
    handle = psa_connect(TFM_ITS_GET_SID, TFM_ITS_GET_VERSION);
 803bbf2:	2101      	movs	r1, #1
 803bbf4:	2071      	movs	r0, #113	; 0x71
 803bbf6:	f000 f837 	bl	803bc68 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 803bbfa:	1e06      	subs	r6, r0, #0
 803bbfc:	dd11      	ble.n	803bc22 <psa_its_get+0x5e>
    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
 803bbfe:	2301      	movs	r3, #1
 803bc00:	9301      	str	r3, [sp, #4]
 803bc02:	ab06      	add	r3, sp, #24
 803bc04:	9300      	str	r3, [sp, #0]
 803bc06:	aa08      	add	r2, sp, #32
 803bc08:	2302      	movs	r3, #2
 803bc0a:	2100      	movs	r1, #0
 803bc0c:	f000 f83a 	bl	803bc84 <psa_call>
 803bc10:	4604      	mov	r4, r0
    psa_close(handle);
 803bc12:	4630      	mov	r0, r6
 803bc14:	f000 f84a 	bl	803bcac <psa_close>
    if (status == (psa_status_t)TFM_ERROR_INVALID_PARAMETER) {
 803bc18:	2c03      	cmp	r4, #3
 803bc1a:	d0e5      	beq.n	803bbe8 <psa_its_get+0x24>
    *p_data_length = out_vec[0].len;
 803bc1c:	9b07      	ldr	r3, [sp, #28]
 803bc1e:	602b      	str	r3, [r5, #0]
    return status;
 803bc20:	e7e4      	b.n	803bbec <psa_its_get+0x28>
        return PSA_ERROR_GENERIC_ERROR;
 803bc22:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803bc26:	e7e1      	b.n	803bbec <psa_its_get+0x28>

0803bc28 <psa_its_remove>:

    return status;
}

psa_status_t psa_its_remove(psa_storage_uid_t uid)
{
 803bc28:	b530      	push	{r4, r5, lr}
 803bc2a:	b087      	sub	sp, #28
 803bc2c:	ab06      	add	r3, sp, #24
 803bc2e:	e963 0104 	strd	r0, r1, [r3, #-16]!
    psa_status_t status;
    psa_handle_t handle;

    psa_invec in_vec[] = {
 803bc32:	9304      	str	r3, [sp, #16]
 803bc34:	2308      	movs	r3, #8
        { .base = &uid, .len = sizeof(uid) }
    };

    handle = psa_connect(TFM_ITS_REMOVE_SID, TFM_ITS_REMOVE_VERSION);
 803bc36:	2101      	movs	r1, #1
 803bc38:	2073      	movs	r0, #115	; 0x73
    psa_invec in_vec[] = {
 803bc3a:	9305      	str	r3, [sp, #20]
    handle = psa_connect(TFM_ITS_REMOVE_SID, TFM_ITS_REMOVE_VERSION);
 803bc3c:	f000 f814 	bl	803bc68 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 803bc40:	1e05      	subs	r5, r0, #0
 803bc42:	dd0d      	ble.n	803bc60 <psa_its_remove+0x38>
        return PSA_ERROR_GENERIC_ERROR;
    }

    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), NULL, 0);
 803bc44:	2100      	movs	r1, #0
 803bc46:	2301      	movs	r3, #1
 803bc48:	e9cd 1100 	strd	r1, r1, [sp]
 803bc4c:	aa04      	add	r2, sp, #16
 803bc4e:	f000 f819 	bl	803bc84 <psa_call>
 803bc52:	4604      	mov	r4, r0

    psa_close(handle);
 803bc54:	4628      	mov	r0, r5
 803bc56:	f000 f829 	bl	803bcac <psa_close>

    return status;
}
 803bc5a:	4620      	mov	r0, r4
 803bc5c:	b007      	add	sp, #28
 803bc5e:	bd30      	pop	{r4, r5, pc}
        return PSA_ERROR_GENERIC_ERROR;
 803bc60:	f06f 0483 	mvn.w	r4, #131	; 0x83
 803bc64:	e7f9      	b.n	803bc5a <psa_its_remove+0x32>
	...

0803bc68 <psa_connect>:
                                0);
}

psa_handle_t psa_connect(uint32_t sid, uint32_t version)
{
    return tfm_ns_interface_dispatch(
 803bc68:	2300      	movs	r3, #0
{
 803bc6a:	b507      	push	{r0, r1, r2, lr}
    return tfm_ns_interface_dispatch(
 803bc6c:	460a      	mov	r2, r1
 803bc6e:	9300      	str	r3, [sp, #0]
 803bc70:	4601      	mov	r1, r0
 803bc72:	4803      	ldr	r0, [pc, #12]	; (803bc80 <psa_connect+0x18>)
 803bc74:	f7fd ff3c 	bl	8039af0 <tfm_ns_interface_dispatch>
                                (veneer_fn)tfm_psa_connect_veneer,
                                sid,
                                version,
                                0,
                                0);
}
 803bc78:	b003      	add	sp, #12
 803bc7a:	f85d fb04 	ldr.w	pc, [sp], #4
 803bc7e:	bf00      	nop
 803bc80:	0c035cb1 	.word	0x0c035cb1

0803bc84 <psa_call>:
psa_status_t psa_call(psa_handle_t handle, int32_t type,
                      const psa_invec *in_vec,
                      size_t in_len,
                      psa_outvec *out_vec,
                      size_t out_len)
{
 803bc84:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
     * serialization in order for NS to pass arguments to S
     */
    psa_invec in_vecs, out_vecs;

    in_vecs.base = in_vec;
    in_vecs.len = in_len;
 803bc86:	e9cd 2302 	strd	r2, r3, [sp, #8]
    out_vecs.base = out_vec;
 803bc8a:	9b08      	ldr	r3, [sp, #32]
    out_vecs.len = out_len;
    return tfm_ns_interface_dispatch(
 803bc8c:	460a      	mov	r2, r1
    out_vecs.base = out_vec;
 803bc8e:	9304      	str	r3, [sp, #16]
    out_vecs.len = out_len;
 803bc90:	9b09      	ldr	r3, [sp, #36]	; 0x24
    return tfm_ns_interface_dispatch(
 803bc92:	4601      	mov	r1, r0
    out_vecs.len = out_len;
 803bc94:	9305      	str	r3, [sp, #20]
    return tfm_ns_interface_dispatch(
 803bc96:	ab04      	add	r3, sp, #16
 803bc98:	9300      	str	r3, [sp, #0]
 803bc9a:	4803      	ldr	r0, [pc, #12]	; (803bca8 <psa_call+0x24>)
 803bc9c:	ab02      	add	r3, sp, #8
 803bc9e:	f7fd ff27 	bl	8039af0 <tfm_ns_interface_dispatch>
                                (veneer_fn)tfm_psa_call_veneer,
                                (uint32_t)handle,
                                (uint32_t)type,
                                (uint32_t)&in_vecs,
                                (uint32_t)&out_vecs);
}
 803bca2:	b007      	add	sp, #28
 803bca4:	f85d fb04 	ldr.w	pc, [sp], #4
 803bca8:	0c035cc9 	.word	0x0c035cc9

0803bcac <psa_close>:

void psa_close(psa_handle_t handle)
{
    (void)tfm_ns_interface_dispatch(
 803bcac:	2300      	movs	r3, #0
{
 803bcae:	b507      	push	{r0, r1, r2, lr}
    (void)tfm_ns_interface_dispatch(
 803bcb0:	4601      	mov	r1, r0
 803bcb2:	9300      	str	r3, [sp, #0]
 803bcb4:	461a      	mov	r2, r3
 803bcb6:	4803      	ldr	r0, [pc, #12]	; (803bcc4 <psa_close+0x18>)
 803bcb8:	f7fd ff1a 	bl	8039af0 <tfm_ns_interface_dispatch>
                         (veneer_fn)tfm_psa_close_veneer,
                         (uint32_t)handle,
                         0,
                         0,
                         0);
}
 803bcbc:	b003      	add	sp, #12
 803bcbe:	f85d fb04 	ldr.w	pc, [sp], #4
 803bcc2:	bf00      	nop
 803bcc4:	0c035ca1 	.word	0x0c035ca1

0803bcc8 <psa_ps_set>:

psa_ps_status_t psa_ps_set(psa_ps_uid_t uid,
                           uint32_t data_length,
                           const void *p_data,
                           psa_ps_create_flags_t create_flags)
{
 803bcc8:	b530      	push	{r4, r5, lr}
 803bcca:	b08f      	sub	sp, #60	; 0x3c
 803bccc:	ac0e      	add	r4, sp, #56	; 0x38
 803bcce:	e964 010c 	strd	r0, r1, [r4, #-48]!	; 0x30
    psa_status_t status;
    psa_ps_status_t err;
    psa_handle_t handle;

    psa_invec in_vec[] = {
 803bcd2:	2108      	movs	r1, #8
 803bcd4:	e9cd 1309 	strd	r1, r3, [sp, #36]	; 0x24
 803bcd8:	ab12      	add	r3, sp, #72	; 0x48
 803bcda:	930c      	str	r3, [sp, #48]	; 0x30
 803bcdc:	2304      	movs	r3, #4
 803bcde:	920b      	str	r2, [sp, #44]	; 0x2c

    psa_outvec out_vec[] = {
        { .base = &err , .len = sizeof(err) }
    };

    handle = psa_connect(TFM_SST_SET_SID, TFM_SST_SET_VERSION);
 803bce0:	2101      	movs	r1, #1
    psa_outvec out_vec[] = {
 803bce2:	aa05      	add	r2, sp, #20
    handle = psa_connect(TFM_SST_SET_SID, TFM_SST_SET_VERSION);
 803bce4:	2060      	movs	r0, #96	; 0x60
    psa_invec in_vec[] = {
 803bce6:	9408      	str	r4, [sp, #32]
 803bce8:	930d      	str	r3, [sp, #52]	; 0x34
    psa_outvec out_vec[] = {
 803bcea:	e9cd 2306 	strd	r2, r3, [sp, #24]
    handle = psa_connect(TFM_SST_SET_SID, TFM_SST_SET_VERSION);
 803bcee:	f7ff ffbb 	bl	803bc68 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 803bcf2:	1e05      	subs	r5, r0, #0
 803bcf4:	dc02      	bgt.n	803bcfc <psa_ps_set+0x34>
        return PSA_PS_ERROR_OPERATION_FAILED;
 803bcf6:	200b      	movs	r0, #11
    if (status != PSA_SUCCESS) {
        return PSA_PS_ERROR_OPERATION_FAILED;
    }

    return err;
}
 803bcf8:	b00f      	add	sp, #60	; 0x3c
 803bcfa:	bd30      	pop	{r4, r5, pc}
    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
 803bcfc:	2301      	movs	r3, #1
 803bcfe:	9301      	str	r3, [sp, #4]
 803bd00:	ab06      	add	r3, sp, #24
 803bd02:	9300      	str	r3, [sp, #0]
 803bd04:	aa08      	add	r2, sp, #32
 803bd06:	2303      	movs	r3, #3
 803bd08:	2100      	movs	r1, #0
 803bd0a:	f7ff ffbb 	bl	803bc84 <psa_call>
 803bd0e:	4604      	mov	r4, r0
    psa_close(handle);
 803bd10:	4628      	mov	r0, r5
 803bd12:	f7ff ffcb 	bl	803bcac <psa_close>
    if (status != PSA_SUCCESS) {
 803bd16:	2c00      	cmp	r4, #0
 803bd18:	d1ed      	bne.n	803bcf6 <psa_ps_set+0x2e>
    return err;
 803bd1a:	9805      	ldr	r0, [sp, #20]
 803bd1c:	e7ec      	b.n	803bcf8 <psa_ps_set+0x30>

0803bd1e <psa_ps_get>:

psa_ps_status_t psa_ps_get(psa_ps_uid_t uid,
                           uint32_t data_offset,
                           uint32_t data_length,
                           void *p_data)
{
 803bd1e:	b530      	push	{r4, r5, lr}
 803bd20:	b091      	sub	sp, #68	; 0x44
 803bd22:	9203      	str	r2, [sp, #12]
    psa_status_t status;
    psa_ps_status_t err;
    psa_handle_t handle;

    psa_invec in_vec[] = {
 803bd24:	aa04      	add	r2, sp, #16
 803bd26:	9208      	str	r2, [sp, #32]
 803bd28:	2208      	movs	r2, #8
 803bd2a:	9209      	str	r2, [sp, #36]	; 0x24
 803bd2c:	aa03      	add	r2, sp, #12
 803bd2e:	920a      	str	r2, [sp, #40]	; 0x28
 803bd30:	2204      	movs	r2, #4
{
 803bd32:	e9cd 0104 	strd	r0, r1, [sp, #16]
        { .base = &uid, .len = sizeof(uid) },
        { .base = &data_offset, .len = sizeof(data_offset) }
    };

    psa_outvec out_vec[] = {
 803bd36:	a907      	add	r1, sp, #28
 803bd38:	e9cd 120c 	strd	r1, r2, [sp, #48]	; 0x30
    psa_invec in_vec[] = {
 803bd3c:	920b      	str	r2, [sp, #44]	; 0x2c
    psa_outvec out_vec[] = {
 803bd3e:	9a14      	ldr	r2, [sp, #80]	; 0x50
        { .base = &err,   .len = sizeof(err) },
        { .base = p_data, .len = data_length }
    };

    handle = psa_connect(TFM_SST_GET_SID, TFM_SST_GET_VERSION);
 803bd40:	2101      	movs	r1, #1
 803bd42:	2061      	movs	r0, #97	; 0x61
    psa_outvec out_vec[] = {
 803bd44:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
    handle = psa_connect(TFM_SST_GET_SID, TFM_SST_GET_VERSION);
 803bd48:	f7ff ff8e 	bl	803bc68 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 803bd4c:	1e05      	subs	r5, r0, #0
 803bd4e:	dc02      	bgt.n	803bd56 <psa_ps_get+0x38>
        return PSA_PS_ERROR_OPERATION_FAILED;
 803bd50:	200b      	movs	r0, #11
    if (status != PSA_SUCCESS) {
        return PSA_PS_ERROR_OPERATION_FAILED;
    }

    return err;
}
 803bd52:	b011      	add	sp, #68	; 0x44
 803bd54:	bd30      	pop	{r4, r5, pc}
    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
 803bd56:	2302      	movs	r3, #2
 803bd58:	aa0c      	add	r2, sp, #48	; 0x30
 803bd5a:	9200      	str	r2, [sp, #0]
 803bd5c:	9301      	str	r3, [sp, #4]
 803bd5e:	aa08      	add	r2, sp, #32
 803bd60:	2100      	movs	r1, #0
 803bd62:	f7ff ff8f 	bl	803bc84 <psa_call>
 803bd66:	4604      	mov	r4, r0
    psa_close(handle);
 803bd68:	4628      	mov	r0, r5
 803bd6a:	f7ff ff9f 	bl	803bcac <psa_close>
    if (status != PSA_SUCCESS) {
 803bd6e:	2c00      	cmp	r4, #0
 803bd70:	d1ee      	bne.n	803bd50 <psa_ps_get+0x32>
    return err;
 803bd72:	9807      	ldr	r0, [sp, #28]
 803bd74:	e7ed      	b.n	803bd52 <psa_ps_get+0x34>

0803bd76 <psa_ps_remove>:

    return err;
}

psa_ps_status_t psa_ps_remove(psa_ps_uid_t uid)
{
 803bd76:	b530      	push	{r4, r5, lr}
 803bd78:	b08b      	sub	sp, #44	; 0x2c
 803bd7a:	ab0a      	add	r3, sp, #40	; 0x28
 803bd7c:	e963 0108 	strd	r0, r1, [r3, #-32]!
    psa_status_t status;
    psa_ps_status_t err;
    psa_handle_t handle;

    psa_invec in_vec[] = {
 803bd80:	9306      	str	r3, [sp, #24]
 803bd82:	2308      	movs	r3, #8
 803bd84:	9307      	str	r3, [sp, #28]
        { .base = &uid, .len = sizeof(uid) }
    };

    psa_outvec out_vec[] = {
 803bd86:	ab05      	add	r3, sp, #20
 803bd88:	9308      	str	r3, [sp, #32]
 803bd8a:	2304      	movs	r3, #4
        { .base = &err, .len = sizeof(err) }
    };

    handle = psa_connect(TFM_SST_REMOVE_SID, TFM_SST_REMOVE_VERSION);
 803bd8c:	2101      	movs	r1, #1
 803bd8e:	2063      	movs	r0, #99	; 0x63
    psa_outvec out_vec[] = {
 803bd90:	9309      	str	r3, [sp, #36]	; 0x24
    handle = psa_connect(TFM_SST_REMOVE_SID, TFM_SST_REMOVE_VERSION);
 803bd92:	f7ff ff69 	bl	803bc68 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 803bd96:	1e05      	subs	r5, r0, #0
 803bd98:	dc02      	bgt.n	803bda0 <psa_ps_remove+0x2a>
        return PSA_PS_ERROR_OPERATION_FAILED;
 803bd9a:	200b      	movs	r0, #11
    if (status != PSA_SUCCESS) {
        return PSA_PS_ERROR_OPERATION_FAILED;
    }

    return err;
}
 803bd9c:	b00b      	add	sp, #44	; 0x2c
 803bd9e:	bd30      	pop	{r4, r5, pc}
    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
 803bda0:	2301      	movs	r3, #1
 803bda2:	aa08      	add	r2, sp, #32
 803bda4:	9200      	str	r2, [sp, #0]
 803bda6:	9301      	str	r3, [sp, #4]
 803bda8:	aa06      	add	r2, sp, #24
 803bdaa:	2100      	movs	r1, #0
 803bdac:	f7ff ff6a 	bl	803bc84 <psa_call>
 803bdb0:	4604      	mov	r4, r0
    psa_close(handle);
 803bdb2:	4628      	mov	r0, r5
 803bdb4:	f7ff ff7a 	bl	803bcac <psa_close>
    if (status != PSA_SUCCESS) {
 803bdb8:	2c00      	cmp	r4, #0
 803bdba:	d1ee      	bne.n	803bd9a <psa_ps_remove+0x24>
    return err;
 803bdbc:	9805      	ldr	r0, [sp, #20]
 803bdbe:	e7ed      	b.n	803bd9c <psa_ps_remove+0x26>

0803bdc0 <psa_cipher_test>:
}

void psa_cipher_test(const psa_key_type_t key_type,
                     const psa_algorithm_t alg,
                     struct test_result_t *ret)
{
 803bdc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    psa_cipher_operation_t handle = psa_cipher_operation_init();
 803bdc4:	2300      	movs	r3, #0
{
 803bdc6:	b0ab      	sub	sp, #172	; 0xac
 803bdc8:	4614      	mov	r4, r2
    psa_cipher_operation_t handle_dec = psa_cipher_operation_init();
    psa_status_t status = PSA_SUCCESS;
    psa_key_handle_t key_handle;
    const uint8_t data[] = "THIS IS MY KEY1";
 803bdca:	aa0e      	add	r2, sp, #56	; 0x38
{
 803bdcc:	4606      	mov	r6, r0
 803bdce:	460f      	mov	r7, r1
 803bdd0:	4693      	mov	fp, r2
    psa_cipher_operation_t handle_dec = psa_cipher_operation_init();
 803bdd2:	e9cd 3306 	strd	r3, r3, [sp, #24]
    const uint8_t data[] = "THIS IS MY KEY1";
 803bdd6:	4b91      	ldr	r3, [pc, #580]	; (803c01c <psa_cipher_test+0x25c>)
 803bdd8:	f103 0c10 	add.w	ip, r3, #16
 803bddc:	4615      	mov	r5, r2
 803bdde:	6818      	ldr	r0, [r3, #0]
 803bde0:	6859      	ldr	r1, [r3, #4]
 803bde2:	3308      	adds	r3, #8
 803bde4:	c503      	stmia	r5!, {r0, r1}
 803bde6:	4563      	cmp	r3, ip
 803bde8:	462a      	mov	r2, r5
 803bdea:	d1f7      	bne.n	803bddc <psa_cipher_test+0x1c>
    psa_key_type_t type = PSA_KEY_TYPE_NONE;
 803bdec:	2300      	movs	r3, #0
    size_t bits = 0;
 803bdee:	e9cd 3308 	strd	r3, r3, [sp, #32]
    const size_t iv_length = PSA_BLOCK_CIPHER_BLOCK_SIZE(key_type);
 803bdf2:	4b8b      	ldr	r3, [pc, #556]	; (803c020 <psa_cipher_test+0x260>)
 803bdf4:	429e      	cmp	r6, r3
 803bdf6:	d049      	beq.n	803be8c <psa_cipher_test+0xcc>
 803bdf8:	3301      	adds	r3, #1
 803bdfa:	429e      	cmp	r6, r3
 803bdfc:	d044      	beq.n	803be88 <psa_cipher_test+0xc8>
 803bdfe:	3301      	adds	r3, #1
 803be00:	429e      	cmp	r6, r3
 803be02:	d043      	beq.n	803be8c <psa_cipher_test+0xcc>
 803be04:	4d87      	ldr	r5, [pc, #540]	; (803c024 <psa_cipher_test+0x264>)
 803be06:	1b73      	subs	r3, r6, r5
 803be08:	425d      	negs	r5, r3
 803be0a:	415d      	adcs	r5, r3
    const uint8_t iv[] = "012345678901234";
 803be0c:	aa12      	add	r2, sp, #72	; 0x48
 803be0e:	4692      	mov	sl, r2
 803be10:	4b85      	ldr	r3, [pc, #532]	; (803c028 <psa_cipher_test+0x268>)
 803be12:	f103 0e10 	add.w	lr, r3, #16
 803be16:	4694      	mov	ip, r2
 803be18:	6818      	ldr	r0, [r3, #0]
 803be1a:	6859      	ldr	r1, [r3, #4]
 803be1c:	3308      	adds	r3, #8
 803be1e:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 803be22:	4573      	cmp	r3, lr
 803be24:	4662      	mov	r2, ip
 803be26:	d1f6      	bne.n	803be16 <psa_cipher_test+0x56>
    const uint8_t plain_text[BYTE_SIZE_CHUNK] = "Sixteen bytes!!";
 803be28:	aa16      	add	r2, sp, #88	; 0x58
 803be2a:	4691      	mov	r9, r2
 803be2c:	4b7f      	ldr	r3, [pc, #508]	; (803c02c <psa_cipher_test+0x26c>)
 803be2e:	f103 0e10 	add.w	lr, r3, #16
 803be32:	4694      	mov	ip, r2
 803be34:	6818      	ldr	r0, [r3, #0]
 803be36:	6859      	ldr	r1, [r3, #4]
 803be38:	3308      	adds	r3, #8
 803be3a:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 803be3e:	4573      	cmp	r3, lr
 803be40:	4662      	mov	r2, ip
 803be42:	d1f6      	bne.n	803be32 <psa_cipher_test+0x72>
    uint8_t decrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
 803be44:	f04f 0820 	mov.w	r8, #32
 803be48:	2100      	movs	r1, #0
 803be4a:	4642      	mov	r2, r8
 803be4c:	a81a      	add	r0, sp, #104	; 0x68
 803be4e:	f000 fbe7 	bl	803c620 <memset>
    size_t output_length = 0, total_output_length = 0;
 803be52:	2300      	movs	r3, #0
    uint8_t encrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
 803be54:	4642      	mov	r2, r8
 803be56:	4619      	mov	r1, r3
 803be58:	a822      	add	r0, sp, #136	; 0x88
    size_t output_length = 0, total_output_length = 0;
 803be5a:	930a      	str	r3, [sp, #40]	; 0x28
    uint8_t encrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
 803be5c:	9303      	str	r3, [sp, #12]
 803be5e:	f000 fbdf 	bl	803c620 <memset>

#define PSA_KEY_POLICY_INIT {0, 0, 0}
static inline struct psa_key_policy_s psa_key_policy_init( void )
{
    const struct psa_key_policy_s v = PSA_KEY_POLICY_INIT;
    return( v );
 803be62:	9b03      	ldr	r3, [sp, #12]
    uint32_t i;

    ret->val = TEST_PASSED;

    /* Allocate a transient key */
    status = psa_allocate_key(&key_handle);
 803be64:	f10d 0016 	add.w	r0, sp, #22
    ret->val = TEST_PASSED;
 803be68:	7023      	strb	r3, [r4, #0]
 803be6a:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
 803be6e:	930d      	str	r3, [sp, #52]	; 0x34
    status = psa_allocate_key(&key_handle);
 803be70:	f7ff fb1e 	bl	803b4b0 <psa_allocate_key>
    if (status != PSA_SUCCESS) {
 803be74:	b160      	cbz	r0, 803be90 <psa_cipher_test+0xd0>
        TEST_FAIL("Failed to allocate key");
 803be76:	4623      	mov	r3, r4
 803be78:	2288      	movs	r2, #136	; 0x88
 803be7a:	496d      	ldr	r1, [pc, #436]	; (803c030 <psa_cipher_test+0x270>)
 803be7c:	486d      	ldr	r0, [pc, #436]	; (803c034 <psa_cipher_test+0x274>)

destroy_key:
    /* Destroy the key */
    status = psa_destroy_key(key_handle);
    if (status != PSA_SUCCESS) {
        TEST_FAIL("Error destroying a key");
 803be7e:	f000 fb65 	bl	803c54c <set_test_failed>
    }

}
 803be82:	b02b      	add	sp, #172	; 0xac
 803be84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    const size_t iv_length = PSA_BLOCK_CIPHER_BLOCK_SIZE(key_type);
 803be88:	2508      	movs	r5, #8
 803be8a:	e7bf      	b.n	803be0c <psa_cipher_test+0x4c>
 803be8c:	2510      	movs	r5, #16
 803be8e:	e7bd      	b.n	803be0c <psa_cipher_test+0x4c>
    psa_key_policy_set_usage(&policy, usage, alg);
 803be90:	f44f 7140 	mov.w	r1, #768	; 0x300
 803be94:	a80b      	add	r0, sp, #44	; 0x2c
 803be96:	463a      	mov	r2, r7
 803be98:	f7ff fbb7 	bl	803b60a <psa_key_policy_set_usage>
    status = psa_set_key_policy(key_handle, &policy);
 803be9c:	a90b      	add	r1, sp, #44	; 0x2c
 803be9e:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 803bea2:	f7ff fbb5 	bl	803b610 <psa_set_key_policy>
    if (status != PSA_SUCCESS) {
 803bea6:	b188      	cbz	r0, 803becc <psa_cipher_test+0x10c>
        TEST_FAIL("Failed to set key policy");
 803bea8:	4623      	mov	r3, r4
 803beaa:	2290      	movs	r2, #144	; 0x90
 803beac:	4960      	ldr	r1, [pc, #384]	; (803c030 <psa_cipher_test+0x270>)
 803beae:	4862      	ldr	r0, [pc, #392]	; (803c038 <psa_cipher_test+0x278>)
        TEST_FAIL("After finalising, unexpected decrypted length");
 803beb0:	f000 fb4c 	bl	803c54c <set_test_failed>
    status = psa_destroy_key(key_handle);
 803beb4:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 803beb8:	f7ff fb4e 	bl	803b558 <psa_destroy_key>
    if (status != PSA_SUCCESS) {
 803bebc:	2800      	cmp	r0, #0
 803bebe:	d0e0      	beq.n	803be82 <psa_cipher_test+0xc2>
        TEST_FAIL("Error destroying a key");
 803bec0:	4623      	mov	r3, r4
 803bec2:	f240 123f 	movw	r2, #319	; 0x13f
 803bec6:	495a      	ldr	r1, [pc, #360]	; (803c030 <psa_cipher_test+0x270>)
 803bec8:	485c      	ldr	r0, [pc, #368]	; (803c03c <psa_cipher_test+0x27c>)
 803beca:	e7d8      	b.n	803be7e <psa_cipher_test+0xbe>
    status = psa_import_key(key_handle, key_type, data, sizeof(data));
 803becc:	2310      	movs	r3, #16
 803bece:	465a      	mov	r2, fp
 803bed0:	4631      	mov	r1, r6
 803bed2:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 803bed6:	f7ff fb12 	bl	803b4fe <psa_import_key>
    if (status != PSA_SUCCESS) {
 803beda:	b120      	cbz	r0, 803bee6 <psa_cipher_test+0x126>
        TEST_FAIL("Error importing a key");
 803bedc:	4623      	mov	r3, r4
 803bede:	2297      	movs	r2, #151	; 0x97
 803bee0:	4953      	ldr	r1, [pc, #332]	; (803c030 <psa_cipher_test+0x270>)
 803bee2:	4857      	ldr	r0, [pc, #348]	; (803c040 <psa_cipher_test+0x280>)
 803bee4:	e7e4      	b.n	803beb0 <psa_cipher_test+0xf0>
    status = psa_get_key_information(key_handle, &type, &bits);
 803bee6:	aa09      	add	r2, sp, #36	; 0x24
 803bee8:	a908      	add	r1, sp, #32
 803beea:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 803beee:	f7ff fb5b 	bl	803b5a8 <psa_get_key_information>
    if (status != PSA_SUCCESS) {
 803bef2:	b120      	cbz	r0, 803befe <psa_cipher_test+0x13e>
        TEST_FAIL("Error getting key metadata");
 803bef4:	4623      	mov	r3, r4
 803bef6:	229d      	movs	r2, #157	; 0x9d
 803bef8:	494d      	ldr	r1, [pc, #308]	; (803c030 <psa_cipher_test+0x270>)
 803befa:	4852      	ldr	r0, [pc, #328]	; (803c044 <psa_cipher_test+0x284>)
 803befc:	e7d8      	b.n	803beb0 <psa_cipher_test+0xf0>
    if (bits != BIT_SIZE_TEST_KEY) {
 803befe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 803bf00:	2b80      	cmp	r3, #128	; 0x80
 803bf02:	d004      	beq.n	803bf0e <psa_cipher_test+0x14e>
        TEST_FAIL("The number of key bits is different from expected");
 803bf04:	4623      	mov	r3, r4
 803bf06:	22a2      	movs	r2, #162	; 0xa2
 803bf08:	4949      	ldr	r1, [pc, #292]	; (803c030 <psa_cipher_test+0x270>)
 803bf0a:	484f      	ldr	r0, [pc, #316]	; (803c048 <psa_cipher_test+0x288>)
 803bf0c:	e7d0      	b.n	803beb0 <psa_cipher_test+0xf0>
    if (type != key_type) {
 803bf0e:	9b08      	ldr	r3, [sp, #32]
 803bf10:	42b3      	cmp	r3, r6
 803bf12:	d004      	beq.n	803bf1e <psa_cipher_test+0x15e>
        TEST_FAIL("The type of the key is different from expected");
 803bf14:	4623      	mov	r3, r4
 803bf16:	22a7      	movs	r2, #167	; 0xa7
 803bf18:	4945      	ldr	r1, [pc, #276]	; (803c030 <psa_cipher_test+0x270>)
 803bf1a:	484c      	ldr	r0, [pc, #304]	; (803c04c <psa_cipher_test+0x28c>)
 803bf1c:	e7c8      	b.n	803beb0 <psa_cipher_test+0xf0>
    status = psa_cipher_encrypt_setup(&handle, key_handle, alg);
 803bf1e:	463a      	mov	r2, r7
 803bf20:	f8bd 1016 	ldrh.w	r1, [sp, #22]
 803bf24:	a806      	add	r0, sp, #24
 803bf26:	f7ff fbcf 	bl	803b6c8 <psa_cipher_encrypt_setup>
    if (status != PSA_SUCCESS) {
 803bf2a:	b150      	cbz	r0, 803bf42 <psa_cipher_test+0x182>
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803bf2c:	3086      	adds	r0, #134	; 0x86
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803bf2e:	4623      	mov	r3, r4
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803bf30:	d103      	bne.n	803bf3a <psa_cipher_test+0x17a>
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803bf32:	22af      	movs	r2, #175	; 0xaf
 803bf34:	493e      	ldr	r1, [pc, #248]	; (803c030 <psa_cipher_test+0x270>)
 803bf36:	4846      	ldr	r0, [pc, #280]	; (803c050 <psa_cipher_test+0x290>)
 803bf38:	e7ba      	b.n	803beb0 <psa_cipher_test+0xf0>
            TEST_FAIL("Error setting up cipher operation object");
 803bf3a:	22b1      	movs	r2, #177	; 0xb1
        TEST_FAIL("Error setting up cipher operation object");
 803bf3c:	493c      	ldr	r1, [pc, #240]	; (803c030 <psa_cipher_test+0x270>)
 803bf3e:	4845      	ldr	r0, [pc, #276]	; (803c054 <psa_cipher_test+0x294>)
 803bf40:	e7b6      	b.n	803beb0 <psa_cipher_test+0xf0>
    status = psa_cipher_set_iv(&handle, iv, iv_length);
 803bf42:	462a      	mov	r2, r5
 803bf44:	4651      	mov	r1, sl
 803bf46:	a806      	add	r0, sp, #24
 803bf48:	f7ff fb8e 	bl	803b668 <psa_cipher_set_iv>
    if (status != PSA_SUCCESS) {
 803bf4c:	b178      	cbz	r0, 803bf6e <psa_cipher_test+0x1ae>
        TEST_FAIL("Error setting the IV on the cypher operation object");
 803bf4e:	4842      	ldr	r0, [pc, #264]	; (803c058 <psa_cipher_test+0x298>)
 803bf50:	4623      	mov	r3, r4
 803bf52:	22b9      	movs	r2, #185	; 0xb9
 803bf54:	4936      	ldr	r1, [pc, #216]	; (803c030 <psa_cipher_test+0x270>)
 803bf56:	f000 faf9 	bl	803c54c <set_test_failed>
        status = psa_cipher_abort(&handle);
 803bf5a:	a806      	add	r0, sp, #24
 803bf5c:	f7ff fc4d 	bl	803b7fa <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803bf60:	2800      	cmp	r0, #0
 803bf62:	d0a7      	beq.n	803beb4 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803bf64:	4623      	mov	r3, r4
 803bf66:	22bc      	movs	r2, #188	; 0xbc
            TEST_FAIL("Error aborting the operation");
 803bf68:	4931      	ldr	r1, [pc, #196]	; (803c030 <psa_cipher_test+0x270>)
 803bf6a:	483c      	ldr	r0, [pc, #240]	; (803c05c <psa_cipher_test+0x29c>)
 803bf6c:	e7a0      	b.n	803beb0 <psa_cipher_test+0xf0>
    status = psa_cipher_update(&handle, plain_text, BYTE_SIZE_CHUNK,
 803bf6e:	ae0a      	add	r6, sp, #40	; 0x28
 803bf70:	e9cd 8600 	strd	r8, r6, [sp]
 803bf74:	ab22      	add	r3, sp, #136	; 0x88
 803bf76:	2210      	movs	r2, #16
 803bf78:	4649      	mov	r1, r9
 803bf7a:	a806      	add	r0, sp, #24
 803bf7c:	f7ff fc06 	bl	803b78c <psa_cipher_update>
    if (status != PSA_SUCCESS) {
 803bf80:	b168      	cbz	r0, 803bf9e <psa_cipher_test+0x1de>
        TEST_FAIL("Error encrypting one chunk of information");
 803bf82:	4837      	ldr	r0, [pc, #220]	; (803c060 <psa_cipher_test+0x2a0>)
 803bf84:	4623      	mov	r3, r4
 803bf86:	22c7      	movs	r2, #199	; 0xc7
 803bf88:	4929      	ldr	r1, [pc, #164]	; (803c030 <psa_cipher_test+0x270>)
 803bf8a:	f000 fadf 	bl	803c54c <set_test_failed>
        status = psa_cipher_abort(&handle);
 803bf8e:	a806      	add	r0, sp, #24
 803bf90:	f7ff fc33 	bl	803b7fa <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803bf94:	2800      	cmp	r0, #0
 803bf96:	d08d      	beq.n	803beb4 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803bf98:	4623      	mov	r3, r4
 803bf9a:	22ca      	movs	r2, #202	; 0xca
 803bf9c:	e7e4      	b.n	803bf68 <psa_cipher_test+0x1a8>
    if (output_length != BYTE_SIZE_CHUNK) {
 803bf9e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 803bfa0:	2a10      	cmp	r2, #16
 803bfa2:	d00e      	beq.n	803bfc2 <psa_cipher_test+0x202>
        TEST_FAIL("Expected encrypted data length is different from expected");
 803bfa4:	482f      	ldr	r0, [pc, #188]	; (803c064 <psa_cipher_test+0x2a4>)
 803bfa6:	4623      	mov	r3, r4
 803bfa8:	22d0      	movs	r2, #208	; 0xd0
 803bfaa:	4921      	ldr	r1, [pc, #132]	; (803c030 <psa_cipher_test+0x270>)
 803bfac:	f000 face 	bl	803c54c <set_test_failed>
        status = psa_cipher_abort(&handle);
 803bfb0:	a806      	add	r0, sp, #24
 803bfb2:	f7ff fc22 	bl	803b7fa <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803bfb6:	2800      	cmp	r0, #0
 803bfb8:	f43f af7c 	beq.w	803beb4 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803bfbc:	4623      	mov	r3, r4
 803bfbe:	22d3      	movs	r2, #211	; 0xd3
 803bfc0:	e7d2      	b.n	803bf68 <psa_cipher_test+0x1a8>
    status = psa_cipher_finish(&handle, &encrypted_data[output_length],
 803bfc2:	4633      	mov	r3, r6
 803bfc4:	a926      	add	r1, sp, #152	; 0x98
 803bfc6:	a806      	add	r0, sp, #24
 803bfc8:	f7ff fc42 	bl	803b850 <psa_cipher_finish>
    if (status != PSA_SUCCESS) {
 803bfcc:	b170      	cbz	r0, 803bfec <psa_cipher_test+0x22c>
        TEST_FAIL("Error finalising the cipher operation");
 803bfce:	4826      	ldr	r0, [pc, #152]	; (803c068 <psa_cipher_test+0x2a8>)
 803bfd0:	4623      	mov	r3, r4
 803bfd2:	22de      	movs	r2, #222	; 0xde
 803bfd4:	4916      	ldr	r1, [pc, #88]	; (803c030 <psa_cipher_test+0x270>)
 803bfd6:	f000 fab9 	bl	803c54c <set_test_failed>
        status = psa_cipher_abort(&handle);
 803bfda:	a806      	add	r0, sp, #24
 803bfdc:	f7ff fc0d 	bl	803b7fa <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803bfe0:	2800      	cmp	r0, #0
 803bfe2:	f43f af67 	beq.w	803beb4 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803bfe6:	4623      	mov	r3, r4
 803bfe8:	22e1      	movs	r2, #225	; 0xe1
 803bfea:	e7bd      	b.n	803bf68 <psa_cipher_test+0x1a8>
    if (output_length != 0) {
 803bfec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 803bfee:	b123      	cbz	r3, 803bffa <psa_cipher_test+0x23a>
        TEST_FAIL("Unexpected output length after finalisation");
 803bff0:	4623      	mov	r3, r4
 803bff2:	22e7      	movs	r2, #231	; 0xe7
 803bff4:	490e      	ldr	r1, [pc, #56]	; (803c030 <psa_cipher_test+0x270>)
 803bff6:	481d      	ldr	r0, [pc, #116]	; (803c06c <psa_cipher_test+0x2ac>)
 803bff8:	e75a      	b.n	803beb0 <psa_cipher_test+0xf0>
    if (alg == PSA_ALG_CFB) {
 803bffa:	4b1d      	ldr	r3, [pc, #116]	; (803c070 <psa_cipher_test+0x2b0>)
 803bffc:	f8bd 1016 	ldrh.w	r1, [sp, #22]
 803c000:	429f      	cmp	r7, r3
        status = psa_cipher_encrypt_setup(&handle_dec, key_handle, alg);
 803c002:	463a      	mov	r2, r7
 803c004:	a807      	add	r0, sp, #28
    if (alg == PSA_ALG_CFB) {
 803c006:	d105      	bne.n	803c014 <psa_cipher_test+0x254>
        status = psa_cipher_encrypt_setup(&handle_dec, key_handle, alg);
 803c008:	f7ff fb5e 	bl	803b6c8 <psa_cipher_encrypt_setup>
    if (status != PSA_SUCCESS) {
 803c00c:	b390      	cbz	r0, 803c074 <psa_cipher_test+0x2b4>
        TEST_FAIL("Error setting up cipher operation object");
 803c00e:	4623      	mov	r3, r4
 803c010:	22f4      	movs	r2, #244	; 0xf4
 803c012:	e793      	b.n	803bf3c <psa_cipher_test+0x17c>
        status = psa_cipher_decrypt_setup(&handle_dec, key_handle, alg);
 803c014:	f7ff fb89 	bl	803b72a <psa_cipher_decrypt_setup>
 803c018:	e7f8      	b.n	803c00c <psa_cipher_test+0x24c>
 803c01a:	bf00      	nop
 803c01c:	0803f04b 	.word	0x0803f04b
 803c020:	40000001 	.word	0x40000001
 803c024:	40000004 	.word	0x40000004
 803c028:	0803ee0e 	.word	0x0803ee0e
 803c02c:	0803ee1e 	.word	0x0803ee1e
 803c030:	0803e9cc 	.word	0x0803e9cc
 803c034:	0803eea8 	.word	0x0803eea8
 803c038:	0803eebf 	.word	0x0803eebf
 803c03c:	0803edf7 	.word	0x0803edf7
 803c040:	0803ef05 	.word	0x0803ef05
 803c044:	0803ef1b 	.word	0x0803ef1b
 803c048:	0803ef36 	.word	0x0803ef36
 803c04c:	0803ef68 	.word	0x0803ef68
 803c050:	0803ec02 	.word	0x0803ec02
 803c054:	0803ec30 	.word	0x0803ec30
 803c058:	0803ec59 	.word	0x0803ec59
 803c05c:	0803ec8d 	.word	0x0803ec8d
 803c060:	0803ecaa 	.word	0x0803ecaa
 803c064:	0803ecd4 	.word	0x0803ecd4
 803c068:	0803ed0e 	.word	0x0803ed0e
 803c06c:	0803ed34 	.word	0x0803ed34
 803c070:	04c00002 	.word	0x04c00002
    status = psa_cipher_set_iv(&handle_dec, iv, iv_length);
 803c074:	462a      	mov	r2, r5
 803c076:	4651      	mov	r1, sl
 803c078:	a807      	add	r0, sp, #28
 803c07a:	f7ff faf5 	bl	803b668 <psa_cipher_set_iv>
    if (status != PSA_SUCCESS) {
 803c07e:	2800      	cmp	r0, #0
 803c080:	d138      	bne.n	803c0f4 <psa_cipher_test+0x334>
        status = psa_cipher_update(&handle_dec,
 803c082:	2320      	movs	r3, #32
 803c084:	9601      	str	r6, [sp, #4]
 803c086:	9300      	str	r3, [sp, #0]
 803c088:	2210      	movs	r2, #16
 803c08a:	ab1a      	add	r3, sp, #104	; 0x68
 803c08c:	a922      	add	r1, sp, #136	; 0x88
 803c08e:	a807      	add	r0, sp, #28
 803c090:	f7ff fb7c 	bl	803b78c <psa_cipher_update>
        if (status != PSA_SUCCESS) {
 803c094:	2800      	cmp	r0, #0
 803c096:	d13c      	bne.n	803c112 <psa_cipher_test+0x352>
        total_output_length += output_length;
 803c098:	9d0a      	ldr	r5, [sp, #40]	; 0x28
        status = psa_cipher_update(&handle_dec,
 803c09a:	9601      	str	r6, [sp, #4]
 803c09c:	f1c5 0320 	rsb	r3, r5, #32
 803c0a0:	9300      	str	r3, [sp, #0]
 803c0a2:	ab1a      	add	r3, sp, #104	; 0x68
 803c0a4:	442b      	add	r3, r5
 803c0a6:	2210      	movs	r2, #16
 803c0a8:	a926      	add	r1, sp, #152	; 0x98
 803c0aa:	a807      	add	r0, sp, #28
 803c0ac:	f7ff fb6e 	bl	803b78c <psa_cipher_update>
        if (status != PSA_SUCCESS) {
 803c0b0:	bb78      	cbnz	r0, 803c112 <psa_cipher_test+0x352>
}

__attribute__ ((always_inline)) __STATIC_INLINE
int tfm_memcmp(const void *ptr1, const void *ptr2, size_t num)
{
    return (memcmp(ptr1, ptr2, num));
 803c0b2:	2210      	movs	r2, #16
 803c0b4:	a91a      	add	r1, sp, #104	; 0x68
 803c0b6:	4648      	mov	r0, r9
 803c0b8:	f000 fa98 	bl	803c5ec <memcmp>
    if (comp_result != 0) {
 803c0bc:	2800      	cmp	r0, #0
 803c0be:	d139      	bne.n	803c134 <psa_cipher_test+0x374>
    status = psa_cipher_finish(&handle_dec, decrypted_data, BYTE_SIZE_CHUNK,
 803c0c0:	4633      	mov	r3, r6
 803c0c2:	2210      	movs	r2, #16
 803c0c4:	a91a      	add	r1, sp, #104	; 0x68
 803c0c6:	a807      	add	r0, sp, #28
        total_output_length += output_length;
 803c0c8:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    status = psa_cipher_finish(&handle_dec, decrypted_data, BYTE_SIZE_CHUNK,
 803c0ca:	f7ff fbc1 	bl	803b850 <psa_cipher_finish>
    if (status != PSA_SUCCESS) {
 803c0ce:	2800      	cmp	r0, #0
 803c0d0:	d041      	beq.n	803c156 <psa_cipher_test+0x396>
        TEST_FAIL("Error finalising the cipher operation");
 803c0d2:	4827      	ldr	r0, [pc, #156]	; (803c170 <psa_cipher_test+0x3b0>)
 803c0d4:	4623      	mov	r3, r4
 803c0d6:	f240 122b 	movw	r2, #299	; 0x12b
 803c0da:	4926      	ldr	r1, [pc, #152]	; (803c174 <psa_cipher_test+0x3b4>)
 803c0dc:	f000 fa36 	bl	803c54c <set_test_failed>
        status = psa_cipher_abort(&handle_dec);
 803c0e0:	a807      	add	r0, sp, #28
 803c0e2:	f7ff fb8a 	bl	803b7fa <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803c0e6:	2800      	cmp	r0, #0
 803c0e8:	f43f aee4 	beq.w	803beb4 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803c0ec:	4623      	mov	r3, r4
 803c0ee:	f44f 7297 	mov.w	r2, #302	; 0x12e
 803c0f2:	e739      	b.n	803bf68 <psa_cipher_test+0x1a8>
        TEST_FAIL("Error setting the IV for decryption");
 803c0f4:	4820      	ldr	r0, [pc, #128]	; (803c178 <psa_cipher_test+0x3b8>)
 803c0f6:	4623      	mov	r3, r4
 803c0f8:	22fb      	movs	r2, #251	; 0xfb
 803c0fa:	491e      	ldr	r1, [pc, #120]	; (803c174 <psa_cipher_test+0x3b4>)
 803c0fc:	f000 fa26 	bl	803c54c <set_test_failed>
        status = psa_cipher_abort(&handle_dec);
 803c100:	a807      	add	r0, sp, #28
 803c102:	f7ff fb7a 	bl	803b7fa <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803c106:	2800      	cmp	r0, #0
 803c108:	f43f aed4 	beq.w	803beb4 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803c10c:	4623      	mov	r3, r4
 803c10e:	22fe      	movs	r2, #254	; 0xfe
 803c110:	e72a      	b.n	803bf68 <psa_cipher_test+0x1a8>
            TEST_FAIL("Error during decryption");
 803c112:	481a      	ldr	r0, [pc, #104]	; (803c17c <psa_cipher_test+0x3bc>)
 803c114:	4623      	mov	r3, r4
 803c116:	f44f 7286 	mov.w	r2, #268	; 0x10c
 803c11a:	4916      	ldr	r1, [pc, #88]	; (803c174 <psa_cipher_test+0x3b4>)
 803c11c:	f000 fa16 	bl	803c54c <set_test_failed>
            status = psa_cipher_abort(&handle_dec);
 803c120:	a807      	add	r0, sp, #28
 803c122:	f7ff fb6a 	bl	803b7fa <psa_cipher_abort>
            if (status != PSA_SUCCESS) {
 803c126:	2800      	cmp	r0, #0
 803c128:	f43f aec4 	beq.w	803beb4 <psa_cipher_test+0xf4>
                TEST_FAIL("Error aborting the operation");
 803c12c:	4623      	mov	r3, r4
 803c12e:	f240 120f 	movw	r2, #271	; 0x10f
 803c132:	e719      	b.n	803bf68 <psa_cipher_test+0x1a8>
        TEST_FAIL("Decrypted data doesn't match with plain text");
 803c134:	4812      	ldr	r0, [pc, #72]	; (803c180 <psa_cipher_test+0x3c0>)
 803c136:	4623      	mov	r3, r4
 803c138:	f44f 728f 	mov.w	r2, #286	; 0x11e
 803c13c:	490d      	ldr	r1, [pc, #52]	; (803c174 <psa_cipher_test+0x3b4>)
 803c13e:	f000 fa05 	bl	803c54c <set_test_failed>
        status = psa_cipher_abort(&handle_dec);
 803c142:	a807      	add	r0, sp, #28
 803c144:	f7ff fb59 	bl	803b7fa <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
 803c148:	2800      	cmp	r0, #0
 803c14a:	f43f aeb3 	beq.w	803beb4 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
 803c14e:	4623      	mov	r3, r4
 803c150:	f240 1221 	movw	r2, #289	; 0x121
 803c154:	e708      	b.n	803bf68 <psa_cipher_test+0x1a8>
    total_output_length += output_length;
 803c156:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        total_output_length += output_length;
 803c158:	443d      	add	r5, r7
    total_output_length += output_length;
 803c15a:	441d      	add	r5, r3
    if (total_output_length != ENC_DEC_BUFFER_SIZE) {
 803c15c:	2d20      	cmp	r5, #32
 803c15e:	f43f aea9 	beq.w	803beb4 <psa_cipher_test+0xf4>
        TEST_FAIL("After finalising, unexpected decrypted length");
 803c162:	4623      	mov	r3, r4
 803c164:	f240 1237 	movw	r2, #311	; 0x137
 803c168:	4902      	ldr	r1, [pc, #8]	; (803c174 <psa_cipher_test+0x3b4>)
 803c16a:	4806      	ldr	r0, [pc, #24]	; (803c184 <psa_cipher_test+0x3c4>)
 803c16c:	e6a0      	b.n	803beb0 <psa_cipher_test+0xf0>
 803c16e:	bf00      	nop
 803c170:	0803ed0e 	.word	0x0803ed0e
 803c174:	0803e9cc 	.word	0x0803e9cc
 803c178:	0803ed60 	.word	0x0803ed60
 803c17c:	0803ed84 	.word	0x0803ed84
 803c180:	0803ed9c 	.word	0x0803ed9c
 803c184:	0803edc9 	.word	0x0803edc9

0803c188 <psa_hash_test>:
    const size_t msg_size[] = {25, 32}; /* Length in bytes of msg[0], msg[1] */
    const uint32_t msg_num = sizeof(msg)/sizeof(msg[0]);
    uint32_t idx;

    psa_status_t status;
    psa_hash_operation_t handle = psa_hash_operation_init();
 803c188:	2300      	movs	r3, #0
{
 803c18a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    psa_hash_operation_t handle = psa_hash_operation_init();
 803c18c:	ae02      	add	r6, sp, #8
 803c18e:	f846 3d04 	str.w	r3, [r6, #-4]!
{
 803c192:	4604      	mov	r4, r0
 803c194:	460d      	mov	r5, r1

    /* Setup the hash object for the desired hash*/
    status = psa_hash_setup(&handle, alg);
 803c196:	4601      	mov	r1, r0
 803c198:	4630      	mov	r0, r6
 803c19a:	f7ff fb8c 	bl	803b8b6 <psa_hash_setup>

    if (status != PSA_SUCCESS) {
 803c19e:	2800      	cmp	r0, #0
 803c1a0:	d14b      	bne.n	803c23a <psa_hash_test+0xb2>
        return;
    }

    /* Update object with all the chunks of message */
    for (idx=0; idx<msg_num; idx++) {
        status = psa_hash_update(&handle,
 803c1a2:	2219      	movs	r2, #25
 803c1a4:	493f      	ldr	r1, [pc, #252]	; (803c2a4 <psa_hash_test+0x11c>)
 803c1a6:	4630      	mov	r0, r6
 803c1a8:	f7ff fbb2 	bl	803b910 <psa_hash_update>
                                 (const uint8_t *)msg[idx],msg_size[idx]);
        if (status != PSA_SUCCESS) {
 803c1ac:	2800      	cmp	r0, #0
 803c1ae:	d154      	bne.n	803c25a <psa_hash_test+0xd2>
        status = psa_hash_update(&handle,
 803c1b0:	2220      	movs	r2, #32
 803c1b2:	493d      	ldr	r1, [pc, #244]	; (803c2a8 <psa_hash_test+0x120>)
 803c1b4:	4630      	mov	r0, r6
 803c1b6:	f7ff fbab 	bl	803b910 <psa_hash_update>
        if (status != PSA_SUCCESS) {
 803c1ba:	2800      	cmp	r0, #0
 803c1bc:	d14d      	bne.n	803c25a <psa_hash_test+0xd2>
            return;
        }
    }

    /* Cycle until idx points to the correct index in the algorithm table */
    for (idx=0; hash_alg[idx] != alg; idx++);
 803c1be:	4b3b      	ldr	r3, [pc, #236]	; (803c2ac <psa_hash_test+0x124>)
 803c1c0:	429c      	cmp	r4, r3
 803c1c2:	d150      	bne.n	803c266 <psa_hash_test+0xde>

    /* Finalise and verify that the hash is as expected */
    status = psa_hash_verify(&handle, &(hash_val[idx][0]), PSA_HASH_SIZE(alg));
 803c1c4:	b2e2      	uxtb	r2, r4
 803c1c6:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 803c1ca:	f102 437f 	add.w	r3, r2, #4278190080	; 0xff000000
 803c1ce:	4938      	ldr	r1, [pc, #224]	; (803c2b0 <psa_hash_test+0x128>)
 803c1d0:	3b01      	subs	r3, #1
 803c1d2:	2b02      	cmp	r3, #2
 803c1d4:	eb01 1180 	add.w	r1, r1, r0, lsl #6
 803c1d8:	d955      	bls.n	803c286 <psa_hash_test+0xfe>
 803c1da:	f102 437f 	add.w	r3, r2, #4278190080	; 0xff000000
 803c1de:	3b04      	subs	r3, #4
 803c1e0:	2b01      	cmp	r3, #1
 803c1e2:	d952      	bls.n	803c28a <psa_hash_test+0x102>
 803c1e4:	4b33      	ldr	r3, [pc, #204]	; (803c2b4 <psa_hash_test+0x12c>)
 803c1e6:	429a      	cmp	r2, r3
 803c1e8:	d053      	beq.n	803c292 <psa_hash_test+0x10a>
 803c1ea:	3301      	adds	r3, #1
 803c1ec:	429a      	cmp	r2, r3
 803c1ee:	d052      	beq.n	803c296 <psa_hash_test+0x10e>
 803c1f0:	3301      	adds	r3, #1
 803c1f2:	429a      	cmp	r2, r3
 803c1f4:	d051      	beq.n	803c29a <psa_hash_test+0x112>
 803c1f6:	3301      	adds	r3, #1
 803c1f8:	429a      	cmp	r2, r3
 803c1fa:	d048      	beq.n	803c28e <psa_hash_test+0x106>
 803c1fc:	3301      	adds	r3, #1
 803c1fe:	429a      	cmp	r2, r3
 803c200:	d047      	beq.n	803c292 <psa_hash_test+0x10a>
 803c202:	3301      	adds	r3, #1
 803c204:	429a      	cmp	r2, r3
 803c206:	d046      	beq.n	803c296 <psa_hash_test+0x10e>
 803c208:	3303      	adds	r3, #3
 803c20a:	429a      	cmp	r2, r3
 803c20c:	d041      	beq.n	803c292 <psa_hash_test+0x10a>
 803c20e:	3301      	adds	r3, #1
 803c210:	429a      	cmp	r2, r3
 803c212:	d040      	beq.n	803c296 <psa_hash_test+0x10e>
 803c214:	3301      	adds	r3, #1
 803c216:	429a      	cmp	r2, r3
 803c218:	d03f      	beq.n	803c29a <psa_hash_test+0x112>
 803c21a:	3301      	adds	r3, #1
 803c21c:	429a      	cmp	r2, r3
 803c21e:	bf0c      	ite	eq
 803c220:	2240      	moveq	r2, #64	; 0x40
 803c222:	2200      	movne	r2, #0
 803c224:	4630      	mov	r0, r6
 803c226:	f7ff fba3 	bl	803b970 <psa_hash_verify>
    if (status != PSA_SUCCESS) {
 803c22a:	2800      	cmp	r0, #0
 803c22c:	d037      	beq.n	803c29e <psa_hash_test+0x116>
        TEST_FAIL("Error verifying the hash operation object");
 803c22e:	462b      	mov	r3, r5
 803c230:	f240 12d3 	movw	r2, #467	; 0x1d3
 803c234:	4920      	ldr	r1, [pc, #128]	; (803c2b8 <psa_hash_test+0x130>)
 803c236:	4821      	ldr	r0, [pc, #132]	; (803c2bc <psa_hash_test+0x134>)
 803c238:	e00b      	b.n	803c252 <psa_hash_test+0xca>
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803c23a:	3086      	adds	r0, #134	; 0x86
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c23c:	462b      	mov	r3, r5
 803c23e:	bf09      	itett	eq
 803c240:	f240 12bb 	movweq	r2, #443	; 0x1bb
        TEST_FAIL("Error setting up hash operation object");
 803c244:	f240 12bf 	movwne	r2, #447	; 0x1bf
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c248:	491b      	ldreq	r1, [pc, #108]	; (803c2b8 <psa_hash_test+0x130>)
 803c24a:	481d      	ldreq	r0, [pc, #116]	; (803c2c0 <psa_hash_test+0x138>)
        TEST_FAIL("Error setting up hash operation object");
 803c24c:	bf1c      	itt	ne
 803c24e:	491a      	ldrne	r1, [pc, #104]	; (803c2b8 <psa_hash_test+0x130>)
 803c250:	481c      	ldrne	r0, [pc, #112]	; (803c2c4 <psa_hash_test+0x13c>)
        TEST_FAIL("Error verifying the hash operation object");
 803c252:	f000 f97b 	bl	803c54c <set_test_failed>
        return;
    }

    ret->val = TEST_PASSED;
}
 803c256:	b002      	add	sp, #8
 803c258:	bd70      	pop	{r4, r5, r6, pc}
            TEST_FAIL("Error updating the hash operation object");
 803c25a:	462b      	mov	r3, r5
 803c25c:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
 803c260:	4915      	ldr	r1, [pc, #84]	; (803c2b8 <psa_hash_test+0x130>)
 803c262:	4819      	ldr	r0, [pc, #100]	; (803c2c8 <psa_hash_test+0x140>)
 803c264:	e7f5      	b.n	803c252 <psa_hash_test+0xca>
    for (idx=0; hash_alg[idx] != alg; idx++);
 803c266:	4b13      	ldr	r3, [pc, #76]	; (803c2b4 <psa_hash_test+0x12c>)
 803c268:	429c      	cmp	r4, r3
 803c26a:	d008      	beq.n	803c27e <psa_hash_test+0xf6>
 803c26c:	3301      	adds	r3, #1
 803c26e:	429c      	cmp	r4, r3
 803c270:	d007      	beq.n	803c282 <psa_hash_test+0xfa>
 803c272:	4816      	ldr	r0, [pc, #88]	; (803c2cc <psa_hash_test+0x144>)
 803c274:	4284      	cmp	r4, r0
 803c276:	bf0c      	ite	eq
 803c278:	2003      	moveq	r0, #3
 803c27a:	2004      	movne	r0, #4
 803c27c:	e7a2      	b.n	803c1c4 <psa_hash_test+0x3c>
 803c27e:	2001      	movs	r0, #1
 803c280:	e7a0      	b.n	803c1c4 <psa_hash_test+0x3c>
 803c282:	2002      	movs	r0, #2
 803c284:	e79e      	b.n	803c1c4 <psa_hash_test+0x3c>
    status = psa_hash_verify(&handle, &(hash_val[idx][0]), PSA_HASH_SIZE(alg));
 803c286:	2210      	movs	r2, #16
 803c288:	e7cc      	b.n	803c224 <psa_hash_test+0x9c>
 803c28a:	2214      	movs	r2, #20
 803c28c:	e7ca      	b.n	803c224 <psa_hash_test+0x9c>
 803c28e:	2240      	movs	r2, #64	; 0x40
 803c290:	e7c8      	b.n	803c224 <psa_hash_test+0x9c>
 803c292:	221c      	movs	r2, #28
 803c294:	e7c6      	b.n	803c224 <psa_hash_test+0x9c>
 803c296:	2220      	movs	r2, #32
 803c298:	e7c4      	b.n	803c224 <psa_hash_test+0x9c>
 803c29a:	2230      	movs	r2, #48	; 0x30
 803c29c:	e7c2      	b.n	803c224 <psa_hash_test+0x9c>
    ret->val = TEST_PASSED;
 803c29e:	7028      	strb	r0, [r5, #0]
 803c2a0:	e7d9      	b.n	803c256 <psa_hash_test+0xce>
 803c2a2:	bf00      	nop
 803c2a4:	0803f05b 	.word	0x0803f05b
 803c2a8:	0803f075 	.word	0x0803f075
 803c2ac:	01000005 	.word	0x01000005
 803c2b0:	0803e9f8 	.word	0x0803e9f8
 803c2b4:	01000008 	.word	0x01000008
 803c2b8:	0803e9dc 	.word	0x0803e9dc
 803c2bc:	0803ee7e 	.word	0x0803ee7e
 803c2c0:	0803ec02 	.word	0x0803ec02
 803c2c4:	0803ee2e 	.word	0x0803ee2e
 803c2c8:	0803ee55 	.word	0x0803ee55
 803c2cc:	0100000a 	.word	0x0100000a

0803c2d0 <psa_aead_test>:
}

void psa_aead_test(const psa_key_type_t key_type,
                   const psa_algorithm_t alg,
                   struct test_result_t *ret)
{
 803c2d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803c2d4:	4614      	mov	r4, r2
    psa_key_handle_t key_handle;
    const size_t nonce_length = 12;
    const uint8_t nonce[] = "01234567890";
 803c2d6:	4a84      	ldr	r2, [pc, #528]	; (803c4e8 <psa_aead_test+0x218>)
{
 803c2d8:	b0b3      	sub	sp, #204	; 0xcc
 803c2da:	4682      	mov	sl, r0
 803c2dc:	460e      	mov	r6, r1
    const uint8_t nonce[] = "01234567890";
 803c2de:	6810      	ldr	r0, [r2, #0]
 803c2e0:	6851      	ldr	r1, [r2, #4]
 803c2e2:	ab0e      	add	r3, sp, #56	; 0x38
 803c2e4:	c303      	stmia	r3!, {r0, r1}
 803c2e6:	6890      	ldr	r0, [r2, #8]
    const uint8_t plain_text[BYTE_SIZE_CHUNK] = "Sixteen bytes!!";
 803c2e8:	aa14      	add	r2, sp, #80	; 0x50
 803c2ea:	4690      	mov	r8, r2
    const uint8_t nonce[] = "01234567890";
 803c2ec:	6018      	str	r0, [r3, #0]
    const uint8_t plain_text[BYTE_SIZE_CHUNK] = "Sixteen bytes!!";
 803c2ee:	4b7f      	ldr	r3, [pc, #508]	; (803c4ec <psa_aead_test+0x21c>)
 803c2f0:	f103 0710 	add.w	r7, r3, #16
 803c2f4:	4615      	mov	r5, r2
 803c2f6:	6818      	ldr	r0, [r3, #0]
 803c2f8:	6859      	ldr	r1, [r3, #4]
 803c2fa:	3308      	adds	r3, #8
 803c2fc:	c503      	stmia	r5!, {r0, r1}
 803c2fe:	42bb      	cmp	r3, r7
 803c300:	462a      	mov	r2, r5
 803c302:	d1f7      	bne.n	803c2f4 <psa_aead_test+0x24>
    const uint8_t associated_data[ASSOCIATED_DATA_SIZE] =
 803c304:	aa1c      	add	r2, sp, #112	; 0x70
 803c306:	4691      	mov	r9, r2
 803c308:	4b79      	ldr	r3, [pc, #484]	; (803c4f0 <psa_aead_test+0x220>)
 803c30a:	f103 0718 	add.w	r7, r3, #24
 803c30e:	4615      	mov	r5, r2
 803c310:	6818      	ldr	r0, [r3, #0]
 803c312:	6859      	ldr	r1, [r3, #4]
 803c314:	3308      	adds	r3, #8
 803c316:	c503      	stmia	r5!, {r0, r1}
 803c318:	42bb      	cmp	r3, r7
 803c31a:	462a      	mov	r2, r5
 803c31c:	d1f7      	bne.n	803c30e <psa_aead_test+0x3e>
                                                      "This is associated data";
    uint8_t encrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
 803c31e:	ad22      	add	r5, sp, #136	; 0x88
 803c320:	2220      	movs	r2, #32
 803c322:	2100      	movs	r1, #0
 803c324:	4628      	mov	r0, r5
 803c326:	f000 f97b 	bl	803c620 <memset>
    size_t encrypted_data_length = 0, decrypted_data_length = 0;
 803c32a:	2100      	movs	r1, #0
    uint8_t decrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
 803c32c:	af2a      	add	r7, sp, #168	; 0xa8
 803c32e:	2220      	movs	r2, #32
 803c330:	4638      	mov	r0, r7
    size_t encrypted_data_length = 0, decrypted_data_length = 0;
 803c332:	e9cd 110a 	strd	r1, r1, [sp, #40]	; 0x28
    uint8_t decrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
 803c336:	f000 f973 	bl	803c620 <memset>
    psa_status_t status;
    const uint8_t data[] = "THIS IS MY KEY1";
 803c33a:	aa18      	add	r2, sp, #96	; 0x60
 803c33c:	4693      	mov	fp, r2
 803c33e:	4b6d      	ldr	r3, [pc, #436]	; (803c4f4 <psa_aead_test+0x224>)
 803c340:	f103 0e10 	add.w	lr, r3, #16
 803c344:	4694      	mov	ip, r2
 803c346:	6818      	ldr	r0, [r3, #0]
 803c348:	6859      	ldr	r1, [r3, #4]
 803c34a:	3308      	adds	r3, #8
 803c34c:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 803c350:	4573      	cmp	r3, lr
 803c352:	4662      	mov	r2, ip
 803c354:	d1f6      	bne.n	803c344 <psa_aead_test+0x74>
    psa_key_type_t type = PSA_KEY_TYPE_NONE;
 803c356:	2300      	movs	r3, #0
    psa_key_usage_t usage = (PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);

    ret->val = TEST_PASSED;

    /* Allocate a transient key */
    status = psa_allocate_key(&key_handle);
 803c358:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    ret->val = TEST_PASSED;
 803c35c:	7023      	strb	r3, [r4, #0]
    size_t bits = 0;
 803c35e:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
 803c362:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
 803c366:	9313      	str	r3, [sp, #76]	; 0x4c
    status = psa_allocate_key(&key_handle);
 803c368:	f7ff f8a2 	bl	803b4b0 <psa_allocate_key>
    if (status != PSA_SUCCESS) {
 803c36c:	b148      	cbz	r0, 803c382 <psa_aead_test+0xb2>
        TEST_FAIL("Failed to allocate key");
 803c36e:	4623      	mov	r3, r4
 803c370:	f240 2292 	movw	r2, #658	; 0x292
 803c374:	4960      	ldr	r1, [pc, #384]	; (803c4f8 <psa_aead_test+0x228>)
 803c376:	4861      	ldr	r0, [pc, #388]	; (803c4fc <psa_aead_test+0x22c>)

destroy_key_aead:
    /* Destroy the key */
    status = psa_destroy_key(key_handle);
    if (status != PSA_SUCCESS) {
        TEST_FAIL("Error destroying a key");
 803c378:	f000 f8e8 	bl	803c54c <set_test_failed>
    }
}
 803c37c:	b033      	add	sp, #204	; 0xcc
 803c37e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    psa_key_policy_set_usage(&policy, usage, alg);
 803c382:	f44f 7140 	mov.w	r1, #768	; 0x300
 803c386:	a811      	add	r0, sp, #68	; 0x44
 803c388:	4632      	mov	r2, r6
 803c38a:	f7ff f93e 	bl	803b60a <psa_key_policy_set_usage>
    status = psa_set_key_policy(key_handle, &policy);
 803c38e:	a911      	add	r1, sp, #68	; 0x44
 803c390:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
 803c394:	f7ff f93c 	bl	803b610 <psa_set_key_policy>
    if (status != PSA_SUCCESS) {
 803c398:	b190      	cbz	r0, 803c3c0 <psa_aead_test+0xf0>
        TEST_FAIL("Failed to set key policy");
 803c39a:	4623      	mov	r3, r4
 803c39c:	f240 229a 	movw	r2, #666	; 0x29a
 803c3a0:	4955      	ldr	r1, [pc, #340]	; (803c4f8 <psa_aead_test+0x228>)
 803c3a2:	4857      	ldr	r0, [pc, #348]	; (803c500 <psa_aead_test+0x230>)
        TEST_FAIL("Decrypted data doesn't match with plain text");
 803c3a4:	f000 f8d2 	bl	803c54c <set_test_failed>
    status = psa_destroy_key(key_handle);
 803c3a8:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
 803c3ac:	f7ff f8d4 	bl	803b558 <psa_destroy_key>
    if (status != PSA_SUCCESS) {
 803c3b0:	2800      	cmp	r0, #0
 803c3b2:	d0e3      	beq.n	803c37c <psa_aead_test+0xac>
        TEST_FAIL("Error destroying a key");
 803c3b4:	4623      	mov	r3, r4
 803c3b6:	f240 22f7 	movw	r2, #759	; 0x2f7
 803c3ba:	494f      	ldr	r1, [pc, #316]	; (803c4f8 <psa_aead_test+0x228>)
 803c3bc:	4851      	ldr	r0, [pc, #324]	; (803c504 <psa_aead_test+0x234>)
 803c3be:	e7db      	b.n	803c378 <psa_aead_test+0xa8>
    status = psa_import_key(key_handle, key_type, data, sizeof(data));
 803c3c0:	2310      	movs	r3, #16
 803c3c2:	465a      	mov	r2, fp
 803c3c4:	4651      	mov	r1, sl
 803c3c6:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
 803c3ca:	f7ff f898 	bl	803b4fe <psa_import_key>
    if (status != PSA_SUCCESS) {
 803c3ce:	b128      	cbz	r0, 803c3dc <psa_aead_test+0x10c>
        TEST_FAIL("Error importing a key");
 803c3d0:	4623      	mov	r3, r4
 803c3d2:	f240 22a1 	movw	r2, #673	; 0x2a1
 803c3d6:	4948      	ldr	r1, [pc, #288]	; (803c4f8 <psa_aead_test+0x228>)
 803c3d8:	484b      	ldr	r0, [pc, #300]	; (803c508 <psa_aead_test+0x238>)
 803c3da:	e7e3      	b.n	803c3a4 <psa_aead_test+0xd4>
    status = psa_get_key_information(key_handle, &type, &bits);
 803c3dc:	aa0d      	add	r2, sp, #52	; 0x34
 803c3de:	a90c      	add	r1, sp, #48	; 0x30
 803c3e0:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
 803c3e4:	f7ff f8e0 	bl	803b5a8 <psa_get_key_information>
    if (status != PSA_SUCCESS) {
 803c3e8:	b128      	cbz	r0, 803c3f6 <psa_aead_test+0x126>
        TEST_FAIL("Error getting key metadata");
 803c3ea:	4623      	mov	r3, r4
 803c3ec:	f240 22a7 	movw	r2, #679	; 0x2a7
 803c3f0:	4941      	ldr	r1, [pc, #260]	; (803c4f8 <psa_aead_test+0x228>)
 803c3f2:	4846      	ldr	r0, [pc, #280]	; (803c50c <psa_aead_test+0x23c>)
 803c3f4:	e7d6      	b.n	803c3a4 <psa_aead_test+0xd4>
    if (bits != BIT_SIZE_TEST_KEY) {
 803c3f6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 803c3f8:	2b80      	cmp	r3, #128	; 0x80
 803c3fa:	d005      	beq.n	803c408 <psa_aead_test+0x138>
        TEST_FAIL("The number of key bits is different from expected");
 803c3fc:	4623      	mov	r3, r4
 803c3fe:	f44f 722b 	mov.w	r2, #684	; 0x2ac
 803c402:	493d      	ldr	r1, [pc, #244]	; (803c4f8 <psa_aead_test+0x228>)
 803c404:	4842      	ldr	r0, [pc, #264]	; (803c510 <psa_aead_test+0x240>)
 803c406:	e7cd      	b.n	803c3a4 <psa_aead_test+0xd4>
    if (type != key_type) {
 803c408:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 803c40a:	4553      	cmp	r3, sl
 803c40c:	d005      	beq.n	803c41a <psa_aead_test+0x14a>
        TEST_FAIL("The type of the key is different from expected");
 803c40e:	4623      	mov	r3, r4
 803c410:	f240 22b1 	movw	r2, #689	; 0x2b1
 803c414:	4938      	ldr	r1, [pc, #224]	; (803c4f8 <psa_aead_test+0x228>)
 803c416:	483f      	ldr	r0, [pc, #252]	; (803c514 <psa_aead_test+0x244>)
 803c418:	e7c4      	b.n	803c3a4 <psa_aead_test+0xd4>
    status = psa_aead_encrypt(key_handle, alg, nonce, nonce_length,
 803c41a:	ab0a      	add	r3, sp, #40	; 0x28
 803c41c:	9306      	str	r3, [sp, #24]
 803c41e:	2320      	movs	r3, #32
 803c420:	e9cd 5304 	strd	r5, r3, [sp, #16]
 803c424:	2310      	movs	r3, #16
 803c426:	e9cd 8302 	strd	r8, r3, [sp, #8]
 803c42a:	2318      	movs	r3, #24
 803c42c:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
 803c430:	e9cd 9300 	strd	r9, r3, [sp]
 803c434:	aa0e      	add	r2, sp, #56	; 0x38
 803c436:	230c      	movs	r3, #12
 803c438:	4631      	mov	r1, r6
 803c43a:	f7ff fac9 	bl	803b9d0 <psa_aead_encrypt>
    if (status != PSA_SUCCESS) {
 803c43e:	b160      	cbz	r0, 803c45a <psa_aead_test+0x18a>
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803c440:	3086      	adds	r0, #134	; 0x86
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c442:	4623      	mov	r3, r4
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803c444:	d104      	bne.n	803c450 <psa_aead_test+0x180>
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c446:	f240 22c1 	movw	r2, #705	; 0x2c1
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c44a:	492b      	ldr	r1, [pc, #172]	; (803c4f8 <psa_aead_test+0x228>)
 803c44c:	4832      	ldr	r0, [pc, #200]	; (803c518 <psa_aead_test+0x248>)
 803c44e:	e7a9      	b.n	803c3a4 <psa_aead_test+0xd4>
        TEST_FAIL("Error performing AEAD encryption");
 803c450:	f240 22c5 	movw	r2, #709	; 0x2c5
 803c454:	4928      	ldr	r1, [pc, #160]	; (803c4f8 <psa_aead_test+0x228>)
 803c456:	4831      	ldr	r0, [pc, #196]	; (803c51c <psa_aead_test+0x24c>)
 803c458:	e7a4      	b.n	803c3a4 <psa_aead_test+0xd4>
        != PSA_AEAD_ENCRYPT_OUTPUT_SIZE(alg, sizeof(plain_text))) {
 803c45a:	f006 43fe 	and.w	r3, r6, #2130706432	; 0x7f000000
 803c45e:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
 803c462:	d10c      	bne.n	803c47e <psa_aead_test+0x1ae>
 803c464:	f3c6 2305 	ubfx	r3, r6, #8, #6
 803c468:	b103      	cbz	r3, 803c46c <psa_aead_test+0x19c>
 803c46a:	3310      	adds	r3, #16
 803c46c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    if (encrypted_data_length
 803c46e:	429a      	cmp	r2, r3
 803c470:	d007      	beq.n	803c482 <psa_aead_test+0x1b2>
        TEST_FAIL("Encrypted data length is different than expected");
 803c472:	4623      	mov	r3, r4
 803c474:	f240 22cb 	movw	r2, #715	; 0x2cb
 803c478:	491f      	ldr	r1, [pc, #124]	; (803c4f8 <psa_aead_test+0x228>)
 803c47a:	4829      	ldr	r0, [pc, #164]	; (803c520 <psa_aead_test+0x250>)
 803c47c:	e792      	b.n	803c3a4 <psa_aead_test+0xd4>
        != PSA_AEAD_ENCRYPT_OUTPUT_SIZE(alg, sizeof(plain_text))) {
 803c47e:	4603      	mov	r3, r0
 803c480:	e7f4      	b.n	803c46c <psa_aead_test+0x19c>
    status = psa_aead_decrypt(key_handle, alg, nonce, nonce_length,
 803c482:	aa0b      	add	r2, sp, #44	; 0x2c
 803c484:	9206      	str	r2, [sp, #24]
 803c486:	e9cd 5302 	strd	r5, r3, [sp, #8]
 803c48a:	2220      	movs	r2, #32
 803c48c:	2318      	movs	r3, #24
 803c48e:	e9cd 7204 	strd	r7, r2, [sp, #16]
 803c492:	e9cd 9300 	strd	r9, r3, [sp]
 803c496:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
 803c49a:	230c      	movs	r3, #12
 803c49c:	aa0e      	add	r2, sp, #56	; 0x38
 803c49e:	4631      	mov	r1, r6
 803c4a0:	f7ff faec 	bl	803ba7c <psa_aead_decrypt>
    if (status != PSA_SUCCESS) {
 803c4a4:	b150      	cbz	r0, 803c4bc <psa_aead_test+0x1ec>
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803c4a6:	3086      	adds	r0, #134	; 0x86
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c4a8:	4623      	mov	r3, r4
        if (status == PSA_ERROR_NOT_SUPPORTED) {
 803c4aa:	d102      	bne.n	803c4b2 <psa_aead_test+0x1e2>
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
 803c4ac:	f240 22db 	movw	r2, #731	; 0x2db
 803c4b0:	e7cb      	b.n	803c44a <psa_aead_test+0x17a>
            TEST_FAIL("Error performing AEAD decryption");
 803c4b2:	f240 22dd 	movw	r2, #733	; 0x2dd
 803c4b6:	4910      	ldr	r1, [pc, #64]	; (803c4f8 <psa_aead_test+0x228>)
 803c4b8:	481a      	ldr	r0, [pc, #104]	; (803c524 <psa_aead_test+0x254>)
 803c4ba:	e773      	b.n	803c3a4 <psa_aead_test+0xd4>
    if (sizeof(plain_text) != decrypted_data_length) {
 803c4bc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 803c4be:	2a10      	cmp	r2, #16
 803c4c0:	d005      	beq.n	803c4ce <psa_aead_test+0x1fe>
        TEST_FAIL("Decrypted data length is different from plain text");
 803c4c2:	4623      	mov	r3, r4
 803c4c4:	f44f 7239 	mov.w	r2, #740	; 0x2e4
 803c4c8:	490b      	ldr	r1, [pc, #44]	; (803c4f8 <psa_aead_test+0x228>)
 803c4ca:	4817      	ldr	r0, [pc, #92]	; (803c528 <psa_aead_test+0x258>)
 803c4cc:	e76a      	b.n	803c3a4 <psa_aead_test+0xd4>
 803c4ce:	4639      	mov	r1, r7
 803c4d0:	4640      	mov	r0, r8
 803c4d2:	f000 f88b 	bl	803c5ec <memcmp>
    if (comp_result != 0) {
 803c4d6:	2800      	cmp	r0, #0
 803c4d8:	f43f af66 	beq.w	803c3a8 <psa_aead_test+0xd8>
        TEST_FAIL("Decrypted data doesn't match with plain text");
 803c4dc:	4623      	mov	r3, r4
 803c4de:	f240 22ef 	movw	r2, #751	; 0x2ef
 803c4e2:	4905      	ldr	r1, [pc, #20]	; (803c4f8 <psa_aead_test+0x228>)
 803c4e4:	4811      	ldr	r0, [pc, #68]	; (803c52c <psa_aead_test+0x25c>)
 803c4e6:	e75d      	b.n	803c3a4 <psa_aead_test+0xd4>
 803c4e8:	0803ebde 	.word	0x0803ebde
 803c4ec:	0803ee1e 	.word	0x0803ee1e
 803c4f0:	0803ebea 	.word	0x0803ebea
 803c4f4:	0803f04b 	.word	0x0803f04b
 803c4f8:	0803e9ea 	.word	0x0803e9ea
 803c4fc:	0803eea8 	.word	0x0803eea8
 803c500:	0803eebf 	.word	0x0803eebf
 803c504:	0803edf7 	.word	0x0803edf7
 803c508:	0803ef05 	.word	0x0803ef05
 803c50c:	0803ef1b 	.word	0x0803ef1b
 803c510:	0803ef36 	.word	0x0803ef36
 803c514:	0803ef68 	.word	0x0803ef68
 803c518:	0803ec02 	.word	0x0803ec02
 803c51c:	0803eb38 	.word	0x0803eb38
 803c520:	0803eb59 	.word	0x0803eb59
 803c524:	0803eb8a 	.word	0x0803eb8a
 803c528:	0803ebab 	.word	0x0803ebab
 803c52c:	0803ed9c 	.word	0x0803ed9c

0803c530 <print_error>:

    printf("  TEST FAILED!\r\n");
}

static void print_error(const char *err_msg)
{
 803c530:	b510      	push	{r4, lr}
 803c532:	4604      	mov	r4, r0
    printf_set_color(RED);
 803c534:	2001      	movs	r0, #1
 803c536:	f000 f81b 	bl	803c570 <printf_set_color>
    printf("Error ( %s )\r\n", err_msg);
 803c53a:	4621      	mov	r1, r4
}
 803c53c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    printf("Error ( %s )\r\n", err_msg);
 803c540:	4801      	ldr	r0, [pc, #4]	; (803c548 <print_error+0x18>)
 803c542:	f000 b875 	b.w	803c630 <iprintf>
 803c546:	bf00      	nop
 803c548:	0803f0b7 	.word	0x0803f0b7

0803c54c <set_test_failed>:
    return TEST_SUITE_ERR_NO_ERROR;
}

void set_test_failed(const char *info_msg, const char *filename, uint32_t line,
                     struct test_result_t *ret)
{
 803c54c:	b410      	push	{r4}
    if (ret == 0) {
 803c54e:	b923      	cbnz	r3, 803c55a <set_test_failed+0xe>
        print_error("TEST_SUITE_ERR_INVALID_TEST_DATA!");
 803c550:	4806      	ldr	r0, [pc, #24]	; (803c56c <set_test_failed+0x20>)

    ret->val = TEST_FAILED;
    ret->info_msg = info_msg;
    ret->filename = filename;
    ret->line = line;
}
 803c552:	f85d 4b04 	ldr.w	r4, [sp], #4
        print_error("TEST_SUITE_ERR_INVALID_TEST_DATA!");
 803c556:	f7ff bfeb 	b.w	803c530 <print_error>
    ret->val = TEST_FAILED;
 803c55a:	2401      	movs	r4, #1
    ret->filename = filename;
 803c55c:	e9c3 0101 	strd	r0, r1, [r3, #4]
    ret->val = TEST_FAILED;
 803c560:	701c      	strb	r4, [r3, #0]
    ret->line = line;
 803c562:	60da      	str	r2, [r3, #12]
}
 803c564:	f85d 4b04 	ldr.w	r4, [sp], #4
 803c568:	4770      	bx	lr
 803c56a:	bf00      	nop
 803c56c:	0803f0c6 	.word	0x0803f0c6

0803c570 <printf_set_color>:
    }
}

void printf_set_color(enum serial_color_t color_id)
{
    printf("\33[3%dm", color_id);
 803c570:	4601      	mov	r1, r0
 803c572:	4801      	ldr	r0, [pc, #4]	; (803c578 <printf_set_color+0x8>)
 803c574:	f000 b85c 	b.w	803c630 <iprintf>
 803c578:	0803f0e8 	.word	0x0803f0e8

0803c57c <exit>:
 803c57c:	b508      	push	{r3, lr}
 803c57e:	4b07      	ldr	r3, [pc, #28]	; (803c59c <exit+0x20>)
 803c580:	4604      	mov	r4, r0
 803c582:	b113      	cbz	r3, 803c58a <exit+0xe>
 803c584:	2100      	movs	r1, #0
 803c586:	e000      	b.n	803c58a <exit+0xe>
 803c588:	bf00      	nop
 803c58a:	4b05      	ldr	r3, [pc, #20]	; (803c5a0 <exit+0x24>)
 803c58c:	6818      	ldr	r0, [r3, #0]
 803c58e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 803c590:	b103      	cbz	r3, 803c594 <exit+0x18>
 803c592:	4798      	blx	r3
 803c594:	4620      	mov	r0, r4
 803c596:	f001 fa27 	bl	803d9e8 <_exit>
 803c59a:	bf00      	nop
 803c59c:	00000000 	.word	0x00000000
 803c5a0:	0803f0f0 	.word	0x0803f0f0

0803c5a4 <__libc_init_array>:
 803c5a4:	b570      	push	{r4, r5, r6, lr}
 803c5a6:	4e0d      	ldr	r6, [pc, #52]	; (803c5dc <__libc_init_array+0x38>)
 803c5a8:	2500      	movs	r5, #0
 803c5aa:	4c0d      	ldr	r4, [pc, #52]	; (803c5e0 <__libc_init_array+0x3c>)
 803c5ac:	1ba4      	subs	r4, r4, r6
 803c5ae:	10a4      	asrs	r4, r4, #2
 803c5b0:	42a5      	cmp	r5, r4
 803c5b2:	d109      	bne.n	803c5c8 <__libc_init_array+0x24>
 803c5b4:	4e0b      	ldr	r6, [pc, #44]	; (803c5e4 <__libc_init_array+0x40>)
 803c5b6:	2500      	movs	r5, #0
 803c5b8:	4c0b      	ldr	r4, [pc, #44]	; (803c5e8 <__libc_init_array+0x44>)
 803c5ba:	f001 fa17 	bl	803d9ec <_init>
 803c5be:	1ba4      	subs	r4, r4, r6
 803c5c0:	10a4      	asrs	r4, r4, #2
 803c5c2:	42a5      	cmp	r5, r4
 803c5c4:	d105      	bne.n	803c5d2 <__libc_init_array+0x2e>
 803c5c6:	bd70      	pop	{r4, r5, r6, pc}
 803c5c8:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 803c5cc:	3501      	adds	r5, #1
 803c5ce:	4798      	blx	r3
 803c5d0:	e7ee      	b.n	803c5b0 <__libc_init_array+0xc>
 803c5d2:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 803c5d6:	3501      	adds	r5, #1
 803c5d8:	4798      	blx	r3
 803c5da:	e7f2      	b.n	803c5c2 <__libc_init_array+0x1e>
 803c5dc:	2000018c 	.word	0x2000018c
 803c5e0:	2000018c 	.word	0x2000018c
 803c5e4:	2000018c 	.word	0x2000018c
 803c5e8:	20000190 	.word	0x20000190

0803c5ec <memcmp>:
 803c5ec:	b530      	push	{r4, r5, lr}
 803c5ee:	2400      	movs	r4, #0
 803c5f0:	42a2      	cmp	r2, r4
 803c5f2:	d101      	bne.n	803c5f8 <memcmp+0xc>
 803c5f4:	2000      	movs	r0, #0
 803c5f6:	e007      	b.n	803c608 <memcmp+0x1c>
 803c5f8:	5d03      	ldrb	r3, [r0, r4]
 803c5fa:	3401      	adds	r4, #1
 803c5fc:	190d      	adds	r5, r1, r4
 803c5fe:	f815 5c01 	ldrb.w	r5, [r5, #-1]
 803c602:	42ab      	cmp	r3, r5
 803c604:	d0f4      	beq.n	803c5f0 <memcmp+0x4>
 803c606:	1b58      	subs	r0, r3, r5
 803c608:	bd30      	pop	{r4, r5, pc}

0803c60a <memcpy>:
 803c60a:	1e43      	subs	r3, r0, #1
 803c60c:	440a      	add	r2, r1
 803c60e:	b510      	push	{r4, lr}
 803c610:	4291      	cmp	r1, r2
 803c612:	d100      	bne.n	803c616 <memcpy+0xc>
 803c614:	bd10      	pop	{r4, pc}
 803c616:	f811 4b01 	ldrb.w	r4, [r1], #1
 803c61a:	f803 4f01 	strb.w	r4, [r3, #1]!
 803c61e:	e7f7      	b.n	803c610 <memcpy+0x6>

0803c620 <memset>:
 803c620:	4402      	add	r2, r0
 803c622:	4603      	mov	r3, r0
 803c624:	4293      	cmp	r3, r2
 803c626:	d100      	bne.n	803c62a <memset+0xa>
 803c628:	4770      	bx	lr
 803c62a:	f803 1b01 	strb.w	r1, [r3], #1
 803c62e:	e7f9      	b.n	803c624 <memset+0x4>

0803c630 <iprintf>:
 803c630:	b40f      	push	{r0, r1, r2, r3}
 803c632:	4b0a      	ldr	r3, [pc, #40]	; (803c65c <iprintf+0x2c>)
 803c634:	b513      	push	{r0, r1, r4, lr}
 803c636:	681c      	ldr	r4, [r3, #0]
 803c638:	b124      	cbz	r4, 803c644 <iprintf+0x14>
 803c63a:	69a3      	ldr	r3, [r4, #24]
 803c63c:	b913      	cbnz	r3, 803c644 <iprintf+0x14>
 803c63e:	4620      	mov	r0, r4
 803c640:	f000 fade 	bl	803cc00 <__sinit>
 803c644:	ab05      	add	r3, sp, #20
 803c646:	9a04      	ldr	r2, [sp, #16]
 803c648:	68a1      	ldr	r1, [r4, #8]
 803c64a:	4620      	mov	r0, r4
 803c64c:	9301      	str	r3, [sp, #4]
 803c64e:	f000 fc9f 	bl	803cf90 <_vfiprintf_r>
 803c652:	b002      	add	sp, #8
 803c654:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 803c658:	b004      	add	sp, #16
 803c65a:	4770      	bx	lr
 803c65c:	20000128 	.word	0x20000128

0803c660 <_puts_r>:
 803c660:	b570      	push	{r4, r5, r6, lr}
 803c662:	460e      	mov	r6, r1
 803c664:	4605      	mov	r5, r0
 803c666:	b118      	cbz	r0, 803c670 <_puts_r+0x10>
 803c668:	6983      	ldr	r3, [r0, #24]
 803c66a:	b90b      	cbnz	r3, 803c670 <_puts_r+0x10>
 803c66c:	f000 fac8 	bl	803cc00 <__sinit>
 803c670:	69ab      	ldr	r3, [r5, #24]
 803c672:	68ac      	ldr	r4, [r5, #8]
 803c674:	b913      	cbnz	r3, 803c67c <_puts_r+0x1c>
 803c676:	4628      	mov	r0, r5
 803c678:	f000 fac2 	bl	803cc00 <__sinit>
 803c67c:	4b23      	ldr	r3, [pc, #140]	; (803c70c <_puts_r+0xac>)
 803c67e:	429c      	cmp	r4, r3
 803c680:	d117      	bne.n	803c6b2 <_puts_r+0x52>
 803c682:	686c      	ldr	r4, [r5, #4]
 803c684:	89a3      	ldrh	r3, [r4, #12]
 803c686:	071b      	lsls	r3, r3, #28
 803c688:	d51d      	bpl.n	803c6c6 <_puts_r+0x66>
 803c68a:	6923      	ldr	r3, [r4, #16]
 803c68c:	b1db      	cbz	r3, 803c6c6 <_puts_r+0x66>
 803c68e:	3e01      	subs	r6, #1
 803c690:	68a3      	ldr	r3, [r4, #8]
 803c692:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 803c696:	3b01      	subs	r3, #1
 803c698:	60a3      	str	r3, [r4, #8]
 803c69a:	b9e9      	cbnz	r1, 803c6d8 <_puts_r+0x78>
 803c69c:	2b00      	cmp	r3, #0
 803c69e:	da2e      	bge.n	803c6fe <_puts_r+0x9e>
 803c6a0:	4622      	mov	r2, r4
 803c6a2:	210a      	movs	r1, #10
 803c6a4:	4628      	mov	r0, r5
 803c6a6:	f000 f8fd 	bl	803c8a4 <__swbuf_r>
 803c6aa:	3001      	adds	r0, #1
 803c6ac:	d011      	beq.n	803c6d2 <_puts_r+0x72>
 803c6ae:	200a      	movs	r0, #10
 803c6b0:	e011      	b.n	803c6d6 <_puts_r+0x76>
 803c6b2:	4b17      	ldr	r3, [pc, #92]	; (803c710 <_puts_r+0xb0>)
 803c6b4:	429c      	cmp	r4, r3
 803c6b6:	d101      	bne.n	803c6bc <_puts_r+0x5c>
 803c6b8:	68ac      	ldr	r4, [r5, #8]
 803c6ba:	e7e3      	b.n	803c684 <_puts_r+0x24>
 803c6bc:	4b15      	ldr	r3, [pc, #84]	; (803c714 <_puts_r+0xb4>)
 803c6be:	429c      	cmp	r4, r3
 803c6c0:	bf08      	it	eq
 803c6c2:	68ec      	ldreq	r4, [r5, #12]
 803c6c4:	e7de      	b.n	803c684 <_puts_r+0x24>
 803c6c6:	4621      	mov	r1, r4
 803c6c8:	4628      	mov	r0, r5
 803c6ca:	f000 f93d 	bl	803c948 <__swsetup_r>
 803c6ce:	2800      	cmp	r0, #0
 803c6d0:	d0dd      	beq.n	803c68e <_puts_r+0x2e>
 803c6d2:	f04f 30ff 	mov.w	r0, #4294967295
 803c6d6:	bd70      	pop	{r4, r5, r6, pc}
 803c6d8:	2b00      	cmp	r3, #0
 803c6da:	da04      	bge.n	803c6e6 <_puts_r+0x86>
 803c6dc:	69a2      	ldr	r2, [r4, #24]
 803c6de:	429a      	cmp	r2, r3
 803c6e0:	dc06      	bgt.n	803c6f0 <_puts_r+0x90>
 803c6e2:	290a      	cmp	r1, #10
 803c6e4:	d004      	beq.n	803c6f0 <_puts_r+0x90>
 803c6e6:	6823      	ldr	r3, [r4, #0]
 803c6e8:	1c5a      	adds	r2, r3, #1
 803c6ea:	6022      	str	r2, [r4, #0]
 803c6ec:	7019      	strb	r1, [r3, #0]
 803c6ee:	e7cf      	b.n	803c690 <_puts_r+0x30>
 803c6f0:	4622      	mov	r2, r4
 803c6f2:	4628      	mov	r0, r5
 803c6f4:	f000 f8d6 	bl	803c8a4 <__swbuf_r>
 803c6f8:	3001      	adds	r0, #1
 803c6fa:	d1c9      	bne.n	803c690 <_puts_r+0x30>
 803c6fc:	e7e9      	b.n	803c6d2 <_puts_r+0x72>
 803c6fe:	6823      	ldr	r3, [r4, #0]
 803c700:	200a      	movs	r0, #10
 803c702:	1c5a      	adds	r2, r3, #1
 803c704:	6022      	str	r2, [r4, #0]
 803c706:	7018      	strb	r0, [r3, #0]
 803c708:	e7e5      	b.n	803c6d6 <_puts_r+0x76>
 803c70a:	bf00      	nop
 803c70c:	0803f114 	.word	0x0803f114
 803c710:	0803f134 	.word	0x0803f134
 803c714:	0803f0f4 	.word	0x0803f0f4

0803c718 <puts>:
 803c718:	4b02      	ldr	r3, [pc, #8]	; (803c724 <puts+0xc>)
 803c71a:	4601      	mov	r1, r0
 803c71c:	6818      	ldr	r0, [r3, #0]
 803c71e:	f7ff bf9f 	b.w	803c660 <_puts_r>
 803c722:	bf00      	nop
 803c724:	20000128 	.word	0x20000128

0803c728 <setvbuf>:
 803c728:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 803c72c:	461d      	mov	r5, r3
 803c72e:	4b50      	ldr	r3, [pc, #320]	; (803c870 <setvbuf+0x148>)
 803c730:	4604      	mov	r4, r0
 803c732:	460f      	mov	r7, r1
 803c734:	681e      	ldr	r6, [r3, #0]
 803c736:	4690      	mov	r8, r2
 803c738:	b126      	cbz	r6, 803c744 <setvbuf+0x1c>
 803c73a:	69b3      	ldr	r3, [r6, #24]
 803c73c:	b913      	cbnz	r3, 803c744 <setvbuf+0x1c>
 803c73e:	4630      	mov	r0, r6
 803c740:	f000 fa5e 	bl	803cc00 <__sinit>
 803c744:	4b4b      	ldr	r3, [pc, #300]	; (803c874 <setvbuf+0x14c>)
 803c746:	429c      	cmp	r4, r3
 803c748:	d152      	bne.n	803c7f0 <setvbuf+0xc8>
 803c74a:	6874      	ldr	r4, [r6, #4]
 803c74c:	f1b8 0f02 	cmp.w	r8, #2
 803c750:	d006      	beq.n	803c760 <setvbuf+0x38>
 803c752:	f1b8 0f01 	cmp.w	r8, #1
 803c756:	f200 8088 	bhi.w	803c86a <setvbuf+0x142>
 803c75a:	2d00      	cmp	r5, #0
 803c75c:	f2c0 8085 	blt.w	803c86a <setvbuf+0x142>
 803c760:	4621      	mov	r1, r4
 803c762:	4630      	mov	r0, r6
 803c764:	f000 f9e2 	bl	803cb2c <_fflush_r>
 803c768:	6b61      	ldr	r1, [r4, #52]	; 0x34
 803c76a:	b141      	cbz	r1, 803c77e <setvbuf+0x56>
 803c76c:	f104 0344 	add.w	r3, r4, #68	; 0x44
 803c770:	4299      	cmp	r1, r3
 803c772:	d002      	beq.n	803c77a <setvbuf+0x52>
 803c774:	4630      	mov	r0, r6
 803c776:	f000 fb39 	bl	803cdec <_free_r>
 803c77a:	2300      	movs	r3, #0
 803c77c:	6363      	str	r3, [r4, #52]	; 0x34
 803c77e:	2300      	movs	r3, #0
 803c780:	61a3      	str	r3, [r4, #24]
 803c782:	6063      	str	r3, [r4, #4]
 803c784:	89a3      	ldrh	r3, [r4, #12]
 803c786:	061b      	lsls	r3, r3, #24
 803c788:	d503      	bpl.n	803c792 <setvbuf+0x6a>
 803c78a:	6921      	ldr	r1, [r4, #16]
 803c78c:	4630      	mov	r0, r6
 803c78e:	f000 fb2d 	bl	803cdec <_free_r>
 803c792:	89a3      	ldrh	r3, [r4, #12]
 803c794:	f1b8 0f02 	cmp.w	r8, #2
 803c798:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
 803c79c:	f023 0303 	bic.w	r3, r3, #3
 803c7a0:	81a3      	strh	r3, [r4, #12]
 803c7a2:	d05c      	beq.n	803c85e <setvbuf+0x136>
 803c7a4:	ab01      	add	r3, sp, #4
 803c7a6:	466a      	mov	r2, sp
 803c7a8:	4621      	mov	r1, r4
 803c7aa:	4630      	mov	r0, r6
 803c7ac:	f000 fab2 	bl	803cd14 <__swhatbuf_r>
 803c7b0:	89a3      	ldrh	r3, [r4, #12]
 803c7b2:	4318      	orrs	r0, r3
 803c7b4:	81a0      	strh	r0, [r4, #12]
 803c7b6:	bb2d      	cbnz	r5, 803c804 <setvbuf+0xdc>
 803c7b8:	9d00      	ldr	r5, [sp, #0]
 803c7ba:	4628      	mov	r0, r5
 803c7bc:	f000 fb0e 	bl	803cddc <malloc>
 803c7c0:	4607      	mov	r7, r0
 803c7c2:	2800      	cmp	r0, #0
 803c7c4:	d14d      	bne.n	803c862 <setvbuf+0x13a>
 803c7c6:	f8dd 9000 	ldr.w	r9, [sp]
 803c7ca:	45a9      	cmp	r9, r5
 803c7cc:	d13b      	bne.n	803c846 <setvbuf+0x11e>
 803c7ce:	f04f 30ff 	mov.w	r0, #4294967295
 803c7d2:	89a3      	ldrh	r3, [r4, #12]
 803c7d4:	f043 0302 	orr.w	r3, r3, #2
 803c7d8:	81a3      	strh	r3, [r4, #12]
 803c7da:	2300      	movs	r3, #0
 803c7dc:	60a3      	str	r3, [r4, #8]
 803c7de:	f104 0347 	add.w	r3, r4, #71	; 0x47
 803c7e2:	6023      	str	r3, [r4, #0]
 803c7e4:	6123      	str	r3, [r4, #16]
 803c7e6:	2301      	movs	r3, #1
 803c7e8:	6163      	str	r3, [r4, #20]
 803c7ea:	b003      	add	sp, #12
 803c7ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 803c7f0:	4b21      	ldr	r3, [pc, #132]	; (803c878 <setvbuf+0x150>)
 803c7f2:	429c      	cmp	r4, r3
 803c7f4:	d101      	bne.n	803c7fa <setvbuf+0xd2>
 803c7f6:	68b4      	ldr	r4, [r6, #8]
 803c7f8:	e7a8      	b.n	803c74c <setvbuf+0x24>
 803c7fa:	4b20      	ldr	r3, [pc, #128]	; (803c87c <setvbuf+0x154>)
 803c7fc:	429c      	cmp	r4, r3
 803c7fe:	bf08      	it	eq
 803c800:	68f4      	ldreq	r4, [r6, #12]
 803c802:	e7a3      	b.n	803c74c <setvbuf+0x24>
 803c804:	2f00      	cmp	r7, #0
 803c806:	d0d8      	beq.n	803c7ba <setvbuf+0x92>
 803c808:	69b3      	ldr	r3, [r6, #24]
 803c80a:	b913      	cbnz	r3, 803c812 <setvbuf+0xea>
 803c80c:	4630      	mov	r0, r6
 803c80e:	f000 f9f7 	bl	803cc00 <__sinit>
 803c812:	f1b8 0f01 	cmp.w	r8, #1
 803c816:	6027      	str	r7, [r4, #0]
 803c818:	bf02      	ittt	eq
 803c81a:	89a3      	ldrheq	r3, [r4, #12]
 803c81c:	f043 0301 	orreq.w	r3, r3, #1
 803c820:	81a3      	strheq	r3, [r4, #12]
 803c822:	89a3      	ldrh	r3, [r4, #12]
 803c824:	f013 0008 	ands.w	r0, r3, #8
 803c828:	e9c4 7504 	strd	r7, r5, [r4, #16]
 803c82c:	d01b      	beq.n	803c866 <setvbuf+0x13e>
 803c82e:	f013 0001 	ands.w	r0, r3, #1
 803c832:	f04f 0300 	mov.w	r3, #0
 803c836:	bf1d      	ittte	ne
 803c838:	426d      	negne	r5, r5
 803c83a:	60a3      	strne	r3, [r4, #8]
 803c83c:	4618      	movne	r0, r3
 803c83e:	60a5      	streq	r5, [r4, #8]
 803c840:	bf18      	it	ne
 803c842:	61a5      	strne	r5, [r4, #24]
 803c844:	e7d1      	b.n	803c7ea <setvbuf+0xc2>
 803c846:	4648      	mov	r0, r9
 803c848:	f000 fac8 	bl	803cddc <malloc>
 803c84c:	4607      	mov	r7, r0
 803c84e:	2800      	cmp	r0, #0
 803c850:	d0bd      	beq.n	803c7ce <setvbuf+0xa6>
 803c852:	89a3      	ldrh	r3, [r4, #12]
 803c854:	464d      	mov	r5, r9
 803c856:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 803c85a:	81a3      	strh	r3, [r4, #12]
 803c85c:	e7d4      	b.n	803c808 <setvbuf+0xe0>
 803c85e:	2000      	movs	r0, #0
 803c860:	e7b7      	b.n	803c7d2 <setvbuf+0xaa>
 803c862:	46a9      	mov	r9, r5
 803c864:	e7f5      	b.n	803c852 <setvbuf+0x12a>
 803c866:	60a0      	str	r0, [r4, #8]
 803c868:	e7bf      	b.n	803c7ea <setvbuf+0xc2>
 803c86a:	f04f 30ff 	mov.w	r0, #4294967295
 803c86e:	e7bc      	b.n	803c7ea <setvbuf+0xc2>
 803c870:	20000128 	.word	0x20000128
 803c874:	0803f114 	.word	0x0803f114
 803c878:	0803f134 	.word	0x0803f134
 803c87c:	0803f0f4 	.word	0x0803f0f4

0803c880 <strncmp>:
 803c880:	b510      	push	{r4, lr}
 803c882:	b16a      	cbz	r2, 803c8a0 <strncmp+0x20>
 803c884:	3901      	subs	r1, #1
 803c886:	1884      	adds	r4, r0, r2
 803c888:	f810 3b01 	ldrb.w	r3, [r0], #1
 803c88c:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 803c890:	4293      	cmp	r3, r2
 803c892:	d103      	bne.n	803c89c <strncmp+0x1c>
 803c894:	42a0      	cmp	r0, r4
 803c896:	d001      	beq.n	803c89c <strncmp+0x1c>
 803c898:	2b00      	cmp	r3, #0
 803c89a:	d1f5      	bne.n	803c888 <strncmp+0x8>
 803c89c:	1a98      	subs	r0, r3, r2
 803c89e:	bd10      	pop	{r4, pc}
 803c8a0:	4610      	mov	r0, r2
 803c8a2:	e7fc      	b.n	803c89e <strncmp+0x1e>

0803c8a4 <__swbuf_r>:
 803c8a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803c8a6:	460e      	mov	r6, r1
 803c8a8:	4614      	mov	r4, r2
 803c8aa:	4605      	mov	r5, r0
 803c8ac:	b118      	cbz	r0, 803c8b6 <__swbuf_r+0x12>
 803c8ae:	6983      	ldr	r3, [r0, #24]
 803c8b0:	b90b      	cbnz	r3, 803c8b6 <__swbuf_r+0x12>
 803c8b2:	f000 f9a5 	bl	803cc00 <__sinit>
 803c8b6:	4b21      	ldr	r3, [pc, #132]	; (803c93c <__swbuf_r+0x98>)
 803c8b8:	429c      	cmp	r4, r3
 803c8ba:	d12a      	bne.n	803c912 <__swbuf_r+0x6e>
 803c8bc:	686c      	ldr	r4, [r5, #4]
 803c8be:	69a3      	ldr	r3, [r4, #24]
 803c8c0:	60a3      	str	r3, [r4, #8]
 803c8c2:	89a3      	ldrh	r3, [r4, #12]
 803c8c4:	071a      	lsls	r2, r3, #28
 803c8c6:	d52e      	bpl.n	803c926 <__swbuf_r+0x82>
 803c8c8:	6923      	ldr	r3, [r4, #16]
 803c8ca:	b363      	cbz	r3, 803c926 <__swbuf_r+0x82>
 803c8cc:	6923      	ldr	r3, [r4, #16]
 803c8ce:	b2f6      	uxtb	r6, r6
 803c8d0:	6820      	ldr	r0, [r4, #0]
 803c8d2:	4637      	mov	r7, r6
 803c8d4:	1ac0      	subs	r0, r0, r3
 803c8d6:	6963      	ldr	r3, [r4, #20]
 803c8d8:	4283      	cmp	r3, r0
 803c8da:	dc04      	bgt.n	803c8e6 <__swbuf_r+0x42>
 803c8dc:	4621      	mov	r1, r4
 803c8de:	4628      	mov	r0, r5
 803c8e0:	f000 f924 	bl	803cb2c <_fflush_r>
 803c8e4:	bb28      	cbnz	r0, 803c932 <__swbuf_r+0x8e>
 803c8e6:	68a3      	ldr	r3, [r4, #8]
 803c8e8:	3001      	adds	r0, #1
 803c8ea:	3b01      	subs	r3, #1
 803c8ec:	60a3      	str	r3, [r4, #8]
 803c8ee:	6823      	ldr	r3, [r4, #0]
 803c8f0:	1c5a      	adds	r2, r3, #1
 803c8f2:	6022      	str	r2, [r4, #0]
 803c8f4:	701e      	strb	r6, [r3, #0]
 803c8f6:	6963      	ldr	r3, [r4, #20]
 803c8f8:	4283      	cmp	r3, r0
 803c8fa:	d004      	beq.n	803c906 <__swbuf_r+0x62>
 803c8fc:	89a3      	ldrh	r3, [r4, #12]
 803c8fe:	07db      	lsls	r3, r3, #31
 803c900:	d519      	bpl.n	803c936 <__swbuf_r+0x92>
 803c902:	2e0a      	cmp	r6, #10
 803c904:	d117      	bne.n	803c936 <__swbuf_r+0x92>
 803c906:	4621      	mov	r1, r4
 803c908:	4628      	mov	r0, r5
 803c90a:	f000 f90f 	bl	803cb2c <_fflush_r>
 803c90e:	b190      	cbz	r0, 803c936 <__swbuf_r+0x92>
 803c910:	e00f      	b.n	803c932 <__swbuf_r+0x8e>
 803c912:	4b0b      	ldr	r3, [pc, #44]	; (803c940 <__swbuf_r+0x9c>)
 803c914:	429c      	cmp	r4, r3
 803c916:	d101      	bne.n	803c91c <__swbuf_r+0x78>
 803c918:	68ac      	ldr	r4, [r5, #8]
 803c91a:	e7d0      	b.n	803c8be <__swbuf_r+0x1a>
 803c91c:	4b09      	ldr	r3, [pc, #36]	; (803c944 <__swbuf_r+0xa0>)
 803c91e:	429c      	cmp	r4, r3
 803c920:	bf08      	it	eq
 803c922:	68ec      	ldreq	r4, [r5, #12]
 803c924:	e7cb      	b.n	803c8be <__swbuf_r+0x1a>
 803c926:	4621      	mov	r1, r4
 803c928:	4628      	mov	r0, r5
 803c92a:	f000 f80d 	bl	803c948 <__swsetup_r>
 803c92e:	2800      	cmp	r0, #0
 803c930:	d0cc      	beq.n	803c8cc <__swbuf_r+0x28>
 803c932:	f04f 37ff 	mov.w	r7, #4294967295
 803c936:	4638      	mov	r0, r7
 803c938:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 803c93a:	bf00      	nop
 803c93c:	0803f114 	.word	0x0803f114
 803c940:	0803f134 	.word	0x0803f134
 803c944:	0803f0f4 	.word	0x0803f0f4

0803c948 <__swsetup_r>:
 803c948:	4b32      	ldr	r3, [pc, #200]	; (803ca14 <__swsetup_r+0xcc>)
 803c94a:	b570      	push	{r4, r5, r6, lr}
 803c94c:	681d      	ldr	r5, [r3, #0]
 803c94e:	4606      	mov	r6, r0
 803c950:	460c      	mov	r4, r1
 803c952:	b125      	cbz	r5, 803c95e <__swsetup_r+0x16>
 803c954:	69ab      	ldr	r3, [r5, #24]
 803c956:	b913      	cbnz	r3, 803c95e <__swsetup_r+0x16>
 803c958:	4628      	mov	r0, r5
 803c95a:	f000 f951 	bl	803cc00 <__sinit>
 803c95e:	4b2e      	ldr	r3, [pc, #184]	; (803ca18 <__swsetup_r+0xd0>)
 803c960:	429c      	cmp	r4, r3
 803c962:	d10f      	bne.n	803c984 <__swsetup_r+0x3c>
 803c964:	686c      	ldr	r4, [r5, #4]
 803c966:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 803c96a:	b29a      	uxth	r2, r3
 803c96c:	0715      	lsls	r5, r2, #28
 803c96e:	d42c      	bmi.n	803c9ca <__swsetup_r+0x82>
 803c970:	06d0      	lsls	r0, r2, #27
 803c972:	d411      	bmi.n	803c998 <__swsetup_r+0x50>
 803c974:	2209      	movs	r2, #9
 803c976:	6032      	str	r2, [r6, #0]
 803c978:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 803c97c:	f04f 30ff 	mov.w	r0, #4294967295
 803c980:	81a3      	strh	r3, [r4, #12]
 803c982:	e03e      	b.n	803ca02 <__swsetup_r+0xba>
 803c984:	4b25      	ldr	r3, [pc, #148]	; (803ca1c <__swsetup_r+0xd4>)
 803c986:	429c      	cmp	r4, r3
 803c988:	d101      	bne.n	803c98e <__swsetup_r+0x46>
 803c98a:	68ac      	ldr	r4, [r5, #8]
 803c98c:	e7eb      	b.n	803c966 <__swsetup_r+0x1e>
 803c98e:	4b24      	ldr	r3, [pc, #144]	; (803ca20 <__swsetup_r+0xd8>)
 803c990:	429c      	cmp	r4, r3
 803c992:	bf08      	it	eq
 803c994:	68ec      	ldreq	r4, [r5, #12]
 803c996:	e7e6      	b.n	803c966 <__swsetup_r+0x1e>
 803c998:	0751      	lsls	r1, r2, #29
 803c99a:	d512      	bpl.n	803c9c2 <__swsetup_r+0x7a>
 803c99c:	6b61      	ldr	r1, [r4, #52]	; 0x34
 803c99e:	b141      	cbz	r1, 803c9b2 <__swsetup_r+0x6a>
 803c9a0:	f104 0344 	add.w	r3, r4, #68	; 0x44
 803c9a4:	4299      	cmp	r1, r3
 803c9a6:	d002      	beq.n	803c9ae <__swsetup_r+0x66>
 803c9a8:	4630      	mov	r0, r6
 803c9aa:	f000 fa1f 	bl	803cdec <_free_r>
 803c9ae:	2300      	movs	r3, #0
 803c9b0:	6363      	str	r3, [r4, #52]	; 0x34
 803c9b2:	89a3      	ldrh	r3, [r4, #12]
 803c9b4:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 803c9b8:	81a3      	strh	r3, [r4, #12]
 803c9ba:	2300      	movs	r3, #0
 803c9bc:	6063      	str	r3, [r4, #4]
 803c9be:	6923      	ldr	r3, [r4, #16]
 803c9c0:	6023      	str	r3, [r4, #0]
 803c9c2:	89a3      	ldrh	r3, [r4, #12]
 803c9c4:	f043 0308 	orr.w	r3, r3, #8
 803c9c8:	81a3      	strh	r3, [r4, #12]
 803c9ca:	6923      	ldr	r3, [r4, #16]
 803c9cc:	b94b      	cbnz	r3, 803c9e2 <__swsetup_r+0x9a>
 803c9ce:	89a3      	ldrh	r3, [r4, #12]
 803c9d0:	f403 7320 	and.w	r3, r3, #640	; 0x280
 803c9d4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 803c9d8:	d003      	beq.n	803c9e2 <__swsetup_r+0x9a>
 803c9da:	4621      	mov	r1, r4
 803c9dc:	4630      	mov	r0, r6
 803c9de:	f000 f9bd 	bl	803cd5c <__smakebuf_r>
 803c9e2:	89a2      	ldrh	r2, [r4, #12]
 803c9e4:	f012 0301 	ands.w	r3, r2, #1
 803c9e8:	d00c      	beq.n	803ca04 <__swsetup_r+0xbc>
 803c9ea:	2300      	movs	r3, #0
 803c9ec:	60a3      	str	r3, [r4, #8]
 803c9ee:	6963      	ldr	r3, [r4, #20]
 803c9f0:	425b      	negs	r3, r3
 803c9f2:	61a3      	str	r3, [r4, #24]
 803c9f4:	6923      	ldr	r3, [r4, #16]
 803c9f6:	b953      	cbnz	r3, 803ca0e <__swsetup_r+0xc6>
 803c9f8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 803c9fc:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 803ca00:	d1ba      	bne.n	803c978 <__swsetup_r+0x30>
 803ca02:	bd70      	pop	{r4, r5, r6, pc}
 803ca04:	0792      	lsls	r2, r2, #30
 803ca06:	bf58      	it	pl
 803ca08:	6963      	ldrpl	r3, [r4, #20]
 803ca0a:	60a3      	str	r3, [r4, #8]
 803ca0c:	e7f2      	b.n	803c9f4 <__swsetup_r+0xac>
 803ca0e:	2000      	movs	r0, #0
 803ca10:	e7f7      	b.n	803ca02 <__swsetup_r+0xba>
 803ca12:	bf00      	nop
 803ca14:	20000128 	.word	0x20000128
 803ca18:	0803f114 	.word	0x0803f114
 803ca1c:	0803f134 	.word	0x0803f134
 803ca20:	0803f0f4 	.word	0x0803f0f4

0803ca24 <__sflush_r>:
 803ca24:	898a      	ldrh	r2, [r1, #12]
 803ca26:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 803ca2a:	4605      	mov	r5, r0
 803ca2c:	0710      	lsls	r0, r2, #28
 803ca2e:	460c      	mov	r4, r1
 803ca30:	d458      	bmi.n	803cae4 <__sflush_r+0xc0>
 803ca32:	684b      	ldr	r3, [r1, #4]
 803ca34:	2b00      	cmp	r3, #0
 803ca36:	dc05      	bgt.n	803ca44 <__sflush_r+0x20>
 803ca38:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 803ca3a:	2b00      	cmp	r3, #0
 803ca3c:	dc02      	bgt.n	803ca44 <__sflush_r+0x20>
 803ca3e:	2000      	movs	r0, #0
 803ca40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 803ca44:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 803ca46:	2e00      	cmp	r6, #0
 803ca48:	d0f9      	beq.n	803ca3e <__sflush_r+0x1a>
 803ca4a:	2300      	movs	r3, #0
 803ca4c:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 803ca50:	682f      	ldr	r7, [r5, #0]
 803ca52:	6a21      	ldr	r1, [r4, #32]
 803ca54:	602b      	str	r3, [r5, #0]
 803ca56:	d032      	beq.n	803cabe <__sflush_r+0x9a>
 803ca58:	6d60      	ldr	r0, [r4, #84]	; 0x54
 803ca5a:	89a3      	ldrh	r3, [r4, #12]
 803ca5c:	075a      	lsls	r2, r3, #29
 803ca5e:	d505      	bpl.n	803ca6c <__sflush_r+0x48>
 803ca60:	6863      	ldr	r3, [r4, #4]
 803ca62:	1ac0      	subs	r0, r0, r3
 803ca64:	6b63      	ldr	r3, [r4, #52]	; 0x34
 803ca66:	b10b      	cbz	r3, 803ca6c <__sflush_r+0x48>
 803ca68:	6c23      	ldr	r3, [r4, #64]	; 0x40
 803ca6a:	1ac0      	subs	r0, r0, r3
 803ca6c:	2300      	movs	r3, #0
 803ca6e:	4602      	mov	r2, r0
 803ca70:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 803ca72:	4628      	mov	r0, r5
 803ca74:	6a21      	ldr	r1, [r4, #32]
 803ca76:	47b0      	blx	r6
 803ca78:	1c43      	adds	r3, r0, #1
 803ca7a:	89a3      	ldrh	r3, [r4, #12]
 803ca7c:	d106      	bne.n	803ca8c <__sflush_r+0x68>
 803ca7e:	6829      	ldr	r1, [r5, #0]
 803ca80:	291d      	cmp	r1, #29
 803ca82:	d847      	bhi.n	803cb14 <__sflush_r+0xf0>
 803ca84:	4a28      	ldr	r2, [pc, #160]	; (803cb28 <__sflush_r+0x104>)
 803ca86:	40ca      	lsrs	r2, r1
 803ca88:	07d6      	lsls	r6, r2, #31
 803ca8a:	d543      	bpl.n	803cb14 <__sflush_r+0xf0>
 803ca8c:	2200      	movs	r2, #0
 803ca8e:	04d9      	lsls	r1, r3, #19
 803ca90:	6062      	str	r2, [r4, #4]
 803ca92:	6922      	ldr	r2, [r4, #16]
 803ca94:	6022      	str	r2, [r4, #0]
 803ca96:	d504      	bpl.n	803caa2 <__sflush_r+0x7e>
 803ca98:	1c42      	adds	r2, r0, #1
 803ca9a:	d101      	bne.n	803caa0 <__sflush_r+0x7c>
 803ca9c:	682b      	ldr	r3, [r5, #0]
 803ca9e:	b903      	cbnz	r3, 803caa2 <__sflush_r+0x7e>
 803caa0:	6560      	str	r0, [r4, #84]	; 0x54
 803caa2:	6b61      	ldr	r1, [r4, #52]	; 0x34
 803caa4:	602f      	str	r7, [r5, #0]
 803caa6:	2900      	cmp	r1, #0
 803caa8:	d0c9      	beq.n	803ca3e <__sflush_r+0x1a>
 803caaa:	f104 0344 	add.w	r3, r4, #68	; 0x44
 803caae:	4299      	cmp	r1, r3
 803cab0:	d002      	beq.n	803cab8 <__sflush_r+0x94>
 803cab2:	4628      	mov	r0, r5
 803cab4:	f000 f99a 	bl	803cdec <_free_r>
 803cab8:	2000      	movs	r0, #0
 803caba:	6360      	str	r0, [r4, #52]	; 0x34
 803cabc:	e7c0      	b.n	803ca40 <__sflush_r+0x1c>
 803cabe:	2301      	movs	r3, #1
 803cac0:	4628      	mov	r0, r5
 803cac2:	47b0      	blx	r6
 803cac4:	1c41      	adds	r1, r0, #1
 803cac6:	d1c8      	bne.n	803ca5a <__sflush_r+0x36>
 803cac8:	682b      	ldr	r3, [r5, #0]
 803caca:	2b00      	cmp	r3, #0
 803cacc:	d0c5      	beq.n	803ca5a <__sflush_r+0x36>
 803cace:	2b1d      	cmp	r3, #29
 803cad0:	d001      	beq.n	803cad6 <__sflush_r+0xb2>
 803cad2:	2b16      	cmp	r3, #22
 803cad4:	d101      	bne.n	803cada <__sflush_r+0xb6>
 803cad6:	602f      	str	r7, [r5, #0]
 803cad8:	e7b1      	b.n	803ca3e <__sflush_r+0x1a>
 803cada:	89a3      	ldrh	r3, [r4, #12]
 803cadc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 803cae0:	81a3      	strh	r3, [r4, #12]
 803cae2:	e7ad      	b.n	803ca40 <__sflush_r+0x1c>
 803cae4:	690f      	ldr	r7, [r1, #16]
 803cae6:	2f00      	cmp	r7, #0
 803cae8:	d0a9      	beq.n	803ca3e <__sflush_r+0x1a>
 803caea:	0793      	lsls	r3, r2, #30
 803caec:	680e      	ldr	r6, [r1, #0]
 803caee:	600f      	str	r7, [r1, #0]
 803caf0:	bf0c      	ite	eq
 803caf2:	694b      	ldreq	r3, [r1, #20]
 803caf4:	2300      	movne	r3, #0
 803caf6:	eba6 0807 	sub.w	r8, r6, r7
 803cafa:	608b      	str	r3, [r1, #8]
 803cafc:	f1b8 0f00 	cmp.w	r8, #0
 803cb00:	dd9d      	ble.n	803ca3e <__sflush_r+0x1a>
 803cb02:	4643      	mov	r3, r8
 803cb04:	463a      	mov	r2, r7
 803cb06:	6a21      	ldr	r1, [r4, #32]
 803cb08:	4628      	mov	r0, r5
 803cb0a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 803cb0c:	47b0      	blx	r6
 803cb0e:	2800      	cmp	r0, #0
 803cb10:	dc06      	bgt.n	803cb20 <__sflush_r+0xfc>
 803cb12:	89a3      	ldrh	r3, [r4, #12]
 803cb14:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 803cb18:	f04f 30ff 	mov.w	r0, #4294967295
 803cb1c:	81a3      	strh	r3, [r4, #12]
 803cb1e:	e78f      	b.n	803ca40 <__sflush_r+0x1c>
 803cb20:	4407      	add	r7, r0
 803cb22:	eba8 0800 	sub.w	r8, r8, r0
 803cb26:	e7e9      	b.n	803cafc <__sflush_r+0xd8>
 803cb28:	20400001 	.word	0x20400001

0803cb2c <_fflush_r>:
 803cb2c:	b538      	push	{r3, r4, r5, lr}
 803cb2e:	690b      	ldr	r3, [r1, #16]
 803cb30:	4605      	mov	r5, r0
 803cb32:	460c      	mov	r4, r1
 803cb34:	b1db      	cbz	r3, 803cb6e <_fflush_r+0x42>
 803cb36:	b118      	cbz	r0, 803cb40 <_fflush_r+0x14>
 803cb38:	6983      	ldr	r3, [r0, #24]
 803cb3a:	b90b      	cbnz	r3, 803cb40 <_fflush_r+0x14>
 803cb3c:	f000 f860 	bl	803cc00 <__sinit>
 803cb40:	4b0c      	ldr	r3, [pc, #48]	; (803cb74 <_fflush_r+0x48>)
 803cb42:	429c      	cmp	r4, r3
 803cb44:	d109      	bne.n	803cb5a <_fflush_r+0x2e>
 803cb46:	686c      	ldr	r4, [r5, #4]
 803cb48:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 803cb4c:	b17b      	cbz	r3, 803cb6e <_fflush_r+0x42>
 803cb4e:	4621      	mov	r1, r4
 803cb50:	4628      	mov	r0, r5
 803cb52:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 803cb56:	f7ff bf65 	b.w	803ca24 <__sflush_r>
 803cb5a:	4b07      	ldr	r3, [pc, #28]	; (803cb78 <_fflush_r+0x4c>)
 803cb5c:	429c      	cmp	r4, r3
 803cb5e:	d101      	bne.n	803cb64 <_fflush_r+0x38>
 803cb60:	68ac      	ldr	r4, [r5, #8]
 803cb62:	e7f1      	b.n	803cb48 <_fflush_r+0x1c>
 803cb64:	4b05      	ldr	r3, [pc, #20]	; (803cb7c <_fflush_r+0x50>)
 803cb66:	429c      	cmp	r4, r3
 803cb68:	bf08      	it	eq
 803cb6a:	68ec      	ldreq	r4, [r5, #12]
 803cb6c:	e7ec      	b.n	803cb48 <_fflush_r+0x1c>
 803cb6e:	2000      	movs	r0, #0
 803cb70:	bd38      	pop	{r3, r4, r5, pc}
 803cb72:	bf00      	nop
 803cb74:	0803f114 	.word	0x0803f114
 803cb78:	0803f134 	.word	0x0803f134
 803cb7c:	0803f0f4 	.word	0x0803f0f4

0803cb80 <std>:
 803cb80:	2300      	movs	r3, #0
 803cb82:	b510      	push	{r4, lr}
 803cb84:	4604      	mov	r4, r0
 803cb86:	6083      	str	r3, [r0, #8]
 803cb88:	8181      	strh	r1, [r0, #12]
 803cb8a:	4619      	mov	r1, r3
 803cb8c:	6643      	str	r3, [r0, #100]	; 0x64
 803cb8e:	81c2      	strh	r2, [r0, #14]
 803cb90:	2208      	movs	r2, #8
 803cb92:	6183      	str	r3, [r0, #24]
 803cb94:	e9c0 3300 	strd	r3, r3, [r0]
 803cb98:	e9c0 3304 	strd	r3, r3, [r0, #16]
 803cb9c:	305c      	adds	r0, #92	; 0x5c
 803cb9e:	f7ff fd3f 	bl	803c620 <memset>
 803cba2:	4b05      	ldr	r3, [pc, #20]	; (803cbb8 <std+0x38>)
 803cba4:	6224      	str	r4, [r4, #32]
 803cba6:	6263      	str	r3, [r4, #36]	; 0x24
 803cba8:	4b04      	ldr	r3, [pc, #16]	; (803cbbc <std+0x3c>)
 803cbaa:	62a3      	str	r3, [r4, #40]	; 0x28
 803cbac:	4b04      	ldr	r3, [pc, #16]	; (803cbc0 <std+0x40>)
 803cbae:	62e3      	str	r3, [r4, #44]	; 0x2c
 803cbb0:	4b04      	ldr	r3, [pc, #16]	; (803cbc4 <std+0x44>)
 803cbb2:	6323      	str	r3, [r4, #48]	; 0x30
 803cbb4:	bd10      	pop	{r4, pc}
 803cbb6:	bf00      	nop
 803cbb8:	0803d4f1 	.word	0x0803d4f1
 803cbbc:	0803d513 	.word	0x0803d513
 803cbc0:	0803d54b 	.word	0x0803d54b
 803cbc4:	0803d56f 	.word	0x0803d56f

0803cbc8 <_cleanup_r>:
 803cbc8:	4901      	ldr	r1, [pc, #4]	; (803cbd0 <_cleanup_r+0x8>)
 803cbca:	f000 b885 	b.w	803ccd8 <_fwalk_reent>
 803cbce:	bf00      	nop
 803cbd0:	0803cb2d 	.word	0x0803cb2d

0803cbd4 <__sfmoreglue>:
 803cbd4:	b570      	push	{r4, r5, r6, lr}
 803cbd6:	1e4a      	subs	r2, r1, #1
 803cbd8:	2568      	movs	r5, #104	; 0x68
 803cbda:	460e      	mov	r6, r1
 803cbdc:	4355      	muls	r5, r2
 803cbde:	f105 0174 	add.w	r1, r5, #116	; 0x74
 803cbe2:	f000 f951 	bl	803ce88 <_malloc_r>
 803cbe6:	4604      	mov	r4, r0
 803cbe8:	b140      	cbz	r0, 803cbfc <__sfmoreglue+0x28>
 803cbea:	2100      	movs	r1, #0
 803cbec:	f105 0268 	add.w	r2, r5, #104	; 0x68
 803cbf0:	e9c0 1600 	strd	r1, r6, [r0]
 803cbf4:	300c      	adds	r0, #12
 803cbf6:	60a0      	str	r0, [r4, #8]
 803cbf8:	f7ff fd12 	bl	803c620 <memset>
 803cbfc:	4620      	mov	r0, r4
 803cbfe:	bd70      	pop	{r4, r5, r6, pc}

0803cc00 <__sinit>:
 803cc00:	6983      	ldr	r3, [r0, #24]
 803cc02:	b510      	push	{r4, lr}
 803cc04:	4604      	mov	r4, r0
 803cc06:	bb33      	cbnz	r3, 803cc56 <__sinit+0x56>
 803cc08:	6503      	str	r3, [r0, #80]	; 0x50
 803cc0a:	4a13      	ldr	r2, [pc, #76]	; (803cc58 <__sinit+0x58>)
 803cc0c:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 803cc10:	4b12      	ldr	r3, [pc, #72]	; (803cc5c <__sinit+0x5c>)
 803cc12:	6282      	str	r2, [r0, #40]	; 0x28
 803cc14:	681b      	ldr	r3, [r3, #0]
 803cc16:	4298      	cmp	r0, r3
 803cc18:	bf04      	itt	eq
 803cc1a:	2301      	moveq	r3, #1
 803cc1c:	6183      	streq	r3, [r0, #24]
 803cc1e:	f000 f81f 	bl	803cc60 <__sfp>
 803cc22:	6060      	str	r0, [r4, #4]
 803cc24:	4620      	mov	r0, r4
 803cc26:	f000 f81b 	bl	803cc60 <__sfp>
 803cc2a:	60a0      	str	r0, [r4, #8]
 803cc2c:	4620      	mov	r0, r4
 803cc2e:	f000 f817 	bl	803cc60 <__sfp>
 803cc32:	2200      	movs	r2, #0
 803cc34:	60e0      	str	r0, [r4, #12]
 803cc36:	2104      	movs	r1, #4
 803cc38:	6860      	ldr	r0, [r4, #4]
 803cc3a:	f7ff ffa1 	bl	803cb80 <std>
 803cc3e:	2201      	movs	r2, #1
 803cc40:	2109      	movs	r1, #9
 803cc42:	68a0      	ldr	r0, [r4, #8]
 803cc44:	f7ff ff9c 	bl	803cb80 <std>
 803cc48:	2202      	movs	r2, #2
 803cc4a:	2112      	movs	r1, #18
 803cc4c:	68e0      	ldr	r0, [r4, #12]
 803cc4e:	f7ff ff97 	bl	803cb80 <std>
 803cc52:	2301      	movs	r3, #1
 803cc54:	61a3      	str	r3, [r4, #24]
 803cc56:	bd10      	pop	{r4, pc}
 803cc58:	0803cbc9 	.word	0x0803cbc9
 803cc5c:	0803f0f0 	.word	0x0803f0f0

0803cc60 <__sfp>:
 803cc60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803cc62:	4b1b      	ldr	r3, [pc, #108]	; (803ccd0 <__sfp+0x70>)
 803cc64:	4607      	mov	r7, r0
 803cc66:	681e      	ldr	r6, [r3, #0]
 803cc68:	69b3      	ldr	r3, [r6, #24]
 803cc6a:	b913      	cbnz	r3, 803cc72 <__sfp+0x12>
 803cc6c:	4630      	mov	r0, r6
 803cc6e:	f7ff ffc7 	bl	803cc00 <__sinit>
 803cc72:	3648      	adds	r6, #72	; 0x48
 803cc74:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 803cc78:	3b01      	subs	r3, #1
 803cc7a:	d503      	bpl.n	803cc84 <__sfp+0x24>
 803cc7c:	6833      	ldr	r3, [r6, #0]
 803cc7e:	b133      	cbz	r3, 803cc8e <__sfp+0x2e>
 803cc80:	6836      	ldr	r6, [r6, #0]
 803cc82:	e7f7      	b.n	803cc74 <__sfp+0x14>
 803cc84:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 803cc88:	b16d      	cbz	r5, 803cca6 <__sfp+0x46>
 803cc8a:	3468      	adds	r4, #104	; 0x68
 803cc8c:	e7f4      	b.n	803cc78 <__sfp+0x18>
 803cc8e:	2104      	movs	r1, #4
 803cc90:	4638      	mov	r0, r7
 803cc92:	f7ff ff9f 	bl	803cbd4 <__sfmoreglue>
 803cc96:	6030      	str	r0, [r6, #0]
 803cc98:	2800      	cmp	r0, #0
 803cc9a:	d1f1      	bne.n	803cc80 <__sfp+0x20>
 803cc9c:	230c      	movs	r3, #12
 803cc9e:	4604      	mov	r4, r0
 803cca0:	603b      	str	r3, [r7, #0]
 803cca2:	4620      	mov	r0, r4
 803cca4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 803cca6:	4b0b      	ldr	r3, [pc, #44]	; (803ccd4 <__sfp+0x74>)
 803cca8:	2208      	movs	r2, #8
 803ccaa:	6665      	str	r5, [r4, #100]	; 0x64
 803ccac:	4629      	mov	r1, r5
 803ccae:	60a5      	str	r5, [r4, #8]
 803ccb0:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 803ccb4:	e9c4 5500 	strd	r5, r5, [r4]
 803ccb8:	e9c4 3503 	strd	r3, r5, [r4, #12]
 803ccbc:	e9c4 5505 	strd	r5, r5, [r4, #20]
 803ccc0:	f7ff fcae 	bl	803c620 <memset>
 803ccc4:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 803ccc8:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 803cccc:	e7e9      	b.n	803cca2 <__sfp+0x42>
 803ccce:	bf00      	nop
 803ccd0:	0803f0f0 	.word	0x0803f0f0
 803ccd4:	ffff0001 	.word	0xffff0001

0803ccd8 <_fwalk_reent>:
 803ccd8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 803ccdc:	4680      	mov	r8, r0
 803ccde:	4689      	mov	r9, r1
 803cce0:	f100 0448 	add.w	r4, r0, #72	; 0x48
 803cce4:	2600      	movs	r6, #0
 803cce6:	b914      	cbnz	r4, 803ccee <_fwalk_reent+0x16>
 803cce8:	4630      	mov	r0, r6
 803ccea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 803ccee:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 803ccf2:	3f01      	subs	r7, #1
 803ccf4:	d501      	bpl.n	803ccfa <_fwalk_reent+0x22>
 803ccf6:	6824      	ldr	r4, [r4, #0]
 803ccf8:	e7f5      	b.n	803cce6 <_fwalk_reent+0xe>
 803ccfa:	89ab      	ldrh	r3, [r5, #12]
 803ccfc:	2b01      	cmp	r3, #1
 803ccfe:	d907      	bls.n	803cd10 <_fwalk_reent+0x38>
 803cd00:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 803cd04:	3301      	adds	r3, #1
 803cd06:	d003      	beq.n	803cd10 <_fwalk_reent+0x38>
 803cd08:	4629      	mov	r1, r5
 803cd0a:	4640      	mov	r0, r8
 803cd0c:	47c8      	blx	r9
 803cd0e:	4306      	orrs	r6, r0
 803cd10:	3568      	adds	r5, #104	; 0x68
 803cd12:	e7ee      	b.n	803ccf2 <_fwalk_reent+0x1a>

0803cd14 <__swhatbuf_r>:
 803cd14:	b570      	push	{r4, r5, r6, lr}
 803cd16:	460e      	mov	r6, r1
 803cd18:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 803cd1c:	b096      	sub	sp, #88	; 0x58
 803cd1e:	4614      	mov	r4, r2
 803cd20:	2900      	cmp	r1, #0
 803cd22:	461d      	mov	r5, r3
 803cd24:	da07      	bge.n	803cd36 <__swhatbuf_r+0x22>
 803cd26:	2300      	movs	r3, #0
 803cd28:	602b      	str	r3, [r5, #0]
 803cd2a:	89b3      	ldrh	r3, [r6, #12]
 803cd2c:	061a      	lsls	r2, r3, #24
 803cd2e:	d410      	bmi.n	803cd52 <__swhatbuf_r+0x3e>
 803cd30:	f44f 6380 	mov.w	r3, #1024	; 0x400
 803cd34:	e00e      	b.n	803cd54 <__swhatbuf_r+0x40>
 803cd36:	466a      	mov	r2, sp
 803cd38:	f000 fc40 	bl	803d5bc <_fstat_r>
 803cd3c:	2800      	cmp	r0, #0
 803cd3e:	dbf2      	blt.n	803cd26 <__swhatbuf_r+0x12>
 803cd40:	9a01      	ldr	r2, [sp, #4]
 803cd42:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 803cd46:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 803cd4a:	425a      	negs	r2, r3
 803cd4c:	415a      	adcs	r2, r3
 803cd4e:	602a      	str	r2, [r5, #0]
 803cd50:	e7ee      	b.n	803cd30 <__swhatbuf_r+0x1c>
 803cd52:	2340      	movs	r3, #64	; 0x40
 803cd54:	2000      	movs	r0, #0
 803cd56:	6023      	str	r3, [r4, #0]
 803cd58:	b016      	add	sp, #88	; 0x58
 803cd5a:	bd70      	pop	{r4, r5, r6, pc}

0803cd5c <__smakebuf_r>:
 803cd5c:	898b      	ldrh	r3, [r1, #12]
 803cd5e:	b573      	push	{r0, r1, r4, r5, r6, lr}
 803cd60:	079d      	lsls	r5, r3, #30
 803cd62:	4606      	mov	r6, r0
 803cd64:	460c      	mov	r4, r1
 803cd66:	d507      	bpl.n	803cd78 <__smakebuf_r+0x1c>
 803cd68:	f104 0347 	add.w	r3, r4, #71	; 0x47
 803cd6c:	6023      	str	r3, [r4, #0]
 803cd6e:	6123      	str	r3, [r4, #16]
 803cd70:	2301      	movs	r3, #1
 803cd72:	6163      	str	r3, [r4, #20]
 803cd74:	b002      	add	sp, #8
 803cd76:	bd70      	pop	{r4, r5, r6, pc}
 803cd78:	ab01      	add	r3, sp, #4
 803cd7a:	466a      	mov	r2, sp
 803cd7c:	f7ff ffca 	bl	803cd14 <__swhatbuf_r>
 803cd80:	9900      	ldr	r1, [sp, #0]
 803cd82:	4605      	mov	r5, r0
 803cd84:	4630      	mov	r0, r6
 803cd86:	f000 f87f 	bl	803ce88 <_malloc_r>
 803cd8a:	b948      	cbnz	r0, 803cda0 <__smakebuf_r+0x44>
 803cd8c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 803cd90:	059a      	lsls	r2, r3, #22
 803cd92:	d4ef      	bmi.n	803cd74 <__smakebuf_r+0x18>
 803cd94:	f023 0303 	bic.w	r3, r3, #3
 803cd98:	f043 0302 	orr.w	r3, r3, #2
 803cd9c:	81a3      	strh	r3, [r4, #12]
 803cd9e:	e7e3      	b.n	803cd68 <__smakebuf_r+0xc>
 803cda0:	4b0d      	ldr	r3, [pc, #52]	; (803cdd8 <__smakebuf_r+0x7c>)
 803cda2:	62b3      	str	r3, [r6, #40]	; 0x28
 803cda4:	89a3      	ldrh	r3, [r4, #12]
 803cda6:	6020      	str	r0, [r4, #0]
 803cda8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 803cdac:	6120      	str	r0, [r4, #16]
 803cdae:	81a3      	strh	r3, [r4, #12]
 803cdb0:	9b00      	ldr	r3, [sp, #0]
 803cdb2:	6163      	str	r3, [r4, #20]
 803cdb4:	9b01      	ldr	r3, [sp, #4]
 803cdb6:	b15b      	cbz	r3, 803cdd0 <__smakebuf_r+0x74>
 803cdb8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 803cdbc:	4630      	mov	r0, r6
 803cdbe:	f000 fc0f 	bl	803d5e0 <_isatty_r>
 803cdc2:	b128      	cbz	r0, 803cdd0 <__smakebuf_r+0x74>
 803cdc4:	89a3      	ldrh	r3, [r4, #12]
 803cdc6:	f023 0303 	bic.w	r3, r3, #3
 803cdca:	f043 0301 	orr.w	r3, r3, #1
 803cdce:	81a3      	strh	r3, [r4, #12]
 803cdd0:	89a3      	ldrh	r3, [r4, #12]
 803cdd2:	431d      	orrs	r5, r3
 803cdd4:	81a5      	strh	r5, [r4, #12]
 803cdd6:	e7cd      	b.n	803cd74 <__smakebuf_r+0x18>
 803cdd8:	0803cbc9 	.word	0x0803cbc9

0803cddc <malloc>:
 803cddc:	4b02      	ldr	r3, [pc, #8]	; (803cde8 <malloc+0xc>)
 803cdde:	4601      	mov	r1, r0
 803cde0:	6818      	ldr	r0, [r3, #0]
 803cde2:	f000 b851 	b.w	803ce88 <_malloc_r>
 803cde6:	bf00      	nop
 803cde8:	20000128 	.word	0x20000128

0803cdec <_free_r>:
 803cdec:	b538      	push	{r3, r4, r5, lr}
 803cdee:	4605      	mov	r5, r0
 803cdf0:	2900      	cmp	r1, #0
 803cdf2:	d045      	beq.n	803ce80 <_free_r+0x94>
 803cdf4:	f851 3c04 	ldr.w	r3, [r1, #-4]
 803cdf8:	1f0c      	subs	r4, r1, #4
 803cdfa:	2b00      	cmp	r3, #0
 803cdfc:	bfb8      	it	lt
 803cdfe:	18e4      	addlt	r4, r4, r3
 803ce00:	f000 fc1e 	bl	803d640 <__malloc_lock>
 803ce04:	4a1f      	ldr	r2, [pc, #124]	; (803ce84 <_free_r+0x98>)
 803ce06:	6813      	ldr	r3, [r2, #0]
 803ce08:	4610      	mov	r0, r2
 803ce0a:	b933      	cbnz	r3, 803ce1a <_free_r+0x2e>
 803ce0c:	6063      	str	r3, [r4, #4]
 803ce0e:	6014      	str	r4, [r2, #0]
 803ce10:	4628      	mov	r0, r5
 803ce12:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 803ce16:	f000 bc14 	b.w	803d642 <__malloc_unlock>
 803ce1a:	42a3      	cmp	r3, r4
 803ce1c:	d90c      	bls.n	803ce38 <_free_r+0x4c>
 803ce1e:	6821      	ldr	r1, [r4, #0]
 803ce20:	1862      	adds	r2, r4, r1
 803ce22:	4293      	cmp	r3, r2
 803ce24:	bf02      	ittt	eq
 803ce26:	681a      	ldreq	r2, [r3, #0]
 803ce28:	685b      	ldreq	r3, [r3, #4]
 803ce2a:	1852      	addeq	r2, r2, r1
 803ce2c:	6063      	str	r3, [r4, #4]
 803ce2e:	bf08      	it	eq
 803ce30:	6022      	streq	r2, [r4, #0]
 803ce32:	6004      	str	r4, [r0, #0]
 803ce34:	e7ec      	b.n	803ce10 <_free_r+0x24>
 803ce36:	4613      	mov	r3, r2
 803ce38:	685a      	ldr	r2, [r3, #4]
 803ce3a:	b10a      	cbz	r2, 803ce40 <_free_r+0x54>
 803ce3c:	42a2      	cmp	r2, r4
 803ce3e:	d9fa      	bls.n	803ce36 <_free_r+0x4a>
 803ce40:	6819      	ldr	r1, [r3, #0]
 803ce42:	1858      	adds	r0, r3, r1
 803ce44:	42a0      	cmp	r0, r4
 803ce46:	d10b      	bne.n	803ce60 <_free_r+0x74>
 803ce48:	6820      	ldr	r0, [r4, #0]
 803ce4a:	4401      	add	r1, r0
 803ce4c:	1858      	adds	r0, r3, r1
 803ce4e:	6019      	str	r1, [r3, #0]
 803ce50:	4282      	cmp	r2, r0
 803ce52:	d1dd      	bne.n	803ce10 <_free_r+0x24>
 803ce54:	6810      	ldr	r0, [r2, #0]
 803ce56:	6852      	ldr	r2, [r2, #4]
 803ce58:	4401      	add	r1, r0
 803ce5a:	605a      	str	r2, [r3, #4]
 803ce5c:	6019      	str	r1, [r3, #0]
 803ce5e:	e7d7      	b.n	803ce10 <_free_r+0x24>
 803ce60:	d902      	bls.n	803ce68 <_free_r+0x7c>
 803ce62:	230c      	movs	r3, #12
 803ce64:	602b      	str	r3, [r5, #0]
 803ce66:	e7d3      	b.n	803ce10 <_free_r+0x24>
 803ce68:	6820      	ldr	r0, [r4, #0]
 803ce6a:	1821      	adds	r1, r4, r0
 803ce6c:	428a      	cmp	r2, r1
 803ce6e:	bf02      	ittt	eq
 803ce70:	6811      	ldreq	r1, [r2, #0]
 803ce72:	6852      	ldreq	r2, [r2, #4]
 803ce74:	1809      	addeq	r1, r1, r0
 803ce76:	6062      	str	r2, [r4, #4]
 803ce78:	bf08      	it	eq
 803ce7a:	6021      	streq	r1, [r4, #0]
 803ce7c:	605c      	str	r4, [r3, #4]
 803ce7e:	e7c7      	b.n	803ce10 <_free_r+0x24>
 803ce80:	bd38      	pop	{r3, r4, r5, pc}
 803ce82:	bf00      	nop
 803ce84:	20000678 	.word	0x20000678

0803ce88 <_malloc_r>:
 803ce88:	b570      	push	{r4, r5, r6, lr}
 803ce8a:	1ccd      	adds	r5, r1, #3
 803ce8c:	4606      	mov	r6, r0
 803ce8e:	f025 0503 	bic.w	r5, r5, #3
 803ce92:	3508      	adds	r5, #8
 803ce94:	2d0c      	cmp	r5, #12
 803ce96:	bf38      	it	cc
 803ce98:	250c      	movcc	r5, #12
 803ce9a:	2d00      	cmp	r5, #0
 803ce9c:	db01      	blt.n	803cea2 <_malloc_r+0x1a>
 803ce9e:	42a9      	cmp	r1, r5
 803cea0:	d903      	bls.n	803ceaa <_malloc_r+0x22>
 803cea2:	230c      	movs	r3, #12
 803cea4:	6033      	str	r3, [r6, #0]
 803cea6:	2000      	movs	r0, #0
 803cea8:	bd70      	pop	{r4, r5, r6, pc}
 803ceaa:	f000 fbc9 	bl	803d640 <__malloc_lock>
 803ceae:	4a21      	ldr	r2, [pc, #132]	; (803cf34 <_malloc_r+0xac>)
 803ceb0:	6814      	ldr	r4, [r2, #0]
 803ceb2:	4621      	mov	r1, r4
 803ceb4:	b991      	cbnz	r1, 803cedc <_malloc_r+0x54>
 803ceb6:	4c20      	ldr	r4, [pc, #128]	; (803cf38 <_malloc_r+0xb0>)
 803ceb8:	6823      	ldr	r3, [r4, #0]
 803ceba:	b91b      	cbnz	r3, 803cec4 <_malloc_r+0x3c>
 803cebc:	4630      	mov	r0, r6
 803cebe:	f000 fb07 	bl	803d4d0 <_sbrk_r>
 803cec2:	6020      	str	r0, [r4, #0]
 803cec4:	4629      	mov	r1, r5
 803cec6:	4630      	mov	r0, r6
 803cec8:	f000 fb02 	bl	803d4d0 <_sbrk_r>
 803cecc:	1c43      	adds	r3, r0, #1
 803cece:	d124      	bne.n	803cf1a <_malloc_r+0x92>
 803ced0:	230c      	movs	r3, #12
 803ced2:	4630      	mov	r0, r6
 803ced4:	6033      	str	r3, [r6, #0]
 803ced6:	f000 fbb4 	bl	803d642 <__malloc_unlock>
 803ceda:	e7e4      	b.n	803cea6 <_malloc_r+0x1e>
 803cedc:	680b      	ldr	r3, [r1, #0]
 803cede:	1b5b      	subs	r3, r3, r5
 803cee0:	d418      	bmi.n	803cf14 <_malloc_r+0x8c>
 803cee2:	2b0b      	cmp	r3, #11
 803cee4:	d90f      	bls.n	803cf06 <_malloc_r+0x7e>
 803cee6:	18cc      	adds	r4, r1, r3
 803cee8:	600b      	str	r3, [r1, #0]
 803ceea:	50cd      	str	r5, [r1, r3]
 803ceec:	4630      	mov	r0, r6
 803ceee:	f000 fba8 	bl	803d642 <__malloc_unlock>
 803cef2:	f104 000b 	add.w	r0, r4, #11
 803cef6:	1d23      	adds	r3, r4, #4
 803cef8:	f020 0007 	bic.w	r0, r0, #7
 803cefc:	1ac3      	subs	r3, r0, r3
 803cefe:	d0d3      	beq.n	803cea8 <_malloc_r+0x20>
 803cf00:	425a      	negs	r2, r3
 803cf02:	50e2      	str	r2, [r4, r3]
 803cf04:	e7d0      	b.n	803cea8 <_malloc_r+0x20>
 803cf06:	428c      	cmp	r4, r1
 803cf08:	684b      	ldr	r3, [r1, #4]
 803cf0a:	bf1a      	itte	ne
 803cf0c:	6063      	strne	r3, [r4, #4]
 803cf0e:	460c      	movne	r4, r1
 803cf10:	6013      	streq	r3, [r2, #0]
 803cf12:	e7eb      	b.n	803ceec <_malloc_r+0x64>
 803cf14:	460c      	mov	r4, r1
 803cf16:	6849      	ldr	r1, [r1, #4]
 803cf18:	e7cc      	b.n	803ceb4 <_malloc_r+0x2c>
 803cf1a:	1cc4      	adds	r4, r0, #3
 803cf1c:	f024 0403 	bic.w	r4, r4, #3
 803cf20:	42a0      	cmp	r0, r4
 803cf22:	d005      	beq.n	803cf30 <_malloc_r+0xa8>
 803cf24:	1a21      	subs	r1, r4, r0
 803cf26:	4630      	mov	r0, r6
 803cf28:	f000 fad2 	bl	803d4d0 <_sbrk_r>
 803cf2c:	3001      	adds	r0, #1
 803cf2e:	d0cf      	beq.n	803ced0 <_malloc_r+0x48>
 803cf30:	6025      	str	r5, [r4, #0]
 803cf32:	e7db      	b.n	803ceec <_malloc_r+0x64>
 803cf34:	20000678 	.word	0x20000678
 803cf38:	2000067c 	.word	0x2000067c

0803cf3c <__sfputc_r>:
 803cf3c:	6893      	ldr	r3, [r2, #8]
 803cf3e:	3b01      	subs	r3, #1
 803cf40:	2b00      	cmp	r3, #0
 803cf42:	6093      	str	r3, [r2, #8]
 803cf44:	b410      	push	{r4}
 803cf46:	da08      	bge.n	803cf5a <__sfputc_r+0x1e>
 803cf48:	6994      	ldr	r4, [r2, #24]
 803cf4a:	42a3      	cmp	r3, r4
 803cf4c:	db01      	blt.n	803cf52 <__sfputc_r+0x16>
 803cf4e:	290a      	cmp	r1, #10
 803cf50:	d103      	bne.n	803cf5a <__sfputc_r+0x1e>
 803cf52:	f85d 4b04 	ldr.w	r4, [sp], #4
 803cf56:	f7ff bca5 	b.w	803c8a4 <__swbuf_r>
 803cf5a:	6813      	ldr	r3, [r2, #0]
 803cf5c:	1c58      	adds	r0, r3, #1
 803cf5e:	6010      	str	r0, [r2, #0]
 803cf60:	4608      	mov	r0, r1
 803cf62:	7019      	strb	r1, [r3, #0]
 803cf64:	f85d 4b04 	ldr.w	r4, [sp], #4
 803cf68:	4770      	bx	lr

0803cf6a <__sfputs_r>:
 803cf6a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803cf6c:	4606      	mov	r6, r0
 803cf6e:	460f      	mov	r7, r1
 803cf70:	4614      	mov	r4, r2
 803cf72:	18d5      	adds	r5, r2, r3
 803cf74:	42ac      	cmp	r4, r5
 803cf76:	d101      	bne.n	803cf7c <__sfputs_r+0x12>
 803cf78:	2000      	movs	r0, #0
 803cf7a:	e007      	b.n	803cf8c <__sfputs_r+0x22>
 803cf7c:	463a      	mov	r2, r7
 803cf7e:	f814 1b01 	ldrb.w	r1, [r4], #1
 803cf82:	4630      	mov	r0, r6
 803cf84:	f7ff ffda 	bl	803cf3c <__sfputc_r>
 803cf88:	1c43      	adds	r3, r0, #1
 803cf8a:	d1f3      	bne.n	803cf74 <__sfputs_r+0xa>
 803cf8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0803cf90 <_vfiprintf_r>:
 803cf90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803cf94:	460c      	mov	r4, r1
 803cf96:	b09d      	sub	sp, #116	; 0x74
 803cf98:	4617      	mov	r7, r2
 803cf9a:	461d      	mov	r5, r3
 803cf9c:	4606      	mov	r6, r0
 803cf9e:	b118      	cbz	r0, 803cfa8 <_vfiprintf_r+0x18>
 803cfa0:	6983      	ldr	r3, [r0, #24]
 803cfa2:	b90b      	cbnz	r3, 803cfa8 <_vfiprintf_r+0x18>
 803cfa4:	f7ff fe2c 	bl	803cc00 <__sinit>
 803cfa8:	4b7c      	ldr	r3, [pc, #496]	; (803d19c <_vfiprintf_r+0x20c>)
 803cfaa:	429c      	cmp	r4, r3
 803cfac:	d158      	bne.n	803d060 <_vfiprintf_r+0xd0>
 803cfae:	6874      	ldr	r4, [r6, #4]
 803cfb0:	89a3      	ldrh	r3, [r4, #12]
 803cfb2:	0718      	lsls	r0, r3, #28
 803cfb4:	d55e      	bpl.n	803d074 <_vfiprintf_r+0xe4>
 803cfb6:	6923      	ldr	r3, [r4, #16]
 803cfb8:	2b00      	cmp	r3, #0
 803cfba:	d05b      	beq.n	803d074 <_vfiprintf_r+0xe4>
 803cfbc:	2300      	movs	r3, #0
 803cfbe:	f04f 0b01 	mov.w	fp, #1
 803cfc2:	9503      	str	r5, [sp, #12]
 803cfc4:	9309      	str	r3, [sp, #36]	; 0x24
 803cfc6:	2320      	movs	r3, #32
 803cfc8:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 803cfcc:	2330      	movs	r3, #48	; 0x30
 803cfce:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 803cfd2:	46b8      	mov	r8, r7
 803cfd4:	4645      	mov	r5, r8
 803cfd6:	f815 3b01 	ldrb.w	r3, [r5], #1
 803cfda:	b10b      	cbz	r3, 803cfe0 <_vfiprintf_r+0x50>
 803cfdc:	2b25      	cmp	r3, #37	; 0x25
 803cfde:	d154      	bne.n	803d08a <_vfiprintf_r+0xfa>
 803cfe0:	ebb8 0a07 	subs.w	sl, r8, r7
 803cfe4:	d00b      	beq.n	803cffe <_vfiprintf_r+0x6e>
 803cfe6:	4653      	mov	r3, sl
 803cfe8:	463a      	mov	r2, r7
 803cfea:	4621      	mov	r1, r4
 803cfec:	4630      	mov	r0, r6
 803cfee:	f7ff ffbc 	bl	803cf6a <__sfputs_r>
 803cff2:	3001      	adds	r0, #1
 803cff4:	f000 80c2 	beq.w	803d17c <_vfiprintf_r+0x1ec>
 803cff8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 803cffa:	4453      	add	r3, sl
 803cffc:	9309      	str	r3, [sp, #36]	; 0x24
 803cffe:	f898 3000 	ldrb.w	r3, [r8]
 803d002:	2b00      	cmp	r3, #0
 803d004:	f000 80ba 	beq.w	803d17c <_vfiprintf_r+0x1ec>
 803d008:	2300      	movs	r3, #0
 803d00a:	f04f 32ff 	mov.w	r2, #4294967295
 803d00e:	9304      	str	r3, [sp, #16]
 803d010:	9307      	str	r3, [sp, #28]
 803d012:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 803d016:	931a      	str	r3, [sp, #104]	; 0x68
 803d018:	e9cd 2305 	strd	r2, r3, [sp, #20]
 803d01c:	46a8      	mov	r8, r5
 803d01e:	2205      	movs	r2, #5
 803d020:	485f      	ldr	r0, [pc, #380]	; (803d1a0 <_vfiprintf_r+0x210>)
 803d022:	f818 1b01 	ldrb.w	r1, [r8], #1
 803d026:	f000 fafd 	bl	803d624 <memchr>
 803d02a:	9b04      	ldr	r3, [sp, #16]
 803d02c:	bb78      	cbnz	r0, 803d08e <_vfiprintf_r+0xfe>
 803d02e:	06d9      	lsls	r1, r3, #27
 803d030:	bf44      	itt	mi
 803d032:	2220      	movmi	r2, #32
 803d034:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 803d038:	071a      	lsls	r2, r3, #28
 803d03a:	bf44      	itt	mi
 803d03c:	222b      	movmi	r2, #43	; 0x2b
 803d03e:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 803d042:	782a      	ldrb	r2, [r5, #0]
 803d044:	2a2a      	cmp	r2, #42	; 0x2a
 803d046:	d02a      	beq.n	803d09e <_vfiprintf_r+0x10e>
 803d048:	46a8      	mov	r8, r5
 803d04a:	9a07      	ldr	r2, [sp, #28]
 803d04c:	2000      	movs	r0, #0
 803d04e:	250a      	movs	r5, #10
 803d050:	4641      	mov	r1, r8
 803d052:	f811 3b01 	ldrb.w	r3, [r1], #1
 803d056:	3b30      	subs	r3, #48	; 0x30
 803d058:	2b09      	cmp	r3, #9
 803d05a:	d969      	bls.n	803d130 <_vfiprintf_r+0x1a0>
 803d05c:	b360      	cbz	r0, 803d0b8 <_vfiprintf_r+0x128>
 803d05e:	e024      	b.n	803d0aa <_vfiprintf_r+0x11a>
 803d060:	4b50      	ldr	r3, [pc, #320]	; (803d1a4 <_vfiprintf_r+0x214>)
 803d062:	429c      	cmp	r4, r3
 803d064:	d101      	bne.n	803d06a <_vfiprintf_r+0xda>
 803d066:	68b4      	ldr	r4, [r6, #8]
 803d068:	e7a2      	b.n	803cfb0 <_vfiprintf_r+0x20>
 803d06a:	4b4f      	ldr	r3, [pc, #316]	; (803d1a8 <_vfiprintf_r+0x218>)
 803d06c:	429c      	cmp	r4, r3
 803d06e:	bf08      	it	eq
 803d070:	68f4      	ldreq	r4, [r6, #12]
 803d072:	e79d      	b.n	803cfb0 <_vfiprintf_r+0x20>
 803d074:	4621      	mov	r1, r4
 803d076:	4630      	mov	r0, r6
 803d078:	f7ff fc66 	bl	803c948 <__swsetup_r>
 803d07c:	2800      	cmp	r0, #0
 803d07e:	d09d      	beq.n	803cfbc <_vfiprintf_r+0x2c>
 803d080:	f04f 30ff 	mov.w	r0, #4294967295
 803d084:	b01d      	add	sp, #116	; 0x74
 803d086:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 803d08a:	46a8      	mov	r8, r5
 803d08c:	e7a2      	b.n	803cfd4 <_vfiprintf_r+0x44>
 803d08e:	4a44      	ldr	r2, [pc, #272]	; (803d1a0 <_vfiprintf_r+0x210>)
 803d090:	4645      	mov	r5, r8
 803d092:	1a80      	subs	r0, r0, r2
 803d094:	fa0b f000 	lsl.w	r0, fp, r0
 803d098:	4318      	orrs	r0, r3
 803d09a:	9004      	str	r0, [sp, #16]
 803d09c:	e7be      	b.n	803d01c <_vfiprintf_r+0x8c>
 803d09e:	9a03      	ldr	r2, [sp, #12]
 803d0a0:	1d11      	adds	r1, r2, #4
 803d0a2:	6812      	ldr	r2, [r2, #0]
 803d0a4:	2a00      	cmp	r2, #0
 803d0a6:	9103      	str	r1, [sp, #12]
 803d0a8:	db01      	blt.n	803d0ae <_vfiprintf_r+0x11e>
 803d0aa:	9207      	str	r2, [sp, #28]
 803d0ac:	e004      	b.n	803d0b8 <_vfiprintf_r+0x128>
 803d0ae:	4252      	negs	r2, r2
 803d0b0:	f043 0302 	orr.w	r3, r3, #2
 803d0b4:	9207      	str	r2, [sp, #28]
 803d0b6:	9304      	str	r3, [sp, #16]
 803d0b8:	f898 3000 	ldrb.w	r3, [r8]
 803d0bc:	2b2e      	cmp	r3, #46	; 0x2e
 803d0be:	d10e      	bne.n	803d0de <_vfiprintf_r+0x14e>
 803d0c0:	f898 3001 	ldrb.w	r3, [r8, #1]
 803d0c4:	2b2a      	cmp	r3, #42	; 0x2a
 803d0c6:	d138      	bne.n	803d13a <_vfiprintf_r+0x1aa>
 803d0c8:	9b03      	ldr	r3, [sp, #12]
 803d0ca:	f108 0802 	add.w	r8, r8, #2
 803d0ce:	1d1a      	adds	r2, r3, #4
 803d0d0:	681b      	ldr	r3, [r3, #0]
 803d0d2:	2b00      	cmp	r3, #0
 803d0d4:	9203      	str	r2, [sp, #12]
 803d0d6:	bfb8      	it	lt
 803d0d8:	f04f 33ff 	movlt.w	r3, #4294967295
 803d0dc:	9305      	str	r3, [sp, #20]
 803d0de:	4d33      	ldr	r5, [pc, #204]	; (803d1ac <_vfiprintf_r+0x21c>)
 803d0e0:	2203      	movs	r2, #3
 803d0e2:	f898 1000 	ldrb.w	r1, [r8]
 803d0e6:	4628      	mov	r0, r5
 803d0e8:	f000 fa9c 	bl	803d624 <memchr>
 803d0ec:	b140      	cbz	r0, 803d100 <_vfiprintf_r+0x170>
 803d0ee:	2340      	movs	r3, #64	; 0x40
 803d0f0:	1b40      	subs	r0, r0, r5
 803d0f2:	f108 0801 	add.w	r8, r8, #1
 803d0f6:	fa03 f000 	lsl.w	r0, r3, r0
 803d0fa:	9b04      	ldr	r3, [sp, #16]
 803d0fc:	4303      	orrs	r3, r0
 803d0fe:	9304      	str	r3, [sp, #16]
 803d100:	f898 1000 	ldrb.w	r1, [r8]
 803d104:	2206      	movs	r2, #6
 803d106:	482a      	ldr	r0, [pc, #168]	; (803d1b0 <_vfiprintf_r+0x220>)
 803d108:	f108 0701 	add.w	r7, r8, #1
 803d10c:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 803d110:	f000 fa88 	bl	803d624 <memchr>
 803d114:	2800      	cmp	r0, #0
 803d116:	d037      	beq.n	803d188 <_vfiprintf_r+0x1f8>
 803d118:	4b26      	ldr	r3, [pc, #152]	; (803d1b4 <_vfiprintf_r+0x224>)
 803d11a:	bb1b      	cbnz	r3, 803d164 <_vfiprintf_r+0x1d4>
 803d11c:	9b03      	ldr	r3, [sp, #12]
 803d11e:	3307      	adds	r3, #7
 803d120:	f023 0307 	bic.w	r3, r3, #7
 803d124:	3308      	adds	r3, #8
 803d126:	9303      	str	r3, [sp, #12]
 803d128:	9b09      	ldr	r3, [sp, #36]	; 0x24
 803d12a:	444b      	add	r3, r9
 803d12c:	9309      	str	r3, [sp, #36]	; 0x24
 803d12e:	e750      	b.n	803cfd2 <_vfiprintf_r+0x42>
 803d130:	fb05 3202 	mla	r2, r5, r2, r3
 803d134:	2001      	movs	r0, #1
 803d136:	4688      	mov	r8, r1
 803d138:	e78a      	b.n	803d050 <_vfiprintf_r+0xc0>
 803d13a:	2300      	movs	r3, #0
 803d13c:	f108 0801 	add.w	r8, r8, #1
 803d140:	250a      	movs	r5, #10
 803d142:	4619      	mov	r1, r3
 803d144:	9305      	str	r3, [sp, #20]
 803d146:	4640      	mov	r0, r8
 803d148:	f810 2b01 	ldrb.w	r2, [r0], #1
 803d14c:	3a30      	subs	r2, #48	; 0x30
 803d14e:	2a09      	cmp	r2, #9
 803d150:	d903      	bls.n	803d15a <_vfiprintf_r+0x1ca>
 803d152:	2b00      	cmp	r3, #0
 803d154:	d0c3      	beq.n	803d0de <_vfiprintf_r+0x14e>
 803d156:	9105      	str	r1, [sp, #20]
 803d158:	e7c1      	b.n	803d0de <_vfiprintf_r+0x14e>
 803d15a:	fb05 2101 	mla	r1, r5, r1, r2
 803d15e:	2301      	movs	r3, #1
 803d160:	4680      	mov	r8, r0
 803d162:	e7f0      	b.n	803d146 <_vfiprintf_r+0x1b6>
 803d164:	ab03      	add	r3, sp, #12
 803d166:	4622      	mov	r2, r4
 803d168:	a904      	add	r1, sp, #16
 803d16a:	4630      	mov	r0, r6
 803d16c:	9300      	str	r3, [sp, #0]
 803d16e:	4b12      	ldr	r3, [pc, #72]	; (803d1b8 <_vfiprintf_r+0x228>)
 803d170:	e000      	b.n	803d174 <_vfiprintf_r+0x1e4>
 803d172:	bf00      	nop
 803d174:	f1b0 3fff 	cmp.w	r0, #4294967295
 803d178:	4681      	mov	r9, r0
 803d17a:	d1d5      	bne.n	803d128 <_vfiprintf_r+0x198>
 803d17c:	89a3      	ldrh	r3, [r4, #12]
 803d17e:	065b      	lsls	r3, r3, #25
 803d180:	f53f af7e 	bmi.w	803d080 <_vfiprintf_r+0xf0>
 803d184:	9809      	ldr	r0, [sp, #36]	; 0x24
 803d186:	e77d      	b.n	803d084 <_vfiprintf_r+0xf4>
 803d188:	ab03      	add	r3, sp, #12
 803d18a:	4622      	mov	r2, r4
 803d18c:	a904      	add	r1, sp, #16
 803d18e:	4630      	mov	r0, r6
 803d190:	9300      	str	r3, [sp, #0]
 803d192:	4b09      	ldr	r3, [pc, #36]	; (803d1b8 <_vfiprintf_r+0x228>)
 803d194:	f000 f88a 	bl	803d2ac <_printf_i>
 803d198:	e7ec      	b.n	803d174 <_vfiprintf_r+0x1e4>
 803d19a:	bf00      	nop
 803d19c:	0803f114 	.word	0x0803f114
 803d1a0:	0803f154 	.word	0x0803f154
 803d1a4:	0803f134 	.word	0x0803f134
 803d1a8:	0803f0f4 	.word	0x0803f0f4
 803d1ac:	0803f15a 	.word	0x0803f15a
 803d1b0:	0803f15e 	.word	0x0803f15e
 803d1b4:	00000000 	.word	0x00000000
 803d1b8:	0803cf6b 	.word	0x0803cf6b

0803d1bc <_printf_common>:
 803d1bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 803d1c0:	4691      	mov	r9, r2
 803d1c2:	461f      	mov	r7, r3
 803d1c4:	688a      	ldr	r2, [r1, #8]
 803d1c6:	4606      	mov	r6, r0
 803d1c8:	690b      	ldr	r3, [r1, #16]
 803d1ca:	460c      	mov	r4, r1
 803d1cc:	f8dd 8020 	ldr.w	r8, [sp, #32]
 803d1d0:	4293      	cmp	r3, r2
 803d1d2:	bfb8      	it	lt
 803d1d4:	4613      	movlt	r3, r2
 803d1d6:	f8c9 3000 	str.w	r3, [r9]
 803d1da:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 803d1de:	b112      	cbz	r2, 803d1e6 <_printf_common+0x2a>
 803d1e0:	3301      	adds	r3, #1
 803d1e2:	f8c9 3000 	str.w	r3, [r9]
 803d1e6:	6823      	ldr	r3, [r4, #0]
 803d1e8:	0699      	lsls	r1, r3, #26
 803d1ea:	bf42      	ittt	mi
 803d1ec:	f8d9 3000 	ldrmi.w	r3, [r9]
 803d1f0:	3302      	addmi	r3, #2
 803d1f2:	f8c9 3000 	strmi.w	r3, [r9]
 803d1f6:	6825      	ldr	r5, [r4, #0]
 803d1f8:	f015 0506 	ands.w	r5, r5, #6
 803d1fc:	d107      	bne.n	803d20e <_printf_common+0x52>
 803d1fe:	f104 0a19 	add.w	sl, r4, #25
 803d202:	68e3      	ldr	r3, [r4, #12]
 803d204:	f8d9 2000 	ldr.w	r2, [r9]
 803d208:	1a9b      	subs	r3, r3, r2
 803d20a:	42ab      	cmp	r3, r5
 803d20c:	dc2b      	bgt.n	803d266 <_printf_common+0xaa>
 803d20e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 803d212:	6822      	ldr	r2, [r4, #0]
 803d214:	3300      	adds	r3, #0
 803d216:	bf18      	it	ne
 803d218:	2301      	movne	r3, #1
 803d21a:	0692      	lsls	r2, r2, #26
 803d21c:	d430      	bmi.n	803d280 <_printf_common+0xc4>
 803d21e:	f104 0243 	add.w	r2, r4, #67	; 0x43
 803d222:	4639      	mov	r1, r7
 803d224:	4630      	mov	r0, r6
 803d226:	47c0      	blx	r8
 803d228:	3001      	adds	r0, #1
 803d22a:	d023      	beq.n	803d274 <_printf_common+0xb8>
 803d22c:	6823      	ldr	r3, [r4, #0]
 803d22e:	341a      	adds	r4, #26
 803d230:	f854 5c0e 	ldr.w	r5, [r4, #-14]
 803d234:	f003 0306 	and.w	r3, r3, #6
 803d238:	f8d9 2000 	ldr.w	r2, [r9]
 803d23c:	f04f 0900 	mov.w	r9, #0
 803d240:	2b04      	cmp	r3, #4
 803d242:	f854 3c12 	ldr.w	r3, [r4, #-18]
 803d246:	bf08      	it	eq
 803d248:	1aad      	subeq	r5, r5, r2
 803d24a:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 803d24e:	bf14      	ite	ne
 803d250:	2500      	movne	r5, #0
 803d252:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 803d256:	4293      	cmp	r3, r2
 803d258:	bfc4      	itt	gt
 803d25a:	1a9b      	subgt	r3, r3, r2
 803d25c:	18ed      	addgt	r5, r5, r3
 803d25e:	454d      	cmp	r5, r9
 803d260:	d11a      	bne.n	803d298 <_printf_common+0xdc>
 803d262:	2000      	movs	r0, #0
 803d264:	e008      	b.n	803d278 <_printf_common+0xbc>
 803d266:	2301      	movs	r3, #1
 803d268:	4652      	mov	r2, sl
 803d26a:	4639      	mov	r1, r7
 803d26c:	4630      	mov	r0, r6
 803d26e:	47c0      	blx	r8
 803d270:	3001      	adds	r0, #1
 803d272:	d103      	bne.n	803d27c <_printf_common+0xc0>
 803d274:	f04f 30ff 	mov.w	r0, #4294967295
 803d278:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 803d27c:	3501      	adds	r5, #1
 803d27e:	e7c0      	b.n	803d202 <_printf_common+0x46>
 803d280:	18e1      	adds	r1, r4, r3
 803d282:	1c5a      	adds	r2, r3, #1
 803d284:	2030      	movs	r0, #48	; 0x30
 803d286:	3302      	adds	r3, #2
 803d288:	4422      	add	r2, r4
 803d28a:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 803d28e:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 803d292:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 803d296:	e7c2      	b.n	803d21e <_printf_common+0x62>
 803d298:	2301      	movs	r3, #1
 803d29a:	4622      	mov	r2, r4
 803d29c:	4639      	mov	r1, r7
 803d29e:	4630      	mov	r0, r6
 803d2a0:	47c0      	blx	r8
 803d2a2:	3001      	adds	r0, #1
 803d2a4:	d0e6      	beq.n	803d274 <_printf_common+0xb8>
 803d2a6:	f109 0901 	add.w	r9, r9, #1
 803d2aa:	e7d8      	b.n	803d25e <_printf_common+0xa2>

0803d2ac <_printf_i>:
 803d2ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 803d2b0:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 803d2b4:	460c      	mov	r4, r1
 803d2b6:	7e09      	ldrb	r1, [r1, #24]
 803d2b8:	b085      	sub	sp, #20
 803d2ba:	4617      	mov	r7, r2
 803d2bc:	4606      	mov	r6, r0
 803d2be:	296e      	cmp	r1, #110	; 0x6e
 803d2c0:	4698      	mov	r8, r3
 803d2c2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 803d2c4:	f000 80b3 	beq.w	803d42e <_printf_i+0x182>
 803d2c8:	d822      	bhi.n	803d310 <_printf_i+0x64>
 803d2ca:	2963      	cmp	r1, #99	; 0x63
 803d2cc:	d036      	beq.n	803d33c <_printf_i+0x90>
 803d2ce:	d80a      	bhi.n	803d2e6 <_printf_i+0x3a>
 803d2d0:	2900      	cmp	r1, #0
 803d2d2:	f000 80b9 	beq.w	803d448 <_printf_i+0x19c>
 803d2d6:	2958      	cmp	r1, #88	; 0x58
 803d2d8:	f000 8083 	beq.w	803d3e2 <_printf_i+0x136>
 803d2dc:	f104 0542 	add.w	r5, r4, #66	; 0x42
 803d2e0:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 803d2e4:	e032      	b.n	803d34c <_printf_i+0xa0>
 803d2e6:	2964      	cmp	r1, #100	; 0x64
 803d2e8:	d001      	beq.n	803d2ee <_printf_i+0x42>
 803d2ea:	2969      	cmp	r1, #105	; 0x69
 803d2ec:	d1f6      	bne.n	803d2dc <_printf_i+0x30>
 803d2ee:	6820      	ldr	r0, [r4, #0]
 803d2f0:	6813      	ldr	r3, [r2, #0]
 803d2f2:	0605      	lsls	r5, r0, #24
 803d2f4:	f103 0104 	add.w	r1, r3, #4
 803d2f8:	d52a      	bpl.n	803d350 <_printf_i+0xa4>
 803d2fa:	681b      	ldr	r3, [r3, #0]
 803d2fc:	6011      	str	r1, [r2, #0]
 803d2fe:	2b00      	cmp	r3, #0
 803d300:	da03      	bge.n	803d30a <_printf_i+0x5e>
 803d302:	222d      	movs	r2, #45	; 0x2d
 803d304:	425b      	negs	r3, r3
 803d306:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 803d30a:	486f      	ldr	r0, [pc, #444]	; (803d4c8 <_printf_i+0x21c>)
 803d30c:	220a      	movs	r2, #10
 803d30e:	e039      	b.n	803d384 <_printf_i+0xd8>
 803d310:	2973      	cmp	r1, #115	; 0x73
 803d312:	f000 809d 	beq.w	803d450 <_printf_i+0x1a4>
 803d316:	d808      	bhi.n	803d32a <_printf_i+0x7e>
 803d318:	296f      	cmp	r1, #111	; 0x6f
 803d31a:	d020      	beq.n	803d35e <_printf_i+0xb2>
 803d31c:	2970      	cmp	r1, #112	; 0x70
 803d31e:	d1dd      	bne.n	803d2dc <_printf_i+0x30>
 803d320:	6823      	ldr	r3, [r4, #0]
 803d322:	f043 0320 	orr.w	r3, r3, #32
 803d326:	6023      	str	r3, [r4, #0]
 803d328:	e003      	b.n	803d332 <_printf_i+0x86>
 803d32a:	2975      	cmp	r1, #117	; 0x75
 803d32c:	d017      	beq.n	803d35e <_printf_i+0xb2>
 803d32e:	2978      	cmp	r1, #120	; 0x78
 803d330:	d1d4      	bne.n	803d2dc <_printf_i+0x30>
 803d332:	2378      	movs	r3, #120	; 0x78
 803d334:	4865      	ldr	r0, [pc, #404]	; (803d4cc <_printf_i+0x220>)
 803d336:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 803d33a:	e055      	b.n	803d3e8 <_printf_i+0x13c>
 803d33c:	6813      	ldr	r3, [r2, #0]
 803d33e:	f104 0542 	add.w	r5, r4, #66	; 0x42
 803d342:	1d19      	adds	r1, r3, #4
 803d344:	681b      	ldr	r3, [r3, #0]
 803d346:	6011      	str	r1, [r2, #0]
 803d348:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 803d34c:	2301      	movs	r3, #1
 803d34e:	e08c      	b.n	803d46a <_printf_i+0x1be>
 803d350:	681b      	ldr	r3, [r3, #0]
 803d352:	f010 0f40 	tst.w	r0, #64	; 0x40
 803d356:	6011      	str	r1, [r2, #0]
 803d358:	bf18      	it	ne
 803d35a:	b21b      	sxthne	r3, r3
 803d35c:	e7cf      	b.n	803d2fe <_printf_i+0x52>
 803d35e:	6813      	ldr	r3, [r2, #0]
 803d360:	6825      	ldr	r5, [r4, #0]
 803d362:	1d18      	adds	r0, r3, #4
 803d364:	6010      	str	r0, [r2, #0]
 803d366:	0628      	lsls	r0, r5, #24
 803d368:	d501      	bpl.n	803d36e <_printf_i+0xc2>
 803d36a:	681b      	ldr	r3, [r3, #0]
 803d36c:	e002      	b.n	803d374 <_printf_i+0xc8>
 803d36e:	0668      	lsls	r0, r5, #25
 803d370:	d5fb      	bpl.n	803d36a <_printf_i+0xbe>
 803d372:	881b      	ldrh	r3, [r3, #0]
 803d374:	296f      	cmp	r1, #111	; 0x6f
 803d376:	4854      	ldr	r0, [pc, #336]	; (803d4c8 <_printf_i+0x21c>)
 803d378:	bf14      	ite	ne
 803d37a:	220a      	movne	r2, #10
 803d37c:	2208      	moveq	r2, #8
 803d37e:	2100      	movs	r1, #0
 803d380:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 803d384:	6865      	ldr	r5, [r4, #4]
 803d386:	2d00      	cmp	r5, #0
 803d388:	60a5      	str	r5, [r4, #8]
 803d38a:	f2c0 8095 	blt.w	803d4b8 <_printf_i+0x20c>
 803d38e:	6821      	ldr	r1, [r4, #0]
 803d390:	f021 0104 	bic.w	r1, r1, #4
 803d394:	6021      	str	r1, [r4, #0]
 803d396:	2b00      	cmp	r3, #0
 803d398:	d13d      	bne.n	803d416 <_printf_i+0x16a>
 803d39a:	2d00      	cmp	r5, #0
 803d39c:	f040 808e 	bne.w	803d4bc <_printf_i+0x210>
 803d3a0:	4665      	mov	r5, ip
 803d3a2:	2a08      	cmp	r2, #8
 803d3a4:	d10b      	bne.n	803d3be <_printf_i+0x112>
 803d3a6:	6823      	ldr	r3, [r4, #0]
 803d3a8:	07db      	lsls	r3, r3, #31
 803d3aa:	d508      	bpl.n	803d3be <_printf_i+0x112>
 803d3ac:	6923      	ldr	r3, [r4, #16]
 803d3ae:	6862      	ldr	r2, [r4, #4]
 803d3b0:	429a      	cmp	r2, r3
 803d3b2:	bfde      	ittt	le
 803d3b4:	2330      	movle	r3, #48	; 0x30
 803d3b6:	f805 3c01 	strble.w	r3, [r5, #-1]
 803d3ba:	f105 35ff 	addle.w	r5, r5, #4294967295
 803d3be:	ebac 0305 	sub.w	r3, ip, r5
 803d3c2:	6123      	str	r3, [r4, #16]
 803d3c4:	f8cd 8000 	str.w	r8, [sp]
 803d3c8:	463b      	mov	r3, r7
 803d3ca:	aa03      	add	r2, sp, #12
 803d3cc:	4621      	mov	r1, r4
 803d3ce:	4630      	mov	r0, r6
 803d3d0:	f7ff fef4 	bl	803d1bc <_printf_common>
 803d3d4:	3001      	adds	r0, #1
 803d3d6:	d14d      	bne.n	803d474 <_printf_i+0x1c8>
 803d3d8:	f04f 30ff 	mov.w	r0, #4294967295
 803d3dc:	b005      	add	sp, #20
 803d3de:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 803d3e2:	4839      	ldr	r0, [pc, #228]	; (803d4c8 <_printf_i+0x21c>)
 803d3e4:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 803d3e8:	6813      	ldr	r3, [r2, #0]
 803d3ea:	6821      	ldr	r1, [r4, #0]
 803d3ec:	1d1d      	adds	r5, r3, #4
 803d3ee:	681b      	ldr	r3, [r3, #0]
 803d3f0:	6015      	str	r5, [r2, #0]
 803d3f2:	060a      	lsls	r2, r1, #24
 803d3f4:	d50b      	bpl.n	803d40e <_printf_i+0x162>
 803d3f6:	07ca      	lsls	r2, r1, #31
 803d3f8:	bf44      	itt	mi
 803d3fa:	f041 0120 	orrmi.w	r1, r1, #32
 803d3fe:	6021      	strmi	r1, [r4, #0]
 803d400:	b91b      	cbnz	r3, 803d40a <_printf_i+0x15e>
 803d402:	6822      	ldr	r2, [r4, #0]
 803d404:	f022 0220 	bic.w	r2, r2, #32
 803d408:	6022      	str	r2, [r4, #0]
 803d40a:	2210      	movs	r2, #16
 803d40c:	e7b7      	b.n	803d37e <_printf_i+0xd2>
 803d40e:	064d      	lsls	r5, r1, #25
 803d410:	bf48      	it	mi
 803d412:	b29b      	uxthmi	r3, r3
 803d414:	e7ef      	b.n	803d3f6 <_printf_i+0x14a>
 803d416:	4665      	mov	r5, ip
 803d418:	fbb3 f1f2 	udiv	r1, r3, r2
 803d41c:	fb02 3311 	mls	r3, r2, r1, r3
 803d420:	5cc3      	ldrb	r3, [r0, r3]
 803d422:	f805 3d01 	strb.w	r3, [r5, #-1]!
 803d426:	460b      	mov	r3, r1
 803d428:	2900      	cmp	r1, #0
 803d42a:	d1f5      	bne.n	803d418 <_printf_i+0x16c>
 803d42c:	e7b9      	b.n	803d3a2 <_printf_i+0xf6>
 803d42e:	6813      	ldr	r3, [r2, #0]
 803d430:	6825      	ldr	r5, [r4, #0]
 803d432:	1d18      	adds	r0, r3, #4
 803d434:	6961      	ldr	r1, [r4, #20]
 803d436:	6010      	str	r0, [r2, #0]
 803d438:	0628      	lsls	r0, r5, #24
 803d43a:	681b      	ldr	r3, [r3, #0]
 803d43c:	d501      	bpl.n	803d442 <_printf_i+0x196>
 803d43e:	6019      	str	r1, [r3, #0]
 803d440:	e002      	b.n	803d448 <_printf_i+0x19c>
 803d442:	066a      	lsls	r2, r5, #25
 803d444:	d5fb      	bpl.n	803d43e <_printf_i+0x192>
 803d446:	8019      	strh	r1, [r3, #0]
 803d448:	2300      	movs	r3, #0
 803d44a:	4665      	mov	r5, ip
 803d44c:	6123      	str	r3, [r4, #16]
 803d44e:	e7b9      	b.n	803d3c4 <_printf_i+0x118>
 803d450:	6813      	ldr	r3, [r2, #0]
 803d452:	1d19      	adds	r1, r3, #4
 803d454:	6011      	str	r1, [r2, #0]
 803d456:	2100      	movs	r1, #0
 803d458:	681d      	ldr	r5, [r3, #0]
 803d45a:	6862      	ldr	r2, [r4, #4]
 803d45c:	4628      	mov	r0, r5
 803d45e:	f000 f8e1 	bl	803d624 <memchr>
 803d462:	b108      	cbz	r0, 803d468 <_printf_i+0x1bc>
 803d464:	1b40      	subs	r0, r0, r5
 803d466:	6060      	str	r0, [r4, #4]
 803d468:	6863      	ldr	r3, [r4, #4]
 803d46a:	6123      	str	r3, [r4, #16]
 803d46c:	2300      	movs	r3, #0
 803d46e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 803d472:	e7a7      	b.n	803d3c4 <_printf_i+0x118>
 803d474:	6923      	ldr	r3, [r4, #16]
 803d476:	462a      	mov	r2, r5
 803d478:	4639      	mov	r1, r7
 803d47a:	4630      	mov	r0, r6
 803d47c:	47c0      	blx	r8
 803d47e:	3001      	adds	r0, #1
 803d480:	d0aa      	beq.n	803d3d8 <_printf_i+0x12c>
 803d482:	6823      	ldr	r3, [r4, #0]
 803d484:	079b      	lsls	r3, r3, #30
 803d486:	d413      	bmi.n	803d4b0 <_printf_i+0x204>
 803d488:	68e0      	ldr	r0, [r4, #12]
 803d48a:	9b03      	ldr	r3, [sp, #12]
 803d48c:	4298      	cmp	r0, r3
 803d48e:	bfb8      	it	lt
 803d490:	4618      	movlt	r0, r3
 803d492:	e7a3      	b.n	803d3dc <_printf_i+0x130>
 803d494:	2301      	movs	r3, #1
 803d496:	464a      	mov	r2, r9
 803d498:	4639      	mov	r1, r7
 803d49a:	4630      	mov	r0, r6
 803d49c:	47c0      	blx	r8
 803d49e:	3001      	adds	r0, #1
 803d4a0:	d09a      	beq.n	803d3d8 <_printf_i+0x12c>
 803d4a2:	3501      	adds	r5, #1
 803d4a4:	68e3      	ldr	r3, [r4, #12]
 803d4a6:	9a03      	ldr	r2, [sp, #12]
 803d4a8:	1a9b      	subs	r3, r3, r2
 803d4aa:	42ab      	cmp	r3, r5
 803d4ac:	dcf2      	bgt.n	803d494 <_printf_i+0x1e8>
 803d4ae:	e7eb      	b.n	803d488 <_printf_i+0x1dc>
 803d4b0:	2500      	movs	r5, #0
 803d4b2:	f104 0919 	add.w	r9, r4, #25
 803d4b6:	e7f5      	b.n	803d4a4 <_printf_i+0x1f8>
 803d4b8:	2b00      	cmp	r3, #0
 803d4ba:	d1ac      	bne.n	803d416 <_printf_i+0x16a>
 803d4bc:	7803      	ldrb	r3, [r0, #0]
 803d4be:	f104 0542 	add.w	r5, r4, #66	; 0x42
 803d4c2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 803d4c6:	e76c      	b.n	803d3a2 <_printf_i+0xf6>
 803d4c8:	0803f165 	.word	0x0803f165
 803d4cc:	0803f176 	.word	0x0803f176

0803d4d0 <_sbrk_r>:
 803d4d0:	b538      	push	{r3, r4, r5, lr}
 803d4d2:	2300      	movs	r3, #0
 803d4d4:	4c05      	ldr	r4, [pc, #20]	; (803d4ec <_sbrk_r+0x1c>)
 803d4d6:	4605      	mov	r5, r0
 803d4d8:	4608      	mov	r0, r1
 803d4da:	6023      	str	r3, [r4, #0]
 803d4dc:	f000 fa76 	bl	803d9cc <_sbrk>
 803d4e0:	1c43      	adds	r3, r0, #1
 803d4e2:	d102      	bne.n	803d4ea <_sbrk_r+0x1a>
 803d4e4:	6823      	ldr	r3, [r4, #0]
 803d4e6:	b103      	cbz	r3, 803d4ea <_sbrk_r+0x1a>
 803d4e8:	602b      	str	r3, [r5, #0]
 803d4ea:	bd38      	pop	{r3, r4, r5, pc}
 803d4ec:	200006d0 	.word	0x200006d0

0803d4f0 <__sread>:
 803d4f0:	b510      	push	{r4, lr}
 803d4f2:	460c      	mov	r4, r1
 803d4f4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 803d4f8:	f000 f8a4 	bl	803d644 <_read_r>
 803d4fc:	2800      	cmp	r0, #0
 803d4fe:	bfab      	itete	ge
 803d500:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 803d502:	89a3      	ldrhlt	r3, [r4, #12]
 803d504:	181b      	addge	r3, r3, r0
 803d506:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 803d50a:	bfac      	ite	ge
 803d50c:	6563      	strge	r3, [r4, #84]	; 0x54
 803d50e:	81a3      	strhlt	r3, [r4, #12]
 803d510:	bd10      	pop	{r4, pc}

0803d512 <__swrite>:
 803d512:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 803d516:	461f      	mov	r7, r3
 803d518:	898b      	ldrh	r3, [r1, #12]
 803d51a:	4605      	mov	r5, r0
 803d51c:	460c      	mov	r4, r1
 803d51e:	05db      	lsls	r3, r3, #23
 803d520:	4616      	mov	r6, r2
 803d522:	d505      	bpl.n	803d530 <__swrite+0x1e>
 803d524:	2302      	movs	r3, #2
 803d526:	2200      	movs	r2, #0
 803d528:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 803d52c:	f000 f868 	bl	803d600 <_lseek_r>
 803d530:	89a3      	ldrh	r3, [r4, #12]
 803d532:	4632      	mov	r2, r6
 803d534:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 803d538:	4628      	mov	r0, r5
 803d53a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 803d53e:	81a3      	strh	r3, [r4, #12]
 803d540:	463b      	mov	r3, r7
 803d542:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 803d546:	f000 b817 	b.w	803d578 <_write_r>

0803d54a <__sseek>:
 803d54a:	b510      	push	{r4, lr}
 803d54c:	460c      	mov	r4, r1
 803d54e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 803d552:	f000 f855 	bl	803d600 <_lseek_r>
 803d556:	1c43      	adds	r3, r0, #1
 803d558:	89a3      	ldrh	r3, [r4, #12]
 803d55a:	bf15      	itete	ne
 803d55c:	6560      	strne	r0, [r4, #84]	; 0x54
 803d55e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 803d562:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 803d566:	81a3      	strheq	r3, [r4, #12]
 803d568:	bf18      	it	ne
 803d56a:	81a3      	strhne	r3, [r4, #12]
 803d56c:	bd10      	pop	{r4, pc}

0803d56e <__sclose>:
 803d56e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 803d572:	f000 b813 	b.w	803d59c <_close_r>
	...

0803d578 <_write_r>:
 803d578:	b538      	push	{r3, r4, r5, lr}
 803d57a:	4605      	mov	r5, r0
 803d57c:	4c06      	ldr	r4, [pc, #24]	; (803d598 <_write_r+0x20>)
 803d57e:	4608      	mov	r0, r1
 803d580:	4611      	mov	r1, r2
 803d582:	2200      	movs	r2, #0
 803d584:	6022      	str	r2, [r4, #0]
 803d586:	461a      	mov	r2, r3
 803d588:	f7fb fcb0 	bl	8038eec <_write>
 803d58c:	1c43      	adds	r3, r0, #1
 803d58e:	d102      	bne.n	803d596 <_write_r+0x1e>
 803d590:	6823      	ldr	r3, [r4, #0]
 803d592:	b103      	cbz	r3, 803d596 <_write_r+0x1e>
 803d594:	602b      	str	r3, [r5, #0]
 803d596:	bd38      	pop	{r3, r4, r5, pc}
 803d598:	200006d0 	.word	0x200006d0

0803d59c <_close_r>:
 803d59c:	b538      	push	{r3, r4, r5, lr}
 803d59e:	2300      	movs	r3, #0
 803d5a0:	4c05      	ldr	r4, [pc, #20]	; (803d5b8 <_close_r+0x1c>)
 803d5a2:	4605      	mov	r5, r0
 803d5a4:	4608      	mov	r0, r1
 803d5a6:	6023      	str	r3, [r4, #0]
 803d5a8:	f000 f9e8 	bl	803d97c <_close>
 803d5ac:	1c43      	adds	r3, r0, #1
 803d5ae:	d102      	bne.n	803d5b6 <_close_r+0x1a>
 803d5b0:	6823      	ldr	r3, [r4, #0]
 803d5b2:	b103      	cbz	r3, 803d5b6 <_close_r+0x1a>
 803d5b4:	602b      	str	r3, [r5, #0]
 803d5b6:	bd38      	pop	{r3, r4, r5, pc}
 803d5b8:	200006d0 	.word	0x200006d0

0803d5bc <_fstat_r>:
 803d5bc:	b538      	push	{r3, r4, r5, lr}
 803d5be:	2300      	movs	r3, #0
 803d5c0:	4c06      	ldr	r4, [pc, #24]	; (803d5dc <_fstat_r+0x20>)
 803d5c2:	4605      	mov	r5, r0
 803d5c4:	4608      	mov	r0, r1
 803d5c6:	4611      	mov	r1, r2
 803d5c8:	6023      	str	r3, [r4, #0]
 803d5ca:	f000 f9df 	bl	803d98c <_fstat>
 803d5ce:	1c43      	adds	r3, r0, #1
 803d5d0:	d102      	bne.n	803d5d8 <_fstat_r+0x1c>
 803d5d2:	6823      	ldr	r3, [r4, #0]
 803d5d4:	b103      	cbz	r3, 803d5d8 <_fstat_r+0x1c>
 803d5d6:	602b      	str	r3, [r5, #0]
 803d5d8:	bd38      	pop	{r3, r4, r5, pc}
 803d5da:	bf00      	nop
 803d5dc:	200006d0 	.word	0x200006d0

0803d5e0 <_isatty_r>:
 803d5e0:	b538      	push	{r3, r4, r5, lr}
 803d5e2:	2300      	movs	r3, #0
 803d5e4:	4c05      	ldr	r4, [pc, #20]	; (803d5fc <_isatty_r+0x1c>)
 803d5e6:	4605      	mov	r5, r0
 803d5e8:	4608      	mov	r0, r1
 803d5ea:	6023      	str	r3, [r4, #0]
 803d5ec:	f000 f9d6 	bl	803d99c <_isatty>
 803d5f0:	1c43      	adds	r3, r0, #1
 803d5f2:	d102      	bne.n	803d5fa <_isatty_r+0x1a>
 803d5f4:	6823      	ldr	r3, [r4, #0]
 803d5f6:	b103      	cbz	r3, 803d5fa <_isatty_r+0x1a>
 803d5f8:	602b      	str	r3, [r5, #0]
 803d5fa:	bd38      	pop	{r3, r4, r5, pc}
 803d5fc:	200006d0 	.word	0x200006d0

0803d600 <_lseek_r>:
 803d600:	b538      	push	{r3, r4, r5, lr}
 803d602:	4605      	mov	r5, r0
 803d604:	4c06      	ldr	r4, [pc, #24]	; (803d620 <_lseek_r+0x20>)
 803d606:	4608      	mov	r0, r1
 803d608:	4611      	mov	r1, r2
 803d60a:	2200      	movs	r2, #0
 803d60c:	6022      	str	r2, [r4, #0]
 803d60e:	461a      	mov	r2, r3
 803d610:	f000 f9cc 	bl	803d9ac <_lseek>
 803d614:	1c43      	adds	r3, r0, #1
 803d616:	d102      	bne.n	803d61e <_lseek_r+0x1e>
 803d618:	6823      	ldr	r3, [r4, #0]
 803d61a:	b103      	cbz	r3, 803d61e <_lseek_r+0x1e>
 803d61c:	602b      	str	r3, [r5, #0]
 803d61e:	bd38      	pop	{r3, r4, r5, pc}
 803d620:	200006d0 	.word	0x200006d0

0803d624 <memchr>:
 803d624:	b2c9      	uxtb	r1, r1
 803d626:	4402      	add	r2, r0
 803d628:	b510      	push	{r4, lr}
 803d62a:	4290      	cmp	r0, r2
 803d62c:	4603      	mov	r3, r0
 803d62e:	d101      	bne.n	803d634 <memchr+0x10>
 803d630:	2300      	movs	r3, #0
 803d632:	e003      	b.n	803d63c <memchr+0x18>
 803d634:	781c      	ldrb	r4, [r3, #0]
 803d636:	3001      	adds	r0, #1
 803d638:	428c      	cmp	r4, r1
 803d63a:	d1f6      	bne.n	803d62a <memchr+0x6>
 803d63c:	4618      	mov	r0, r3
 803d63e:	bd10      	pop	{r4, pc}

0803d640 <__malloc_lock>:
 803d640:	4770      	bx	lr

0803d642 <__malloc_unlock>:
 803d642:	4770      	bx	lr

0803d644 <_read_r>:
 803d644:	b538      	push	{r3, r4, r5, lr}
 803d646:	4605      	mov	r5, r0
 803d648:	4c06      	ldr	r4, [pc, #24]	; (803d664 <_read_r+0x20>)
 803d64a:	4608      	mov	r0, r1
 803d64c:	4611      	mov	r1, r2
 803d64e:	2200      	movs	r2, #0
 803d650:	6022      	str	r2, [r4, #0]
 803d652:	461a      	mov	r2, r3
 803d654:	f000 f9b2 	bl	803d9bc <_read>
 803d658:	1c43      	adds	r3, r0, #1
 803d65a:	d102      	bne.n	803d662 <_read_r+0x1e>
 803d65c:	6823      	ldr	r3, [r4, #0]
 803d65e:	b103      	cbz	r3, 803d662 <_read_r+0x1e>
 803d660:	602b      	str	r3, [r5, #0]
 803d662:	bd38      	pop	{r3, r4, r5, pc}
 803d664:	200006d0 	.word	0x200006d0

0803d668 <__aeabi_uldivmod>:
 803d668:	b953      	cbnz	r3, 803d680 <__aeabi_uldivmod+0x18>
 803d66a:	b94a      	cbnz	r2, 803d680 <__aeabi_uldivmod+0x18>
 803d66c:	2900      	cmp	r1, #0
 803d66e:	bf08      	it	eq
 803d670:	2800      	cmpeq	r0, #0
 803d672:	bf1c      	itt	ne
 803d674:	f04f 31ff 	movne.w	r1, #4294967295
 803d678:	f04f 30ff 	movne.w	r0, #4294967295
 803d67c:	f000 b97c 	b.w	803d978 <__aeabi_idiv0>
 803d680:	f1ad 0c08 	sub.w	ip, sp, #8
 803d684:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 803d688:	f000 f806 	bl	803d698 <__udivmoddi4>
 803d68c:	f8dd e004 	ldr.w	lr, [sp, #4]
 803d690:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 803d694:	b004      	add	sp, #16
 803d696:	4770      	bx	lr

0803d698 <__udivmoddi4>:
 803d698:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 803d69c:	468c      	mov	ip, r1
 803d69e:	9d08      	ldr	r5, [sp, #32]
 803d6a0:	4604      	mov	r4, r0
 803d6a2:	468a      	mov	sl, r1
 803d6a4:	2b00      	cmp	r3, #0
 803d6a6:	d14a      	bne.n	803d73e <__udivmoddi4+0xa6>
 803d6a8:	428a      	cmp	r2, r1
 803d6aa:	4617      	mov	r7, r2
 803d6ac:	d962      	bls.n	803d774 <__udivmoddi4+0xdc>
 803d6ae:	fab2 f682 	clz	r6, r2
 803d6b2:	b14e      	cbz	r6, 803d6c8 <__udivmoddi4+0x30>
 803d6b4:	f1c6 0e20 	rsb	lr, r6, #32
 803d6b8:	fa01 f306 	lsl.w	r3, r1, r6
 803d6bc:	40b7      	lsls	r7, r6
 803d6be:	40b4      	lsls	r4, r6
 803d6c0:	fa20 fe0e 	lsr.w	lr, r0, lr
 803d6c4:	ea4e 0a03 	orr.w	sl, lr, r3
 803d6c8:	ea4f 4817 	mov.w	r8, r7, lsr #16
 803d6cc:	0c23      	lsrs	r3, r4, #16
 803d6ce:	fa1f f987 	uxth.w	r9, r7
 803d6d2:	fbba fef8 	udiv	lr, sl, r8
 803d6d6:	fb08 aa1e 	mls	sl, r8, lr, sl
 803d6da:	fb0e f209 	mul.w	r2, lr, r9
 803d6de:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
 803d6e2:	429a      	cmp	r2, r3
 803d6e4:	d90b      	bls.n	803d6fe <__udivmoddi4+0x66>
 803d6e6:	18fb      	adds	r3, r7, r3
 803d6e8:	f10e 31ff 	add.w	r1, lr, #4294967295
 803d6ec:	bf2c      	ite	cs
 803d6ee:	2001      	movcs	r0, #1
 803d6f0:	2000      	movcc	r0, #0
 803d6f2:	429a      	cmp	r2, r3
 803d6f4:	d902      	bls.n	803d6fc <__udivmoddi4+0x64>
 803d6f6:	2800      	cmp	r0, #0
 803d6f8:	f000 812a 	beq.w	803d950 <__udivmoddi4+0x2b8>
 803d6fc:	468e      	mov	lr, r1
 803d6fe:	1a9a      	subs	r2, r3, r2
 803d700:	b2a3      	uxth	r3, r4
 803d702:	fbb2 f0f8 	udiv	r0, r2, r8
 803d706:	fb08 2210 	mls	r2, r8, r0, r2
 803d70a:	fb00 f909 	mul.w	r9, r0, r9
 803d70e:	ea43 4402 	orr.w	r4, r3, r2, lsl #16
 803d712:	45a1      	cmp	r9, r4
 803d714:	d907      	bls.n	803d726 <__udivmoddi4+0x8e>
 803d716:	193c      	adds	r4, r7, r4
 803d718:	f100 33ff 	add.w	r3, r0, #4294967295
 803d71c:	d202      	bcs.n	803d724 <__udivmoddi4+0x8c>
 803d71e:	45a1      	cmp	r9, r4
 803d720:	f200 8110 	bhi.w	803d944 <__udivmoddi4+0x2ac>
 803d724:	4618      	mov	r0, r3
 803d726:	eba4 0409 	sub.w	r4, r4, r9
 803d72a:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
 803d72e:	2100      	movs	r1, #0
 803d730:	b11d      	cbz	r5, 803d73a <__udivmoddi4+0xa2>
 803d732:	40f4      	lsrs	r4, r6
 803d734:	2300      	movs	r3, #0
 803d736:	e9c5 4300 	strd	r4, r3, [r5]
 803d73a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 803d73e:	428b      	cmp	r3, r1
 803d740:	d908      	bls.n	803d754 <__udivmoddi4+0xbc>
 803d742:	2d00      	cmp	r5, #0
 803d744:	f000 80f2 	beq.w	803d92c <__udivmoddi4+0x294>
 803d748:	2100      	movs	r1, #0
 803d74a:	e9c5 0c00 	strd	r0, ip, [r5]
 803d74e:	4608      	mov	r0, r1
 803d750:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 803d754:	fab3 f183 	clz	r1, r3
 803d758:	2900      	cmp	r1, #0
 803d75a:	d14e      	bne.n	803d7fa <__udivmoddi4+0x162>
 803d75c:	4563      	cmp	r3, ip
 803d75e:	f0c0 80e8 	bcc.w	803d932 <__udivmoddi4+0x29a>
 803d762:	4282      	cmp	r2, r0
 803d764:	f240 80e5 	bls.w	803d932 <__udivmoddi4+0x29a>
 803d768:	4608      	mov	r0, r1
 803d76a:	2d00      	cmp	r5, #0
 803d76c:	d0e5      	beq.n	803d73a <__udivmoddi4+0xa2>
 803d76e:	e9c5 4a00 	strd	r4, sl, [r5]
 803d772:	e7e2      	b.n	803d73a <__udivmoddi4+0xa2>
 803d774:	b902      	cbnz	r2, 803d778 <__udivmoddi4+0xe0>
 803d776:	deff      	udf	#255	; 0xff
 803d778:	fab2 f682 	clz	r6, r2
 803d77c:	2e00      	cmp	r6, #0
 803d77e:	f040 8099 	bne.w	803d8b4 <__udivmoddi4+0x21c>
 803d782:	1a8b      	subs	r3, r1, r2
 803d784:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 803d788:	fa1f f882 	uxth.w	r8, r2
 803d78c:	2101      	movs	r1, #1
 803d78e:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 803d792:	fbb3 f2fe 	udiv	r2, r3, lr
 803d796:	fb0e 3012 	mls	r0, lr, r2, r3
 803d79a:	fb08 f902 	mul.w	r9, r8, r2
 803d79e:	ea4c 4c00 	orr.w	ip, ip, r0, lsl #16
 803d7a2:	45e1      	cmp	r9, ip
 803d7a4:	d908      	bls.n	803d7b8 <__udivmoddi4+0x120>
 803d7a6:	eb17 0c0c 	adds.w	ip, r7, ip
 803d7aa:	f102 33ff 	add.w	r3, r2, #4294967295
 803d7ae:	d202      	bcs.n	803d7b6 <__udivmoddi4+0x11e>
 803d7b0:	45e1      	cmp	r9, ip
 803d7b2:	f200 80ca 	bhi.w	803d94a <__udivmoddi4+0x2b2>
 803d7b6:	461a      	mov	r2, r3
 803d7b8:	ebac 0c09 	sub.w	ip, ip, r9
 803d7bc:	b2a3      	uxth	r3, r4
 803d7be:	fbbc f0fe 	udiv	r0, ip, lr
 803d7c2:	fb0e cc10 	mls	ip, lr, r0, ip
 803d7c6:	fb08 f800 	mul.w	r8, r8, r0
 803d7ca:	ea43 440c 	orr.w	r4, r3, ip, lsl #16
 803d7ce:	45a0      	cmp	r8, r4
 803d7d0:	d90e      	bls.n	803d7f0 <__udivmoddi4+0x158>
 803d7d2:	193c      	adds	r4, r7, r4
 803d7d4:	f100 33ff 	add.w	r3, r0, #4294967295
 803d7d8:	bf2c      	ite	cs
 803d7da:	f04f 0c01 	movcs.w	ip, #1
 803d7de:	f04f 0c00 	movcc.w	ip, #0
 803d7e2:	45a0      	cmp	r8, r4
 803d7e4:	d903      	bls.n	803d7ee <__udivmoddi4+0x156>
 803d7e6:	f1bc 0f00 	cmp.w	ip, #0
 803d7ea:	f000 80a8 	beq.w	803d93e <__udivmoddi4+0x2a6>
 803d7ee:	4618      	mov	r0, r3
 803d7f0:	eba4 0408 	sub.w	r4, r4, r8
 803d7f4:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 803d7f8:	e79a      	b.n	803d730 <__udivmoddi4+0x98>
 803d7fa:	f1c1 0420 	rsb	r4, r1, #32
 803d7fe:	408b      	lsls	r3, r1
 803d800:	fa02 fe01 	lsl.w	lr, r2, r1
 803d804:	fa0c f601 	lsl.w	r6, ip, r1
 803d808:	40e2      	lsrs	r2, r4
 803d80a:	fa20 f704 	lsr.w	r7, r0, r4
 803d80e:	fa2c fc04 	lsr.w	ip, ip, r4
 803d812:	fa00 f801 	lsl.w	r8, r0, r1
 803d816:	4313      	orrs	r3, r2
 803d818:	433e      	orrs	r6, r7
 803d81a:	0c1f      	lsrs	r7, r3, #16
 803d81c:	0c32      	lsrs	r2, r6, #16
 803d81e:	fa1f f983 	uxth.w	r9, r3
 803d822:	fbbc f0f7 	udiv	r0, ip, r7
 803d826:	fb07 cc10 	mls	ip, r7, r0, ip
 803d82a:	fb00 fa09 	mul.w	sl, r0, r9
 803d82e:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
 803d832:	45e2      	cmp	sl, ip
 803d834:	d908      	bls.n	803d848 <__udivmoddi4+0x1b0>
 803d836:	eb13 0c0c 	adds.w	ip, r3, ip
 803d83a:	f100 32ff 	add.w	r2, r0, #4294967295
 803d83e:	d202      	bcs.n	803d846 <__udivmoddi4+0x1ae>
 803d840:	45e2      	cmp	sl, ip
 803d842:	f200 8089 	bhi.w	803d958 <__udivmoddi4+0x2c0>
 803d846:	4610      	mov	r0, r2
 803d848:	ebac 0c0a 	sub.w	ip, ip, sl
 803d84c:	b2b6      	uxth	r6, r6
 803d84e:	fbbc faf7 	udiv	sl, ip, r7
 803d852:	fb07 cc1a 	mls	ip, r7, sl, ip
 803d856:	fb0a f909 	mul.w	r9, sl, r9
 803d85a:	ea46 420c 	orr.w	r2, r6, ip, lsl #16
 803d85e:	4591      	cmp	r9, r2
 803d860:	d906      	bls.n	803d870 <__udivmoddi4+0x1d8>
 803d862:	189a      	adds	r2, r3, r2
 803d864:	f10a 36ff 	add.w	r6, sl, #4294967295
 803d868:	d201      	bcs.n	803d86e <__udivmoddi4+0x1d6>
 803d86a:	4591      	cmp	r9, r2
 803d86c:	d87a      	bhi.n	803d964 <__udivmoddi4+0x2cc>
 803d86e:	46b2      	mov	sl, r6
 803d870:	ea4a 4000 	orr.w	r0, sl, r0, lsl #16
 803d874:	eba2 0209 	sub.w	r2, r2, r9
 803d878:	fba0 670e 	umull	r6, r7, r0, lr
 803d87c:	42ba      	cmp	r2, r7
 803d87e:	46b4      	mov	ip, r6
 803d880:	46b9      	mov	r9, r7
 803d882:	d302      	bcc.n	803d88a <__udivmoddi4+0x1f2>
 803d884:	d107      	bne.n	803d896 <__udivmoddi4+0x1fe>
 803d886:	45b0      	cmp	r8, r6
 803d888:	d205      	bcs.n	803d896 <__udivmoddi4+0x1fe>
 803d88a:	ebb6 0c0e 	subs.w	ip, r6, lr
 803d88e:	eb67 0303 	sbc.w	r3, r7, r3
 803d892:	3801      	subs	r0, #1
 803d894:	4699      	mov	r9, r3
 803d896:	2d00      	cmp	r5, #0
 803d898:	d06b      	beq.n	803d972 <__udivmoddi4+0x2da>
 803d89a:	ebb8 030c 	subs.w	r3, r8, ip
 803d89e:	eb62 0209 	sbc.w	r2, r2, r9
 803d8a2:	fa02 f404 	lsl.w	r4, r2, r4
 803d8a6:	40cb      	lsrs	r3, r1
 803d8a8:	40ca      	lsrs	r2, r1
 803d8aa:	2100      	movs	r1, #0
 803d8ac:	431c      	orrs	r4, r3
 803d8ae:	e9c5 4200 	strd	r4, r2, [r5]
 803d8b2:	e742      	b.n	803d73a <__udivmoddi4+0xa2>
 803d8b4:	40b7      	lsls	r7, r6
 803d8b6:	f1c6 0220 	rsb	r2, r6, #32
 803d8ba:	fa01 f306 	lsl.w	r3, r1, r6
 803d8be:	40b4      	lsls	r4, r6
 803d8c0:	fa21 fc02 	lsr.w	ip, r1, r2
 803d8c4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 803d8c8:	fa20 f202 	lsr.w	r2, r0, r2
 803d8cc:	fa1f f887 	uxth.w	r8, r7
 803d8d0:	fbbc f1fe 	udiv	r1, ip, lr
 803d8d4:	431a      	orrs	r2, r3
 803d8d6:	fb0e cc11 	mls	ip, lr, r1, ip
 803d8da:	fb01 f008 	mul.w	r0, r1, r8
 803d8de:	0c13      	lsrs	r3, r2, #16
 803d8e0:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
 803d8e4:	4560      	cmp	r0, ip
 803d8e6:	d907      	bls.n	803d8f8 <__udivmoddi4+0x260>
 803d8e8:	eb17 0c0c 	adds.w	ip, r7, ip
 803d8ec:	f101 33ff 	add.w	r3, r1, #4294967295
 803d8f0:	d201      	bcs.n	803d8f6 <__udivmoddi4+0x25e>
 803d8f2:	4560      	cmp	r0, ip
 803d8f4:	d833      	bhi.n	803d95e <__udivmoddi4+0x2c6>
 803d8f6:	4619      	mov	r1, r3
 803d8f8:	ebac 0c00 	sub.w	ip, ip, r0
 803d8fc:	b292      	uxth	r2, r2
 803d8fe:	fbbc f0fe 	udiv	r0, ip, lr
 803d902:	fb0e cc10 	mls	ip, lr, r0, ip
 803d906:	fb00 f308 	mul.w	r3, r0, r8
 803d90a:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
 803d90e:	4563      	cmp	r3, ip
 803d910:	d907      	bls.n	803d922 <__udivmoddi4+0x28a>
 803d912:	eb17 0c0c 	adds.w	ip, r7, ip
 803d916:	f100 32ff 	add.w	r2, r0, #4294967295
 803d91a:	d201      	bcs.n	803d920 <__udivmoddi4+0x288>
 803d91c:	4563      	cmp	r3, ip
 803d91e:	d825      	bhi.n	803d96c <__udivmoddi4+0x2d4>
 803d920:	4610      	mov	r0, r2
 803d922:	ebac 0303 	sub.w	r3, ip, r3
 803d926:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 803d92a:	e730      	b.n	803d78e <__udivmoddi4+0xf6>
 803d92c:	4629      	mov	r1, r5
 803d92e:	4628      	mov	r0, r5
 803d930:	e703      	b.n	803d73a <__udivmoddi4+0xa2>
 803d932:	1a84      	subs	r4, r0, r2
 803d934:	eb6c 0303 	sbc.w	r3, ip, r3
 803d938:	2001      	movs	r0, #1
 803d93a:	469a      	mov	sl, r3
 803d93c:	e715      	b.n	803d76a <__udivmoddi4+0xd2>
 803d93e:	3802      	subs	r0, #2
 803d940:	443c      	add	r4, r7
 803d942:	e755      	b.n	803d7f0 <__udivmoddi4+0x158>
 803d944:	3802      	subs	r0, #2
 803d946:	443c      	add	r4, r7
 803d948:	e6ed      	b.n	803d726 <__udivmoddi4+0x8e>
 803d94a:	3a02      	subs	r2, #2
 803d94c:	44bc      	add	ip, r7
 803d94e:	e733      	b.n	803d7b8 <__udivmoddi4+0x120>
 803d950:	f1ae 0e02 	sub.w	lr, lr, #2
 803d954:	443b      	add	r3, r7
 803d956:	e6d2      	b.n	803d6fe <__udivmoddi4+0x66>
 803d958:	3802      	subs	r0, #2
 803d95a:	449c      	add	ip, r3
 803d95c:	e774      	b.n	803d848 <__udivmoddi4+0x1b0>
 803d95e:	3902      	subs	r1, #2
 803d960:	44bc      	add	ip, r7
 803d962:	e7c9      	b.n	803d8f8 <__udivmoddi4+0x260>
 803d964:	f1aa 0a02 	sub.w	sl, sl, #2
 803d968:	441a      	add	r2, r3
 803d96a:	e781      	b.n	803d870 <__udivmoddi4+0x1d8>
 803d96c:	3802      	subs	r0, #2
 803d96e:	44bc      	add	ip, r7
 803d970:	e7d7      	b.n	803d922 <__udivmoddi4+0x28a>
 803d972:	4629      	mov	r1, r5
 803d974:	e6e1      	b.n	803d73a <__udivmoddi4+0xa2>
 803d976:	bf00      	nop

0803d978 <__aeabi_idiv0>:
 803d978:	4770      	bx	lr
 803d97a:	bf00      	nop

0803d97c <_close>:
 803d97c:	4b02      	ldr	r3, [pc, #8]	; (803d988 <_close+0xc>)
 803d97e:	2258      	movs	r2, #88	; 0x58
 803d980:	f04f 30ff 	mov.w	r0, #4294967295
 803d984:	601a      	str	r2, [r3, #0]
 803d986:	4770      	bx	lr
 803d988:	200006d0 	.word	0x200006d0

0803d98c <_fstat>:
 803d98c:	4b02      	ldr	r3, [pc, #8]	; (803d998 <_fstat+0xc>)
 803d98e:	2258      	movs	r2, #88	; 0x58
 803d990:	f04f 30ff 	mov.w	r0, #4294967295
 803d994:	601a      	str	r2, [r3, #0]
 803d996:	4770      	bx	lr
 803d998:	200006d0 	.word	0x200006d0

0803d99c <_isatty>:
 803d99c:	4b02      	ldr	r3, [pc, #8]	; (803d9a8 <_isatty+0xc>)
 803d99e:	2258      	movs	r2, #88	; 0x58
 803d9a0:	2000      	movs	r0, #0
 803d9a2:	601a      	str	r2, [r3, #0]
 803d9a4:	4770      	bx	lr
 803d9a6:	bf00      	nop
 803d9a8:	200006d0 	.word	0x200006d0

0803d9ac <_lseek>:
 803d9ac:	4b02      	ldr	r3, [pc, #8]	; (803d9b8 <_lseek+0xc>)
 803d9ae:	2258      	movs	r2, #88	; 0x58
 803d9b0:	f04f 30ff 	mov.w	r0, #4294967295
 803d9b4:	601a      	str	r2, [r3, #0]
 803d9b6:	4770      	bx	lr
 803d9b8:	200006d0 	.word	0x200006d0

0803d9bc <_read>:
 803d9bc:	4b02      	ldr	r3, [pc, #8]	; (803d9c8 <_read+0xc>)
 803d9be:	2258      	movs	r2, #88	; 0x58
 803d9c0:	f04f 30ff 	mov.w	r0, #4294967295
 803d9c4:	601a      	str	r2, [r3, #0]
 803d9c6:	4770      	bx	lr
 803d9c8:	200006d0 	.word	0x200006d0

0803d9cc <_sbrk>:
 803d9cc:	4b04      	ldr	r3, [pc, #16]	; (803d9e0 <_sbrk+0x14>)
 803d9ce:	4602      	mov	r2, r0
 803d9d0:	6819      	ldr	r1, [r3, #0]
 803d9d2:	b909      	cbnz	r1, 803d9d8 <_sbrk+0xc>
 803d9d4:	4903      	ldr	r1, [pc, #12]	; (803d9e4 <_sbrk+0x18>)
 803d9d6:	6019      	str	r1, [r3, #0]
 803d9d8:	6818      	ldr	r0, [r3, #0]
 803d9da:	4402      	add	r2, r0
 803d9dc:	601a      	str	r2, [r3, #0]
 803d9de:	4770      	bx	lr
 803d9e0:	20000680 	.word	0x20000680
 803d9e4:	200016e0 	.word	0x200016e0

0803d9e8 <_exit>:
 803d9e8:	e7fe      	b.n	803d9e8 <_exit>
	...

0803d9ec <_init>:
 803d9ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803d9ee:	bf00      	nop
 803d9f0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803d9f2:	bc08      	pop	{r3}
 803d9f4:	469e      	mov	lr, r3
 803d9f6:	4770      	bx	lr

0803d9f8 <_fini>:
 803d9f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803d9fa:	bf00      	nop
 803d9fc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803d9fe:	bc08      	pop	{r3}
 803da00:	469e      	mov	lr, r3
 803da02:	4770      	bx	lr
 803da04:	414c465b 	.word	0x414c465b
 803da08:	495f4853 	.word	0x495f4853
 803da0c:	4c205d46 	.word	0x4c205d46
 803da10:	206b636f 	.word	0x206b636f
 803da14:	6c696166 	.word	0x6c696166
 803da18:	0d657275 	.word	0x0d657275
 803da1c:	4c465b00 	.word	0x4c465b00
 803da20:	5f485341 	.word	0x5f485341
 803da24:	205d4649 	.word	0x205d4649
 803da28:	6f6c6e55 	.word	0x6f6c6e55
 803da2c:	66206b63 	.word	0x66206b63
 803da30:	756c6961 	.word	0x756c6961
 803da34:	000d6572 	.word	0x000d6572
 803da38:	2d2d2020 	.word	0x2d2d2020
 803da3c:	6e655320 	.word	0x6e655320
 803da40:	69462064 	.word	0x69462064
 803da44:	61776d72 	.word	0x61776d72
 803da48:	0d206572 	.word	0x0d206572
 803da4c:	2020000a 	.word	0x2020000a
 803da50:	2d202d2d 	.word	0x2d202d2d
 803da54:	6946202d 	.word	0x6946202d
 803da58:	203e656c 	.word	0x203e656c
 803da5c:	6e617254 	.word	0x6e617254
 803da60:	72656673 	.word	0x72656673
 803da64:	4d59203e 	.word	0x4d59203e
 803da68:	4d45444f 	.word	0x4d45444f
 803da6c:	6553203e 	.word	0x6553203e
 803da70:	0920646e 	.word	0x0920646e
 803da74:	2d202000 	.word	0x2d202000
 803da78:	2d2d202d 	.word	0x2d2d202d
 803da7c:	6f725020 	.word	0x6f725020
 803da80:	6d617267 	.word	0x6d617267
 803da84:	676e696d 	.word	0x676e696d
 803da88:	6d6f4320 	.word	0x6d6f4320
 803da8c:	74656c70 	.word	0x74656c70
 803da90:	53206465 	.word	0x53206465
 803da94:	65636375 	.word	0x65636375
 803da98:	75667373 	.word	0x75667373
 803da9c:	21796c6c 	.word	0x21796c6c
 803daa0:	20000a0d 	.word	0x20000a0d
 803daa4:	202d2d20 	.word	0x202d2d20
 803daa8:	42202d2d 	.word	0x42202d2d
 803daac:	73657479 	.word	0x73657479
 803dab0:	6c25203a 	.word	0x6c25203a
 803dab4:	0a0a0d75 	.word	0x0a0a0d75
 803dab8:	2d202000 	.word	0x2d202000
 803dabc:	2d2d202d 	.word	0x2d2d202d
 803dac0:	41212120 	.word	0x41212120
 803dac4:	74726f62 	.word	0x74726f62
 803dac8:	62206465 	.word	0x62206465
 803dacc:	73752079 	.word	0x73752079
 803dad0:	21217265 	.word	0x21217265
 803dad4:	20000a0d 	.word	0x20000a0d
 803dad8:	202d2d20 	.word	0x202d2d20
 803dadc:	21202d2d 	.word	0x21202d2d
 803dae0:	72724521 	.word	0x72724521
 803dae4:	6420726f 	.word	0x6420726f
 803dae8:	6e697275 	.word	0x6e697275
 803daec:	69662067 	.word	0x69662067
 803daf0:	6420656c 	.word	0x6420656c
 803daf4:	6c6e776f 	.word	0x6c6e776f
 803daf8:	2164616f 	.word	0x2164616f
 803dafc:	000a0d21 	.word	0x000a0d21
 803db00:	3d3d0a0d 	.word	0x3d3d0a0d
 803db04:	3d3d3d3d 	.word	0x3d3d3d3d
 803db08:	3d3d3d3d 	.word	0x3d3d3d3d
 803db0c:	3d3d3d3d 	.word	0x3d3d3d3d
 803db10:	4e203d3d 	.word	0x4e203d3d
 803db14:	46207765 	.word	0x46207765
 803db18:	6f442077 	.word	0x6f442077
 803db1c:	6f6c6e77 	.word	0x6f6c6e77
 803db20:	3d206461 	.word	0x3d206461
 803db24:	3d3d3d3d 	.word	0x3d3d3d3d
 803db28:	3d3d3d3d 	.word	0x3d3d3d3d
 803db2c:	3d3d3d3d 	.word	0x3d3d3d3d
 803db30:	3d3d3d3d 	.word	0x3d3d3d3d
 803db34:	3d3d3d3d 	.word	0x3d3d3d3d
 803db38:	3d3d3d3d 	.word	0x3d3d3d3d
 803db3c:	20000a0d 	.word	0x20000a0d
 803db40:	776f4420 	.word	0x776f4420
 803db44:	616f6c6e 	.word	0x616f6c6e
 803db48:	65532064 	.word	0x65532064
 803db4c:	65727563 	.word	0x65727563
 803db50:	616d4920 	.word	0x616d4920
 803db54:	2d206567 	.word	0x2d206567
 803db58:	2d2d2d2d 	.word	0x2d2d2d2d
 803db5c:	2d2d2d2d 	.word	0x2d2d2d2d
 803db60:	2d2d2d2d 	.word	0x2d2d2d2d
 803db64:	2d2d2d2d 	.word	0x2d2d2d2d
 803db68:	2d2d2d2d 	.word	0x2d2d2d2d
 803db6c:	2d2d2d2d 	.word	0x2d2d2d2d
 803db70:	2d2d2d2d 	.word	0x2d2d2d2d
 803db74:	2d2d2d2d 	.word	0x2d2d2d2d
 803db78:	0a0d3120 	.word	0x0a0d3120
 803db7c:	44202000 	.word	0x44202000
 803db80:	6c6e776f 	.word	0x6c6e776f
 803db84:	2064616f 	.word	0x2064616f
 803db88:	536e6f4e 	.word	0x536e6f4e
 803db8c:	72756365 	.word	0x72756365
 803db90:	6d492065 	.word	0x6d492065
 803db94:	2d656761 	.word	0x2d656761
 803db98:	2d2d2d2d 	.word	0x2d2d2d2d
 803db9c:	2d2d2d2d 	.word	0x2d2d2d2d
 803dba0:	2d2d2d2d 	.word	0x2d2d2d2d
 803dba4:	2d2d2d2d 	.word	0x2d2d2d2d
 803dba8:	2d2d2d2d 	.word	0x2d2d2d2d
 803dbac:	2d2d2d2d 	.word	0x2d2d2d2d
 803dbb0:	2d2d2d2d 	.word	0x2d2d2d2d
 803dbb4:	32202d2d 	.word	0x32202d2d
 803dbb8:	20000a0d 	.word	0x20000a0d
 803dbbc:	73655220 	.word	0x73655220
 803dbc0:	74207465 	.word	0x74207465
 803dbc4:	7274206f 	.word	0x7274206f
 803dbc8:	65676769 	.word	0x65676769
 803dbcc:	6e492072 	.word	0x6e492072
 803dbd0:	6c617473 	.word	0x6c617473
 803dbd4:	6974616c 	.word	0x6974616c
 803dbd8:	2d2d6e6f 	.word	0x2d2d6e6f
 803dbdc:	2d2d2d2d 	.word	0x2d2d2d2d
 803dbe0:	2d2d2d2d 	.word	0x2d2d2d2d
 803dbe4:	2d2d2d2d 	.word	0x2d2d2d2d
 803dbe8:	2d2d2d2d 	.word	0x2d2d2d2d
 803dbec:	2d2d2d2d 	.word	0x2d2d2d2d
 803dbf0:	2d2d2d2d 	.word	0x2d2d2d2d
 803dbf4:	0a0d3320 	.word	0x0a0d3320
 803dbf8:	45202000 	.word	0x45202000
 803dbfc:	20746978 	.word	0x20746978
 803dc00:	2077654e 	.word	0x2077654e
 803dc04:	44205746 	.word	0x44205746
 803dc08:	6c6e776f 	.word	0x6c6e776f
 803dc0c:	2064616f 	.word	0x2064616f
 803dc10:	756e654d 	.word	0x756e654d
 803dc14:	2d2d2d20 	.word	0x2d2d2d20
 803dc18:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc1c:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc20:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc24:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc28:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc2c:	2d2d2d2d 	.word	0x2d2d2d2d
 803dc30:	78202d2d 	.word	0x78202d2d
 803dc34:	0a0d      	.short	0x0a0d
 803dc36:	00          	.byte	0x00
 803dc37:	44          	.byte	0x44
 803dc38:	6c6e776f 	.word	0x6c6e776f
 803dc3c:	2064616f 	.word	0x2064616f
 803dc40:	75636553 	.word	0x75636553
 803dc44:	49206572 	.word	0x49206572
 803dc48:	6567616d 	.word	0x6567616d
 803dc4c:	2020000d 	.word	0x2020000d
 803dc50:	53202d2d 	.word	0x53202d2d
 803dc54:	72756365 	.word	0x72756365
 803dc58:	6d492065 	.word	0x6d492065
 803dc5c:	20656761 	.word	0x20656761
 803dc60:	72726f63 	.word	0x72726f63
 803dc64:	6c746365 	.word	0x6c746365
 803dc68:	6f642079 	.word	0x6f642079
 803dc6c:	6f6c6e77 	.word	0x6f6c6e77
 803dc70:	64656461 	.word	0x64656461
 803dc74:	000a0d20 	.word	0x000a0d20
 803dc78:	6e776f44 	.word	0x6e776f44
 803dc7c:	64616f6c 	.word	0x64616f6c
 803dc80:	6e6f4e20 	.word	0x6e6f4e20
 803dc84:	75636553 	.word	0x75636553
 803dc88:	49206572 	.word	0x49206572
 803dc8c:	6567616d 	.word	0x6567616d
 803dc90:	2020000d 	.word	0x2020000d
 803dc94:	4e202d2d 	.word	0x4e202d2d
 803dc98:	65536e6f 	.word	0x65536e6f
 803dc9c:	65727563 	.word	0x65727563
 803dca0:	616d4920 	.word	0x616d4920
 803dca4:	63206567 	.word	0x63206567
 803dca8:	6572726f 	.word	0x6572726f
 803dcac:	796c7463 	.word	0x796c7463
 803dcb0:	776f6420 	.word	0x776f6420
 803dcb4:	616f6c6e 	.word	0x616f6c6e
 803dcb8:	20646564 	.word	0x20646564
 803dcbc:	20000a0d 	.word	0x20000a0d
 803dcc0:	202d2d20 	.word	0x202d2d20
 803dcc4:	74736e49 	.word	0x74736e49
 803dcc8:	206c6c61 	.word	0x206c6c61
 803dccc:	67616d69 	.word	0x67616d69
 803dcd0:	203a2065 	.word	0x203a2065
 803dcd4:	6f626572 	.word	0x6f626572
 803dcd8:	0a0d746f 	.word	0x0a0d746f
 803dcdc:	766e4900 	.word	0x766e4900
 803dce0:	64696c61 	.word	0x64696c61
 803dce4:	6d754e20 	.word	0x6d754e20
 803dce8:	20726562 	.word	0x20726562
 803dcec:	0d21      	.short	0x0d21
 803dcee:	00          	.byte	0x00
 803dcef:	0d          	.byte	0x0d
 803dcf0:	3d3d3d0a 	.word	0x3d3d3d0a
 803dcf4:	3d3d3d3d 	.word	0x3d3d3d3d
 803dcf8:	3d3d3d3d 	.word	0x3d3d3d3d
 803dcfc:	3d3d3d3d 	.word	0x3d3d3d3d
 803dd00:	3d3d3d3d 	.word	0x3d3d3d3d
 803dd04:	69614d20 	.word	0x69614d20
 803dd08:	654d206e 	.word	0x654d206e
 803dd0c:	3d20756e 	.word	0x3d20756e
 803dd10:	3d3d3d3d 	.word	0x3d3d3d3d
 803dd14:	3d3d3d3d 	.word	0x3d3d3d3d
 803dd18:	3d3d3d3d 	.word	0x3d3d3d3d
 803dd1c:	3d3d3d3d 	.word	0x3d3d3d3d
 803dd20:	3d3d3d3d 	.word	0x3d3d3d3d
 803dd24:	3d3d3d3d 	.word	0x3d3d3d3d
 803dd28:	0d3d3d3d 	.word	0x0d3d3d3d
 803dd2c:	2020000a 	.word	0x2020000a
 803dd30:	6e776f44 	.word	0x6e776f44
 803dd34:	64616f6c 	.word	0x64616f6c
 803dd38:	6e206120 	.word	0x6e206120
 803dd3c:	46207765 	.word	0x46207765
 803dd40:	6d492077 	.word	0x6d492077
 803dd44:	20656761 	.word	0x20656761
 803dd48:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd4c:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd50:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd54:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd58:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd5c:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd60:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd64:	202d2d2d 	.word	0x202d2d2d
 803dd68:	000a0d31 	.word	0x000a0d31
 803dd6c:	65542020 	.word	0x65542020
 803dd70:	50207473 	.word	0x50207473
 803dd74:	65746f72 	.word	0x65746f72
 803dd78:	6f697463 	.word	0x6f697463
 803dd7c:	2d20736e 	.word	0x2d20736e
 803dd80:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd84:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd88:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd8c:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd90:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd94:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd98:	2d2d2d2d 	.word	0x2d2d2d2d
 803dd9c:	2d2d2d2d 	.word	0x2d2d2d2d
 803dda0:	2d2d2d2d 	.word	0x2d2d2d2d
 803dda4:	0d32202d 	.word	0x0d32202d
 803dda8:	2020000a 	.word	0x2020000a
 803ddac:	74736554 	.word	0x74736554
 803ddb0:	4d465420 	.word	0x4d465420
 803ddb4:	2d2d2d20 	.word	0x2d2d2d20
 803ddb8:	2d2d2d2d 	.word	0x2d2d2d2d
 803ddbc:	2d2d2d2d 	.word	0x2d2d2d2d
 803ddc0:	2d2d2d2d 	.word	0x2d2d2d2d
 803ddc4:	2d2d2d2d 	.word	0x2d2d2d2d
 803ddc8:	2d2d2d2d 	.word	0x2d2d2d2d
 803ddcc:	2d2d2d2d 	.word	0x2d2d2d2d
 803ddd0:	2d2d2d2d 	.word	0x2d2d2d2d
 803ddd4:	2d2d2d2d 	.word	0x2d2d2d2d
 803ddd8:	2d2d2d2d 	.word	0x2d2d2d2d
 803dddc:	2d2d2d2d 	.word	0x2d2d2d2d
 803dde0:	202d2d2d 	.word	0x202d2d2d
 803dde4:	000a0d33 	.word	0x000a0d33
 803dde8:	65532020 	.word	0x65532020
 803ddec:	7463656c 	.word	0x7463656c
 803ddf0:	206e6f69 	.word	0x206e6f69
 803ddf4:	000a0d3a 	.word	0x000a0d3a

0803ddf8 <UserAppId>:
 803ddf8:	3d0a0d41 3d3d3d3d 3d3d3d3d 3d3d3d3d     A..=============
 803de08:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 803de18:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 803de28:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 803de38:	3d3d3d3d 3d3d3d3d 0a0d003d 2020203d     =========...=   
 803de48:	20202020 20202020 28202020 43202943                (C) C
 803de58:	5259504f 54484749 31303220 54532039     OPYRIGHT 2019 ST
 803de68:	7263694d 656c656f 6f727463 7363696e     Microelectronics
 803de78:	20202020 20202020 20202020 20202020                     
 803de88:	0d003d20 20203d0a 20202020 20202020      =...=          
 803de98:	20202020 20202020 20202020 20202020                     
 803dea8:	20202020 20202020 20202020 20202020                     
 803deb8:	20202020 20202020 20202020 20202020                     
 803dec8:	20202020 20202020 003d2020 203d0a0d               =...= 
 803ded8:	20202020 20202020 20202020 20202020                     
 803dee8:	20202020 20202020 65735520 70412072              User Ap
 803def8:	25232070 20202063 20202020 20202020     p #%c           
 803df08:	20202020 20202020 20202020 20202020                     
 803df18:	20202020 0a0d003d                            =.....

0803df22 <AHBPrescTable>:
	...
 803df2a:	04030201 09080706                       ........

0803df32 <APBPrescTable>:
 803df32:	00000000 04030201                        ..........

0803df3c <MSIRangeTable>:
 803df3c:	000186a0 00030d40 00061a80 000c3500     ....@........5..
 803df4c:	000f4240 001e8480 003d0900 007a1200     @B........=...z.
 803df5c:	00f42400 016e3600 01e84800 02dc6c00     .$...6n..H...l..
	...
 803df7c:	3d3d0a0d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ..==============
 803df8c:	3d3d3d3d 6554203d 4d207473 20756e65     ===== Test Menu 
 803df9c:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 803dfac:	3d3d3d3d 3d3d3d3d 3d3d3d3d 20000a0d     ============... 
 803dfbc:	73655420 72502074 6365746f 6e6f6974      Test Protection
 803dfcc:	4e203a20 65536e6f 65727563 79727420      : NonSecure try
 803dfdc:	206f7420 65636361 74207373 6553206f      to access to Se
 803dfec:	65727563 2d2d2d20 0a0d3120 52202000     cure --- 1...  R
 803dffc:	52205044 65726765 6f697373 2d2d206e     DP Regression --
 803e00c:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e01c:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e02c:	2d2d2d2d 32202d2d 20000a0d 65725020     ------ 2...  Pre
 803e03c:	756f6976 654d2073 2d20756e 2d2d2d2d     vious Menu -----
 803e04c:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e05c:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e06c:	2d2d2d2d 0a0d7820 200a0d00 69766544     ---- x..... Devi
 803e07c:	72206563 79646165 726f6620 67657220     ce ready for reg
 803e08c:	73736572 206e6f69 000d203a 2d200a0d     ression : .... -
 803e09c:	6e6f4320 7463656e 4d545320 75433233      Connect STM32Cu
 803e0ac:	72506562 6172676f 72656d6d 646f6d20     beProgrammer mod
 803e0bc:	6f483d65 756c5074 0a0d0067 50202d20     e=HotPlug... - P
 803e0cc:	6f667265 52206d72 52205044 65726765     erform RDP Regre
 803e0dc:	6f697373 0d00206e 0d00200a 5b203d0a     ssion ... ...= [
 803e0ec:	54534554 7325205d 25204020 30252073     TEST] %s @ %s %0
 803e0fc:	0d007838 616c660a 65206873 726f7272     8x...flash error
 803e10c:	646f6320 25203a65 424f0078 00402073      code: %x.OBs @.
 803e11c:	6c6f7349 64657461 61762000 2065756c     Isolated. value 
 803e12c:	6425203a 76200020 65756c61 25203a20     : %d . value : %
 803e13c:	0d002078 4554200a 505f5453 45544f52     x ... TEST_PROTE
 803e14c:	4f495443 525f534e 535f6e75 73556365     CTIONS_Run_SecUs
 803e15c:	654d7265 203a206d 73736150 0d006465     erMem : Passed..
 803e16c:	4554200a 505f5453 45544f52 4f495443     . TEST_PROTECTIO
 803e17c:	525f534e 535f6e75 73556365 654d7265     NS_Run_SecUserMe
 803e18c:	203a206d 6c696146 08006465 08080808     m : Failed......
 803e19c:	00080808                                ....

0803e1a0 <aProtectTests>:
 803e1a0:	20030000 61746144 63655320 20657275     ... Data Secure 
 803e1b0:	72617453 00000074 00000000 00000000     Start...........
 803e1c0:	00000000 00000104 2003fc00 61746144     ........... Data
 803e1d0:	63655320 20657275 00646e45 00000000      Secure End.....
	...
 803e1ec:	00000104 0c000400 65646f43 63655320     ........Code Sec
 803e1fc:	20657275 72617453 00000074 00000000     ure Start.......
	...
 803e214:	00000101 0c024400 65646f43 63655320     .....D..Code Sec
 803e224:	20657275 28444e45 656e6576 00297265     ure END(veneer).
	...
 803e23c:	00000101 420c0804 20474e52 53205049     .......BRNG IP S
 803e24c:	00000052 00000000 00000000 00000000     R...............
	...
 803e264:	00000006 420c0808 20474e52 44205049     .......BRNG IP D
 803e274:	00000052 00000000 00000000 00000000     R...............
	...
 803e28c:	00000006 40003500 4b434142 52205055     .....5.@BACKUP R
 803e29c:	30204745 00000000 00000000 00000000     EG 0............
	...
 803e2b4:	00000106 4000351c 4b434142 52205055     .....5.@BACKUP R
 803e2c4:	37204745 00000000 00000000 00000000     EG 7............
	...
 803e2dc:	00000106 00000000 63657845 6f697475     ........Executio
 803e2ec:	7573206e 73656363 6c756673 00000000     n successful....
	...
 803e304:	00000007                                ....

0803e308 <aTestOperation>:
 803e308:	74697277 20382065 65747962 00000073     write 8 bytes...
 803e318:	00000000 64616572 62203120 00657479     ....read 1 byte.
	...
 803e330:	73617265 31352065 79622032 00736574     erase 512 bytes.
 803e340:	00000000 74697277 20342065 65747962     ....write 4 byte
 803e350:	00000073 00000000 64616572 62203120     s.......read 1 b
 803e360:	00657479 00000000 00000000 63657865     yte.........exec
 803e370:	00657475 00000000 00000000 00000000     ute.............
 803e380:	64616572 62203420 73657479 00000000     read 4 bytes....
 803e390:	00000000 00646e65 00000000 00000000     ....end.........
	...
 803e3a8:	322e3225 55530078 53454343 4c554653     %2.2x.SUCCESSFUL
 803e3b8:	4146004c 44454c49 53454100 4d434720     L.FAILED.AES GCM
 803e3c8:	73657420 73252074 41000a0d 43205345      test %s...AES C
 803e3d8:	74204342 20747365 0a0d7325 54535300     BC test %s...SST
 803e3e8:	74657320 44495520 73657420 73252074      set UID test %s
 803e3f8:	53000a0d 72205453 20646165 6863202f     ...SST read / ch
 803e408:	206b6365 20444955 74736574 0d732520     eck UID test %s.
 803e418:	5353000a 65722054 65766f6d 44495520     ..SST remove UID
 803e428:	73657420 73252074 45000a0d 6e205441      test %s...EAT n
 803e438:	616d726f 6963206c 69756372 69732074     ormal circuit si
 803e448:	65742067 25207473 000a0d73 20535449     g test %s...ITS 
 803e458:	20746573 20444955 74736574 0d732520     set UID test %s.
 803e468:	5449000a 65722053 2f206461 65686320     ..ITS read / che
 803e478:	55206b63 74204449 20747365 0a0d7325     ck UID test %s..
 803e488:	53544900 6d657220 2065766f 20444955     .ITS remove UID 
 803e498:	74736574 0d732520 4853000a 34323241     test %s...SHA224
 803e4a8:	73657420 73252074 53000a0d 35324148      test %s...SHA25
 803e4b8:	65742036 25207473 000a0d73 554d5543     6 test %s...CUMU
 803e4c8:	4954414c 52204556 4c555345 25203a54     LATIVE RESULT: %
 803e4d8:	64252f64 63757320 73736563 0d000a0d     d/%d success....
 803e4e8:	3d3d3d0a 3d3d3d3d 3d3d3d3d 3d3d3d3d     .===============
 803e4f8:	3d3d3d3d 3d3d3d3d 4d465420 61784520     ======== TFM Exa
 803e508:	656c706d 654d2073 3d20756e 3d3d3d3d     mples Menu =====
 803e518:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 803e528:	3d3d3d3d 0a0d3d3d 54202000 2d204d46     ======...  TFM -
 803e538:	73655420 6c412074 2020206c 20202020      Test All       
 803e548:	20202020 20202020 20202020 20202020                     
 803e558:	20202020 20202020 20202020 2d2d2d2d                 ----
 803e568:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e578:	0d30202d 2020000a 204d4654 6554202d     - 0...  TFM - Te
 803e588:	41207473 472d5345 20204d43 20202020     st AES-GCM      
 803e598:	20202020 20202020 20202020 20202020                     
 803e5a8:	20202020 20202020 2d2d2d20 2d2d2d2d              -------
 803e5b8:	2d2d2d2d 2d2d2d2d 2d2d2d2d 31202d2d     -------------- 1
 803e5c8:	20000a0d 4d465420 54202d20 20747365     ...  TFM - Test 
 803e5d8:	2d534541 20434243 20202020 20202020     AES-CBC         
 803e5e8:	20202020 20202020 20202020 20202020                     
 803e5f8:	20202020 2d2d2020 2d2d2d2d 2d2d2d2d           ----------
 803e608:	2d2d2d2d 2d2d2d2d 202d2d2d 000a0d32     ----------- 2...
 803e618:	46542020 202d204d 74736554 54535320       TFM - Test SST
 803e628:	74657320 44495520 20202020 20202020      set UID        
 803e638:	20202020 20202020 20202020 20202020                     
 803e648:	2d202020 2d2d2d2d 2d2d2d2d 2d2d2d2d        -------------
 803e658:	2d2d2d2d 2d2d2d2d 0a0d3320 54202000     -------- 3...  T
 803e668:	2d204d46 73655420 53532074 65722054     FM - Test SST re
 803e678:	2f206461 65686320 55206b63 20204449     ad / check UID  
 803e688:	20202020 20202020 20202020 20202020                     
 803e698:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e6a8:	2d2d2d2d 0d34202d 2020000a 204d4654     ----- 4...  TFM 
 803e6b8:	6554202d 53207473 72205453 766f6d65     - Test SST remov
 803e6c8:	49552065 20202044 20202020 20202020     e UID           
 803e6d8:	20202020 20202020 20202020 2d2d2d20                  ---
 803e6e8:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e6f8:	35202d2d 20000a0d 4d465420 54202d20     -- 5...  TFM - T
 803e708:	20747365 20544145 20202020 20202020     est EAT         
 803e718:	20202020 20202020 20202020 20202020                     
 803e728:	20202020 20202020 2d2d2020 2d2d2d2d               ------
 803e738:	2d2d2d2d 2d2d2d2d 2d2d2d2d 202d2d2d     --------------- 
 803e748:	000a0d36 46542020 202d204d 74736554     6...  TFM - Test
 803e758:	53544920 74657320 44495520 20202020      ITS set UID    
 803e768:	20202020 20202020 20202020 20202020                     
 803e778:	20202020 2d202020 2d2d2d2d 2d2d2d2d            ---------
 803e788:	2d2d2d2d 2d2d2d2d 2d2d2d2d 0a0d3720     ------------ 7..
 803e798:	54202000 2d204d46 73655420 54492074     .  TFM - Test IT
 803e7a8:	65722053 2f206461 65686320 55206b63     S read / check U
 803e7b8:	20204449 20202020 20202020 20202020     ID              
 803e7c8:	20202020 2d2d2d2d 2d2d2d2d 2d2d2d2d         ------------
 803e7d8:	2d2d2d2d 2d2d2d2d 0d38202d 2020000a     --------- 8...  
 803e7e8:	204d4654 6554202d 49207473 72205354     TFM - Test ITS r
 803e7f8:	766f6d65 49552065 20202044 20202020     emove UID       
 803e808:	20202020 20202020 20202020 20202020                     
 803e818:	2d2d2d20 2d2d2d2d 2d2d2d2d 2d2d2d2d      ---------------
 803e828:	2d2d2d2d 39202d2d 20000a0d 4d465420     ------ 9...  TFM
 803e838:	54202d20 20747365 32414853 20203432      - Test SHA224  
 803e848:	20202020 20202020 20202020 20202020                     
 803e858:	20202020 20202020 20202020 2d2d2020                   --
 803e868:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e878:	202d2d2d 000a0d61 46542020 202d204d     --- a...  TFM - 
 803e888:	74736554 41485320 20363532 20202020     Test SHA256     
 803e898:	20202020 20202020 20202020 20202020                     
 803e8a8:	20202020 20202020 2d202020 2d2d2d2d                -----
 803e8b8:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 803e8c8:	0a0d6220 45202000 20746978 204d4654      b...  Exit TFM 
 803e8d8:	6d617845 73656c70 6e654d20 20202075     Examples Menu   
 803e8e8:	20202020 20202020 20202020 20202020                     
 803e8f8:	20202020 20202020 2d2d2d2d 2d2d2d2d             --------
 803e908:	2d2d2d2d 2d2d2d2d 2d2d2d2d 0d78202d     ------------- x.
 803e918:	6f74000a 206e656b 75716572 20747365     ..token request 
 803e928:	756c6176 0d3a2065 6b6f7400 72206e65     value :..token r
 803e938:	6f707365 2065736e 756c6176 0d3a2065     esponse value :.
 803e948:	69616600 2064656c 74617473 25207375     .failed status %
 803e958:	000a0d64 23232323 23232323 23232323     d...############
 803e968:	23232323 23232323 23232323 23232323     ################
 803e978:	23232323 23232323 23232323 23232323     ################
 803e988:	55525400 44455453 4d524946 45524157     .TRUSTEDFIRMWARE
 803e998:	524f465f 4d54535f 08003233 5f65002e     _FOR_STM32....e_
 803e9a8:	75736572 3d20746c 20782520 6c25202c     result = %x , %l
 803e9b8:	                                         u..

0803e9bb <CSWTCH.301>:
 803e9bb:	08020401                                ....

0803e9bf <CSWTCH.302>:
 803e9bf:	10101000 10101004 10101002               .............

0803e9cc <__func__.7640>:
 803e9cc:	5f617370 68706963 745f7265 00747365     psa_cipher_test.

0803e9dc <__func__.7670>:
 803e9dc:	5f617370 68736168 7365745f               psa_hash_test.

0803e9ea <__func__.7727>:
 803e9ea:	5f617370 64616561 7365745f               psa_aead_test.

0803e9f8 <hash_val>:
 803e9f8:	350e4a56 d0bcc7f1 bcb1cf7d 2efa16c9     VJ.5....}.......
 803ea08:	b296bef5 00000000 00000000 00000000     ................
	...
 803ea38:	e290d200 7ec14e0e 10f5957a 0474765c     .....N.~z...\vt.
 803ea48:	5e56b56e 15bae7e5 f347236c 00000000     n.V^....l#G.....
	...
 803ea78:	2a09226b 14f51e37 cf4d39f7 46174dad     k".*7....9M..M.F
 803ea88:	a033cb66 4e41d839 4dd32af1 3eb5c369     f.3.9.AN.*.Mi..>
	...
 803eab8:	bb117964 59474e47 60bc4d3e 9cbff9a5     dy..GNGY>M.`....
 803eac8:	0f55bac0 df72ca93 56501e57 d6014af9     ..U...r.W.PV.J..
 803ead8:	62f76fa5 fd484f34 4207159d b89472b7     .o.b4OH....B.r..
	...
 803eaf8:	6ca31cb4 ad1d67a9 1bbe1f34 2a40c483     ...l.g..4.....@*
 803eb08:	bb794247 60f0ca21 9b6ed2e4 3f341270     GBy.!..`..n.p.4?
 803eb18:	31092c55 21405b0a 583ba801 1a1348e7     U,.1.[@!..;X.H..
 803eb28:	d2e1cd7e 34581046 aa4b1449 b1f5a989     ~...F.X4I.K.....
 803eb38:	6f727245 65702072 726f6672 676e696d     Error performing
 803eb48:	41454120 6e652044 70797263 6e6f6974      AEAD encryption
 803eb58:	636e4500 74707972 64206465 20617461     .Encrypted data 
 803eb68:	676e656c 69206874 69642073 72656666     length is differ
 803eb78:	20746e65 6e616874 70786520 65746365     ent than expecte
 803eb88:	72450064 20726f72 66726570 696d726f     d.Error performi
 803eb98:	4120676e 20444145 72636564 69747079     ng AEAD decrypti
 803eba8:	44006e6f 79726365 64657470 74616420     on.Decrypted dat
 803ebb8:	656c2061 6874676e 20736920 66666964     a length is diff
 803ebc8:	6e657265 72662074 70206d6f 6e69616c     erent from plain
 803ebd8:	78657420 31300074 35343332 39383736      text.0123456789
 803ebe8:	68540030 69207369 73612073 69636f73     0.This is associ
 803ebf8:	64657461 74616420 6c410061 69726f67     ated data.Algori
 803ec08:	206d6874 20544f4e 50505553 4554524f     thm NOT SUPPORTE
 803ec18:	79622044 65687420 706d6920 656d656c     D by the impleme
 803ec28:	7461746e 006e6f69 6f727245 65732072     ntation.Error se
 803ec38:	6e697474 70752067 70696320 20726568     tting up cipher 
 803ec48:	7265706f 6f697461 626f206e 7463656a     operation object
 803ec58:	72724500 7320726f 69747465 7420676e     .Error setting t
 803ec68:	49206568 6e6f2056 65687420 70796320     he IV on the cyp
 803ec78:	20726568 7265706f 6f697461 626f206e     her operation ob
 803ec88:	7463656a 72724500 6120726f 74726f62     ject.Error abort
 803ec98:	20676e69 20656874 7265706f 6f697461     ing the operatio
 803eca8:	7245006e 20726f72 72636e65 69747079     n.Error encrypti
 803ecb8:	6f20676e 6320656e 6b6e7568 20666f20     ng one chunk of 
 803ecc8:	6f666e69 74616d72 006e6f69 65707845     information.Expe
 803ecd8:	64657463 636e6520 74707972 64206465     cted encrypted d
 803ece8:	20617461 676e656c 69206874 69642073     ata length is di
 803ecf8:	72656666 20746e65 6d6f7266 70786520     fferent from exp
 803ed08:	65746365 72450064 20726f72 616e6966     ected.Error fina
 803ed18:	6973696c 7420676e 63206568 65687069     lising the ciphe
 803ed28:	706f2072 74617265 006e6f69 78656e55     r operation.Unex
 803ed38:	74636570 6f206465 75707475 656c2074     pected output le
 803ed48:	6874676e 74666120 66207265 6c616e69     ngth after final
 803ed58:	74617369 006e6f69 6f727245 65732072     isation.Error se
 803ed68:	6e697474 68742067 56492065 726f6620     tting the IV for
 803ed78:	63656420 74707972 006e6f69 6f727245      decryption.Erro
 803ed88:	75642072 676e6972 63656420 74707972     r during decrypt
 803ed98:	006e6f69 72636544 65747079 61642064     ion.Decrypted da
 803eda8:	64206174 6e73656f 6d207427 68637461     ta doesn't match
 803edb8:	74697720 6c702068 206e6961 74786574      with plain text
 803edc8:	74664100 66207265 6c616e69 6e697369     .After finalisin
 803edd8:	75202c67 7078656e 65746365 65642064     g, unexpected de
 803ede8:	70797263 20646574 676e656c 45006874     crypted length.E
 803edf8:	726f7272 73656420 796f7274 20676e69     rror destroying 
 803ee08:	656b2061 31300079 35343332 39383736     a key.0123456789
 803ee18:	33323130 69530034 65657478 7962206e     01234.Sixteen by
 803ee28:	21736574 72450021 20726f72 74746573     tes!!.Error sett
 803ee38:	20676e69 68207075 20687361 7265706f     ing up hash oper
 803ee48:	6f697461 626f206e 7463656a 72724500     ation object.Err
 803ee58:	7520726f 74616470 20676e69 20656874     or updating the 
 803ee68:	68736168 65706f20 69746172 6f206e6f     hash operation o
 803ee78:	63656a62 72450074 20726f72 69726576     bject.Error veri
 803ee88:	6e697966 68742067 61682065 6f206873     fying the hash o
 803ee98:	61726570 6e6f6974 6a626f20 00746365     peration object.
 803eea8:	6c696146 74206465 6c61206f 61636f6c     Failed to alloca
 803eeb8:	6b206574 46007965 656c6961 6f742064     te key.Failed to
 803eec8:	74657320 79656b20 6c6f7020 00796369      set key policy.
 803eed8:	2079654b 646e6168 6420656c 2073656f     Key handle does 
 803eee8:	20746f6e 20746579 746e6f63 206e6961     not yet contain 
 803eef8:	2079656b 6574616d 6c616972 72724500     key material.Err
 803ef08:	6920726f 726f706d 676e6974 6b206120     or importing a k
 803ef18:	45007965 726f7272 74656720 676e6974     ey.Error getting
 803ef28:	79656b20 74656d20 74616461 68540061      key metadata.Th
 803ef38:	756e2065 7265626d 20666f20 2079656b     e number of key 
 803ef48:	73746962 20736920 66666964 6e657265     bits is differen
 803ef58:	72662074 65206d6f 63657078 00646574     t from expected.
 803ef68:	20656854 65707974 20666f20 20656874     The type of the 
 803ef78:	2079656b 64207369 65666669 746e6572     key is different
 803ef88:	6f726620 7865206d 74636570 45006465      from expected.E
 803ef98:	726f7272 70786520 6974726f 6120676e     rror exporting a
 803efa8:	79656b20 6d754e00 20726562 6220666f      key.Number of b
 803efb8:	73657479 20666f20 6f707865 64657472     ytes of exported
 803efc8:	79656b20 66696420 65726566 6620746e      key different f
 803efd8:	206d6f72 65707865 64657463 70784500     rom expected.Exp
 803efe8:	6574726f 656b2064 6f642079 276e7365     orted key doesn'
 803eff8:	616d2074 20686374 20656874 6f706d69     t match the impo
 803f008:	64657472 79656b20 72724500 6420726f     rted key.Error d
 803f018:	72747365 6e69796f 68742067 656b2065     estroying the ke
 803f028:	654b0079 61682079 656c646e 6f687320     y.Key handle sho
 803f038:	20646c75 69206562 6c61766e 6e206469     uld be invalid n
 803f048:	5400776f 20534948 4d205349 454b2059     ow.THIS IS MY KE
 803f058:	54003159 20736968 6d207369 65742079     Y1.This is my te
 803f068:	6d207473 61737365 202c6567 656c7000     st message, .ple
 803f078:	20657361 656e6567 65746172 68206120     ase generate a h
 803f088:	20687361 20726f66 73696874 6c70002e     ash for this..pl
 803f098:	65736165 6e656720 74617265 20612065     ease generate a 
 803f0a8:	63616d68 726f6620 69687420 45002e73     hmac for this..E
 803f0b8:	726f7272 25202820 0d292073 4554000a     rror ( %s )...TE
 803f0c8:	535f5453 45544955 5252455f 564e495f     ST_SUITE_ERR_INV
 803f0d8:	44494c41 5345545f 41445f54 00214154     ALID_TEST_DATA!.
 803f0e8:	25335b1b 00006d64                       .[3%dm..

0803f0f0 <_global_impure_ptr>:
 803f0f0:	2000012c                                ,.. 

0803f0f4 <__sf_fake_stderr>:
	...

0803f114 <__sf_fake_stdin>:
	...

0803f134 <__sf_fake_stdout>:
	...
 803f154:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
 803f164:	32313000 36353433 41393837 45444342     .0123456789ABCDE
 803f174:	31300046 35343332 39383736 64636261     F.0123456789abcd
 803f184:	00006665                                ef..

0803f188 <__EH_FRAME_BEGIN__>:
 803f188:	00000000                                ....

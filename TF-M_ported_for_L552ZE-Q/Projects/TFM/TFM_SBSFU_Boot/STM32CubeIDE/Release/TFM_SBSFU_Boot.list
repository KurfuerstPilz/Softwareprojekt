
TFM_SBSFU_Boot.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .provision    000003ce  0c000000  0c000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000a43c  0c000800  0c000800  00010800  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ARM.exidx    00000008  0c00ac3c  0c00ac3c  0001ac3c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .copy.table   00000018  0c00ac44  0c00ac44  0001ac44  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .zero.table   00000010  0c00ac5c  0c00ac5c  0001ac5c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         0000010c  30030000  0c00ac6c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          0000388c  3003010c  0c00ad78  0002010c  2**2
                  ALLOC
  7 .heap         00001000  30033998  0c00e604  0002010c  2**0
                  ALLOC
  8 .msp_stack    00001800  30034998  0c00f604  0002010c  2**0
                  ALLOC
  9 .ARM.attributes 00000036  00000000  00000000  0002010c  2**0
                  CONTENTS, READONLY
 10 .comment      0000007b  00000000  00000000  00020142  2**0
                  CONTENTS, READONLY
 11 .debug_info   00037b70  00000000  00000000  000201bd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000080ed  00000000  00000000  00057d2d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00018b0f  00000000  00000000  0005fe1a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00001808  00000000  00000000  00078929  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000022a8  00000000  00000000  0007a131  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  0003177d  00000000  00000000  0007c3d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   00020dc0  00000000  00000000  000adb56  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00119b41  00000000  00000000  000ce916  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_frame  00004e50  00000000  00000000  001e8458  2**2
                  CONTENTS, READONLY, DEBUGGING
 20 .stab         00000084  00000000  00000000  001ed2a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .stabstr      00000117  00000000  00000000  001ed32c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0c000800 <__Vectors>:
 c000800:	30036198 	.word	0x30036198
 c000804:	0c000aa9 	.word	0x0c000aa9
 c000808:	0c001441 	.word	0x0c001441
 c00080c:	0c000ad5 	.word	0x0c000ad5
 c000810:	0c000ad9 	.word	0x0c000ad9
 c000814:	0c000add 	.word	0x0c000add
 c000818:	0c000ae1 	.word	0x0c000ae1
 c00081c:	0c000ae5 	.word	0x0c000ae5
	...
 c00082c:	0c000ae9 	.word	0x0c000ae9
 c000830:	0c000aed 	.word	0x0c000aed
 c000834:	00000000 	.word	0x00000000
 c000838:	0c000af1 	.word	0x0c000af1
 c00083c:	0c000af5 	.word	0x0c000af5
 c000840:	0c000af9 	.word	0x0c000af9
 c000844:	0c000afd 	.word	0x0c000afd
 c000848:	0c000b01 	.word	0x0c000b01
 c00084c:	0c000b05 	.word	0x0c000b05
 c000850:	0c000b09 	.word	0x0c000b09
 c000854:	0c000b0d 	.word	0x0c000b0d
 c000858:	0c000b11 	.word	0x0c000b11
 c00085c:	0c000b15 	.word	0x0c000b15
 c000860:	0c000b19 	.word	0x0c000b19
 c000864:	0c000b1d 	.word	0x0c000b1d
 c000868:	0c000b21 	.word	0x0c000b21
 c00086c:	0c000b25 	.word	0x0c000b25
 c000870:	0c000b29 	.word	0x0c000b29
 c000874:	0c000b2d 	.word	0x0c000b2d
 c000878:	0c000b31 	.word	0x0c000b31
 c00087c:	0c000b35 	.word	0x0c000b35
 c000880:	0c000b39 	.word	0x0c000b39
 c000884:	0c000b3d 	.word	0x0c000b3d
 c000888:	0c000b41 	.word	0x0c000b41
 c00088c:	0c000b45 	.word	0x0c000b45
 c000890:	0c000b49 	.word	0x0c000b49
 c000894:	0c000b4d 	.word	0x0c000b4d
 c000898:	0c000b51 	.word	0x0c000b51
 c00089c:	0c000b55 	.word	0x0c000b55
 c0008a0:	0c000b59 	.word	0x0c000b59
 c0008a4:	0c000b5d 	.word	0x0c000b5d
 c0008a8:	0c000b61 	.word	0x0c000b61
 c0008ac:	0c000b65 	.word	0x0c000b65
 c0008b0:	0c000b69 	.word	0x0c000b69
 c0008b4:	0c000b6d 	.word	0x0c000b6d
 c0008b8:	0c000b71 	.word	0x0c000b71
 c0008bc:	0c000b75 	.word	0x0c000b75
 c0008c0:	0c000b79 	.word	0x0c000b79
 c0008c4:	0c000b7d 	.word	0x0c000b7d
 c0008c8:	0c000b81 	.word	0x0c000b81
 c0008cc:	0c000b85 	.word	0x0c000b85
 c0008d0:	0c000b89 	.word	0x0c000b89
 c0008d4:	0c000b8d 	.word	0x0c000b8d
 c0008d8:	0c000b91 	.word	0x0c000b91
 c0008dc:	0c000b95 	.word	0x0c000b95
 c0008e0:	0c000b99 	.word	0x0c000b99
 c0008e4:	0c000b9d 	.word	0x0c000b9d
 c0008e8:	0c000ba1 	.word	0x0c000ba1
 c0008ec:	0c000ba5 	.word	0x0c000ba5
 c0008f0:	0c000ba9 	.word	0x0c000ba9
 c0008f4:	0c000bad 	.word	0x0c000bad
 c0008f8:	0c000bb1 	.word	0x0c000bb1
 c0008fc:	0c000bb5 	.word	0x0c000bb5
 c000900:	0c000bb9 	.word	0x0c000bb9
 c000904:	0c000bbd 	.word	0x0c000bbd
 c000908:	0c000bc1 	.word	0x0c000bc1
 c00090c:	0c000bc5 	.word	0x0c000bc5
 c000910:	0c000bc9 	.word	0x0c000bc9
 c000914:	0c000bcd 	.word	0x0c000bcd
 c000918:	0c000bd1 	.word	0x0c000bd1
 c00091c:	0c000bd5 	.word	0x0c000bd5
 c000920:	0c000bd9 	.word	0x0c000bd9
 c000924:	0c000bdd 	.word	0x0c000bdd
 c000928:	0c000be1 	.word	0x0c000be1
 c00092c:	0c000be5 	.word	0x0c000be5
 c000930:	0c000be9 	.word	0x0c000be9
 c000934:	0c000bed 	.word	0x0c000bed
 c000938:	0c000bf1 	.word	0x0c000bf1
 c00093c:	0c000bf5 	.word	0x0c000bf5
 c000940:	0c000bf9 	.word	0x0c000bf9
 c000944:	0c000bfd 	.word	0x0c000bfd
 c000948:	0c000c01 	.word	0x0c000c01
 c00094c:	0c000c05 	.word	0x0c000c05
 c000950:	0c000c09 	.word	0x0c000c09
 c000954:	0c000c0d 	.word	0x0c000c0d
 c000958:	0c000c11 	.word	0x0c000c11
 c00095c:	0c000c15 	.word	0x0c000c15
 c000960:	0c000c19 	.word	0x0c000c19
 c000964:	0c000c1d 	.word	0x0c000c1d
 c000968:	0c000c21 	.word	0x0c000c21
 c00096c:	0c000c25 	.word	0x0c000c25
 c000970:	0c000c29 	.word	0x0c000c29
 c000974:	00000000 	.word	0x00000000
 c000978:	0c000c2d 	.word	0x0c000c2d
 c00097c:	00000000 	.word	0x00000000
 c000980:	0c000c31 	.word	0x0c000c31
 c000984:	0c000c35 	.word	0x0c000c35
 c000988:	0c000c39 	.word	0x0c000c39
 c00098c:	0c000c3d 	.word	0x0c000c3d
 c000990:	0c000c41 	.word	0x0c000c41
 c000994:	0c000c45 	.word	0x0c000c45
 c000998:	0c000c49 	.word	0x0c000c49
 c00099c:	0c000c4d 	.word	0x0c000c4d
 c0009a0:	0c000c51 	.word	0x0c000c51
 c0009a4:	0c000c55 	.word	0x0c000c55
 c0009a8:	0c000c59 	.word	0x0c000c59
 c0009ac:	0c000c5d 	.word	0x0c000c5d
 c0009b0:	0c000c61 	.word	0x0c000c61
 c0009b4:	00000000 	.word	0x00000000
 c0009b8:	0c000c65 	.word	0x0c000c65
 c0009bc:	0c000c69 	.word	0x0c000c69
	...
 c0009c8:	0c000c6d 	.word	0x0c000c6d
 c0009cc:	0c000c71 	.word	0x0c000c71
 c0009d0:	0c000c75 	.word	0x0c000c75
 c0009d4:	0c000c79 	.word	0x0c000c79
 c0009d8:	0c000c7d 	.word	0x0c000c7d
 c0009dc:	0c000c81 	.word	0x0c000c81
 c0009e0:	0c000c85 	.word	0x0c000c85
 c0009e4:	0c000c89 	.word	0x0c000c89
 c0009e8:	0c000c8d 	.word	0x0c000c8d
 c0009ec:	0c000c91 	.word	0x0c000c91
 c0009f0:	0c000c95 	.word	0x0c000c95

0c0009f4 <__do_global_dtors_aux>:
 c0009f4:	b510      	push	{r4, lr}
 c0009f6:	4c05      	ldr	r4, [pc, #20]	; (c000a0c <__do_global_dtors_aux+0x18>)
 c0009f8:	7823      	ldrb	r3, [r4, #0]
 c0009fa:	b933      	cbnz	r3, c000a0a <__do_global_dtors_aux+0x16>
 c0009fc:	4b04      	ldr	r3, [pc, #16]	; (c000a10 <__do_global_dtors_aux+0x1c>)
 c0009fe:	b113      	cbz	r3, c000a06 <__do_global_dtors_aux+0x12>
 c000a00:	4804      	ldr	r0, [pc, #16]	; (c000a14 <__do_global_dtors_aux+0x20>)
 c000a02:	e000      	b.n	c000a06 <__do_global_dtors_aux+0x12>
 c000a04:	bf00      	nop
 c000a06:	2301      	movs	r3, #1
 c000a08:	7023      	strb	r3, [r4, #0]
 c000a0a:	bd10      	pop	{r4, pc}
 c000a0c:	3003010c 	.word	0x3003010c
 c000a10:	00000000 	.word	0x00000000
 c000a14:	0c00ac38 	.word	0x0c00ac38

0c000a18 <frame_dummy>:
 c000a18:	b508      	push	{r3, lr}
 c000a1a:	4b03      	ldr	r3, [pc, #12]	; (c000a28 <frame_dummy+0x10>)
 c000a1c:	b11b      	cbz	r3, c000a26 <frame_dummy+0xe>
 c000a1e:	4903      	ldr	r1, [pc, #12]	; (c000a2c <frame_dummy+0x14>)
 c000a20:	4803      	ldr	r0, [pc, #12]	; (c000a30 <frame_dummy+0x18>)
 c000a22:	e000      	b.n	c000a26 <frame_dummy+0xe>
 c000a24:	bf00      	nop
 c000a26:	bd08      	pop	{r3, pc}
 c000a28:	00000000 	.word	0x00000000
 c000a2c:	30030110 	.word	0x30030110
 c000a30:	0c00ac38 	.word	0x0c00ac38

0c000a34 <_mainCRTStartup>:
 c000a34:	4b15      	ldr	r3, [pc, #84]	; (c000a8c <_mainCRTStartup+0x58>)
 c000a36:	2b00      	cmp	r3, #0
 c000a38:	bf08      	it	eq
 c000a3a:	4b13      	ldreq	r3, [pc, #76]	; (c000a88 <_mainCRTStartup+0x54>)
 c000a3c:	469d      	mov	sp, r3
 c000a3e:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
 c000a42:	2100      	movs	r1, #0
 c000a44:	468b      	mov	fp, r1
 c000a46:	460f      	mov	r7, r1
 c000a48:	4813      	ldr	r0, [pc, #76]	; (c000a98 <_mainCRTStartup+0x64>)
 c000a4a:	4a14      	ldr	r2, [pc, #80]	; (c000a9c <_mainCRTStartup+0x68>)
 c000a4c:	1a12      	subs	r2, r2, r0
 c000a4e:	f007 fe4c 	bl	c0086ea <memset>
 c000a52:	4b0f      	ldr	r3, [pc, #60]	; (c000a90 <_mainCRTStartup+0x5c>)
 c000a54:	2b00      	cmp	r3, #0
 c000a56:	d000      	beq.n	c000a5a <_mainCRTStartup+0x26>
 c000a58:	4798      	blx	r3
 c000a5a:	4b0e      	ldr	r3, [pc, #56]	; (c000a94 <_mainCRTStartup+0x60>)
 c000a5c:	2b00      	cmp	r3, #0
 c000a5e:	d000      	beq.n	c000a62 <_mainCRTStartup+0x2e>
 c000a60:	4798      	blx	r3
 c000a62:	2000      	movs	r0, #0
 c000a64:	2100      	movs	r1, #0
 c000a66:	0004      	movs	r4, r0
 c000a68:	000d      	movs	r5, r1
 c000a6a:	480d      	ldr	r0, [pc, #52]	; (c000aa0 <_mainCRTStartup+0x6c>)
 c000a6c:	2800      	cmp	r0, #0
 c000a6e:	d002      	beq.n	c000a76 <_mainCRTStartup+0x42>
 c000a70:	480c      	ldr	r0, [pc, #48]	; (c000aa4 <_mainCRTStartup+0x70>)
 c000a72:	e000      	b.n	c000a76 <_mainCRTStartup+0x42>
 c000a74:	bf00      	nop
 c000a76:	f007 fe01 	bl	c00867c <__libc_init_array>
 c000a7a:	0020      	movs	r0, r4
 c000a7c:	0029      	movs	r1, r5
 c000a7e:	f000 fe03 	bl	c001688 <main>
 c000a82:	f007 fde7 	bl	c008654 <exit>
 c000a86:	bf00      	nop
 c000a88:	00080000 	.word	0x00080000
 c000a8c:	30036198 	.word	0x30036198
	...
 c000a98:	3003010c 	.word	0x3003010c
 c000a9c:	30033998 	.word	0x30033998
	...

0c000aa8 <Reset_Handler>:
 c000aa8:	4906      	ldr	r1, [pc, #24]	; (c000ac4 <Reset_Handler+0x1c>)
 c000aaa:	4a07      	ldr	r2, [pc, #28]	; (c000ac8 <Reset_Handler+0x20>)
 c000aac:	4b07      	ldr	r3, [pc, #28]	; (c000acc <Reset_Handler+0x24>)
 c000aae:	1a9b      	subs	r3, r3, r2
 c000ab0:	dd03      	ble.n	c000aba <Reset_Handler+0x12>
 c000ab2:	3b04      	subs	r3, #4
 c000ab4:	58c8      	ldr	r0, [r1, r3]
 c000ab6:	50d0      	str	r0, [r2, r3]
 c000ab8:	dcfb      	bgt.n	c000ab2 <Reset_Handler+0xa>
 c000aba:	f001 f901 	bl	c001cc0 <SystemInit>
 c000abe:	f7ff ffb9 	bl	c000a34 <_mainCRTStartup>
 c000ac2:	0000      	.short	0x0000
 c000ac4:	0c00ac6c 	.word	0x0c00ac6c
 c000ac8:	30030000 	.word	0x30030000
 c000acc:	3003010c 	.word	0x3003010c
 c000ad0:	f000 bcb6 	b.w	c001440 <NMI_Handler>

0c000ad4 <HardFault_Handler>:
 c000ad4:	f7ff bffe 	b.w	c000ad4 <HardFault_Handler>

0c000ad8 <MemManage_Handler>:
 c000ad8:	f7ff bffe 	b.w	c000ad8 <MemManage_Handler>

0c000adc <BusFault_Handler>:
 c000adc:	f7ff bffe 	b.w	c000adc <BusFault_Handler>

0c000ae0 <UsageFault_Handler>:
 c000ae0:	f7ff bffe 	b.w	c000ae0 <UsageFault_Handler>

0c000ae4 <SecureFault_Handler>:
 c000ae4:	f7ff bffe 	b.w	c000ae4 <SecureFault_Handler>

0c000ae8 <SVC_Handler>:
 c000ae8:	f7ff bffe 	b.w	c000ae8 <SVC_Handler>

0c000aec <DebugMon_Handler>:
 c000aec:	f7ff bffe 	b.w	c000aec <DebugMon_Handler>

0c000af0 <PendSV_Handler>:
 c000af0:	f7ff bffe 	b.w	c000af0 <PendSV_Handler>

0c000af4 <SysTick_Handler>:
 c000af4:	f7ff bffe 	b.w	c000af4 <SysTick_Handler>

0c000af8 <WWDG_IRQHandler>:
 c000af8:	f7ff bffe 	b.w	c000af8 <WWDG_IRQHandler>

0c000afc <PVD_PVM_IRQHandler>:
 c000afc:	f7ff bffe 	b.w	c000afc <PVD_PVM_IRQHandler>

0c000b00 <RTC_IRQHandler>:
 c000b00:	f7ff bffe 	b.w	c000b00 <RTC_IRQHandler>

0c000b04 <RTC_IRQHandler_S>:
 c000b04:	f7ff bffe 	b.w	c000b04 <RTC_IRQHandler_S>

0c000b08 <TAMP_IRQHandler>:
 c000b08:	f7ff bffe 	b.w	c000b08 <TAMP_IRQHandler>

0c000b0c <TAMP_IRQHandler_S>:
 c000b0c:	f7ff bffe 	b.w	c000b0c <TAMP_IRQHandler_S>

0c000b10 <FLASH_IRQHandler>:
 c000b10:	f7ff bffe 	b.w	c000b10 <FLASH_IRQHandler>

0c000b14 <FLASH_IRQHandler_S>:
 c000b14:	f7ff bffe 	b.w	c000b14 <FLASH_IRQHandler_S>

0c000b18 <SERR_IRQHandler>:
 c000b18:	f7ff bffe 	b.w	c000b18 <SERR_IRQHandler>

0c000b1c <RCC_IRQHandler>:
 c000b1c:	f7ff bffe 	b.w	c000b1c <RCC_IRQHandler>

0c000b20 <RCC_IRQHandler_S>:
 c000b20:	f7ff bffe 	b.w	c000b20 <RCC_IRQHandler_S>

0c000b24 <EXTI0_IRQHandler>:
 c000b24:	f7ff bffe 	b.w	c000b24 <EXTI0_IRQHandler>

0c000b28 <EXTI1_IRQHandler>:
 c000b28:	f7ff bffe 	b.w	c000b28 <EXTI1_IRQHandler>

0c000b2c <EXTI2_IRQHandler>:
 c000b2c:	f7ff bffe 	b.w	c000b2c <EXTI2_IRQHandler>

0c000b30 <EXTI3_IRQHandler>:
 c000b30:	f7ff bffe 	b.w	c000b30 <EXTI3_IRQHandler>

0c000b34 <EXTI4_IRQHandler>:
 c000b34:	f7ff bffe 	b.w	c000b34 <EXTI4_IRQHandler>

0c000b38 <EXTI5_IRQHandler>:
 c000b38:	f7ff bffe 	b.w	c000b38 <EXTI5_IRQHandler>

0c000b3c <EXTI6_IRQHandler>:
 c000b3c:	f7ff bffe 	b.w	c000b3c <EXTI6_IRQHandler>

0c000b40 <EXTI7_IRQHandler>:
 c000b40:	f7ff bffe 	b.w	c000b40 <EXTI7_IRQHandler>

0c000b44 <EXTI8_IRQHandler>:
 c000b44:	f7ff bffe 	b.w	c000b44 <EXTI8_IRQHandler>

0c000b48 <EXTI9_IRQHandler>:
 c000b48:	f7ff bffe 	b.w	c000b48 <EXTI9_IRQHandler>

0c000b4c <EXTI10_IRQHandler>:
 c000b4c:	f7ff bffe 	b.w	c000b4c <EXTI10_IRQHandler>

0c000b50 <EXTI11_IRQHandler>:
 c000b50:	f7ff bffe 	b.w	c000b50 <EXTI11_IRQHandler>

0c000b54 <EXTI12_IRQHandler>:
 c000b54:	f7ff bffe 	b.w	c000b54 <EXTI12_IRQHandler>

0c000b58 <EXTI13_IRQHandler>:
 c000b58:	f7ff bffe 	b.w	c000b58 <EXTI13_IRQHandler>

0c000b5c <EXTI14_IRQHandler>:
 c000b5c:	f7ff bffe 	b.w	c000b5c <EXTI14_IRQHandler>

0c000b60 <EXTI15_IRQHandler>:
 c000b60:	f7ff bffe 	b.w	c000b60 <EXTI15_IRQHandler>

0c000b64 <DMAMUX1_IRQHandler>:
 c000b64:	f7ff bffe 	b.w	c000b64 <DMAMUX1_IRQHandler>

0c000b68 <DMAMUX1_IRQHandler_S>:
 c000b68:	f7ff bffe 	b.w	c000b68 <DMAMUX1_IRQHandler_S>

0c000b6c <DMA1_Channel1_IRQHandler>:
 c000b6c:	f7ff bffe 	b.w	c000b6c <DMA1_Channel1_IRQHandler>

0c000b70 <DMA1_Channel2_IRQHandler>:
 c000b70:	f7ff bffe 	b.w	c000b70 <DMA1_Channel2_IRQHandler>

0c000b74 <DMA1_Channel3_IRQHandler>:
 c000b74:	f7ff bffe 	b.w	c000b74 <DMA1_Channel3_IRQHandler>

0c000b78 <DMA1_Channel4_IRQHandler>:
 c000b78:	f7ff bffe 	b.w	c000b78 <DMA1_Channel4_IRQHandler>

0c000b7c <DMA1_Channel5_IRQHandler>:
 c000b7c:	f7ff bffe 	b.w	c000b7c <DMA1_Channel5_IRQHandler>

0c000b80 <DMA1_Channel6_IRQHandler>:
 c000b80:	f7ff bffe 	b.w	c000b80 <DMA1_Channel6_IRQHandler>

0c000b84 <DMA1_Channel7_IRQHandler>:
 c000b84:	f7ff bffe 	b.w	c000b84 <DMA1_Channel7_IRQHandler>

0c000b88 <DMA1_Channel8_IRQHandler>:
 c000b88:	f7ff bffe 	b.w	c000b88 <DMA1_Channel8_IRQHandler>

0c000b8c <ADC1_2_IRQHandler>:
 c000b8c:	f7ff bffe 	b.w	c000b8c <ADC1_2_IRQHandler>

0c000b90 <DAC_IRQHandler>:
 c000b90:	f7ff bffe 	b.w	c000b90 <DAC_IRQHandler>

0c000b94 <FDCAN1_IT0_IRQHandler>:
 c000b94:	f7ff bffe 	b.w	c000b94 <FDCAN1_IT0_IRQHandler>

0c000b98 <FDCAN1_IT1_IRQHandler>:
 c000b98:	f7ff bffe 	b.w	c000b98 <FDCAN1_IT1_IRQHandler>

0c000b9c <TIM1_BRK_IRQHandler>:
 c000b9c:	f7ff bffe 	b.w	c000b9c <TIM1_BRK_IRQHandler>

0c000ba0 <TIM1_UP_IRQHandler>:
 c000ba0:	f7ff bffe 	b.w	c000ba0 <TIM1_UP_IRQHandler>

0c000ba4 <TIM1_TRG_COM_IRQHandler>:
 c000ba4:	f7ff bffe 	b.w	c000ba4 <TIM1_TRG_COM_IRQHandler>

0c000ba8 <TIM1_CC_IRQHandler>:
 c000ba8:	f7ff bffe 	b.w	c000ba8 <TIM1_CC_IRQHandler>

0c000bac <TIM2_IRQHandler>:
 c000bac:	f7ff bffe 	b.w	c000bac <TIM2_IRQHandler>

0c000bb0 <TIM3_IRQHandler>:
 c000bb0:	f7ff bffe 	b.w	c000bb0 <TIM3_IRQHandler>

0c000bb4 <TIM4_IRQHandler>:
 c000bb4:	f7ff bffe 	b.w	c000bb4 <TIM4_IRQHandler>

0c000bb8 <TIM5_IRQHandler>:
 c000bb8:	f7ff bffe 	b.w	c000bb8 <TIM5_IRQHandler>

0c000bbc <TIM6_IRQHandler>:
 c000bbc:	f7ff bffe 	b.w	c000bbc <TIM6_IRQHandler>

0c000bc0 <TIM7_IRQHandler>:
 c000bc0:	f7ff bffe 	b.w	c000bc0 <TIM7_IRQHandler>

0c000bc4 <TIM8_BRK_IRQHandler>:
 c000bc4:	f7ff bffe 	b.w	c000bc4 <TIM8_BRK_IRQHandler>

0c000bc8 <TIM8_UP_IRQHandler>:
 c000bc8:	f7ff bffe 	b.w	c000bc8 <TIM8_UP_IRQHandler>

0c000bcc <TIM8_TRG_COM_IRQHandler>:
 c000bcc:	f7ff bffe 	b.w	c000bcc <TIM8_TRG_COM_IRQHandler>

0c000bd0 <TIM8_CC_IRQHandler>:
 c000bd0:	f7ff bffe 	b.w	c000bd0 <TIM8_CC_IRQHandler>

0c000bd4 <I2C1_EV_IRQHandler>:
 c000bd4:	f7ff bffe 	b.w	c000bd4 <I2C1_EV_IRQHandler>

0c000bd8 <I2C1_ER_IRQHandler>:
 c000bd8:	f7ff bffe 	b.w	c000bd8 <I2C1_ER_IRQHandler>

0c000bdc <I2C2_EV_IRQHandler>:
 c000bdc:	f7ff bffe 	b.w	c000bdc <I2C2_EV_IRQHandler>

0c000be0 <I2C2_ER_IRQHandler>:
 c000be0:	f7ff bffe 	b.w	c000be0 <I2C2_ER_IRQHandler>

0c000be4 <SPI1_IRQHandler>:
 c000be4:	f7ff bffe 	b.w	c000be4 <SPI1_IRQHandler>

0c000be8 <SPI2_IRQHandler>:
 c000be8:	f7ff bffe 	b.w	c000be8 <SPI2_IRQHandler>

0c000bec <USART1_IRQHandler>:
 c000bec:	f7ff bffe 	b.w	c000bec <USART1_IRQHandler>

0c000bf0 <USART2_IRQHandler>:
 c000bf0:	f7ff bffe 	b.w	c000bf0 <USART2_IRQHandler>

0c000bf4 <USART3_IRQHandler>:
 c000bf4:	f7ff bffe 	b.w	c000bf4 <USART3_IRQHandler>

0c000bf8 <UART4_IRQHandler>:
 c000bf8:	f7ff bffe 	b.w	c000bf8 <UART4_IRQHandler>

0c000bfc <UART5_IRQHandler>:
 c000bfc:	f7ff bffe 	b.w	c000bfc <UART5_IRQHandler>

0c000c00 <LPUART1_IRQHandler>:
 c000c00:	f7ff bffe 	b.w	c000c00 <LPUART1_IRQHandler>

0c000c04 <LPTIM1_IRQHandler>:
 c000c04:	f7ff bffe 	b.w	c000c04 <LPTIM1_IRQHandler>

0c000c08 <LPTIM2_IRQHandler>:
 c000c08:	f7ff bffe 	b.w	c000c08 <LPTIM2_IRQHandler>

0c000c0c <TIM15_IRQHandler>:
 c000c0c:	f7ff bffe 	b.w	c000c0c <TIM15_IRQHandler>

0c000c10 <TIM16_IRQHandler>:
 c000c10:	f7ff bffe 	b.w	c000c10 <TIM16_IRQHandler>

0c000c14 <TIM17_IRQHandler>:
 c000c14:	f7ff bffe 	b.w	c000c14 <TIM17_IRQHandler>

0c000c18 <COMP_IRQHandler>:
 c000c18:	f7ff bffe 	b.w	c000c18 <COMP_IRQHandler>

0c000c1c <USB_FS_IRQHandler>:
 c000c1c:	f7ff bffe 	b.w	c000c1c <USB_FS_IRQHandler>

0c000c20 <CRS_IRQHandler>:
 c000c20:	f7ff bffe 	b.w	c000c20 <CRS_IRQHandler>

0c000c24 <FMC_IRQHandler>:
 c000c24:	f7ff bffe 	b.w	c000c24 <FMC_IRQHandler>

0c000c28 <OCTOSPI1_IRQHandler>:
 c000c28:	f7ff bffe 	b.w	c000c28 <OCTOSPI1_IRQHandler>

0c000c2c <SDMMC1_IRQHandler>:
 c000c2c:	f7ff bffe 	b.w	c000c2c <SDMMC1_IRQHandler>

0c000c30 <DMA2_Channel1_IRQHandler>:
 c000c30:	f7ff bffe 	b.w	c000c30 <DMA2_Channel1_IRQHandler>

0c000c34 <DMA2_Channel2_IRQHandler>:
 c000c34:	f7ff bffe 	b.w	c000c34 <DMA2_Channel2_IRQHandler>

0c000c38 <DMA2_Channel3_IRQHandler>:
 c000c38:	f7ff bffe 	b.w	c000c38 <DMA2_Channel3_IRQHandler>

0c000c3c <DMA2_Channel4_IRQHandler>:
 c000c3c:	f7ff bffe 	b.w	c000c3c <DMA2_Channel4_IRQHandler>

0c000c40 <DMA2_Channel5_IRQHandler>:
 c000c40:	f7ff bffe 	b.w	c000c40 <DMA2_Channel5_IRQHandler>

0c000c44 <DMA2_Channel6_IRQHandler>:
 c000c44:	f7ff bffe 	b.w	c000c44 <DMA2_Channel6_IRQHandler>

0c000c48 <DMA2_Channel7_IRQHandler>:
 c000c48:	f7ff bffe 	b.w	c000c48 <DMA2_Channel7_IRQHandler>

0c000c4c <DMA2_Channel8_IRQHandler>:
 c000c4c:	f7ff bffe 	b.w	c000c4c <DMA2_Channel8_IRQHandler>

0c000c50 <I2C3_EV_IRQHandler>:
 c000c50:	f7ff bffe 	b.w	c000c50 <I2C3_EV_IRQHandler>

0c000c54 <I2C3_ER_IRQHandler>:
 c000c54:	f7ff bffe 	b.w	c000c54 <I2C3_ER_IRQHandler>

0c000c58 <SAI1_IRQHandler>:
 c000c58:	f7ff bffe 	b.w	c000c58 <SAI1_IRQHandler>

0c000c5c <SAI2_IRQHandler>:
 c000c5c:	f7ff bffe 	b.w	c000c5c <SAI2_IRQHandler>

0c000c60 <TSC_IRQHandler>:
 c000c60:	f7ff bffe 	b.w	c000c60 <TSC_IRQHandler>

0c000c64 <RNG_IRQHandler>:
 c000c64:	f7ff bffe 	b.w	c000c64 <RNG_IRQHandler>

0c000c68 <FPU_IRQHandler>:
 c000c68:	f7ff bffe 	b.w	c000c68 <FPU_IRQHandler>

0c000c6c <LPTIM3_IRQHandler>:
 c000c6c:	f7ff bffe 	b.w	c000c6c <LPTIM3_IRQHandler>

0c000c70 <SPI3_IRQHandler>:
 c000c70:	f7ff bffe 	b.w	c000c70 <SPI3_IRQHandler>

0c000c74 <I2C4_ER_IRQHandler>:
 c000c74:	f7ff bffe 	b.w	c000c74 <I2C4_ER_IRQHandler>

0c000c78 <I2C4_EV_IRQHandler>:
 c000c78:	f7ff bffe 	b.w	c000c78 <I2C4_EV_IRQHandler>

0c000c7c <DFSDM1_FLT0_IRQHandler>:
 c000c7c:	f7ff bffe 	b.w	c000c7c <DFSDM1_FLT0_IRQHandler>

0c000c80 <DFSDM1_FLT1_IRQHandler>:
 c000c80:	f7ff bffe 	b.w	c000c80 <DFSDM1_FLT1_IRQHandler>

0c000c84 <DFSDM1_FLT2_IRQHandler>:
 c000c84:	f7ff bffe 	b.w	c000c84 <DFSDM1_FLT2_IRQHandler>

0c000c88 <DFSDM1_FLT3_IRQHandler>:
 c000c88:	f7ff bffe 	b.w	c000c88 <DFSDM1_FLT3_IRQHandler>

0c000c8c <UCPD1_IRQHandler>:
 c000c8c:	f7ff bffe 	b.w	c000c8c <UCPD1_IRQHandler>

0c000c90 <ICACHE_IRQHandler>:
 c000c90:	f7ff bffe 	b.w	c000c90 <ICACHE_IRQHandler>

0c000c94 <OTFDEC1_IRQHandler>:
 c000c94:	f7ff bffe 	b.w	c000c94 <OTFDEC1_IRQHandler>

0c000c98 <CalculateCrc>:
  * @param  CRCx CRC Instance
  * @retval None
  */
__STATIC_INLINE void LL_CRC_ResetCRCCalculationUnit(CRC_TypeDef *CRCx)
{
  SET_BIT(CRCx->CR, CRC_CR_RESET);
 c000c98:	4b0f      	ldr	r3, [pc, #60]	; (c000cd8 <CalculateCrc+0x40>)
  * @param  Data value of  the eeprom variable.
  * @param  VirtAddress address of the eeprom variable.
  * @retval 16-bit CRC value computed on Data and Virtual Address.
  */
static uint16_t CalculateCrc(NVCNT_DATA_TYPE Data, uint16_t VirtAddress)
{
 c000c9a:	b513      	push	{r0, r1, r4, lr}
 c000c9c:	689a      	ldr	r2, [r3, #8]
 c000c9e:	f042 0201 	orr.w	r2, r2, #1
 c000ca2:	609a      	str	r2, [r3, #8]
  * @retval None
*/
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB1ENR, Periphs);
 c000ca4:	4a0d      	ldr	r2, [pc, #52]	; (c000cdc <CalculateCrc+0x44>)
 c000ca6:	6c94      	ldr	r4, [r2, #72]	; 0x48
 c000ca8:	f444 5480 	orr.w	r4, r4, #4096	; 0x1000
 c000cac:	6494      	str	r4, [r2, #72]	; 0x48
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 c000cae:	6c92      	ldr	r2, [r2, #72]	; 0x48
 c000cb0:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 c000cb4:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 c000cb6:	9a01      	ldr	r2, [sp, #4]
  * @param  PolynomCoef Value to be programmed in Programmable Polynomial value register
  * @retval None
  */
__STATIC_INLINE void LL_CRC_SetPolynomialCoef(CRC_TypeDef *CRCx, uint32_t PolynomCoef)
{
  WRITE_REG(CRCx->POL, PolynomCoef);
 c000cb8:	f248 0205 	movw	r2, #32773	; 0x8005
 c000cbc:	615a      	str	r2, [r3, #20]
  MODIFY_REG(CRCx->CR, CRC_CR_POLYSIZE, PolySize);
 c000cbe:	689a      	ldr	r2, [r3, #8]
 c000cc0:	f022 0218 	bic.w	r2, r2, #24
 c000cc4:	f042 0208 	orr.w	r2, r2, #8
 c000cc8:	609a      	str	r2, [r3, #8]
  * @param  InData value to be provided to CRC calculator between between Min_Data=0 and Max_Data=0xFFFFFFFF
  * @retval None
  */
__STATIC_INLINE void LL_CRC_FeedData32(CRC_TypeDef *CRCx, uint32_t InData)
{
  WRITE_REG(CRCx->DR, InData);
 c000cca:	6018      	str	r0, [r3, #0]
__STATIC_INLINE void LL_CRC_FeedData16(CRC_TypeDef *CRCx, uint16_t InData)
{
  __IO uint16_t *pReg;

  pReg = (__IO uint16_t *)(__IO void *)(&CRCx->DR);                             /* Derogation MisraC2012 R.11.5 */
  *pReg = InData;
 c000ccc:	8019      	strh	r1, [r3, #0]
  * @param  CRCx CRC Instance
  * @retval Current CRC calculation result as stored in CRC_DR register (16 bits).
  */
__STATIC_INLINE uint16_t LL_CRC_ReadData16(CRC_TypeDef *CRCx)
{
  return (uint16_t)READ_REG(CRCx->DR);
 c000cce:	6818      	ldr	r0, [r3, #0]
  LL_CRC_FeedData32(CRC, Data);
  LL_CRC_FeedData16(CRC, VirtAddress);

  /* Return computed CRC value */
  return (LL_CRC_ReadData16(CRC));
}
 c000cd0:	b280      	uxth	r0, r0
 c000cd2:	b002      	add	sp, #8
 c000cd4:	bd10      	pop	{r4, pc}
 c000cd6:	bf00      	nop
 c000cd8:	50023000 	.word	0x50023000
 c000cdc:	50021000 	.word	0x50021000

0c000ce0 <tfm_plat_read_nv_counter>:
{
 c000ce0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c000ce4:	2300      	movs	r3, #0
{
 c000ce6:	4691      	mov	r9, r2
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c000ce8:	2200      	movs	r2, #0
  if (size < sizeof(NVCNT_DATA_TYPE))
 c000cea:	2903      	cmp	r1, #3
{
 c000cec:	4680      	mov	r8, r0
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c000cee:	e9cd 2300 	strd	r2, r3, [sp]
  if (size < sizeof(NVCNT_DATA_TYPE))
 c000cf2:	d934      	bls.n	c000d5e <tfm_plat_read_nv_counter+0x7e>
  uint32_t previous_value = 0;
 c000cf4:	2600      	movs	r6, #0
 c000cf6:	f64c 75f8 	movw	r5, #53240	; 0xcff8
  uint32_t found = 0;
 c000cfa:	4634      	mov	r4, r6
    err = FLASH_DEV_NAME.ReadData(BL2_NV_COUNTERS_AREA_ADDR + counter, &addressvalue,
 c000cfc:	4b19      	ldr	r3, [pc, #100]	; (c000d64 <tfm_plat_read_nv_counter+0x84>)
 c000cfe:	695f      	ldr	r7, [r3, #20]
 c000d00:	2208      	movs	r2, #8
 c000d02:	4669      	mov	r1, sp
 c000d04:	4628      	mov	r0, r5
 c000d06:	47b8      	blx	r7
    if ((err == ARM_DRIVER_OK) && (addressvalue != NVCNT_PAGESTAT_ERASED))
 c000d08:	b9e8      	cbnz	r0, c000d46 <tfm_plat_read_nv_counter+0x66>
 c000d0a:	e9dd 2300 	ldrd	r2, r3, [sp]
 c000d0e:	1c59      	adds	r1, r3, #1
 c000d10:	bf08      	it	eq
 c000d12:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 c000d16:	d016      	beq.n	c000d46 <tfm_plat_read_nv_counter+0x66>
      if (addressvalue == 0)
 c000d18:	ea52 0103 	orrs.w	r1, r2, r3
 c000d1c:	d103      	bne.n	c000d26 <tfm_plat_read_nv_counter+0x46>
        return TFM_PLAT_ERR_SYSTEM_ERR;
 c000d1e:	2001      	movs	r0, #1
}
 c000d20:	b003      	add	sp, #12
 c000d22:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (NVCNT_ID_VALUE(addressvalue) == counter_id)
 c000d26:	b291      	uxth	r1, r2
 c000d28:	4541      	cmp	r1, r8
 c000d2a:	d10c      	bne.n	c000d46 <tfm_plat_read_nv_counter+0x66>
        crc = CalculateCrc(NVCNT_DATA_VALUE(addressvalue), NVCNT_ID_VALUE(addressvalue));
 c000d2c:	4618      	mov	r0, r3
 c000d2e:	f7ff ffb3 	bl	c000c98 <CalculateCrc>
        if (crc == NVCNT_CRC_VALUE(addressvalue))
 c000d32:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 c000d36:	9b01      	ldr	r3, [sp, #4]
 c000d38:	4290      	cmp	r0, r2
 c000d3a:	d104      	bne.n	c000d46 <tfm_plat_read_nv_counter+0x66>
          if (found != 1)
 c000d3c:	b95c      	cbnz	r4, c000d56 <tfm_plat_read_nv_counter+0x76>
 c000d3e:	461e      	mov	r6, r3
            found = 1;
 c000d40:	2401      	movs	r4, #1
            *((uint32_t *)val) = NVCNT_DATA_VALUE(addressvalue);
 c000d42:	f8c9 3000 	str.w	r3, [r9]
  while (counter >= PAGE_HEADER_SIZE)
 c000d46:	f24c 0338 	movw	r3, #49208	; 0xc038
 c000d4a:	3d08      	subs	r5, #8
 c000d4c:	429d      	cmp	r5, r3
 c000d4e:	d1d7      	bne.n	c000d00 <tfm_plat_read_nv_counter+0x20>
 c000d50:	f084 0001 	eor.w	r0, r4, #1
 c000d54:	e7e4      	b.n	c000d20 <tfm_plat_read_nv_counter+0x40>
            if (current_value >= previous_value)
 c000d56:	42b3      	cmp	r3, r6
 c000d58:	d2e1      	bcs.n	c000d1e <tfm_plat_read_nv_counter+0x3e>
 c000d5a:	461e      	mov	r6, r3
 c000d5c:	e7f3      	b.n	c000d46 <tfm_plat_read_nv_counter+0x66>
    return TFM_PLAT_ERR_INVALID_INPUT;
 c000d5e:	2003      	movs	r0, #3
 c000d60:	e7de      	b.n	c000d20 <tfm_plat_read_nv_counter+0x40>
 c000d62:	bf00      	nop
 c000d64:	0c00a054 	.word	0x0c00a054

0c000d68 <tfm_plat_init_nv_counter>:
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c000d68:	2200      	movs	r2, #0
 c000d6a:	2300      	movs	r3, #0
{
 c000d6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c000d70:	f44f 4640 	mov.w	r6, #49152	; 0xc000
  bool readstatus = true;
 c000d74:	2701      	movs	r7, #1
{
 c000d76:	b089      	sub	sp, #36	; 0x24
    err = FLASH_DEV_NAME.ReadData(Address + counter, &addressvalue,
 c000d78:	4c7b      	ldr	r4, [pc, #492]	; (c000f68 <tfm_plat_init_nv_counter+0x200>)
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c000d7a:	e9cd 2302 	strd	r2, r3, [sp, #8]
    err = FLASH_DEV_NAME.ReadData(Address + counter, &addressvalue,
 c000d7e:	6965      	ldr	r5, [r4, #20]
 c000d80:	2208      	movs	r2, #8
 c000d82:	a906      	add	r1, sp, #24
 c000d84:	4630      	mov	r0, r6
 c000d86:	47a8      	blx	r5
    if ((err != ARM_DRIVER_OK) || (addressvalue != NVCNT_PAGESTAT_ERASED))
 c000d88:	2800      	cmp	r0, #0
 c000d8a:	d140      	bne.n	c000e0e <tfm_plat_init_nv_counter+0xa6>
 c000d8c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
      readstatus = false;
 c000d90:	3301      	adds	r3, #1
 c000d92:	bf0c      	ite	eq
 c000d94:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 c000d98:	2700      	movne	r7, #0
 c000d9a:	3608      	adds	r6, #8
  while (counter < PageSize)
 c000d9c:	f5b6 4f50 	cmp.w	r6, #53248	; 0xd000
 c000da0:	d1ee      	bne.n	c000d80 <tfm_plat_init_nv_counter+0x18>
 c000da2:	4e72      	ldr	r6, [pc, #456]	; (c000f6c <tfm_plat_init_nv_counter+0x204>)
  if (VerifyPageFullyErased(BL2_NV_COUNTERS_AREA_ADDR, BL2_NV_COUNTERS_AREA_SIZE))
 c000da4:	2f00      	cmp	r7, #0
 c000da6:	f000 80b9 	beq.w	c000f1c <tfm_plat_init_nv_counter+0x1b4>
  {
    /* store in revert order , read is done in revert at the end all is in order */
    /* compute crc */
    crc = CalculateCrc(huk[loop], huk_random_id);
    /*  build element  */
    element = NVCNT_ELEMENT_VALUE(huk_random_id, huk[loop], crc);
 c000daa:	f04f 0900 	mov.w	r9, #0
 c000dae:	f04f 0a00 	mov.w	sl, #0
 c000db2:	f644 0855 	movw	r8, #18517	; 0x4855
    HAL_Delay(500);
 c000db6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 c000dba:	f001 f9f3 	bl	c0021a4 <HAL_Delay>
    BOOT_LOG_INF("Initializing BL2 NV area : Power down/reset not supported...");
 c000dbe:	486c      	ldr	r0, [pc, #432]	; (c000f70 <tfm_plat_init_nv_counter+0x208>)
 c000dc0:	f007 fdc6 	bl	c008950 <puts>
  huk[0] = NVCNT_HEADER_VALUE;
 c000dc4:	9600      	str	r6, [sp, #0]
    crc = CalculateCrc(huk[loop], huk_random_id);
 c000dc6:	f644 0155 	movw	r1, #18517	; 0x4855
 c000dca:	9800      	ldr	r0, [sp, #0]
 c000dcc:	f7ff ff64 	bl	c000c98 <CalculateCrc>
    element = NVCNT_ELEMENT_VALUE(huk_random_id, huk[loop], crc);
 c000dd0:	9900      	ldr	r1, [sp, #0]
 c000dd2:	ea4a 0208 	orr.w	r2, sl, r8
 c000dd6:	ea41 0309 	orr.w	r3, r1, r9
 c000dda:	4698      	mov	r8, r3
 c000ddc:	0400      	lsls	r0, r0, #16
 c000dde:	ea42 0700 	orr.w	r7, r2, r0
 c000de2:	a908      	add	r1, sp, #32
    /* write element  */
    err = FLASH_DEV_NAME.ProgramData(address,
 c000de4:	2208      	movs	r2, #8
    element = NVCNT_ELEMENT_VALUE(huk_random_id, huk[loop], crc);
 c000de6:	e961 7804 	strd	r7, r8, [r1, #-16]!
    err = FLASH_DEV_NAME.ProgramData(address,
 c000dea:	f8d4 a018 	ldr.w	sl, [r4, #24]
 c000dee:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 c000df2:	47d0      	blx	sl
    address += sizeof(NVCNT_ELEMENT_TYPE);
    loop--;
  }

  /* clean huk footprint  */
  element = 0;
 c000df4:	2200      	movs	r2, #0
 c000df6:	2300      	movs	r3, #0
 c000df8:	e9cd 2304 	strd	r2, r3, [sp, #16]
  memset((void *)huk, 0, sizeof(huk));
  if (err == ARM_DRIVER_OK)
 c000dfc:	b148      	cbz	r0, c000e12 <tfm_plat_init_nv_counter+0xaa>
      BOOT_LOG_ERR("Init BL2 NV Header area: Failed");
 c000dfe:	485d      	ldr	r0, [pc, #372]	; (c000f74 <tfm_plat_init_nv_counter+0x20c>)
    BOOT_LOG_ERR("Wrong BL2 NV Area header");
 c000e00:	f007 fda6 	bl	c008950 <puts>
    return TFM_PLAT_ERR_SYSTEM_ERR;
 c000e04:	2401      	movs	r4, #1
}
 c000e06:	4620      	mov	r0, r4
 c000e08:	b009      	add	sp, #36	; 0x24
 c000e0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      readstatus = false;
 c000e0e:	2700      	movs	r7, #0
 c000e10:	e7c3      	b.n	c000d9a <tfm_plat_init_nv_counter+0x32>
    BOOT_LOG_INF("Init BL2 NV Header area: Done");
 c000e12:	4859      	ldr	r0, [pc, #356]	; (c000f78 <tfm_plat_init_nv_counter+0x210>)
 c000e14:	f007 fd9c 	bl	c008950 <puts>
    BOOT_LOG_INF("Initializing BL2 NV Counters");
 c000e18:	4858      	ldr	r0, [pc, #352]	; (c000f7c <tfm_plat_init_nv_counter+0x214>)
 c000e1a:	f007 fd99 	bl	c008950 <puts>
 c000e1e:	f04f 0803 	mov.w	r8, #3
 c000e22:	f04f 0900 	mov.w	r9, #0
  /* initialize only one counter */
  for (counter_id = PLAT_NV_COUNTER_3; counter_id < PLAT_NV_COUNTER_MAX; counter_id++)
  {

    /* Check if pages are full, i.e. max number of written elements achieved */
    if (uhNbWrittenElements >= NVCNT_MAX_WRITTEN_ELEMENTS)
 c000e26:	4c56      	ldr	r4, [pc, #344]	; (c000f80 <tfm_plat_init_nv_counter+0x218>)
    /* Calculate crc of variable data and virtual address */
    crc = CalculateCrc(data, counter_id);
    /*  build element  */
    element = NVCNT_ELEMENT_VALUE(counter_id, data, crc);
    /* Program variable data + virtual address + crc */
    err = FLASH_DEV_NAME.ProgramData(BL2_NV_COUNTERS_AREA_ADDR + uwAddressNextWrite,
 c000e28:	4f56      	ldr	r7, [pc, #344]	; (c000f84 <tfm_plat_init_nv_counter+0x21c>)
    if (uhNbWrittenElements >= NVCNT_MAX_WRITTEN_ELEMENTS)
 c000e2a:	6823      	ldr	r3, [r4, #0]
 c000e2c:	f5b3 7ffc 	cmp.w	r3, #504	; 0x1f8
 c000e30:	d26c      	bcs.n	c000f0c <tfm_plat_init_nv_counter+0x1a4>
    crc = CalculateCrc(data, counter_id);
 c000e32:	fa1f f188 	uxth.w	r1, r8
 c000e36:	2000      	movs	r0, #0
 c000e38:	f7ff ff2e 	bl	c000c98 <CalculateCrc>
    element = NVCNT_ELEMENT_VALUE(counter_id, data, crc);
 c000e3c:	464b      	mov	r3, r9
 c000e3e:	0400      	lsls	r0, r0, #16
 c000e40:	ea48 0200 	orr.w	r2, r8, r0
    err = FLASH_DEV_NAME.ProgramData(BL2_NV_COUNTERS_AREA_ADDR + uwAddressNextWrite,
 c000e44:	6838      	ldr	r0, [r7, #0]
    element = NVCNT_ELEMENT_VALUE(counter_id, data, crc);
 c000e46:	e9cd 2306 	strd	r2, r3, [sp, #24]
    err = FLASH_DEV_NAME.ProgramData(BL2_NV_COUNTERS_AREA_ADDR + uwAddressNextWrite,
 c000e4a:	a906      	add	r1, sp, #24
 c000e4c:	2208      	movs	r2, #8
 c000e4e:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
 c000e52:	47d0      	blx	sl
                                     &element,
                                     NVCNT_ELEMENT_SIZE);
    /* If program operation was failed, a Flash error code is returned */
    if (err != ARM_DRIVER_OK)
 c000e54:	2800      	cmp	r0, #0
 c000e56:	d159      	bne.n	c000f0c <tfm_plat_init_nv_counter+0x1a4>
    {
      return false;
    }

    /* Increment global variables relative to write operation done*/
    uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c000e58:	683b      	ldr	r3, [r7, #0]
  for (counter_id = PLAT_NV_COUNTER_3; counter_id < PLAT_NV_COUNTER_MAX; counter_id++)
 c000e5a:	f1b9 0f00 	cmp.w	r9, #0
    uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c000e5e:	f103 0308 	add.w	r3, r3, #8
 c000e62:	603b      	str	r3, [r7, #0]
    uhNbWrittenElements++;
 c000e64:	6823      	ldr	r3, [r4, #0]
  for (counter_id = PLAT_NV_COUNTER_3; counter_id < PLAT_NV_COUNTER_MAX; counter_id++)
 c000e66:	bf08      	it	eq
 c000e68:	f1b8 0f04 	cmpeq.w	r8, #4
    uhNbWrittenElements++;
 c000e6c:	f103 0301 	add.w	r3, r3, #1
 c000e70:	6023      	str	r3, [r4, #0]
  for (counter_id = PLAT_NV_COUNTER_3; counter_id < PLAT_NV_COUNTER_MAX; counter_id++)
 c000e72:	d04d      	beq.n	c000f10 <tfm_plat_init_nv_counter+0x1a8>
 c000e74:	f04f 0804 	mov.w	r8, #4
 c000e78:	f04f 0900 	mov.w	r9, #0
 c000e7c:	e7d5      	b.n	c000e2a <tfm_plat_init_nv_counter+0xc2>
  BOOT_LOG_INF("Checking BL2 NV Counter consitency");
 c000e7e:	4842      	ldr	r0, [pc, #264]	; (c000f88 <tfm_plat_init_nv_counter+0x220>)
 c000e80:	f007 fd66 	bl	c008950 <puts>
  if (tfm_plat_read_nv_counter(PLAT_NV_COUNTER_3, sizeof(counter_value),
 c000e84:	aa06      	add	r2, sp, #24
 c000e86:	2104      	movs	r1, #4
 c000e88:	2003      	movs	r0, #3
 c000e8a:	f7ff ff29 	bl	c000ce0 <tfm_plat_read_nv_counter>
 c000e8e:	b120      	cbz	r0, c000e9a <tfm_plat_init_nv_counter+0x132>
    BOOT_LOG_ERR("NV Counter Not consitent %d", PLAT_NV_COUNTER_3);
 c000e90:	2103      	movs	r1, #3
    BOOT_LOG_ERR("NV Counter Not consitent %d", PLAT_NV_COUNTER_4);
 c000e92:	483e      	ldr	r0, [pc, #248]	; (c000f8c <tfm_plat_init_nv_counter+0x224>)
 c000e94:	f007 fce8 	bl	c008868 <iprintf>
 c000e98:	e7b4      	b.n	c000e04 <tfm_plat_init_nv_counter+0x9c>
  BOOT_LOG_INF("Consistent BL2 NV Counter %d  = 0x%x", PLAT_NV_COUNTER_3, counter_value);
 c000e9a:	9a06      	ldr	r2, [sp, #24]
 c000e9c:	2103      	movs	r1, #3
 c000e9e:	483c      	ldr	r0, [pc, #240]	; (c000f90 <tfm_plat_init_nv_counter+0x228>)
 c000ea0:	f007 fce2 	bl	c008868 <iprintf>
  if (tfm_plat_read_nv_counter(PLAT_NV_COUNTER_4, sizeof(counter_value),
 c000ea4:	2104      	movs	r1, #4
 c000ea6:	aa06      	add	r2, sp, #24
 c000ea8:	4608      	mov	r0, r1
 c000eaa:	f7ff ff19 	bl	c000ce0 <tfm_plat_read_nv_counter>
 c000eae:	4604      	mov	r4, r0
 c000eb0:	b108      	cbz	r0, c000eb6 <tfm_plat_init_nv_counter+0x14e>
    BOOT_LOG_ERR("NV Counter Not consitent %d", PLAT_NV_COUNTER_4);
 c000eb2:	2104      	movs	r1, #4
 c000eb4:	e7ed      	b.n	c000e92 <tfm_plat_init_nv_counter+0x12a>
  BOOT_LOG_INF("Consistent BL2 NV Counter %d  = 0x%x", PLAT_NV_COUNTER_4, counter_value);
 c000eb6:	9a06      	ldr	r2, [sp, #24]
 c000eb8:	2104      	movs	r1, #4
 c000eba:	4835      	ldr	r0, [pc, #212]	; (c000f90 <tfm_plat_init_nv_counter+0x228>)
 c000ebc:	f007 fcd4 	bl	c008868 <iprintf>
  uwAddressNextWrite = PAGE_HEADER_SIZE;
 c000ec0:	2340      	movs	r3, #64	; 0x40
 c000ec2:	f24c 0840 	movw	r8, #49216	; 0xc040
  uhNbWrittenElements = 0U;
 c000ec6:	4f2e      	ldr	r7, [pc, #184]	; (c000f80 <tfm_plat_init_nv_counter+0x218>)
  uwAddressNextWrite = PAGE_HEADER_SIZE;
 c000ec8:	4e2e      	ldr	r6, [pc, #184]	; (c000f84 <tfm_plat_init_nv_counter+0x21c>)
  uhNbWrittenElements = 0U;
 c000eca:	603c      	str	r4, [r7, #0]
  uwAddressNextWrite = PAGE_HEADER_SIZE;
 c000ecc:	6033      	str	r3, [r6, #0]
    err = FLASH_DEV_NAME.ReadData(BL2_NV_COUNTERS_AREA_ADDR + varidx, &addressvalue,
 c000ece:	2208      	movs	r2, #8
 c000ed0:	4640      	mov	r0, r8
 c000ed2:	eb0d 0102 	add.w	r1, sp, r2
 c000ed6:	47a8      	blx	r5
    if ((err == ARM_DRIVER_ERROR_SPECIFIC) || (addressvalue != NVCNT_MASK_FULL))
 c000ed8:	1d83      	adds	r3, r0, #6
 c000eda:	d006      	beq.n	c000eea <tfm_plat_init_nv_counter+0x182>
 c000edc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 c000ee0:	3301      	adds	r3, #1
 c000ee2:	bf08      	it	eq
 c000ee4:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 c000ee8:	d00c      	beq.n	c000f04 <tfm_plat_init_nv_counter+0x19c>
      uhNbWrittenElements++;
 c000eea:	683b      	ldr	r3, [r7, #0]
 c000eec:	f108 0808 	add.w	r8, r8, #8
 c000ef0:	3301      	adds	r3, #1
 c000ef2:	603b      	str	r3, [r7, #0]
      uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c000ef4:	6833      	ldr	r3, [r6, #0]
  for (varidx = PAGE_HEADER_SIZE; varidx < BL2_NV_COUNTERS_AREA_SIZE; varidx += NVCNT_ELEMENT_SIZE)
 c000ef6:	f5b8 4f50 	cmp.w	r8, #53248	; 0xd000
      uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c000efa:	f103 0308 	add.w	r3, r3, #8
 c000efe:	6033      	str	r3, [r6, #0]
  for (varidx = PAGE_HEADER_SIZE; varidx < BL2_NV_COUNTERS_AREA_SIZE; varidx += NVCNT_ELEMENT_SIZE)
 c000f00:	d1e5      	bne.n	c000ece <tfm_plat_init_nv_counter+0x166>
 c000f02:	e780      	b.n	c000e06 <tfm_plat_init_nv_counter+0x9e>
      if (err != ARM_DRIVER_OK)
 c000f04:	1c04      	adds	r4, r0, #0
 c000f06:	bf18      	it	ne
 c000f08:	2401      	movne	r4, #1
 c000f0a:	e77c      	b.n	c000e06 <tfm_plat_init_nv_counter+0x9e>
      BOOT_LOG_ERR("Init BL2 NV counters : Failed");
 c000f0c:	4821      	ldr	r0, [pc, #132]	; (c000f94 <tfm_plat_init_nv_counter+0x22c>)
 c000f0e:	e777      	b.n	c000e00 <tfm_plat_init_nv_counter+0x98>
    BOOT_LOG_INF("Init BL2 NV counters to 0 : Done");
 c000f10:	4821      	ldr	r0, [pc, #132]	; (c000f98 <tfm_plat_init_nv_counter+0x230>)
 c000f12:	f007 fd1d 	bl	c008950 <puts>
    BOOT_LOG_INF("BL2 NV Area Initialized : Power Down/reset supported");
 c000f16:	4821      	ldr	r0, [pc, #132]	; (c000f9c <tfm_plat_init_nv_counter+0x234>)
 c000f18:	f007 fd1a 	bl	c008950 <puts>
  BOOT_LOG_INF("Checking BL2 NV area");
 c000f1c:	4820      	ldr	r0, [pc, #128]	; (c000fa0 <tfm_plat_init_nv_counter+0x238>)
 c000f1e:	f007 fd17 	bl	c008950 <puts>
  BOOT_LOG_INF("Checking BL2 NV area header");
 c000f22:	4820      	ldr	r0, [pc, #128]	; (c000fa4 <tfm_plat_init_nv_counter+0x23c>)
 c000f24:	f007 fd14 	bl	c008950 <puts>
    err = FLASH_DEV_NAME.ReadData(address, (void *)&addressvalue,
 c000f28:	2208      	movs	r2, #8
 c000f2a:	a906      	add	r1, sp, #24
 c000f2c:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 c000f30:	47a8      	blx	r5
    if ((err == ARM_DRIVER_OK) && (addressvalue != NVCNT_PAGESTAT_ERASED))
 c000f32:	4604      	mov	r4, r0
 c000f34:	b980      	cbnz	r0, c000f58 <tfm_plat_init_nv_counter+0x1f0>
 c000f36:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 c000f3a:	1c59      	adds	r1, r3, #1
 c000f3c:	bf08      	it	eq
 c000f3e:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 c000f42:	d009      	beq.n	c000f58 <tfm_plat_init_nv_counter+0x1f0>
      crc = CalculateCrc(NVCNT_DATA_VALUE(addressvalue), NVCNT_ID_VALUE(addressvalue));
 c000f44:	b291      	uxth	r1, r2
 c000f46:	4618      	mov	r0, r3
 c000f48:	f7ff fea6 	bl	c000c98 <CalculateCrc>
      if (crc == NVCNT_CRC_VALUE(addressvalue))
 c000f4c:	f8bd 201a 	ldrh.w	r2, [sp, #26]
 c000f50:	9b07      	ldr	r3, [sp, #28]
 c000f52:	4290      	cmp	r0, r2
 c000f54:	d101      	bne.n	c000f5a <tfm_plat_init_nv_counter+0x1f2>
        huk[loop] = NVCNT_DATA_VALUE(addressvalue);
 c000f56:	9301      	str	r3, [sp, #4]
    if ((err == ARM_DRIVER_OK) && (addressvalue != NVCNT_PAGESTAT_ERASED))
 c000f58:	2401      	movs	r4, #1
  if (huk[0] != NVCNT_HEADER_VALUE)
 c000f5a:	9b01      	ldr	r3, [sp, #4]
 c000f5c:	42b3      	cmp	r3, r6
 c000f5e:	d101      	bne.n	c000f64 <tfm_plat_init_nv_counter+0x1fc>
  if (!Check_Header())
 c000f60:	2c00      	cmp	r4, #0
 c000f62:	d18c      	bne.n	c000e7e <tfm_plat_init_nv_counter+0x116>
    BOOT_LOG_ERR("Wrong BL2 NV Area header");
 c000f64:	4810      	ldr	r0, [pc, #64]	; (c000fa8 <tfm_plat_init_nv_counter+0x240>)
 c000f66:	e74b      	b.n	c000e00 <tfm_plat_init_nv_counter+0x98>
 c000f68:	0c00a054 	.word	0x0c00a054
 c000f6c:	aaddeecc 	.word	0xaaddeecc
 c000f70:	0c009d68 	.word	0x0c009d68
 c000f74:	0c009dac 	.word	0x0c009dac
 c000f78:	0c009dd3 	.word	0x0c009dd3
 c000f7c:	0c009df8 	.word	0x0c009df8
 c000f80:	30030128 	.word	0x30030128
 c000f84:	30030000 	.word	0x30030000
 c000f88:	0c009e7b 	.word	0x0c009e7b
 c000f8c:	0c009ea5 	.word	0x0c009ea5
 c000f90:	0c009ec9 	.word	0x0c009ec9
 c000f94:	0c009ef6 	.word	0x0c009ef6
 c000f98:	0c009f1b 	.word	0x0c009f1b
 c000f9c:	0c009f43 	.word	0x0c009f43
 c000fa0:	0c009e1c 	.word	0x0c009e1c
 c000fa4:	0c009e38 	.word	0x0c009e38
 c000fa8:	0c009e5b 	.word	0x0c009e5b

0c000fac <tfm_plat_set_nv_counter>:
{
 c000fac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c000fb0:	b085      	sub	sp, #20
 c000fb2:	460d      	mov	r5, r1
  if ((tfm_plat_read_nv_counter(CounterId, sizeof(current_value), (uint8_t *)&current_value)
 c000fb4:	aa01      	add	r2, sp, #4
 c000fb6:	2104      	movs	r1, #4
{
 c000fb8:	4606      	mov	r6, r0
  if ((tfm_plat_read_nv_counter(CounterId, sizeof(current_value), (uint8_t *)&current_value)
 c000fba:	f7ff fe91 	bl	c000ce0 <tfm_plat_read_nv_counter>
 c000fbe:	4604      	mov	r4, r0
 c000fc0:	bb88      	cbnz	r0, c001026 <tfm_plat_set_nv_counter+0x7a>
       != TFM_PLAT_ERR_SUCCESS) || (Data < current_value))
 c000fc2:	9b01      	ldr	r3, [sp, #4]
 c000fc4:	42ab      	cmp	r3, r5
 c000fc6:	d82e      	bhi.n	c001026 <tfm_plat_set_nv_counter+0x7a>
  if (current_value == Data)
 c000fc8:	d029      	beq.n	c00101e <tfm_plat_set_nv_counter+0x72>
  if (uhNbWrittenElements >= NVCNT_MAX_WRITTEN_ELEMENTS)
 c000fca:	4f19      	ldr	r7, [pc, #100]	; (c001030 <tfm_plat_set_nv_counter+0x84>)
 c000fcc:	683b      	ldr	r3, [r7, #0]
 c000fce:	f5b3 7ffc 	cmp.w	r3, #504	; 0x1f8
 c000fd2:	d22a      	bcs.n	c00102a <tfm_plat_set_nv_counter+0x7e>
  crc = CalculateCrc(Data, CounterId);
 c000fd4:	4631      	mov	r1, r6
 c000fd6:	4628      	mov	r0, r5
 c000fd8:	f7ff fe5e 	bl	c000c98 <CalculateCrc>
  element = NVCNT_ELEMENT_VALUE(CounterId, Data, crc);
 c000fdc:	462b      	mov	r3, r5
 c000fde:	ea44 0806 	orr.w	r8, r4, r6
 c000fe2:	0400      	lsls	r0, r0, #16
 c000fe4:	ea48 0200 	orr.w	r2, r8, r0
  err = FLASH_DEV_NAME.ProgramData(BL2_NV_COUNTERS_AREA_ADDR + uwAddressNextWrite,
 c000fe8:	f8df 8050 	ldr.w	r8, [pc, #80]	; c00103c <tfm_plat_set_nv_counter+0x90>
  element = NVCNT_ELEMENT_VALUE(CounterId, Data, crc);
 c000fec:	a904      	add	r1, sp, #16
 c000fee:	e961 2302 	strd	r2, r3, [r1, #-8]!
  err = FLASH_DEV_NAME.ProgramData(BL2_NV_COUNTERS_AREA_ADDR + uwAddressNextWrite,
 c000ff2:	f8d8 0000 	ldr.w	r0, [r8]
 c000ff6:	4b0f      	ldr	r3, [pc, #60]	; (c001034 <tfm_plat_set_nv_counter+0x88>)
 c000ff8:	2208      	movs	r2, #8
 c000ffa:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
 c000ffe:	699b      	ldr	r3, [r3, #24]
 c001000:	4798      	blx	r3
  if (err != ARM_DRIVER_OK)
 c001002:	b980      	cbnz	r0, c001026 <tfm_plat_set_nv_counter+0x7a>
  uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c001004:	f8d8 3000 	ldr.w	r3, [r8]
  BOOT_LOG_INF("Counter %d set to 0x%x", CounterId, Data);
 c001008:	462a      	mov	r2, r5
  uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c00100a:	3308      	adds	r3, #8
 c00100c:	f8c8 3000 	str.w	r3, [r8]
  uhNbWrittenElements++;
 c001010:	683b      	ldr	r3, [r7, #0]
  BOOT_LOG_INF("Counter %d set to 0x%x", CounterId, Data);
 c001012:	4631      	mov	r1, r6
  uhNbWrittenElements++;
 c001014:	3301      	adds	r3, #1
  BOOT_LOG_INF("Counter %d set to 0x%x", CounterId, Data);
 c001016:	4808      	ldr	r0, [pc, #32]	; (c001038 <tfm_plat_set_nv_counter+0x8c>)
  uhNbWrittenElements++;
 c001018:	603b      	str	r3, [r7, #0]
  BOOT_LOG_INF("Counter %d set to 0x%x", CounterId, Data);
 c00101a:	f007 fc25 	bl	c008868 <iprintf>
}
 c00101e:	4620      	mov	r0, r4
 c001020:	b005      	add	sp, #20
 c001022:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return TFM_PLAT_ERR_SYSTEM_ERR;
 c001026:	2401      	movs	r4, #1
 c001028:	e7f9      	b.n	c00101e <tfm_plat_set_nv_counter+0x72>
    return TFM_PLAT_ERR_MAX_VALUE;
 c00102a:	2402      	movs	r4, #2
 c00102c:	e7f7      	b.n	c00101e <tfm_plat_set_nv_counter+0x72>
 c00102e:	bf00      	nop
 c001030:	30030128 	.word	0x30030128
 c001034:	0c00a054 	.word	0x0c00a054
 c001038:	0c009f7f 	.word	0x0c009f7f
 c00103c:	30030000 	.word	0x30030000

0c001040 <jumper>:
  * @brief  jumper;
  * @param  arm_vector_table *vt
  * @retval None
  */
void jumper(struct arm_vector_table *vt)
{
 c001040:	4604      	mov	r4, r0
 c001042:	b507      	push	{r0, r1, r2, lr}
     */
#if !defined(TFM_HDP_PROTECT_ENABLE)
  static struct arm_vector_table *vt_cpy;
#endif /* !defined(TFM_HDP_PROTECT_ENABLE)*/
#ifdef TFM_BOOT_MPU_PROTECTION
  mpu_config_appli();
 c001044:	f000 fcb8 	bl	c0019b8 <mpu_config_appli>
#endif /* TFM_BOOT_MPU_PROTECTION */
  /* set the secure vector */
  SCB->VTOR = (uint32_t)vt;
 c001048:	4b12      	ldr	r3, [pc, #72]	; (c001094 <jumper+0x54>)
	{
		pt = SRAM2_CFG[index];
#if 0
	  BOOT_LOG_INF("SRAM2 write protection [0x%x] : %x", pt, val[index]);
#endif
		*pt = val[index];
 c00104a:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 c00104e:	609c      	str	r4, [r3, #8]
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 c001050:	4b11      	ldr	r3, [pc, #68]	; (c001098 <jumper+0x58>)
 c001052:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 c001054:	f042 0201 	orr.w	r2, r2, #1
 c001058:	661a      	str	r2, [r3, #96]	; 0x60
 c00105a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
		*pt = val[index];
 c00105c:	4a0f      	ldr	r2, [pc, #60]	; (c00109c <jumper+0x5c>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 c00105e:	f003 0301 	and.w	r3, r3, #1
 c001062:	9301      	str	r3, [sp, #4]
 c001064:	9b01      	ldr	r3, [sp, #4]
		*pt = val[index];
 c001066:	2300      	movs	r3, #0
 c001068:	6013      	str	r3, [r2, #0]
 c00106a:	6051      	str	r1, [r2, #4]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 c00106c:	f383 880a 	msr	MSPLIM, r3
  if (BL_ID == (0xd0))
 c001070:	4b0b      	ldr	r3, [pc, #44]	; (c0010a0 <jumper+0x60>)
 c001072:	7819      	ldrb	r1, [r3, #0]
 c001074:	29d0      	cmp	r1, #208	; 0xd0
 c001076:	d103      	bne.n	c001080 <jumper+0x40>
    BOOT_LOG_ERR("Wrong BootLoader version: 0x%1x, HDP (switch TFM_HDP_PROTECT_ENABLE) must be disabled",
 c001078:	480a      	ldr	r0, [pc, #40]	; (c0010a4 <jumper+0x64>)
 c00107a:	f007 fbf5 	bl	c008868 <iprintf>
 c00107e:	e7fe      	b.n	c00107e <jumper+0x3e>
 c001080:	4b09      	ldr	r3, [pc, #36]	; (c0010a8 <jumper+0x68>)
  else if (BL_ID == (0x90))
 c001082:	2990      	cmp	r1, #144	; 0x90
    RSSLIB_PFUNC->S.CloseExitHDP_BL90(hdp_area, VectorTableAddr);
 c001084:	bf0c      	ite	eq
 c001086:	6a1b      	ldreq	r3, [r3, #32]
    RSSLIB_PFUNC->S.CloseExitHDP_BL91(hdp_area, VectorTableAddr);
 c001088:	6a9b      	ldrne	r3, [r3, #40]	; 0x28
 c00108a:	4621      	mov	r1, r4
 c00108c:	2001      	movs	r0, #1
 c00108e:	4798      	blx	r3
 c001090:	e7f5      	b.n	c00107e <jumper+0x3e>
 c001092:	bf00      	nop
 c001094:	e000ed00 	.word	0xe000ed00
 c001098:	50021000 	.word	0x50021000
 c00109c:	50010020 	.word	0x50010020
 c0010a0:	0bf97ffe 	.word	0x0bf97ffe
 c0010a4:	0c009f9e 	.word	0x0c009f9e
 c0010a8:	0bf97f40 	.word	0x0bf97f40

0c0010ac <USART_GetVersion>:
  0  /* Reserved */
};

static ARM_DRIVER_VERSION USART_GetVersion(void)
{
  return DriverVersion;
 c0010ac:	4b03      	ldr	r3, [pc, #12]	; (c0010bc <USART_GetVersion+0x10>)
{
 c0010ae:	b082      	sub	sp, #8
  return DriverVersion;
 c0010b0:	6818      	ldr	r0, [r3, #0]
 c0010b2:	b283      	uxth	r3, r0
}
 c0010b4:	f363 000f 	bfi	r0, r3, #0, #16
 c0010b8:	b002      	add	sp, #8
 c0010ba:	4770      	bx	lr
 c0010bc:	0c009ffc 	.word	0x0c009ffc

0c0010c0 <USART_GetCapabilities>:

static ARM_USART_CAPABILITIES USART_GetCapabilities(void)
{
  return DriverCapabilities;
}
 c0010c0:	2001      	movs	r0, #1
 c0010c2:	4770      	bx	lr

0c0010c4 <USART0_Uninitialize>:

static int32_t USART0_Uninitialize(void)
{
  /* Nothing to be done */
  return ARM_DRIVER_OK;
}
 c0010c4:	2000      	movs	r0, #0
 c0010c6:	4770      	bx	lr

0c0010c8 <USART0_PowerControl>:

static int32_t USART0_PowerControl(ARM_POWER_STATE state)
{
  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c0010c8:	f06f 0003 	mvn.w	r0, #3
 c0010cc:	4770      	bx	lr

0c0010ce <USART0_Transfer>:
  ARG_UNUSED(data_out);
  ARG_UNUSED(data_in);
  ARG_UNUSED(num);

  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c0010ce:	f06f 0003 	mvn.w	r0, #3
 c0010d2:	4770      	bx	lr

0c0010d4 <USART0_GetTxCount>:

static uint32_t USART0_GetTxCount(void)
{
  return (uint32_t)ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c0010d4:	f06f 0003 	mvn.w	r0, #3
 c0010d8:	4770      	bx	lr

0c0010da <USART0_Control>:
  return (uint32_t)ARM_DRIVER_ERROR_UNSUPPORTED;
}
static int32_t USART0_Control(uint32_t control, uint32_t arg)
{
  return ARM_DRIVER_OK;
}
 c0010da:	2000      	movs	r0, #0
 c0010dc:	4770      	bx	lr

0c0010de <USART0_GetStatus>:

static ARM_USART_STATUS USART0_GetStatus(void)
{
  ARM_USART_STATUS status = {0, 0, 0, 0, 0, 0, 0, 0};
 c0010de:	2300      	movs	r3, #0
{
 c0010e0:	b082      	sub	sp, #8
  ARM_USART_STATUS status = {0, 0, 0, 0, 0, 0, 0, 0};
 c0010e2:	9301      	str	r3, [sp, #4]
  return status;
 c0010e4:	9801      	ldr	r0, [sp, #4]
}
 c0010e6:	b002      	add	sp, #8
 c0010e8:	4770      	bx	lr

0c0010ea <USART0_GetModemStatus>:
  return ARM_DRIVER_ERROR_UNSUPPORTED;
}

static ARM_USART_MODEM_STATUS USART0_GetModemStatus(void)
{
  ARM_USART_MODEM_STATUS modem_status = {0, 0, 0, 0, 0};
 c0010ea:	2300      	movs	r3, #0
{
 c0010ec:	b082      	sub	sp, #8
  ARM_USART_MODEM_STATUS modem_status = {0, 0, 0, 0, 0};
 c0010ee:	9301      	str	r3, [sp, #4]
  return modem_status;
 c0010f0:	9801      	ldr	r0, [sp, #4]
}
 c0010f2:	b002      	add	sp, #8
 c0010f4:	4770      	bx	lr
	...

0c0010f8 <USART0_Receive>:
{
 c0010f8:	b510      	push	{r4, lr}
 c0010fa:	460c      	mov	r4, r1
  if ((data == NULL) || (num == 0U))
 c0010fc:	4601      	mov	r1, r0
 c0010fe:	b130      	cbz	r0, c00110e <USART0_Receive+0x16>
 c001100:	b12c      	cbz	r4, c00110e <USART0_Receive+0x16>
  HAL_UART_Receive_IT(&uart_device, data, num);
 c001102:	b2a2      	uxth	r2, r4
 c001104:	4803      	ldr	r0, [pc, #12]	; (c001114 <USART0_Receive+0x1c>)
 c001106:	f003 f98b 	bl	c004420 <HAL_UART_Receive_IT>
  return num;
 c00110a:	4620      	mov	r0, r4
}
 c00110c:	bd10      	pop	{r4, pc}
    return ARM_DRIVER_ERROR_PARAMETER;
 c00110e:	f06f 0004 	mvn.w	r0, #4
 c001112:	e7fb      	b.n	c00110c <USART0_Receive+0x14>
 c001114:	3003012c 	.word	0x3003012c

0c001118 <USART0_Send>:
{
 c001118:	b508      	push	{r3, lr}
  if ((data == NULL) || (num == 0U))
 c00111a:	b148      	cbz	r0, c001130 <USART0_Send+0x18>
 c00111c:	b141      	cbz	r1, c001130 <USART0_Send+0x18>
  HAL_UART_Transmit(&uart_device, (uint8_t *) data, num,  1000);
 c00111e:	b28a      	uxth	r2, r1
 c001120:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 c001124:	4601      	mov	r1, r0
 c001126:	4804      	ldr	r0, [pc, #16]	; (c001138 <USART0_Send+0x20>)
 c001128:	f004 f88e 	bl	c005248 <HAL_UART_Transmit>
  return ARM_DRIVER_OK;
 c00112c:	2000      	movs	r0, #0
}
 c00112e:	bd08      	pop	{r3, pc}
    return ARM_DRIVER_ERROR_PARAMETER;
 c001130:	f06f 0004 	mvn.w	r0, #4
 c001134:	e7fb      	b.n	c00112e <USART0_Send+0x16>
 c001136:	bf00      	nop
 c001138:	3003012c 	.word	0x3003012c

0c00113c <USART0_Initialize>:
  COM_UART_TX_GPIO_CLK_ENABLE();
 c00113c:	4b2c      	ldr	r3, [pc, #176]	; (c0011f0 <USART0_Initialize+0xb4>)
{
 c00113e:	b530      	push	{r4, r5, lr}
  COM_UART_TX_GPIO_CLK_ENABLE();
 c001140:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 c001142:	b08b      	sub	sp, #44	; 0x2c
  COM_UART_TX_GPIO_CLK_ENABLE();
 c001144:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 c001148:	64da      	str	r2, [r3, #76]	; 0x4c
 c00114a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  GPIO_Init.Alternate = COM_UART_TX_AF;
 c00114c:	2508      	movs	r5, #8
  COM_UART_TX_GPIO_CLK_ENABLE();
 c00114e:	f002 0240 	and.w	r2, r2, #64	; 0x40
 c001152:	9201      	str	r2, [sp, #4]
 c001154:	9a01      	ldr	r2, [sp, #4]
  COM_UART_RX_GPIO_CLK_ENABLE();
 c001156:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_Init);
 c001158:	4c26      	ldr	r4, [pc, #152]	; (c0011f4 <USART0_Initialize+0xb8>)
  COM_UART_RX_GPIO_CLK_ENABLE();
 c00115a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 c00115e:	64da      	str	r2, [r3, #76]	; 0x4c
 c001160:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c001162:	f002 0240 	and.w	r2, r2, #64	; 0x40
 c001166:	9202      	str	r2, [sp, #8]
 c001168:	9a02      	ldr	r2, [sp, #8]
  COM_UART_CLK_ENABLE();
 c00116a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 c00116c:	f042 0201 	orr.w	r2, r2, #1
 c001170:	65da      	str	r2, [r3, #92]	; 0x5c
 c001172:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 c001174:	f002 0201 	and.w	r2, r2, #1
 c001178:	9203      	str	r2, [sp, #12]
 c00117a:	9a03      	ldr	r2, [sp, #12]
 c00117c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c00117e:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 c001182:	659a      	str	r2, [r3, #88]	; 0x58
 c001184:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 c001186:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c00118a:	9304      	str	r3, [sp, #16]
 c00118c:	9b04      	ldr	r3, [sp, #16]
 c00118e:	f001 ffb1 	bl	c0030f4 <HAL_PWREx_EnableVddIO2>
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
 c001192:	2280      	movs	r2, #128	; 0x80
 c001194:	2302      	movs	r3, #2
 c001196:	e9cd 2305 	strd	r2, r3, [sp, #20]
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
 c00119a:	9308      	str	r3, [sp, #32]
  GPIO_Init.Pull      = GPIO_PULLUP;
 c00119c:	2301      	movs	r3, #1
  HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_Init);
 c00119e:	a905      	add	r1, sp, #20
 c0011a0:	4620      	mov	r0, r4
  GPIO_Init.Pull      = GPIO_PULLUP;
 c0011a2:	9307      	str	r3, [sp, #28]
  GPIO_Init.Alternate = COM_UART_TX_AF;
 c0011a4:	9509      	str	r5, [sp, #36]	; 0x24
  HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_Init);
 c0011a6:	f001 fbd5 	bl	c002954 <HAL_GPIO_Init>
  GPIO_Init.Pin       = COM_UART_RX_PIN;
 c0011aa:	f44f 7380 	mov.w	r3, #256	; 0x100
  HAL_GPIO_Init(COM_UART_RX_GPIO_PORT, &GPIO_Init);
 c0011ae:	a905      	add	r1, sp, #20
 c0011b0:	4620      	mov	r0, r4
  GPIO_Init.Pin       = COM_UART_RX_PIN;
 c0011b2:	9305      	str	r3, [sp, #20]
  GPIO_Init.Alternate = COM_UART_RX_AF;
 c0011b4:	9509      	str	r5, [sp, #36]	; 0x24
  HAL_GPIO_Init(COM_UART_RX_GPIO_PORT, &GPIO_Init);
 c0011b6:	f001 fbcd 	bl	c002954 <HAL_GPIO_Init>
  uart_device.Init.BaudRate       = 115200;
 c0011ba:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
  uart_device.Instance = COM_UART;
 c0011be:	480e      	ldr	r0, [pc, #56]	; (c0011f8 <USART0_Initialize+0xbc>)
  uart_device.Init.BaudRate       = 115200;
 c0011c0:	490e      	ldr	r1, [pc, #56]	; (c0011fc <USART0_Initialize+0xc0>)
  uart_device.Init.Mode           = UART_MODE_TX_RX;
 c0011c2:	220c      	movs	r2, #12
  uart_device.Init.BaudRate       = 115200;
 c0011c4:	e9c0 1300 	strd	r1, r3, [r0]
  uart_device.Init.WordLength     = UART_WORDLENGTH_8B;
 c0011c8:	2300      	movs	r3, #0
  uart_device.Init.HwFlowCtl      = UART_HWCONTROL_NONE;
 c0011ca:	e9c0 2305 	strd	r2, r3, [r0, #20]
  uart_device.Init.OverSampling   = UART_OVERSAMPLING_8;
 c0011ce:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  uart_device.Init.StopBits       = UART_STOPBITS_1;
 c0011d2:	e9c0 3302 	strd	r3, r3, [r0, #8]
  uart_device.Init.Parity         = UART_PARITY_NONE;
 c0011d6:	6103      	str	r3, [r0, #16]
  uart_device.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 c0011d8:	e9c0 2307 	strd	r2, r3, [r0, #28]
  uart_device.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 c0011dc:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&uart_device) != HAL_OK)
 c0011de:	f004 f8c2 	bl	c005366 <HAL_UART_Init>
 c0011e2:	3000      	adds	r0, #0
 c0011e4:	bf18      	it	ne
 c0011e6:	2001      	movne	r0, #1
}
 c0011e8:	4240      	negs	r0, r0
 c0011ea:	b00b      	add	sp, #44	; 0x2c
 c0011ec:	bd30      	pop	{r4, r5, pc}
 c0011ee:	bf00      	nop
 c0011f0:	50021000 	.word	0x50021000
 c0011f4:	52021800 	.word	0x52021800
 c0011f8:	3003012c 	.word	0x3003012c
 c0011fc:	50008000 	.word	0x50008000

0c001200 <USART0_SetModemControl>:
 c001200:	f06f 0003 	mvn.w	r0, #3
 c001204:	4770      	bx	lr

0c001206 <USART0_GetRxCount>:
 c001206:	f06f 0003 	mvn.w	r0, #3
 c00120a:	4770      	bx	lr

0c00120c <Flash_GetVersion>:
/* Flash Status */
static ARM_FLASH_STATUS ARM_FLASH0_STATUS = {0, 0, 0};

static ARM_DRIVER_VERSION Flash_GetVersion(void)
{
  return DriverVersion;
 c00120c:	4b03      	ldr	r3, [pc, #12]	; (c00121c <Flash_GetVersion+0x10>)
{
 c00120e:	b082      	sub	sp, #8
  return DriverVersion;
 c001210:	6818      	ldr	r0, [r3, #0]
 c001212:	b283      	uxth	r3, r0
}
 c001214:	f363 000f 	bfi	r0, r3, #0, #16
 c001218:	b002      	add	sp, #8
 c00121a:	4770      	bx	lr
 c00121c:	0c00a050 	.word	0x0c00a050

0c001220 <Flash_GetCapabilities>:

static ARM_FLASH_CAPABILITIES Flash_GetCapabilities(void)
{
  return DriverCapabilities;
}
 c001220:	200c      	movs	r0, #12
 c001222:	4770      	bx	lr

0c001224 <Flash_Uninitialize>:
}

static int32_t Flash_Uninitialize(void)
{
  return ARM_DRIVER_OK;
}
 c001224:	2000      	movs	r0, #0
 c001226:	4770      	bx	lr

0c001228 <Flash_PowerControl>:

static int32_t Flash_PowerControl(ARM_POWER_STATE state)
{
  switch (state)
 c001228:	2801      	cmp	r0, #1
 c00122a:	d905      	bls.n	c001238 <Flash_PowerControl+0x10>
 c00122c:	2802      	cmp	r0, #2
      return ARM_DRIVER_OK;
    case ARM_POWER_OFF:
    case ARM_POWER_LOW:
      return ARM_DRIVER_ERROR_UNSUPPORTED;
    default:
      return ARM_DRIVER_ERROR_PARAMETER;
 c00122e:	bf0c      	ite	eq
 c001230:	2000      	moveq	r0, #0
 c001232:	f06f 0004 	mvnne.w	r0, #4
 c001236:	4770      	bx	lr
      return ARM_DRIVER_ERROR_UNSUPPORTED;
 c001238:	f06f 0003 	mvn.w	r0, #3
  }
}
 c00123c:	4770      	bx	lr

0c00123e <Flash_EraseChip>:
}

static int32_t Flash_EraseChip(void)
{
  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c00123e:	f06f 0003 	mvn.w	r0, #3
 c001242:	4770      	bx	lr

0c001244 <Flash_GetStatus>:

static ARM_FLASH_STATUS Flash_GetStatus(void)
{
  return ARM_FLASH0_STATUS;
 c001244:	4b01      	ldr	r3, [pc, #4]	; (c00124c <Flash_GetStatus+0x8>)
 c001246:	6818      	ldr	r0, [r3, #0]
}
 c001248:	4770      	bx	lr
 c00124a:	bf00      	nop
 c00124c:	300301b8 	.word	0x300301b8

0c001250 <Flash_GetInfo>:

static ARM_FLASH_INFO *Flash_GetInfo(void)
{
  return ARM_FLASH0_DEV.data;
}
 c001250:	4b01      	ldr	r3, [pc, #4]	; (c001258 <Flash_GetInfo+0x8>)
 c001252:	6818      	ldr	r0, [r3, #0]
 c001254:	4770      	bx	lr
 c001256:	bf00      	nop
 c001258:	30030004 	.word	0x30030004

0c00125c <Flash_ReadData>:
{
 c00125c:	4603      	mov	r3, r0
 c00125e:	b510      	push	{r4, lr}
 c001260:	4608      	mov	r0, r1
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c001262:	4913      	ldr	r1, [pc, #76]	; (c0012b0 <Flash_ReadData+0x54>)
 c001264:	680c      	ldr	r4, [r1, #0]
 c001266:	f36f 0441 	bfc	r4, #1, #1
 c00126a:	600c      	str	r4, [r1, #0]
  is_valid = is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1);
 c00126c:	1e54      	subs	r4, r2, #1
 c00126e:	441c      	add	r4, r3
  if (is_valid != true)
 c001270:	f5b4 2f00 	cmp.w	r4, #524288	; 0x80000
 c001274:	d306      	bcc.n	c001284 <Flash_ReadData+0x28>
    return ARM_DRIVER_ERROR_PARAMETER;
 c001276:	f06f 0004 	mvn.w	r0, #4
    ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c00127a:	680b      	ldr	r3, [r1, #0]
 c00127c:	f043 0302 	orr.w	r3, r3, #2
 c001280:	600b      	str	r3, [r1, #0]
}
 c001282:	bd10      	pop	{r4, pc}
  DoubleECC_Error_Counter = 0U;
 c001284:	2100      	movs	r1, #0
 c001286:	4c0b      	ldr	r4, [pc, #44]	; (c0012b4 <Flash_ReadData+0x58>)
  if (addr < FLASH_AREA_1_OFFSET)
 c001288:	f5b3 3f60 	cmp.w	r3, #229376	; 0x38000
  DoubleECC_Error_Counter = 0U;
 c00128c:	6021      	str	r1, [r4, #0]
    memcpy(data, (void *)((uint32_t)addr + FLASH_BASE), cnt);
 c00128e:	bf34      	ite	cc
 c001290:	f103 6140 	addcc.w	r1, r3, #201326592	; 0xc000000
    memcpy(data, (void *)((uint32_t)addr + FLASH_BASE_NS), cnt);
 c001294:	f103 6100 	addcs.w	r1, r3, #134217728	; 0x8000000
 c001298:	f007 fa1c 	bl	c0086d4 <memcpy>
  if (DoubleECC_Error_Counter == 0U)
 c00129c:	6823      	ldr	r3, [r4, #0]
    ret = ARM_DRIVER_OK;
 c00129e:	2b00      	cmp	r3, #0
  DoubleECC_Error_Counter = 0U;
 c0012a0:	f04f 0300 	mov.w	r3, #0
    ret = ARM_DRIVER_OK;
 c0012a4:	bf14      	ite	ne
 c0012a6:	f06f 0005 	mvnne.w	r0, #5
 c0012aa:	2000      	moveq	r0, #0
  DoubleECC_Error_Counter = 0U;
 c0012ac:	6023      	str	r3, [r4, #0]
  return ret;
 c0012ae:	e7e8      	b.n	c001282 <Flash_ReadData+0x26>
 c0012b0:	300301b8 	.word	0x300301b8
 c0012b4:	300301bc 	.word	0x300301bc

0c0012b8 <Flash_Initialize>:
{
 c0012b8:	b508      	push	{r3, lr}
  FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0012ba:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 c0012be:	f001 f857 	bl	c002370 <FLASH_WaitForLastOperation>
}
 c0012c2:	2000      	movs	r0, #0
 c0012c4:	bd08      	pop	{r3, pc}
	...

0c0012c8 <Flash_ProgramData>:
{
 c0012c8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c0012cc:	4c2c      	ldr	r4, [pc, #176]	; (c001380 <Flash_ProgramData+0xb8>)
{
 c0012ce:	4689      	mov	r9, r1
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c0012d0:	6823      	ldr	r3, [r4, #0]
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 c0012d2:	1881      	adds	r1, r0, r2
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c0012d4:	f36f 0341 	bfc	r3, #1, #1
 c0012d8:	6023      	str	r3, [r4, #0]
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 c0012da:	1e4b      	subs	r3, r1, #1
 c0012dc:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
{
 c0012e0:	4607      	mov	r7, r0
 c0012e2:	4690      	mov	r8, r2
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 c0012e4:	d212      	bcs.n	c00130c <Flash_ProgramData+0x44>
  return ((param % flash_dev->data->program_unit) != 0) ? (false) : (true);
 c0012e6:	4b27      	ldr	r3, [pc, #156]	; (c001384 <Flash_ProgramData+0xbc>)
 c0012e8:	681b      	ldr	r3, [r3, #0]
 c0012ea:	691b      	ldr	r3, [r3, #16]
 c0012ec:	fbb0 f2f3 	udiv	r2, r0, r3
 c0012f0:	fb03 0212 	mls	r2, r3, r2, r0
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 c0012f4:	b952      	cbnz	r2, c00130c <Flash_ProgramData+0x44>
  return ((param % flash_dev->data->program_unit) != 0) ? (false) : (true);
 c0012f6:	fbb8 f2f3 	udiv	r2, r8, r3
 c0012fa:	fb03 8312 	mls	r3, r3, r2, r8
      (!is_write_aligned(&ARM_FLASH0_DEV, addr))     ||
 c0012fe:	b92b      	cbnz	r3, c00130c <Flash_ProgramData+0x44>
         ? true : false;
 c001300:	f5b1 4f70 	cmp.w	r1, #61440	; 0xf000
 c001304:	d30b      	bcc.n	c00131e <Flash_ProgramData+0x56>
      (!is_write_aligned(&ARM_FLASH0_DEV, cnt))      ||
 c001306:	f5b0 3fa0 	cmp.w	r0, #81920	; 0x14000
 c00130a:	d208      	bcs.n	c00131e <Flash_ProgramData+0x56>
    return ARM_DRIVER_ERROR_PARAMETER;
 c00130c:	f06f 0004 	mvn.w	r0, #4
    ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c001310:	6823      	ldr	r3, [r4, #0]
 c001312:	f043 0302 	orr.w	r3, r3, #2
 c001316:	6023      	str	r3, [r4, #0]
}
 c001318:	b003      	add	sp, #12
 c00131a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c00131e:	463e      	mov	r6, r7
  HAL_FLASH_Unlock();
 c001320:	f000 ffd6 	bl	c0022d0 <HAL_FLASH_Unlock>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c001324:	6823      	ldr	r3, [r4, #0]
    if (addr < FLASH_AREA_1_OFFSET)
 c001326:	f8df a060 	ldr.w	sl, [pc, #96]	; c001388 <Flash_ProgramData+0xc0>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c00132a:	f043 0301 	orr.w	r3, r3, #1
      err = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD_NS, (FLASH_BASE_NS + addr), dword);
 c00132e:	f8df b05c 	ldr.w	fp, [pc, #92]	; c00138c <Flash_ProgramData+0xc4>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c001332:	6023      	str	r3, [r4, #0]
    memcpy(&dword, (void *)((uint32_t)data + loop), sizeof(dword));
 c001334:	466b      	mov	r3, sp
 c001336:	eba9 0207 	sub.w	r2, r9, r7
 c00133a:	4432      	add	r2, r6
 c00133c:	6810      	ldr	r0, [r2, #0]
 c00133e:	6851      	ldr	r1, [r2, #4]
    if (addr < FLASH_AREA_1_OFFSET)
 c001340:	4556      	cmp	r6, sl
    memcpy(&dword, (void *)((uint32_t)data + loop), sizeof(dword));
 c001342:	c303      	stmia	r3!, {r0, r1}
      err = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, (FLASH_BASE + addr), dword);
 c001344:	bf94      	ite	ls
 c001346:	f106 6140 	addls.w	r1, r6, #201326592	; 0xc000000
      err = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD_NS, (FLASH_BASE_NS + addr), dword);
 c00134a:	f106 6100 	addhi.w	r1, r6, #134217728	; 0x8000000
 c00134e:	e9dd 2300 	ldrd	r2, r3, [sp]
      err = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, (FLASH_BASE + addr), dword);
 c001352:	bf94      	ite	ls
 c001354:	2001      	movls	r0, #1
      err = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD_NS, (FLASH_BASE_NS + addr), dword);
 c001356:	4658      	movhi	r0, fp
 c001358:	f001 f848 	bl	c0023ec <HAL_FLASH_Program>
    addr += sizeof(dword);
 c00135c:	3608      	adds	r6, #8
  } while ((loop != cnt) && (err == HAL_OK));
 c00135e:	1bf3      	subs	r3, r6, r7
 c001360:	4598      	cmp	r8, r3
      err = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD_NS, (FLASH_BASE_NS + addr), dword);
 c001362:	4605      	mov	r5, r0
  } while ((loop != cnt) && (err == HAL_OK));
 c001364:	d001      	beq.n	c00136a <Flash_ProgramData+0xa2>
 c001366:	2800      	cmp	r0, #0
 c001368:	d0e4      	beq.n	c001334 <Flash_ProgramData+0x6c>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c00136a:	6823      	ldr	r3, [r4, #0]
 c00136c:	f36f 0300 	bfc	r3, #0, #1
 c001370:	6023      	str	r3, [r4, #0]
  HAL_FLASH_Lock();
 c001372:	f000 ffcd 	bl	c002310 <HAL_FLASH_Lock>
  return (err == HAL_OK) ? ARM_DRIVER_OK : ARM_DRIVER_ERROR;
 c001376:	1c28      	adds	r0, r5, #0
 c001378:	bf18      	it	ne
 c00137a:	2001      	movne	r0, #1
 c00137c:	4240      	negs	r0, r0
 c00137e:	e7cb      	b.n	c001318 <Flash_ProgramData+0x50>
 c001380:	300301b8 	.word	0x300301b8
 c001384:	30030004 	.word	0x30030004
 c001388:	00037fff 	.word	0x00037fff
 c00138c:	80000001 	.word	0x80000001

0c001390 <Flash_EraseSector>:
{
 c001390:	b530      	push	{r4, r5, lr}
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 c001392:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
{
 c001396:	b087      	sub	sp, #28
 c001398:	4c26      	ldr	r4, [pc, #152]	; (c001434 <Flash_EraseSector+0xa4>)
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 c00139a:	d20f      	bcs.n	c0013bc <Flash_EraseSector+0x2c>
  return ((param % (flash_dev->data->sector_size)) != 0) ? (false) : (true);
 c00139c:	4b26      	ldr	r3, [pc, #152]	; (c001438 <Flash_EraseSector+0xa8>)
 c00139e:	681b      	ldr	r3, [r3, #0]
 c0013a0:	6899      	ldr	r1, [r3, #8]
 c0013a2:	fbb0 f2f1 	udiv	r2, r0, r1
 c0013a6:	fb01 0212 	mls	r2, r1, r2, r0
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 c0013aa:	b93a      	cbnz	r2, c0013bc <Flash_EraseSector+0x2c>
    ((param < FLASH_NV_COUNTERS_AREA_OFFSET) && 
 c0013ac:	f5a0 4250 	sub.w	r2, r0, #53248	; 0xd000
    ? (true) : (false);
 c0013b0:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 c0013b4:	d30d      	bcc.n	c0013d2 <Flash_EraseSector+0x42>
      !(is_erase_aligned(&ARM_FLASH0_DEV, addr)) ||
 c0013b6:	f5b0 3fa0 	cmp.w	r0, #81920	; 0x14000
 c0013ba:	d207      	bcs.n	c0013cc <Flash_EraseSector+0x3c>
    return ARM_DRIVER_ERROR_PARAMETER;
 c0013bc:	f06f 0004 	mvn.w	r0, #4
    ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c0013c0:	6823      	ldr	r3, [r4, #0]
 c0013c2:	f043 0302 	orr.w	r3, r3, #2
 c0013c6:	6023      	str	r3, [r4, #0]
}
 c0013c8:	b007      	add	sp, #28
 c0013ca:	bd30      	pop	{r4, r5, pc}
  if (addr < FLASH_AREA_1_OFFSET)
 c0013cc:	f5b0 3f60 	cmp.w	r0, #229376	; 0x38000
 c0013d0:	d227      	bcs.n	c001422 <Flash_EraseSector+0x92>
    EraseInit.TypeErase = FLASH_TYPEERASE_PAGES;
 c0013d2:	2202      	movs	r2, #2
 c0013d4:	9202      	str	r2, [sp, #8]
  return ((param >= (FLASH_TOTAL_SIZE / 2)) ? 2 : 1);
 c0013d6:	2201      	movs	r2, #1
  EraseInit.Banks = bank_number(&ARM_FLASH0_DEV, addr);
 c0013d8:	9203      	str	r2, [sp, #12]
  EraseInit.NbPages = 2;
 c0013da:	2202      	movs	r2, #2
 c0013dc:	9205      	str	r2, [sp, #20]
  uint32_t page = param / flash_dev->data->page_size ;
 c0013de:	68da      	ldr	r2, [r3, #12]
  page = ((page > (flash_dev->data->sector_count))) ? page - ((flash_dev->data->sector_count)) : page;
 c0013e0:	685b      	ldr	r3, [r3, #4]
  uint32_t page = param / flash_dev->data->page_size ;
 c0013e2:	fbb0 f0f2 	udiv	r0, r0, r2
  page = ((page > (flash_dev->data->sector_count))) ? page - ((flash_dev->data->sector_count)) : page;
 c0013e6:	4298      	cmp	r0, r3
 c0013e8:	bf88      	it	hi
 c0013ea:	1ac0      	subhi	r0, r0, r3
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c0013ec:	6823      	ldr	r3, [r4, #0]
  EraseInit.Page = page_number(&ARM_FLASH0_DEV, addr);
 c0013ee:	9004      	str	r0, [sp, #16]
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c0013f0:	f36f 0341 	bfc	r3, #1, #1
 c0013f4:	6023      	str	r3, [r4, #0]
  HAL_FLASH_Unlock();
 c0013f6:	f000 ff6b 	bl	c0022d0 <HAL_FLASH_Unlock>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c0013fa:	6823      	ldr	r3, [r4, #0]
  err = HAL_FLASHEx_Erase(&EraseInit, &pageError);
 c0013fc:	a901      	add	r1, sp, #4
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c0013fe:	f043 0301 	orr.w	r3, r3, #1
  err = HAL_FLASHEx_Erase(&EraseInit, &pageError);
 c001402:	a802      	add	r0, sp, #8
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c001404:	6023      	str	r3, [r4, #0]
  err = HAL_FLASHEx_Erase(&EraseInit, &pageError);
 c001406:	f001 fa4f 	bl	c0028a8 <HAL_FLASHEx_Erase>
 c00140a:	4605      	mov	r5, r0
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c00140c:	6823      	ldr	r3, [r4, #0]
 c00140e:	f36f 0300 	bfc	r3, #0, #1
 c001412:	6023      	str	r3, [r4, #0]
  HAL_FLASH_Lock();
 c001414:	f000 ff7c 	bl	c002310 <HAL_FLASH_Lock>
  return (err == HAL_OK) ? ARM_DRIVER_OK : ARM_DRIVER_ERROR;
 c001418:	1c28      	adds	r0, r5, #0
 c00141a:	bf18      	it	ne
 c00141c:	2001      	movne	r0, #1
 c00141e:	4240      	negs	r0, r0
 c001420:	e7d2      	b.n	c0013c8 <Flash_EraseSector+0x38>
    EraseInit.TypeErase = FLASH_TYPEERASE_PAGES_NS;
 c001422:	4a06      	ldr	r2, [pc, #24]	; (c00143c <Flash_EraseSector+0xac>)
  return ((param >= (FLASH_TOTAL_SIZE / 2)) ? 2 : 1);
 c001424:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
    EraseInit.TypeErase = FLASH_TYPEERASE_PAGES_NS;
 c001428:	9202      	str	r2, [sp, #8]
  return ((param >= (FLASH_TOTAL_SIZE / 2)) ? 2 : 1);
 c00142a:	bf2c      	ite	cs
 c00142c:	2202      	movcs	r2, #2
 c00142e:	2201      	movcc	r2, #1
 c001430:	e7d2      	b.n	c0013d8 <Flash_EraseSector+0x48>
 c001432:	bf00      	nop
 c001434:	300301b8 	.word	0x300301b8
 c001438:	30030004 	.word	0x30030004
 c00143c:	80000002 	.word	0x80000002

0c001440 <NMI_Handler>:
void NMI_Handler(void)
{
  uint32_t *p_sp;
  uint32_t lr;
  uint16_t opcode_msb;
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_ECCD))
 c001440:	4b17      	ldr	r3, [pc, #92]	; (c0014a0 <NMI_Handler+0x60>)
 c001442:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 c001444:	f002 4220 	and.w	r2, r2, #2684354560	; 0xa0000000
 c001448:	f1b2 4f20 	cmp.w	r2, #2684354560	; 0xa0000000
 c00144c:	d127      	bne.n	c00149e <NMI_Handler+0x5e>
  {
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ECCD);
 c00144e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 c001450:	f042 4220 	orr.w	r2, r2, #2684354560	; 0xa0000000
 c001454:	631a      	str	r2, [r3, #48]	; 0x30
    /* Memorize error to ignore the read value */
    DoubleECC_Error_Counter++;
 c001456:	4a13      	ldr	r2, [pc, #76]	; (c0014a4 <NMI_Handler+0x64>)
 c001458:	6813      	ldr	r3, [r2, #0]
 c00145a:	3301      	adds	r3, #1
 c00145c:	6013      	str	r3, [r2, #0]
  __ASM volatile("MOV %0, LR" : "=r"(result));
 c00145e:	4673      	mov	r3, lr

    lr = __get_LR();

    /* Check EXC_RETURN value in LR to know which SP was used prior entering exception */
    if (((lr) & (0xFU)) == 0xDU)
 c001460:	f003 030f 	and.w	r3, r3, #15
 c001464:	2b0d      	cmp	r3, #13
 c001466:	d114      	bne.n	c001492 <NMI_Handler+0x52>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 c001468:	f3ef 8209 	mrs	r2, PSP
      /* interrupted code was using Main Stack Pointer */
      p_sp = (uint32_t *)__get_MSP();
    }

    /* Test caller mode T bit from CPSR in stack */
    if ((*(p_sp + 7U) & (1U << xPSR_T_Pos)) != 0U)
 c00146c:	e9d2 3106 	ldrd	r3, r1, [r2, #24]
 c001470:	01c9      	lsls	r1, r1, #7
 c001472:	d50c      	bpl.n	c00148e <NMI_Handler+0x4e>
         Test PC in stack.
         If bits [15:11] of the halfword being decoded take any of the following values,
         the halfword is the first halfword of a 32-bit instruction: 0b11101, 0b11110, 0b11111.
         Otherwise, the halfword is a 16-bit instruction.
      */
      opcode_msb = (*(uint16_t *)(*(p_sp + 6) & 0xFFFFFFFEU) & 0xF800U);
 c001474:	f023 0101 	bic.w	r1, r3, #1
 c001478:	8809      	ldrh	r1, [r1, #0]
 c00147a:	f401 4078 	and.w	r0, r1, #63488	; 0xf800
      if ((opcode_msb == 0xE800U) || (opcode_msb == 0xF000U) || (opcode_msb == 0xF800U))
 c00147e:	f401 4168 	and.w	r1, r1, #59392	; 0xe800
 c001482:	f5b1 4f68 	cmp.w	r1, #59392	; 0xe800
 c001486:	d002      	beq.n	c00148e <NMI_Handler+0x4e>
 c001488:	f5b0 4f70 	cmp.w	r0, #61440	; 0xf000
 c00148c:	d104      	bne.n	c001498 <NMI_Handler+0x58>
      }
    }
    else
    {
      /* ARM mode execute next instruction PC +4 */
      *(p_sp + 6U) += 4U;
 c00148e:	3304      	adds	r3, #4
 c001490:	e003      	b.n	c00149a <NMI_Handler+0x5a>
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
 c001492:	f3ef 8208 	mrs	r2, MSP
 c001496:	e7e9      	b.n	c00146c <NMI_Handler+0x2c>
        *(p_sp + 6U) += 2U;
 c001498:	3302      	adds	r3, #2
      *(p_sp + 6U) += 4U;
 c00149a:	6193      	str	r3, [r2, #24]
  else
  {
    /* This exception occurs for another reason than flash double ECC errors */
    while (1U);
  }
}
 c00149c:	4770      	bx	lr
 c00149e:	e7fe      	b.n	c00149e <NMI_Handler+0x5e>
 c0014a0:	50022000 	.word	0x50022000
 c0014a4:	300301bc 	.word	0x300301bc

0c0014a8 <mbedtls_hardware_poll>:
}


/*  interface for mbed-crypto */
int mbedtls_hardware_poll(void *data, unsigned char *output, size_t len, size_t *olen)
{
 c0014a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0014ac:	460e      	mov	r6, r1
 c0014ae:	b0a9      	sub	sp, #164	; 0xa4
 c0014b0:	4617      	mov	r7, r2
 c0014b2:	461d      	mov	r5, r3
__STATIC_FORCEINLINE uint8_t __LDREXB(volatile uint8_t *addr)
{
    uint32_t result;

#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
 c0014b4:	4a37      	ldr	r2, [pc, #220]	; (c001594 <mbedtls_hardware_poll+0xec>)
 c0014b6:	4690      	mov	r8, r2
 c0014b8:	e8d2 3f4f 	ldrexb	r3, [r2]
    newValue = __LDREXB(valuePtr) + delta;
 c0014bc:	3301      	adds	r3, #1
 c0014be:	b2db      	uxtb	r3, r3
 */
__STATIC_FORCEINLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
{
   uint32_t result;

   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
 c0014c0:	e8c2 3f41 	strexb	r1, r3, [r2]
  } while (__STREXB(newValue, valuePtr));
 c0014c4:	2900      	cmp	r1, #0
 c0014c6:	d1f7      	bne.n	c0014b8 <mbedtls_hardware_poll+0x10>
  if (atomic_incr_u8(&users, 1) > 1)
 c0014c8:	2b01      	cmp	r3, #1
 c0014ca:	d901      	bls.n	c0014d0 <mbedtls_hardware_poll+0x28>
    Error_Handler();
 c0014cc:	f000 f8a4 	bl	c001618 <Error_Handler>
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RNG;
 c0014d0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 c0014d4:	9303      	str	r3, [sp, #12]
  PeriphClkInitStruct.RngClockSelection = RCC_RNGCLKSOURCE_MSI;
 c0014d6:	f04f 6340 	mov.w	r3, #201326592	; 0xc000000
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 c0014da:	a803      	add	r0, sp, #12
  PeriphClkInitStruct.RngClockSelection = RCC_RNGCLKSOURCE_MSI;
 c0014dc:	9322      	str	r3, [sp, #136]	; 0x88
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 c0014de:	f002 fbed 	bl	c003cbc <HAL_RCCEx_PeriphCLKConfig>
 c0014e2:	b108      	cbz	r0, c0014e8 <mbedtls_hardware_poll+0x40>
   Error_Handler();
 c0014e4:	f000 f898 	bl	c001618 <Error_Handler>
  handle.Instance = RNG;
 c0014e8:	4c2b      	ldr	r4, [pc, #172]	; (c001598 <mbedtls_hardware_poll+0xf0>)
  handle.State = HAL_RNG_STATE_RESET;
 c0014ea:	f04f 0900 	mov.w	r9, #0
    if (HAL_RNG_GenerateRandomNumber(&handle, (uint32_t *)random) != HAL_OK)
 c0014ee:	46a2      	mov	sl, r4
  __HAL_RCC_RNG_CLK_ENABLE();
 c0014f0:	4b2a      	ldr	r3, [pc, #168]	; (c00159c <mbedtls_hardware_poll+0xf4>)
  HAL_RNG_Init(&handle);
 c0014f2:	4620      	mov	r0, r4
  __HAL_RCC_RNG_CLK_ENABLE();
 c0014f4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c0014f6:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 c0014fa:	64da      	str	r2, [r3, #76]	; 0x4c
 c0014fc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  handle.Lock = HAL_UNLOCKED;
 c0014fe:	f884 9008 	strb.w	r9, [r4, #8]
  __HAL_RCC_RNG_CLK_ENABLE();
 c001502:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 c001506:	9302      	str	r3, [sp, #8]
 c001508:	9b02      	ldr	r3, [sp, #8]
  handle.Instance = RNG;
 c00150a:	4b25      	ldr	r3, [pc, #148]	; (c0015a0 <mbedtls_hardware_poll+0xf8>)
  handle.State = HAL_RNG_STATE_RESET;
 c00150c:	f884 9009 	strb.w	r9, [r4, #9]
  handle.Instance = RNG;
 c001510:	6023      	str	r3, [r4, #0]
  HAL_RNG_Init(&handle);
 c001512:	f002 fe1e 	bl	c004152 <HAL_RNG_Init>
  HAL_RNG_GenerateRandomNumber(&handle, &dummy);
 c001516:	a901      	add	r1, sp, #4
 c001518:	4620      	mov	r0, r4
 c00151a:	f002 fea0 	bl	c00425e <HAL_RNG_GenerateRandomNumber>
  *output_length = 0;
 c00151e:	f8c5 9000 	str.w	r9, [r5]
  while ((*output_length < length) && (ret == 0))
 c001522:	682b      	ldr	r3, [r5, #0]
    if (HAL_RNG_GenerateRandomNumber(&handle, (uint32_t *)random) != HAL_OK)
 c001524:	46b3      	mov	fp, r6
  while ((*output_length < length) && (ret == 0))
 c001526:	429f      	cmp	r7, r3
 c001528:	d904      	bls.n	c001534 <mbedtls_hardware_poll+0x8c>
    if (HAL_RNG_GenerateRandomNumber(&handle, (uint32_t *)random) != HAL_OK)
 c00152a:	a903      	add	r1, sp, #12
 c00152c:	4650      	mov	r0, sl
 c00152e:	f002 fe96 	bl	c00425e <HAL_RNG_GenerateRandomNumber>
 c001532:	b1d0      	cbz	r0, c00156a <mbedtls_hardware_poll+0xc2>
  if ((__HAL_RNG_GET_FLAG(&handle, (RNG_FLAG_CECS | RNG_FLAG_SECS))) != 0)
 c001534:	6823      	ldr	r3, [r4, #0]
  HAL_RNG_DeInit(&handle);
 c001536:	4818      	ldr	r0, [pc, #96]	; (c001598 <mbedtls_hardware_poll+0xf0>)
  if ((__HAL_RNG_GET_FLAG(&handle, (RNG_FLAG_CECS | RNG_FLAG_SECS))) != 0)
 c001538:	685b      	ldr	r3, [r3, #4]
 c00153a:	f003 0306 	and.w	r3, r3, #6
 c00153e:	2b06      	cmp	r3, #6
    *output_length = 0;
 c001540:	bf04      	itt	eq
 c001542:	2300      	moveq	r3, #0
 c001544:	602b      	streq	r3, [r5, #0]
  HAL_RNG_DeInit(&handle);
 c001546:	f002 fe56 	bl	c0041f6 <HAL_RNG_DeInit>
  __HAL_RCC_RNG_CLK_DISABLE();
 c00154a:	4a14      	ldr	r2, [pc, #80]	; (c00159c <mbedtls_hardware_poll+0xf4>)
 c00154c:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 c00154e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 c001552:	64d3      	str	r3, [r2, #76]	; 0x4c
  users = 0;
 c001554:	2300      	movs	r3, #0
 c001556:	f888 3000 	strb.w	r3, [r8]
  RNG_Init();
  RNG_GetBytes(output, len, olen);
  RNG_DeInit();
  if (*olen != len)
 c00155a:	6828      	ldr	r0, [r5, #0]
  {
    return -1;
  }
  return 0;
}
 c00155c:	1bc0      	subs	r0, r0, r7
 c00155e:	bf18      	it	ne
 c001560:	f04f 30ff 	movne.w	r0, #4294967295
 c001564:	b029      	add	sp, #164	; 0xa4
 c001566:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c00156a:	1d31      	adds	r1, r6, #4
      for (uint8_t i = 0; (i < 4) && (*output_length < length) ; i++)
 c00156c:	682b      	ldr	r3, [r5, #0]
 c00156e:	429f      	cmp	r7, r3
 c001570:	d9d7      	bls.n	c001522 <mbedtls_hardware_poll+0x7a>
 c001572:	eba6 030b 	sub.w	r3, r6, fp
        *output++ = random[i];
 c001576:	aa28      	add	r2, sp, #160	; 0xa0
 c001578:	4413      	add	r3, r2
 c00157a:	f813 2c94 	ldrb.w	r2, [r3, #-148]
        random[i] = 0;
 c00157e:	f803 9c94 	strb.w	r9, [r3, #-148]
        *output++ = random[i];
 c001582:	f806 2b01 	strb.w	r2, [r6], #1
        *output_length += 1;
 c001586:	682a      	ldr	r2, [r5, #0]
      for (uint8_t i = 0; (i < 4) && (*output_length < length) ; i++)
 c001588:	428e      	cmp	r6, r1
        *output_length += 1;
 c00158a:	f102 0201 	add.w	r2, r2, #1
 c00158e:	602a      	str	r2, [r5, #0]
      for (uint8_t i = 0; (i < 4) && (*output_length < length) ; i++)
 c001590:	d1ec      	bne.n	c00156c <mbedtls_hardware_poll+0xc4>
 c001592:	e7c6      	b.n	c001522 <mbedtls_hardware_poll+0x7a>
 c001594:	300301d4 	.word	0x300301d4
 c001598:	300301c0 	.word	0x300301c0
 c00159c:	50021000 	.word	0x50021000
 c0015a0:	520c0800 	.word	0x520c0800

0c0015a4 <HAL_InitTick>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /* load 1Hz for timeout 1 second */
  uint32_t ticks = SystemCoreClock ;
 c0015a4:	4b04      	ldr	r3, [pc, #16]	; (c0015b8 <HAL_InitTick+0x14>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 c0015a6:	2000      	movs	r0, #0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 c0015a8:	681a      	ldr	r2, [r3, #0]
 c0015aa:	4b04      	ldr	r3, [pc, #16]	; (c0015bc <HAL_InitTick+0x18>)
 c0015ac:	3a01      	subs	r2, #1
 c0015ae:	605a      	str	r2, [r3, #4]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 c0015b0:	2205      	movs	r2, #5
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 c0015b2:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 c0015b4:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_ENABLE_Msk;
  return HAL_OK;
}
 c0015b6:	4770      	bx	lr
 c0015b8:	30030008 	.word	0x30030008
 c0015bc:	e000e010 	.word	0xe000e010

0c0015c0 <HAL_GetTick>:
  * @note This function overwrites the one declared as __weak in HAL.
  *       In this implementation, time is counted without using SysTick timer interrupts.
  * @retval tick value
  */
uint32_t HAL_GetTick(void)
{
 c0015c0:	b530      	push	{r4, r5, lr}
  static uint32_t t1 = 0U, tdelta = 0U;
  uint32_t t2;

  t2 =  SysTick->VAL;

  if (t2 <= t1)
 c0015c2:	4910      	ldr	r1, [pc, #64]	; (c001604 <HAL_GetTick+0x44>)
  t2 =  SysTick->VAL;
 c0015c4:	4c10      	ldr	r4, [pc, #64]	; (c001608 <HAL_GetTick+0x48>)
 c0015c6:	4a11      	ldr	r2, [pc, #68]	; (c00160c <HAL_GetTick+0x4c>)
 c0015c8:	68a0      	ldr	r0, [r4, #8]
  if (t2 <= t1)
 c0015ca:	680b      	ldr	r3, [r1, #0]
 c0015cc:	6815      	ldr	r5, [r2, #0]
 c0015ce:	4283      	cmp	r3, r0
  {
    tdelta += t1 - t2;
  }
  else
  {
    tdelta += t1 + SysTick->LOAD - t2;
 c0015d0:	bf38      	it	cc
 c0015d2:	6864      	ldrcc	r4, [r4, #4]
 c0015d4:	442b      	add	r3, r5
 c0015d6:	bf38      	it	cc
 c0015d8:	191b      	addcc	r3, r3, r4
  }

  if (tdelta > (SystemCoreClock / (1000U)))
 c0015da:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    tdelta += t1 + SysTick->LOAD - t2;
 c0015de:	1a1b      	subs	r3, r3, r0
 c0015e0:	6013      	str	r3, [r2, #0]
  if (tdelta > (SystemCoreClock / (1000U)))
 c0015e2:	4b0b      	ldr	r3, [pc, #44]	; (c001610 <HAL_GetTick+0x50>)
 c0015e4:	681b      	ldr	r3, [r3, #0]
 c0015e6:	fbb3 f3f4 	udiv	r3, r3, r4
 c0015ea:	6814      	ldr	r4, [r2, #0]
 c0015ec:	42a3      	cmp	r3, r4
 c0015ee:	4b09      	ldr	r3, [pc, #36]	; (c001614 <HAL_GetTick+0x54>)
 c0015f0:	d204      	bcs.n	c0015fc <HAL_GetTick+0x3c>
  {
    tdelta = 0U;
 c0015f2:	2500      	movs	r5, #0
 c0015f4:	681c      	ldr	r4, [r3, #0]
 c0015f6:	6015      	str	r5, [r2, #0]
    m_uTick ++;
 c0015f8:	3401      	adds	r4, #1
 c0015fa:	601c      	str	r4, [r3, #0]
  }

  t1 = t2;
 c0015fc:	6008      	str	r0, [r1, #0]
  return m_uTick;
}
 c0015fe:	6818      	ldr	r0, [r3, #0]
 c001600:	bd30      	pop	{r4, r5, pc}
 c001602:	bf00      	nop
 c001604:	300301dc 	.word	0x300301dc
 c001608:	e000e010 	.word	0xe000e010
 c00160c:	300301e0 	.word	0x300301e0
 c001610:	30030008 	.word	0x30030008
 c001614:	300301d8 	.word	0x300301d8

0c001618 <Error_Handler>:
#define WHILE_1_OPCODE 0xe7fe
  typedef void (*nsfptr_t)(void) __attribute__((cmse_nonsecure_call));
  nsfptr_t nsfptr = (nsfptr_t)(SRAM1_BASE_NS + 1);
  __IO uint16_t *pt = (uint16_t *)SRAM1_BASE_NS;
  /*  copy while(1) instruction */
  *pt = WHILE_1_OPCODE;
 c001618:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 c00161c:	f24e 72fe 	movw	r2, #59390	; 0xe7fe
{
 c001620:	b510      	push	{r4, lr}
  *pt = WHILE_1_OPCODE;
 c001622:	801a      	strh	r2, [r3, #0]
  __ASM volatile ("dsb 0xF":::"memory");
 c001624:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c001628:	f3bf 8f6f 	isb	sy
  /* Flush and refill pipeline  */
  __DSB();
  __ISB();
  /*  call non secure while(1) */
  nsfptr();
 c00162c:	4c14      	ldr	r4, [pc, #80]	; (c001680 <Error_Handler+0x68>)
 c00162e:	0864      	lsrs	r4, r4, #1
 c001630:	0064      	lsls	r4, r4, #1
 c001632:	4620      	mov	r0, r4
 c001634:	4621      	mov	r1, r4
 c001636:	4622      	mov	r2, r4
 c001638:	4623      	mov	r3, r4
 c00163a:	ed9f 0a12 	vldr	s0, [pc, #72]	; c001684 <Error_Handler+0x6c>
 c00163e:	eddf 0a11 	vldr	s1, [pc, #68]	; c001684 <Error_Handler+0x6c>
 c001642:	ed9f 1a10 	vldr	s2, [pc, #64]	; c001684 <Error_Handler+0x6c>
 c001646:	eddf 1a0f 	vldr	s3, [pc, #60]	; c001684 <Error_Handler+0x6c>
 c00164a:	ed9f 2a0e 	vldr	s4, [pc, #56]	; c001684 <Error_Handler+0x6c>
 c00164e:	eddf 2a0d 	vldr	s5, [pc, #52]	; c001684 <Error_Handler+0x6c>
 c001652:	ed9f 3a0c 	vldr	s6, [pc, #48]	; c001684 <Error_Handler+0x6c>
 c001656:	eddf 3a0b 	vldr	s7, [pc, #44]	; c001684 <Error_Handler+0x6c>
 c00165a:	ed9f 4a0a 	vldr	s8, [pc, #40]	; c001684 <Error_Handler+0x6c>
 c00165e:	eddf 4a09 	vldr	s9, [pc, #36]	; c001684 <Error_Handler+0x6c>
 c001662:	ed9f 5a08 	vldr	s10, [pc, #32]	; c001684 <Error_Handler+0x6c>
 c001666:	eddf 5a07 	vldr	s11, [pc, #28]	; c001684 <Error_Handler+0x6c>
 c00166a:	ed9f 6a06 	vldr	s12, [pc, #24]	; c001684 <Error_Handler+0x6c>
 c00166e:	eddf 6a05 	vldr	s13, [pc, #20]	; c001684 <Error_Handler+0x6c>
 c001672:	ed9f 7a04 	vldr	s14, [pc, #16]	; c001684 <Error_Handler+0x6c>
 c001676:	eddf 7a03 	vldr	s15, [pc, #12]	; c001684 <Error_Handler+0x6c>
 c00167a:	f008 f979 	bl	c009970 <__gnu_cmse_nonsecure_call>
  /*  an infinite loop,  and a reset for single fault injection */
  static __IO int once = 1;
  while (once);
  NVIC_SystemReset();
#endif  /*  TFM_ERROR_HANDLER_NON_SECURE */
}
 c00167e:	bd10      	pop	{r4, pc}
 c001680:	20000001 	.word	0x20000001
 c001684:	00000000 	.word	0x00000000

0c001688 <main>:
  GTZC_MPCBB1_S->VCTR[0] = 0xfffffffe;
 c001688:	f06f 0201 	mvn.w	r2, #1
 c00168c:	4bb4      	ldr	r3, [pc, #720]	; (c001960 <main+0x2d8>)
{
 c00168e:	b570      	push	{r4, r5, r6, lr}
  GTZC_MPCBB1_S->VCTR[0] = 0xfffffffe;
 c001690:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  region_cfg.region_base = FLASH_BASE_S + FLASH_AREA_0_OFFSET ;
 c001694:	2200      	movs	r2, #0
  struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 c001696:	4bb3      	ldr	r3, [pc, #716]	; (c001964 <main+0x2dc>)
{
 c001698:	b0a2      	sub	sp, #136	; 0x88
  struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 c00169a:	9301      	str	r3, [sp, #4]
  struct mpu_armv8m_dev_t dev_mpu_ns = { MPU_BASE_NS};
 c00169c:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 c0016a0:	9302      	str	r3, [sp, #8]
  region_cfg.region_base = FLASH_BASE_S + FLASH_AREA_0_OFFSET ;
 c0016a2:	4bb1      	ldr	r3, [pc, #708]	; (c001968 <main+0x2e0>)
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c0016a4:	2501      	movs	r5, #1
  region_cfg.region_base = FLASH_BASE_S + FLASH_AREA_0_OFFSET ;
 c0016a6:	e9cd 2307 	strd	r2, r3, [sp, #28]
  region_cfg.region_limit = FLASH_BASE_S + FLASH_AREA_0_OFFSET + FLASH_AREA_0_SIZE;
 c0016aa:	f503 3310 	add.w	r3, r3, #147456	; 0x24000
 c0016ae:	9309      	str	r3, [sp, #36]	; 0x24
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c0016b0:	2302      	movs	r3, #2
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c0016b2:	a907      	add	r1, sp, #28
 c0016b4:	a801      	add	r0, sp, #4
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c0016b6:	930a      	str	r3, [sp, #40]	; 0x28
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c0016b8:	f88d 202d 	strb.w	r2, [sp, #45]	; 0x2d
  region_cfg.attr_sh = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c0016bc:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c0016c0:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c0016c4:	f000 f9cc 	bl	c001a60 <mpu_armv8m_region_enable>
 c0016c8:	b108      	cbz	r0, c0016ce <main+0x46>
    Error_Handler();
 c0016ca:	f7ff ffa5 	bl	c001618 <Error_Handler>
  region_cfg.region_base = FLASH_BASE_S + FLASH_AREA_PERSO_OFFSET + FLASH_AREA_BL2_SIZE;
 c0016ce:	4ba7      	ldr	r3, [pc, #668]	; (c00196c <main+0x2e4>)
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c0016d0:	2402      	movs	r4, #2
  region_cfg.region_base = FLASH_BASE_S + FLASH_AREA_PERSO_OFFSET + FLASH_AREA_BL2_SIZE;
 c0016d2:	9308      	str	r3, [sp, #32]
  region_cfg.region_limit = FLASH_BASE_S + FLASH_AREA_0_OFFSET - 1;
 c0016d4:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
 c0016d8:	337f      	adds	r3, #127	; 0x7f
 c0016da:	9309      	str	r3, [sp, #36]	; 0x24
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c0016dc:	2300      	movs	r3, #0
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c0016de:	a907      	add	r1, sp, #28
 c0016e0:	a801      	add	r0, sp, #4
  region_cfg.region_nr = 1;
 c0016e2:	9507      	str	r5, [sp, #28]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c0016e4:	940a      	str	r4, [sp, #40]	; 0x28
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c0016e6:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
  region_cfg.attr_sh = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c0016ea:	f88d 402e 	strb.w	r4, [sp, #46]	; 0x2e
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c0016ee:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c0016f2:	f000 f9b5 	bl	c001a60 <mpu_armv8m_region_enable>
 c0016f6:	b108      	cbz	r0, c0016fc <main+0x74>
    Error_Handler();
 c0016f8:	f7ff ff8e 	bl	c001618 <Error_Handler>
  region_cfg.region_base = SRAM1_BASE_S ;
 c0016fc:	f04f 5340 	mov.w	r3, #805306368	; 0x30000000
 c001700:	9308      	str	r3, [sp, #32]
  region_cfg.region_limit = SRAM1_BASE_S + TOTAL_RAM_SIZE;
 c001702:	f503 337f 	add.w	r3, r3, #261120	; 0x3fc00
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c001706:	e9cd 3409 	strd	r3, r4, [sp, #36]	; 0x24
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c00170a:	2300      	movs	r3, #0
 c00170c:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c001710:	2301      	movs	r3, #1
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c001712:	a907      	add	r1, sp, #28
 c001714:	a801      	add	r0, sp, #4
  region_cfg.region_nr = 2;
 c001716:	9407      	str	r4, [sp, #28]
  region_cfg.attr_sh = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c001718:	f88d 402e 	strb.w	r4, [sp, #46]	; 0x2e
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c00171c:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c001720:	f000 f99e 	bl	c001a60 <mpu_armv8m_region_enable>
 c001724:	b108      	cbz	r0, c00172a <main+0xa2>
    Error_Handler();
 c001726:	f7ff ff77 	bl	c001618 <Error_Handler>
  region_cfg.region_base = PERIPH_BASE_S;
 c00172a:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 c00172e:	f04f 0c03 	mov.w	ip, #3
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c001732:	f06f 4e20 	mvn.w	lr, #2684354560	; 0xa0000000
  region_cfg.region_base = PERIPH_BASE_S;
 c001736:	e9cd c307 	strd	ip, r3, [sp, #28]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c00173a:	2300      	movs	r3, #0
 c00173c:	e9cd e309 	strd	lr, r3, [sp, #36]	; 0x24
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c001740:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
  region_cfg.attr_sh = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c001744:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c001748:	2301      	movs	r3, #1
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c00174a:	a907      	add	r1, sp, #28
 c00174c:	a801      	add	r0, sp, #4
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c00174e:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c001752:	f000 f985 	bl	c001a60 <mpu_armv8m_region_enable>
 c001756:	b108      	cbz	r0, c00175c <main+0xd4>
    Error_Handler();
 c001758:	f7ff ff5e 	bl	c001618 <Error_Handler>
  mpu_armv8m_enable(&dev_mpu_s, PRIVILEGED_DEFAULT_ENABLE,
 c00175c:	2201      	movs	r2, #1
 c00175e:	a801      	add	r0, sp, #4
 c001760:	4611      	mov	r1, r2
 c001762:	f000 f963 	bl	c001a2c <mpu_armv8m_enable>
  region_cfg.region_base = FLASH_BASE_NS + FLASH_AREA_1_OFFSET;
 c001766:	2200      	movs	r2, #0
 c001768:	4b81      	ldr	r3, [pc, #516]	; (c001970 <main+0x2e8>)
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c00176a:	2501      	movs	r5, #1
  region_cfg.region_base = FLASH_BASE_NS + FLASH_AREA_1_OFFSET;
 c00176c:	e9cd 2307 	strd	r2, r3, [sp, #28]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c001770:	2302      	movs	r3, #2
 c001772:	4e80      	ldr	r6, [pc, #512]	; (c001974 <main+0x2ec>)
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c001774:	a907      	add	r1, sp, #28
 c001776:	a802      	add	r0, sp, #8
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c001778:	e9cd 6309 	strd	r6, r3, [sp, #36]	; 0x24
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c00177c:	f88d 202d 	strb.w	r2, [sp, #45]	; 0x2d
  region_cfg.attr_sh = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c001780:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c001784:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c001788:	f000 f96a 	bl	c001a60 <mpu_armv8m_region_enable>
 c00178c:	b108      	cbz	r0, c001792 <main+0x10a>
    Error_Handler();
 c00178e:	f7ff ff43 	bl	c001618 <Error_Handler>
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c001792:	2402      	movs	r4, #2
 c001794:	4b78      	ldr	r3, [pc, #480]	; (c001978 <main+0x2f0>)
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c001796:	a907      	add	r1, sp, #28
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c001798:	e9cd 3409 	strd	r3, r4, [sp, #36]	; 0x24
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c00179c:	2300      	movs	r3, #0
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c00179e:	a802      	add	r0, sp, #8
  region_cfg.region_base = FLASH_BASE_NS + FLASH_AREA_2_OFFSET;
 c0017a0:	e9cd 5607 	strd	r5, r6, [sp, #28]
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c0017a4:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
  region_cfg.attr_sh = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c0017a8:	f88d 402e 	strb.w	r4, [sp, #46]	; 0x2e
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c0017ac:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c0017b0:	f000 f956 	bl	c001a60 <mpu_armv8m_region_enable>
 c0017b4:	b108      	cbz	r0, c0017ba <main+0x132>
    Error_Handler();
 c0017b6:	f7ff ff2f 	bl	c001618 <Error_Handler>
  region_cfg.region_limit = SRAM1_BASE_NS + TOTAL_RAM_SIZE;
 c0017ba:	4b70      	ldr	r3, [pc, #448]	; (c00197c <main+0x2f4>)
 c0017bc:	4e70      	ldr	r6, [pc, #448]	; (c001980 <main+0x2f8>)
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c0017be:	a907      	add	r1, sp, #28
  region_cfg.region_limit = SRAM1_BASE_NS + TOTAL_RAM_SIZE;
 c0017c0:	e9cd 6308 	strd	r6, r3, [sp, #32]
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c0017c4:	2300      	movs	r3, #0
 c0017c6:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c0017ca:	2301      	movs	r3, #1
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c0017cc:	a802      	add	r0, sp, #8
  region_cfg.region_nr = 2;
 c0017ce:	9407      	str	r4, [sp, #28]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c0017d0:	940a      	str	r4, [sp, #40]	; 0x28
  region_cfg.attr_sh = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c0017d2:	f88d 402e 	strb.w	r4, [sp, #46]	; 0x2e
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c0017d6:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c0017da:	f000 f941 	bl	c001a60 <mpu_armv8m_region_enable>
 c0017de:	b108      	cbz	r0, c0017e4 <main+0x15c>
    Error_Handler();
 c0017e0:	f7ff ff1a 	bl	c001618 <Error_Handler>
  mpu_armv8m_enable(&dev_mpu_ns, PRIVILEGED_DEFAULT_ENABLE,
 c0017e4:	2201      	movs	r2, #1
 c0017e6:	a802      	add	r0, sp, #8
 c0017e8:	4611      	mov	r1, r2
 c0017ea:	f000 f91f 	bl	c001a2c <mpu_armv8m_enable>
  \brief   Disable SAU
  \details Disables the Security Attribution Unit (SAU).
 */
__STATIC_INLINE void TZ_SAU_Disable(void)
{
    SAU->CTRL &= ~(SAU_CTRL_ENABLE_Msk);
 c0017ee:	4b65      	ldr	r3, [pc, #404]	; (c001984 <main+0x2fc>)
  SAU->RNR  = 0;
 c0017f0:	2400      	movs	r4, #0
 c0017f2:	681a      	ldr	r2, [r3, #0]
 c0017f4:	f022 0201 	bic.w	r2, r2, #1
 c0017f8:	601a      	str	r2, [r3, #0]
  SAU->RBAR = (SRAM1_BASE_NS & SAU_RBAR_BADDR_Msk);
 c0017fa:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  SAU->RNR  = 0;
 c0017fe:	609c      	str	r4, [r3, #8]
  SAU->RBAR = (SRAM1_BASE_NS & SAU_RBAR_BADDR_Msk);
 c001800:	60da      	str	r2, [r3, #12]
  SAU->RLAR = ((SRAM1_BASE_NS + 0xff) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 c001802:	32e1      	adds	r2, #225	; 0xe1
 c001804:	611a      	str	r2, [r3, #16]
  SAU->RNR  = 1;
 c001806:	2201      	movs	r2, #1
 c001808:	609a      	str	r2, [r3, #8]
  SAU->RBAR = (0x0BF90000 & SAU_RBAR_BADDR_Msk);
 c00180a:	4a5f      	ldr	r2, [pc, #380]	; (c001988 <main+0x300>)
 c00180c:	60da      	str	r2, [r3, #12]
  SAU->RLAR = ((0x0BF90000 + 0xffff) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 c00180e:	f502 427f 	add.w	r2, r2, #65280	; 0xff00
 c001812:	32e1      	adds	r2, #225	; 0xe1
 c001814:	611a      	str	r2, [r3, #16]
  SAU->RNR  = 2;
 c001816:	2202      	movs	r2, #2
 c001818:	609a      	str	r2, [r3, #8]
  SAU->RBAR = ((uint32_t)FLASH_NS & SAU_RBAR_BADDR_Msk);
 c00181a:	4a5c      	ldr	r2, [pc, #368]	; (c00198c <main+0x304>)
 c00181c:	60da      	str	r2, [r3, #12]
  SAU->RLAR = (((uint32_t)FLASH_NS + 0xffff) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 c00181e:	f502 427f 	add.w	r2, r2, #65280	; 0xff00
 c001822:	32e1      	adds	r2, #225	; 0xe1
 c001824:	611a      	str	r2, [r3, #16]
  SAU->RNR  = 3;
 c001826:	2203      	movs	r2, #3
 c001828:	609a      	str	r2, [r3, #8]
  SAU->RBAR = ((uint32_t)FLASH_BASE_NS & SAU_RBAR_BADDR_Msk);
 c00182a:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 c00182e:	60da      	str	r2, [r3, #12]
  SAU->RLAR = (((uint32_t)FLASH_BASE_NS + FLASH_AREA_3_OFFSET
 c001830:	f502 2200 	add.w	r2, r2, #524288	; 0x80000
 c001834:	3201      	adds	r2, #1
 c001836:	611a      	str	r2, [r3, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 c001838:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c00183c:	f3bf 8f6f 	isb	sy
    SAU->CTRL |=  (SAU_CTRL_ENABLE_Msk);
 c001840:	681a      	ldr	r2, [r3, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 c001842:	4d53      	ldr	r5, [pc, #332]	; (c001990 <main+0x308>)
 c001844:	f042 0201 	orr.w	r2, r2, #1
 c001848:	601a      	str	r2, [r3, #0]
  HAL_Init();
 c00184a:	f000 fc9a 	bl	c002182 <HAL_Init>
  __HAL_RCC_PWR_CLK_ENABLE();
 c00184e:	6dab      	ldr	r3, [r5, #88]	; 0x58
 c001850:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 c001854:	65ab      	str	r3, [r5, #88]	; 0x58
 c001856:	6dab      	ldr	r3, [r5, #88]	; 0x58
 c001858:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c00185c:	9300      	str	r3, [sp, #0]
 c00185e:	9b00      	ldr	r3, [sp, #0]
  HAL_PWREx_EnableSRAM2ContentRetention();
 c001860:	f001 fc5a 	bl	c003118 <HAL_PWREx_EnableSRAM2ContentRetention>
  __HAL_RCC_RTC_DISABLE();
 c001864:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
  RTCHandle.Init.SynchPrediv    = RTC_SYNCH_PREDIV;
 c001868:	217f      	movs	r1, #127	; 0x7f
  __HAL_RCC_RTC_DISABLE();
 c00186a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 c00186e:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
  RTCHandle.Init.SynchPrediv    = RTC_SYNCH_PREDIV;
 c001872:	23ff      	movs	r3, #255	; 0xff
  RTCHandle.Init.HourFormat     = RTC_HOURFORMAT_24;
 c001874:	4847      	ldr	r0, [pc, #284]	; (c001994 <main+0x30c>)
  RTCHandle.Init.SynchPrediv    = RTC_SYNCH_PREDIV;
 c001876:	e9c0 1302 	strd	r1, r3, [r0, #8]
  RTCHandle.Init.OutPutType     = RTC_OUTPUT_TYPE_OPENDRAIN;
 c00187a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 c00187e:	61c3      	str	r3, [r0, #28]
  RTCHandle.Instance            = RTC;
 c001880:	4b45      	ldr	r3, [pc, #276]	; (c001998 <main+0x310>)
  RTCHandle.Init.HourFormat     = RTC_HOURFORMAT_24;
 c001882:	6044      	str	r4, [r0, #4]
  RTCHandle.Init.OutPut         = RTC_OUTPUT_DISABLE;
 c001884:	6104      	str	r4, [r0, #16]
  RTCHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 c001886:	6184      	str	r4, [r0, #24]
  RTCHandle.Instance            = RTC;
 c001888:	6003      	str	r3, [r0, #0]
  RTCHandle.State = HAL_RTC_STATE_RESET;
 c00188a:	f880 4025 	strb.w	r4, [r0, #37]	; 0x25
  if (HAL_RTC_Init(&RTCHandle) != HAL_OK)
 c00188e:	f002 fd77 	bl	c004380 <HAL_RTC_Init>
 c001892:	b108      	cbz	r0, c001898 <main+0x210>
    Error_Handler();
 c001894:	f7ff fec0 	bl	c001618 <Error_Handler>
  __HAL_RCC_PWR_CLK_ENABLE();
 c001898:	4c3d      	ldr	r4, [pc, #244]	; (c001990 <main+0x308>)
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 c00189a:	2214      	movs	r2, #20
 c00189c:	2100      	movs	r1, #0
 c00189e:	a802      	add	r0, sp, #8
 c0018a0:	f006 ff23 	bl	c0086ea <memset>
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 c0018a4:	2248      	movs	r2, #72	; 0x48
 c0018a6:	2100      	movs	r1, #0
 c0018a8:	a807      	add	r0, sp, #28
 c0018aa:	f006 ff1e 	bl	c0086ea <memset>
  __HAL_RCC_PWR_CLK_ENABLE();
 c0018ae:	6da3      	ldr	r3, [r4, #88]	; 0x58
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0);
 c0018b0:	2000      	movs	r0, #0
  __HAL_RCC_PWR_CLK_ENABLE();
 c0018b2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 c0018b6:	65a3      	str	r3, [r4, #88]	; 0x58
 c0018b8:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c0018ba:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c0018be:	9301      	str	r3, [sp, #4]
 c0018c0:	9b01      	ldr	r3, [sp, #4]
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0);
 c0018c2:	f001 fc3d 	bl	c003140 <HAL_PWREx_ControlVoltageScaling>
  __HAL_RCC_PWR_CLK_DISABLE();
 c0018c6:	6da3      	ldr	r3, [r4, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
 c0018c8:	2201      	movs	r2, #1
  __HAL_RCC_PWR_CLK_DISABLE();
 c0018ca:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 c0018ce:	65a3      	str	r3, [r4, #88]	; 0x58
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
 c0018d0:	2300      	movs	r3, #0
 c0018d2:	9307      	str	r3, [sp, #28]
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
 c0018d4:	2302      	movs	r3, #2
  RCC_OscInitStruct.PLL.PLLM = 1;
 c0018d6:	9214      	str	r2, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
 c0018d8:	e9cd 3212 	strd	r3, r2, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLN = 55;
 c0018dc:	2237      	movs	r2, #55	; 0x37
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 c0018de:	a807      	add	r0, sp, #28
  RCC_OscInitStruct.PLL.PLLN = 55;
 c0018e0:	9215      	str	r2, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 c0018e2:	e9cd 3317 	strd	r3, r3, [sp, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 c0018e6:	9316      	str	r3, [sp, #88]	; 0x58
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 c0018e8:	f001 fcf0 	bl	c0032cc <HAL_RCC_OscConfig>
 c0018ec:	b108      	cbz	r0, c0018f2 <main+0x26a>
    Error_Handler();
 c0018ee:	f7ff fe93 	bl	c001618 <Error_Handler>
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 c0018f2:	230f      	movs	r3, #15
 c0018f4:	2103      	movs	r1, #3
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 c0018f6:	2400      	movs	r4, #0
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 c0018f8:	e9cd 3102 	strd	r3, r1, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 c0018fc:	2380      	movs	r3, #128	; 0x80
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
 c0018fe:	a802      	add	r0, sp, #8
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 c001900:	e9cd 3404 	strd	r3, r4, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 c001904:	9406      	str	r4, [sp, #24]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
 c001906:	f001 ffdb 	bl	c0038c0 <HAL_RCC_ClockConfig>
 c00190a:	b108      	cbz	r0, c001910 <main+0x288>
    Error_Handler();
 c00190c:	f7ff fe84 	bl	c001618 <Error_Handler>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK;
 c001910:	2302      	movs	r3, #2
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 c001912:	2105      	movs	r1, #5
 c001914:	a802      	add	r0, sp, #8
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK;
 c001916:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 c001918:	9404      	str	r4, [sp, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 c00191a:	f001 ffd1 	bl	c0038c0 <HAL_RCC_ClockConfig>
 c00191e:	b108      	cbz	r0, c001924 <main+0x29c>
    Error_Handler();
 c001920:	f7ff fe7a 	bl	c001618 <Error_Handler>
    __HAL_RCC_GTZC_CLK_ENABLE();
 c001924:	4b1a      	ldr	r3, [pc, #104]	; (c001990 <main+0x308>)
    if (HAL_GTZC_MPCBB_GetConfigMem(SRAM2_BASE, &MPCBB_desc) != HAL_OK)
 c001926:	a907      	add	r1, sp, #28
    __HAL_RCC_GTZC_CLK_ENABLE();
 c001928:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    if (HAL_GTZC_MPCBB_GetConfigMem(SRAM2_BASE, &MPCBB_desc) != HAL_OK)
 c00192a:	481c      	ldr	r0, [pc, #112]	; (c00199c <main+0x314>)
    __HAL_RCC_GTZC_CLK_ENABLE();
 c00192c:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 c001930:	649a      	str	r2, [r3, #72]	; 0x48
 c001932:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 c001934:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 c001938:	9302      	str	r3, [sp, #8]
 c00193a:	9b02      	ldr	r3, [sp, #8]
    if (HAL_GTZC_MPCBB_GetConfigMem(SRAM2_BASE, &MPCBB_desc) != HAL_OK)
 c00193c:	f001 f912 	bl	c002b64 <HAL_GTZC_MPCBB_GetConfigMem>
 c001940:	b108      	cbz	r0, c001946 <main+0x2be>
      Error_Handler();
 c001942:	f7ff fe69 	bl	c001618 <Error_Handler>
    MPCBB_desc.AttributeConfig.MPCBB_LockConfig_array[0] |= 0x00000080;
 c001946:	9b21      	ldr	r3, [sp, #132]	; 0x84
    if (HAL_GTZC_MPCBB_ConfigMem(SRAM2_BASE, &MPCBB_desc) != HAL_OK)
 c001948:	a907      	add	r1, sp, #28
    MPCBB_desc.AttributeConfig.MPCBB_LockConfig_array[0] |= 0x00000080;
 c00194a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    if (HAL_GTZC_MPCBB_ConfigMem(SRAM2_BASE, &MPCBB_desc) != HAL_OK)
 c00194e:	4813      	ldr	r0, [pc, #76]	; (c00199c <main+0x314>)
    MPCBB_desc.AttributeConfig.MPCBB_LockConfig_array[0] |= 0x00000080;
 c001950:	9321      	str	r3, [sp, #132]	; 0x84
    if (HAL_GTZC_MPCBB_ConfigMem(SRAM2_BASE, &MPCBB_desc) != HAL_OK)
 c001952:	f001 f8c7 	bl	c002ae4 <HAL_GTZC_MPCBB_ConfigMem>
 c001956:	b318      	cbz	r0, c0019a0 <main+0x318>
      Error_Handler();
 c001958:	f7ff fe5e 	bl	c001618 <Error_Handler>
 c00195c:	e020      	b.n	c0019a0 <main+0x318>
 c00195e:	bf00      	nop
 c001960:	50032c00 	.word	0x50032c00
 c001964:	e000ed90 	.word	0xe000ed90
 c001968:	0c014000 	.word	0x0c014000
 c00196c:	0c00c000 	.word	0x0c00c000
 c001970:	08038000 	.word	0x08038000
 c001974:	0804a000 	.word	0x0804a000
 c001978:	08080000 	.word	0x08080000
 c00197c:	2003fc00 	.word	0x2003fc00
 c001980:	20000020 	.word	0x20000020
 c001984:	e000edd0 	.word	0xe000edd0
 c001988:	0bf90000 	.word	0x0bf90000
 c00198c:	40022000 	.word	0x40022000
 c001990:	50021000 	.word	0x50021000
 c001994:	3003396c 	.word	0x3003396c
 c001998:	50002800 	.word	0x50002800
 c00199c:	30030000 	.word	0x30030000
  stdio_init();
 c0019a0:	f006 fe3c 	bl	c00861c <stdio_init>
  TFM_LL_SECU_CheckStaticProtections();
 c0019a4:	f000 fa88 	bl	c001eb8 <TFM_LL_SECU_CheckStaticProtections>
  TFM_LL_SECU_ApplyRunTimeProtections();
 c0019a8:	f000 fa7a 	bl	c001ea0 <TFM_LL_SECU_ApplyRunTimeProtections>
  (void)bl2_main();
 c0019ac:	f005 fb08 	bl	c006fc0 <bl2_main>
}
 c0019b0:	2000      	movs	r0, #0
 c0019b2:	b022      	add	sp, #136	; 0x88
 c0019b4:	bd70      	pop	{r4, r5, r6, pc}
 c0019b6:	bf00      	nop

0c0019b8 <mpu_config_appli>:
{
 c0019b8:	b510      	push	{r4, lr}
  region_cfg.region_base = FLASH_BASE_S + FLASH_AREA_0_OFFSET ;
 c0019ba:	2400      	movs	r4, #0
  struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 c0019bc:	4b18      	ldr	r3, [pc, #96]	; (c001a20 <mpu_config_appli+0x68>)
{
 c0019be:	b088      	sub	sp, #32
  struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 c0019c0:	9301      	str	r3, [sp, #4]
  struct mpu_armv8m_dev_t dev_mpu_ns = { MPU_BASE_NS};
 c0019c2:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 c0019c6:	9302      	str	r3, [sp, #8]
  region_cfg.region_base = FLASH_BASE_S + FLASH_AREA_0_OFFSET ;
 c0019c8:	4b16      	ldr	r3, [pc, #88]	; (c001a24 <mpu_config_appli+0x6c>)
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c0019ca:	a903      	add	r1, sp, #12
  region_cfg.region_base = FLASH_BASE_S + FLASH_AREA_0_OFFSET ;
 c0019cc:	e9cd 4303 	strd	r4, r3, [sp, #12]
  region_cfg.region_limit = FLASH_BASE_S + FLASH_AREA_0_OFFSET + FLASH_AREA_0_SIZE;
 c0019d0:	f503 3310 	add.w	r3, r3, #147456	; 0x24000
 c0019d4:	9305      	str	r3, [sp, #20]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c0019d6:	2302      	movs	r3, #2
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c0019d8:	a801      	add	r0, sp, #4
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c0019da:	9306      	str	r3, [sp, #24]
  region_cfg.attr_access = MPU_ARMV8M_AP_RO_PRIV_ONLY;
 c0019dc:	f88d 301d 	strb.w	r3, [sp, #29]
  region_cfg.attr_sh = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c0019e0:	f88d 301e 	strb.w	r3, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_OK;
 c0019e4:	f88d 401c 	strb.w	r4, [sp, #28]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c0019e8:	f000 f83a 	bl	c001a60 <mpu_armv8m_region_enable>
 c0019ec:	b108      	cbz	r0, c0019f2 <mpu_config_appli+0x3a>
    Error_Handler();
 c0019ee:	f7ff fe13 	bl	c001618 <Error_Handler>
  region_cfg.region_base = FLASH_BASE_NS + FLASH_AREA_1_OFFSET;
 c0019f2:	4b0d      	ldr	r3, [pc, #52]	; (c001a28 <mpu_config_appli+0x70>)
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c0019f4:	a903      	add	r1, sp, #12
  region_cfg.region_base = FLASH_BASE_NS + FLASH_AREA_1_OFFSET;
 c0019f6:	9304      	str	r3, [sp, #16]
  region_cfg.region_limit = FLASH_BASE_NS + FLASH_AREA_1_OFFSET + FLASH_AREA_1_SIZE;
 c0019f8:	f503 3390 	add.w	r3, r3, #73728	; 0x12000
 c0019fc:	9305      	str	r3, [sp, #20]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c0019fe:	2302      	movs	r3, #2
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c001a00:	a802      	add	r0, sp, #8
  region_cfg.region_nr = 0;
 c001a02:	9403      	str	r4, [sp, #12]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c001a04:	9306      	str	r3, [sp, #24]
  region_cfg.attr_access = MPU_ARMV8M_AP_RO_PRIV_ONLY;
 c001a06:	f88d 301d 	strb.w	r3, [sp, #29]
  region_cfg.attr_sh = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c001a0a:	f88d 301e 	strb.w	r3, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_OK;
 c001a0e:	f88d 401c 	strb.w	r4, [sp, #28]
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c001a12:	f000 f825 	bl	c001a60 <mpu_armv8m_region_enable>
 c001a16:	b108      	cbz	r0, c001a1c <mpu_config_appli+0x64>
    Error_Handler();
 c001a18:	f7ff fdfe 	bl	c001618 <Error_Handler>
}
 c001a1c:	b008      	add	sp, #32
 c001a1e:	bd10      	pop	{r4, pc}
 c001a20:	e000ed90 	.word	0xe000ed90
 c001a24:	0c014000 	.word	0x0c014000
 c001a28:	08038000 	.word	0x08038000

0c001a2c <mpu_armv8m_enable>:
  mpu->MAIR0 = (MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL << MPU_MAIR0_Attr0_Pos) |
               (MPU_ARMV8M_MAIR_ATTR_CODE_VAL << MPU_MAIR0_Attr1_Pos) |
               (MPU_ARMV8M_MAIR_ATTR_DATA_VAL << MPU_MAIR0_Attr2_Pos);

  mpu->CTRL =
    (privdef_en ? MPU_CTRL_PRIVDEFENA_Msk : 0) |
 c001a2c:	2900      	cmp	r1, #0
 c001a2e:	bf14      	ite	ne
 c001a30:	2104      	movne	r1, #4
 c001a32:	2100      	moveq	r1, #0
    (hfnmi_en   ? MPU_CTRL_HFNMIENA_Msk   : 0);
 c001a34:	2a00      	cmp	r2, #0
 c001a36:	bf14      	ite	ne
 c001a38:	2202      	movne	r2, #2
 c001a3a:	2200      	moveq	r2, #0
  MPU_Type *mpu = (MPU_Type *)dev->base;
 c001a3c:	6803      	ldr	r3, [r0, #0]
  mpu->MAIR0 = (MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL << MPU_MAIR0_Attr0_Pos) |
 c001a3e:	4807      	ldr	r0, [pc, #28]	; (c001a5c <mpu_armv8m_enable+0x30>)
    (privdef_en ? MPU_CTRL_PRIVDEFENA_Msk : 0) |
 c001a40:	4311      	orrs	r1, r2
  mpu->MAIR0 = (MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL << MPU_MAIR0_Attr0_Pos) |
 c001a42:	6318      	str	r0, [r3, #48]	; 0x30
  mpu->CTRL =
 c001a44:	6059      	str	r1, [r3, #4]

  /*Ensure all configuration is written before enable*/

  mpu->CTRL |= MPU_CTRL_ENABLE_Msk;
 c001a46:	685a      	ldr	r2, [r3, #4]
 c001a48:	f042 0201 	orr.w	r2, r2, #1
 c001a4c:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
 c001a4e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c001a52:	f3bf 8f6f 	isb	sy

  /* Enable MPU before next instruction */
  __DSB();
  __ISB();
  return MPU_ARMV8M_OK;
}
 c001a56:	2000      	movs	r0, #0
 c001a58:	4770      	bx	lr
 c001a5a:	bf00      	nop
 c001a5c:	00ffaa04 	.word	0x00ffaa04

0c001a60 <mpu_armv8m_region_enable>:
  enum mpu_armv8m_error_t ret_val = MPU_ARMV8M_OK;
  uint32_t base_cfg;
  uint32_t limit_cfg;

  /*FIXME : Add complete error checking*/
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 c001a60:	684a      	ldr	r2, [r1, #4]
{
 c001a62:	b510      	push	{r4, lr}
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 c001a64:	f012 041f 	ands.w	r4, r2, #31
 c001a68:	d125      	bne.n	c001ab6 <mpu_armv8m_region_enable+0x56>
  /* region_limit doesn't need to be aligned but the scatter
   * file needs to be setup to ensure that partitions do not overlap.
   */
  /* don't disable MPU */

  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 c001a6a:	780b      	ldrb	r3, [r1, #0]
  MPU_Type *mpu = (MPU_Type *)dev->base;
 c001a6c:	6800      	ldr	r0, [r0, #0]

  /* This 0s the lower bits of the base address */
  base_cfg = region_cfg->region_base & MPU_RBAR_BASE_Msk;
 c001a6e:	f022 021f 	bic.w	r2, r2, #31
  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 c001a72:	6083      	str	r3, [r0, #8]
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 c001a74:	7c0b      	ldrb	r3, [r1, #16]
 c001a76:	f003 0301 	and.w	r3, r3, #1
 c001a7a:	4313      	orrs	r3, r2
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
 c001a7c:	7c8a      	ldrb	r2, [r1, #18]
 c001a7e:	00d2      	lsls	r2, r2, #3
 c001a80:	f002 0218 	and.w	r2, r2, #24
 c001a84:	431a      	orrs	r2, r3
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
 c001a86:	7c4b      	ldrb	r3, [r1, #17]
 c001a88:	005b      	lsls	r3, r3, #1
 c001a8a:	f003 0306 	and.w	r3, r3, #6
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 c001a8e:	4313      	orrs	r3, r2

  mpu->RBAR = base_cfg;
 c001a90:	60c3      	str	r3, [r0, #12]

  /*This 0s the lower bits of base address but they are treated as 1 */
  limit_cfg = (region_cfg->region_limit - 1) & MPU_RLAR_LIMIT_Msk;
 c001a92:	688b      	ldr	r3, [r1, #8]
 c001a94:	3b01      	subs	r3, #1
 c001a96:	f023 021f 	bic.w	r2, r3, #31

  limit_cfg |= (region_cfg->region_attridx << MPU_RLAR_AttrIndx_Pos) &
 c001a9a:	68cb      	ldr	r3, [r1, #12]
 c001a9c:	005b      	lsls	r3, r3, #1
 c001a9e:	f003 030e 	and.w	r3, r3, #14
 c001aa2:	4313      	orrs	r3, r2
               MPU_RLAR_AttrIndx_Msk;

  limit_cfg |= MPU_RLAR_EN_Msk;
 c001aa4:	f043 0301 	orr.w	r3, r3, #1

  mpu->RLAR = limit_cfg;
 c001aa8:	6103      	str	r3, [r0, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 c001aaa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c001aae:	f3bf 8f6f 	isb	sy

  /* Enable MPU before the next instruction */
  __DSB();
  __ISB();

  return ret_val;
 c001ab2:	4620      	mov	r0, r4
}
 c001ab4:	bd10      	pop	{r4, pc}
    return MPU_ARMV8M_ERROR;
 c001ab6:	2001      	movs	r0, #1
 c001ab8:	e7fc      	b.n	c001ab4 <mpu_armv8m_region_enable+0x54>
	...

0c001abc <mbedtls_sha256_init>:
static void mbedtls_zeroize(void *v, size_t n)
{
    volatile unsigned char *p = (unsigned char *)v;
    while (n--)
    {
        *p++ = 0;
 c001abc:	2200      	movs	r2, #0
    }
}

void mbedtls_sha256_init(mbedtls_sha256_context *ctx)
{
 c001abe:	b082      	sub	sp, #8
 c001ac0:	f500 73b8 	add.w	r3, r0, #368	; 0x170
    while (n--)
 c001ac4:	4298      	cmp	r0, r3
 c001ac6:	d10b      	bne.n	c001ae0 <mbedtls_sha256_init+0x24>
    mbedtls_zeroize(ctx, sizeof(mbedtls_sha256_context));

    /* Enable HASH clock */
    __HAL_RCC_HASH_CLK_ENABLE();
 c001ac8:	4b07      	ldr	r3, [pc, #28]	; (c001ae8 <mbedtls_sha256_init+0x2c>)
 c001aca:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c001acc:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 c001ad0:	64da      	str	r2, [r3, #76]	; 0x4c
 c001ad2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 c001ad4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 c001ad8:	9301      	str	r3, [sp, #4]
 c001ada:	9b01      	ldr	r3, [sp, #4]
}
 c001adc:	b002      	add	sp, #8
 c001ade:	4770      	bx	lr
        *p++ = 0;
 c001ae0:	7002      	strb	r2, [r0, #0]
 c001ae2:	3001      	adds	r0, #1
 c001ae4:	e7ee      	b.n	c001ac4 <mbedtls_sha256_init+0x8>
 c001ae6:	bf00      	nop
 c001ae8:	50021000 	.word	0x50021000

0c001aec <mbedtls_sha256_starts_ret>:
{
    *dst = *src;
}

int mbedtls_sha256_starts_ret(mbedtls_sha256_context *ctx, int is224)
{
 c001aec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    /* HASH Configuration */
    if (HAL_HASH_DeInit(&ctx->hhash) != HAL_OK)
 c001aee:	1d06      	adds	r6, r0, #4
{
 c001af0:	4604      	mov	r4, r0
    if (HAL_HASH_DeInit(&ctx->hhash) != HAL_OK)
 c001af2:	4630      	mov	r0, r6
{
 c001af4:	460f      	mov	r7, r1
    if (HAL_HASH_DeInit(&ctx->hhash) != HAL_OK)
 c001af6:	f001 f990 	bl	c002e1a <HAL_HASH_DeInit>
 c001afa:	b110      	cbz	r0, c001b02 <mbedtls_sha256_starts_ret+0x16>
    {
        return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c001afc:	f06f 006f 	mvn.w	r0, #111	; 0x6f

    /* save hw context */
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);

    return 0;
}
 c001b00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ctx->hhash.Init.DataType = HASH_DATATYPE_8B;
 c001b02:	2320      	movs	r3, #32
    if (HAL_HASH_Init(&ctx->hhash) != HAL_OK)
 c001b04:	4630      	mov	r0, r6
    ctx->hhash.Init.DataType = HASH_DATATYPE_8B;
 c001b06:	6063      	str	r3, [r4, #4]
    if (HAL_HASH_Init(&ctx->hhash) != HAL_OK)
 c001b08:	f001 f956 	bl	c002db8 <HAL_HASH_Init>
 c001b0c:	4605      	mov	r5, r0
 c001b0e:	2800      	cmp	r0, #0
 c001b10:	d1f4      	bne.n	c001afc <mbedtls_sha256_starts_ret+0x10>
    ctx->is224 = is224;
 c001b12:	4621      	mov	r1, r4
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);
 c001b14:	4630      	mov	r0, r6
    ctx->is224 = is224;
 c001b16:	f841 7b89 	str.w	r7, [r1], #137
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);
 c001b1a:	f001 f997 	bl	c002e4c <HAL_HASH_ContextSaving>
    return 0;
 c001b1e:	4628      	mov	r0, r5
 c001b20:	e7ee      	b.n	c001b00 <mbedtls_sha256_starts_ret+0x14>

0c001b22 <mbedtls_sha256_update_ret>:

    return 0;
}

int mbedtls_sha256_update_ret(mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen)
{
 c001b22:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c001b26:	4604      	mov	r4, r0
 c001b28:	4616      	mov	r6, r2
    size_t currentlen = ilen;

    /* restore hw context */
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
 c001b2a:	f100 0a89 	add.w	sl, r0, #137	; 0x89
 c001b2e:	1d07      	adds	r7, r0, #4
 c001b30:	4638      	mov	r0, r7
{
 c001b32:	4689      	mov	r9, r1
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
 c001b34:	4651      	mov	r1, sl
 c001b36:	f001 f9af 	bl	c002e98 <HAL_HASH_ContextRestoring>

    if (currentlen < (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len))
 c001b3a:	f894 0088 	ldrb.w	r0, [r4, #136]	; 0x88
 c001b3e:	f104 0848 	add.w	r8, r4, #72	; 0x48
 c001b42:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
 c001b46:	42b2      	cmp	r2, r6
 c001b48:	4440      	add	r0, r8
 c001b4a:	d90e      	bls.n	c001b6a <mbedtls_sha256_update_ret+0x48>
    {
        /* only store input data in context buffer */
        memcpy(ctx->sbuf + ctx->sbuf_len, input, currentlen);
 c001b4c:	4632      	mov	r2, r6
 c001b4e:	4649      	mov	r1, r9
 c001b50:	f006 fdc0 	bl	c0086d4 <memcpy>
        ctx->sbuf_len += currentlen;
 c001b54:	f894 1088 	ldrb.w	r1, [r4, #136]	; 0x88
 c001b58:	440e      	add	r6, r1
 c001b5a:	f884 6088 	strb.w	r6, [r4, #136]	; 0x88
            memcpy(ctx->sbuf, input + ilen - ctx->sbuf_len, ctx->sbuf_len);
        }
    }

    /* save hw context */
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);
 c001b5e:	4638      	mov	r0, r7
 c001b60:	4651      	mov	r1, sl
 c001b62:	f001 f973 	bl	c002e4c <HAL_HASH_ContextSaving>
    return 0;
 c001b66:	2000      	movs	r0, #0
 c001b68:	e030      	b.n	c001bcc <mbedtls_sha256_update_ret+0xaa>
        memcpy(ctx->sbuf + ctx->sbuf_len, input, (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len));
 c001b6a:	4649      	mov	r1, r9
 c001b6c:	f006 fdb2 	bl	c0086d4 <memcpy>
        currentlen -= (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len);
 c001b70:	f894 5088 	ldrb.w	r5, [r4, #136]	; 0x88
        if (ctx->is224 == 0)
 c001b74:	6823      	ldr	r3, [r4, #0]
        currentlen -= (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len);
 c001b76:	f1a6 0240 	sub.w	r2, r6, #64	; 0x40
 c001b7a:	4415      	add	r5, r2
            if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(ctx->sbuf), ST_SHA256_BLOCK_SIZE) != 0)
 c001b7c:	4641      	mov	r1, r8
 c001b7e:	2240      	movs	r2, #64	; 0x40
 c001b80:	4638      	mov	r0, r7
        if (ctx->is224 == 0)
 c001b82:	b983      	cbnz	r3, c001ba6 <mbedtls_sha256_update_ret+0x84>
            if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(ctx->sbuf), ST_SHA256_BLOCK_SIZE) != 0)
 c001b84:	f001 fa9e 	bl	c0030c4 <HAL_HASHEx_SHA256_Accmlt>
 c001b88:	b9f0      	cbnz	r0, c001bc8 <mbedtls_sha256_update_ret+0xa6>
        if (iter != 0)
 c001b8a:	2d3f      	cmp	r5, #63	; 0x3f
 c001b8c:	d80e      	bhi.n	c001bac <mbedtls_sha256_update_ret+0x8a>
        ctx->sbuf_len = currentlen % ST_SHA256_BLOCK_SIZE;
 c001b8e:	f005 023f 	and.w	r2, r5, #63	; 0x3f
 c001b92:	f884 2088 	strb.w	r2, [r4, #136]	; 0x88
        if (ctx->sbuf_len != 0)
 c001b96:	2a00      	cmp	r2, #0
 c001b98:	d0e1      	beq.n	c001b5e <mbedtls_sha256_update_ret+0x3c>
            memcpy(ctx->sbuf, input + ilen - ctx->sbuf_len, ctx->sbuf_len);
 c001b9a:	1ab1      	subs	r1, r6, r2
 c001b9c:	4449      	add	r1, r9
 c001b9e:	4640      	mov	r0, r8
 c001ba0:	f006 fd98 	bl	c0086d4 <memcpy>
 c001ba4:	e7db      	b.n	c001b5e <mbedtls_sha256_update_ret+0x3c>
            if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *)(ctx->sbuf), ST_SHA256_BLOCK_SIZE) != 0)
 c001ba6:	f001 fa7b 	bl	c0030a0 <HAL_HASHEx_SHA224_Accmlt>
 c001baa:	e7ed      	b.n	c001b88 <mbedtls_sha256_update_ret+0x66>
 c001bac:	f894 1088 	ldrb.w	r1, [r4, #136]	; 0x88
            if (ctx->is224 == 0)
 c001bb0:	6823      	ldr	r3, [r4, #0]
 c001bb2:	f1c1 0140 	rsb	r1, r1, #64	; 0x40
 c001bb6:	4449      	add	r1, r9
 c001bb8:	f025 023f 	bic.w	r2, r5, #63	; 0x3f
                if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c001bbc:	4638      	mov	r0, r7
            if (ctx->is224 == 0)
 c001bbe:	b93b      	cbnz	r3, c001bd0 <mbedtls_sha256_update_ret+0xae>
                if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c001bc0:	f001 fa80 	bl	c0030c4 <HAL_HASHEx_SHA256_Accmlt>
                if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c001bc4:	2800      	cmp	r0, #0
 c001bc6:	d0e2      	beq.n	c001b8e <mbedtls_sha256_update_ret+0x6c>
                return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c001bc8:	f06f 006f 	mvn.w	r0, #111	; 0x6f
}
 c001bcc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c001bd0:	f001 fa66 	bl	c0030a0 <HAL_HASHEx_SHA224_Accmlt>
 c001bd4:	e7f6      	b.n	c001bc4 <mbedtls_sha256_update_ret+0xa2>

0c001bd6 <mbedtls_sha256_finish_ret>:

int mbedtls_sha256_finish_ret(mbedtls_sha256_context *ctx, unsigned char output[32])
{
 c001bd6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c001bd8:	4604      	mov	r4, r0
    /* restore hw context */
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
 c001bda:	1d05      	adds	r5, r0, #4
{
 c001bdc:	460e      	mov	r6, r1
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
 c001bde:	f100 0189 	add.w	r1, r0, #137	; 0x89
 c001be2:	4628      	mov	r0, r5
 c001be4:	f001 f958 	bl	c002e98 <HAL_HASH_ContextRestoring>
 c001be8:	2303      	movs	r3, #3

    /* Last accumulation for pending bytes in sbuf_len, then trig processing and get digest */
    if (ctx->is224 == 0)
 c001bea:	6820      	ldr	r0, [r4, #0]
    {
        if (HAL_HASHEx_SHA256_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
 c001bec:	9300      	str	r3, [sp, #0]
 c001bee:	f104 0148 	add.w	r1, r4, #72	; 0x48
 c001bf2:	f894 2088 	ldrb.w	r2, [r4, #136]	; 0x88
 c001bf6:	4633      	mov	r3, r6
    if (ctx->is224 == 0)
 c001bf8:	b958      	cbnz	r0, c001c12 <mbedtls_sha256_finish_ret+0x3c>
        if (HAL_HASHEx_SHA256_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
 c001bfa:	4628      	mov	r0, r5
 c001bfc:	f001 fa68 	bl	c0030d0 <HAL_HASHEx_SHA256_Accmlt_End>
 c001c00:	b920      	cbnz	r0, c001c0c <mbedtls_sha256_finish_ret+0x36>
        {
            return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
        }
    }

    ctx->sbuf_len = 0;
 c001c02:	2000      	movs	r0, #0
 c001c04:	f884 0088 	strb.w	r0, [r4, #136]	; 0x88

    return 0;
}
 c001c08:	b002      	add	sp, #8
 c001c0a:	bd70      	pop	{r4, r5, r6, pc}
            return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c001c0c:	f06f 006f 	mvn.w	r0, #111	; 0x6f
 c001c10:	e7fa      	b.n	c001c08 <mbedtls_sha256_finish_ret+0x32>
        if (HAL_HASHEx_SHA224_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
 c001c12:	4628      	mov	r0, r5
 c001c14:	f001 fa48 	bl	c0030a8 <HAL_HASHEx_SHA224_Accmlt_End>
 c001c18:	e7f2      	b.n	c001c00 <mbedtls_sha256_finish_ret+0x2a>

0c001c1a <mbedtls_sha256_starts>:

void mbedtls_sha256_starts( mbedtls_sha256_context *ctx,
                            int is224 )
{
    mbedtls_sha256_starts_ret( ctx, is224 );
 c001c1a:	f7ff bf67 	b.w	c001aec <mbedtls_sha256_starts_ret>

0c001c1e <mbedtls_sha256_update>:

void mbedtls_sha256_update( mbedtls_sha256_context *ctx,
                            const unsigned char *input,
                            size_t ilen )
{
    mbedtls_sha256_update_ret( ctx, input, ilen );
 c001c1e:	f7ff bf80 	b.w	c001b22 <mbedtls_sha256_update_ret>

0c001c22 <mbedtls_sha256_finish>:
}

void mbedtls_sha256_finish( mbedtls_sha256_context *ctx,
                            unsigned char output[32] )
{
    mbedtls_sha256_finish_ret( ctx, output );
 c001c22:	f7ff bfd8 	b.w	c001bd6 <mbedtls_sha256_finish_ret>
	...

0c001c28 <HAL_RTC_MspInit>:
     - Enable the power clock using __HAL_RCC_PWR_CLK_ENABLE()
     - Enable write access using HAL_PWR_EnableBkUpAccess() function before to
       configure the RTC clock source (to be done once after reset).
     - Configure the needed RTC clock source */

  __HAL_RCC_PWR_CLK_ENABLE();
 c001c28:	4b23      	ldr	r3, [pc, #140]	; (c001cb8 <HAL_RTC_MspInit+0x90>)
{
 c001c2a:	b500      	push	{lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 c001c2c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
{
 c001c2e:	b0bb      	sub	sp, #236	; 0xec
  __HAL_RCC_PWR_CLK_ENABLE();
 c001c30:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 c001c34:	659a      	str	r2, [r3, #88]	; 0x58
 c001c36:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 c001c38:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c001c3c:	9301      	str	r3, [sp, #4]
 c001c3e:	9b01      	ldr	r3, [sp, #4]
  
  HAL_PWR_EnableBkUpAccess();
 c001c40:	f001 fa48 	bl	c0030d4 <HAL_PWR_EnableBkUpAccess>

  /* If the system has resumed from STANDBY mode, no need to reconfigure all clocks */
  if (__HAL_PWR_GET_FLAG(PWR_FLAG_SB) == RESET)
 c001c44:	4b1d      	ldr	r3, [pc, #116]	; (c001cbc <HAL_RTC_MspInit+0x94>)
 c001c46:	691b      	ldr	r3, [r3, #16]
 c001c48:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 c001c4c:	d11e      	bne.n	c001c8c <HAL_RTC_MspInit+0x64>
  {

#ifdef RTC_CLOCK_SOURCE_LSE
    RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_LSE;
 c001c4e:	220c      	movs	r2, #12
 c001c50:	9203      	str	r2, [sp, #12]
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
    RCC_OscInitStruct.LSEState = RCC_LSE_ON_RTC_ONLY;
 c001c52:	2201      	movs	r2, #1
    RCC_OscInitStruct.LSIState = RCC_LSI_OFF;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 c001c54:	a803      	add	r0, sp, #12
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 c001c56:	930e      	str	r3, [sp, #56]	; 0x38
    RCC_OscInitStruct.LSEState = RCC_LSE_ON_RTC_ONLY;
 c001c58:	9205      	str	r2, [sp, #20]
    RCC_OscInitStruct.LSIState = RCC_LSI_OFF;
 c001c5a:	9308      	str	r3, [sp, #32]
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 c001c5c:	f001 fb36 	bl	c0032cc <HAL_RCC_OscConfig>
 c001c60:	b108      	cbz	r0, c001c66 <HAL_RTC_MspInit+0x3e>
    {
      Error_Handler();
 c001c62:	f7ff fcd9 	bl	c001618 <Error_Handler>
    }

    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 c001c66:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 c001c6a:	9315      	str	r3, [sp, #84]	; 0x54
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 c001c6c:	f44f 7380 	mov.w	r3, #256	; 0x100
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 c001c70:	a815      	add	r0, sp, #84	; 0x54
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 c001c72:	9339      	str	r3, [sp, #228]	; 0xe4
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 c001c74:	f002 f822 	bl	c003cbc <HAL_RCCEx_PeriphCLKConfig>
 c001c78:	b108      	cbz	r0, c001c7e <HAL_RTC_MspInit+0x56>
    {
      Error_Handler();
 c001c7a:	f7ff fccd 	bl	c001618 <Error_Handler>
#else
#error Please select the RTC Clock source inside the main.h file
#endif /*RTC_CLOCK_SOURCE_LSE*/

    /* Enable RTC Clock */
    __HAL_RCC_RTC_ENABLE();
 c001c7e:	4a0e      	ldr	r2, [pc, #56]	; (c001cb8 <HAL_RTC_MspInit+0x90>)
 c001c80:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 c001c84:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 c001c88:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  } /* if(__HAL_PWR_GET_FLAG(PWR_FLAG_SB) != RESET) */

  /* Enable RTC APB clock  */
  __HAL_RCC_RTCAPB_CLK_ENABLE();

  HAL_NVIC_SetPriority(TAMP_IRQn, 0x4, 0);
 c001c8c:	2104      	movs	r1, #4
  __HAL_RCC_RTCAPB_CLK_ENABLE();
 c001c8e:	4b0a      	ldr	r3, [pc, #40]	; (c001cb8 <HAL_RTC_MspInit+0x90>)
  HAL_NVIC_SetPriority(TAMP_IRQn, 0x4, 0);
 c001c90:	4608      	mov	r0, r1
  __HAL_RCC_RTCAPB_CLK_ENABLE();
 c001c92:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c001c94:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 c001c98:	659a      	str	r2, [r3, #88]	; 0x58
 c001c9a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
  HAL_NVIC_SetPriority(TAMP_IRQn, 0x4, 0);
 c001c9c:	2200      	movs	r2, #0
  __HAL_RCC_RTCAPB_CLK_ENABLE();
 c001c9e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 c001ca2:	9302      	str	r3, [sp, #8]
 c001ca4:	9b02      	ldr	r3, [sp, #8]
  HAL_NVIC_SetPriority(TAMP_IRQn, 0x4, 0);
 c001ca6:	f000 faa1 	bl	c0021ec <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TAMP_IRQn);
 c001caa:	2004      	movs	r0, #4
 c001cac:	f000 fad2 	bl	c002254 <HAL_NVIC_EnableIRQ>
}
 c001cb0:	b03b      	add	sp, #236	; 0xec
 c001cb2:	f85d fb04 	ldr.w	pc, [sp], #4
 c001cb6:	bf00      	nop
 c001cb8:	50021000 	.word	0x50021000
 c001cbc:	50007000 	.word	0x50007000

0c001cc0 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 c001cc0:	4a03      	ldr	r2, [pc, #12]	; (c001cd0 <SystemInit+0x10>)
 c001cc2:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 c001cc6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 c001cca:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif
}
 c001cce:	4770      	bx	lr
 c001cd0:	e000ed00 	.word	0xe000ed00

0c001cd4 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
  uint32_t tmp, msirange, pllvco, pllsource, pllm, pllr;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 c001cd4:	4a23      	ldr	r2, [pc, #140]	; (c001d64 <SystemCoreClockUpdate+0x90>)
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];
 c001cd6:	4924      	ldr	r1, [pc, #144]	; (c001d68 <SystemCoreClockUpdate+0x94>)
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 c001cd8:	6813      	ldr	r3, [r2, #0]
{
 c001cda:	b510      	push	{r4, lr}
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 c001cdc:	071b      	lsls	r3, r3, #28
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 c001cde:	bf54      	ite	pl
 c001ce0:	f8d2 3094 	ldrpl.w	r3, [r2, #148]	; 0x94
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 c001ce4:	6813      	ldrmi	r3, [r2, #0]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c001ce6:	6890      	ldr	r0, [r2, #8]
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 c001ce8:	bf58      	it	pl
 c001cea:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c001cee:	f000 000c 	and.w	r0, r0, #12
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 c001cf2:	bf48      	it	mi
 c001cf4:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c001cf8:	2808      	cmp	r0, #8
  msirange = MSIRangeTable[msirange];
 c001cfa:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
 c001cfe:	491b      	ldr	r1, [pc, #108]	; (c001d6c <SystemCoreClockUpdate+0x98>)
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c001d00:	d003      	beq.n	c001d0a <SystemCoreClockUpdate+0x36>
 c001d02:	280c      	cmp	r0, #12
 c001d04:	d00d      	beq.n	c001d22 <SystemCoreClockUpdate+0x4e>
 c001d06:	2804      	cmp	r0, #4
 c001d08:	d129      	bne.n	c001d5e <SystemCoreClockUpdate+0x8a>
    case 0x00:  /* MSI used as system clock source */
      SystemCoreClock = msirange;
      break;

    case 0x04:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
 c001d0a:	4b19      	ldr	r3, [pc, #100]	; (c001d70 <SystemCoreClockUpdate+0x9c>)
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
      SystemCoreClock = pllvco/pllr;
 c001d0c:	600b      	str	r3, [r1, #0]
      SystemCoreClock = msirange;
      break;
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
 c001d0e:	4b15      	ldr	r3, [pc, #84]	; (c001d64 <SystemCoreClockUpdate+0x90>)
 c001d10:	4a18      	ldr	r2, [pc, #96]	; (c001d74 <SystemCoreClockUpdate+0xa0>)
 c001d12:	689b      	ldr	r3, [r3, #8]
 c001d14:	f3c3 1303 	ubfx	r3, r3, #4, #4
 c001d18:	5cd2      	ldrb	r2, [r2, r3]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 c001d1a:	680b      	ldr	r3, [r1, #0]
 c001d1c:	40d3      	lsrs	r3, r2
 c001d1e:	600b      	str	r3, [r1, #0]
}
 c001d20:	bd10      	pop	{r4, pc}
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c001d22:	68d0      	ldr	r0, [r2, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 c001d24:	68d3      	ldr	r3, [r2, #12]
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c001d26:	f000 0203 	and.w	r2, r0, #3
      switch (pllsource)
 c001d2a:	3a02      	subs	r2, #2
 c001d2c:	2a01      	cmp	r2, #1
          pllvco = (HSE_VALUE / pllm);
 c001d2e:	bf98      	it	ls
 c001d30:	4a0f      	ldrls	r2, [pc, #60]	; (c001d70 <SystemCoreClockUpdate+0x9c>)
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 c001d32:	f3c3 1303 	ubfx	r3, r3, #4, #4
 c001d36:	f103 0301 	add.w	r3, r3, #1
          pllvco = (HSE_VALUE / pllm);
 c001d3a:	bf94      	ite	ls
 c001d3c:	fbb2 f3f3 	udivls	r3, r2, r3
          pllvco = (msirange / pllm);
 c001d40:	fbb4 f3f3 	udivhi	r3, r4, r3
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 c001d44:	4a07      	ldr	r2, [pc, #28]	; (c001d64 <SystemCoreClockUpdate+0x90>)
 c001d46:	68d0      	ldr	r0, [r2, #12]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 c001d48:	68d2      	ldr	r2, [r2, #12]
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 c001d4a:	f3c0 2006 	ubfx	r0, r0, #8, #7
 c001d4e:	4343      	muls	r3, r0
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 c001d50:	f3c2 6241 	ubfx	r2, r2, #25, #2
 c001d54:	3201      	adds	r2, #1
 c001d56:	0052      	lsls	r2, r2, #1
      SystemCoreClock = pllvco/pllr;
 c001d58:	fbb3 f3f2 	udiv	r3, r3, r2
 c001d5c:	e7d6      	b.n	c001d0c <SystemCoreClockUpdate+0x38>
      SystemCoreClock = msirange;
 c001d5e:	600c      	str	r4, [r1, #0]
      break;
 c001d60:	e7d5      	b.n	c001d0e <SystemCoreClockUpdate+0x3a>
 c001d62:	bf00      	nop
 c001d64:	50021000 	.word	0x50021000
 c001d68:	0c00a098 	.word	0x0c00a098
 c001d6c:	30030008 	.word	0x30030008
 c001d70:	00f42400 	.word	0x00f42400
 c001d74:	0c00a080 	.word	0x0c00a080

0c001d78 <TFM_BL2_CopySharedData>:

void TFM_BL2_CopySharedData(void)
{
  uint32_t i;
  /*  default value */
  enum tfm_security_lifecycle_t lifecycle = TFM_SLC_SECURED;
 c001d78:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  /* if 1 for TFM regression test */
  uint8_t boot_seed[BOOT_SEED_SIZE];
  uint8_t implementation_id[IMPLEMENTATION_ID_MAX_SIZE];
  size_t len = sizeof(boot_seed);
 c001d7c:	2220      	movs	r2, #32
{
 c001d7e:	b570      	push	{r4, r5, r6, lr}
 c001d80:	b0ee      	sub	sp, #440	; 0x1b8
  enum tfm_security_lifecycle_t lifecycle = TFM_SLC_SECURED;
 c001d82:	f8ad 3002 	strh.w	r3, [sp, #2]
  mbedtls_hardware_poll(NULL, boot_seed, sizeof(boot_seed), &len);
 c001d86:	a902      	add	r1, sp, #8
 c001d88:	ab01      	add	r3, sp, #4
 c001d8a:	2000      	movs	r0, #0
  size_t len = sizeof(boot_seed);
 c001d8c:	9201      	str	r2, [sp, #4]
  mbedtls_hardware_poll(NULL, boot_seed, sizeof(boot_seed), &len);
 c001d8e:	f7ff fb8b 	bl	c0014a8 <mbedtls_hardware_poll>
  if (len != sizeof(boot_seed))
 c001d92:	9b01      	ldr	r3, [sp, #4]
 c001d94:	2b20      	cmp	r3, #32
 c001d96:	d004      	beq.n	c001da2 <TFM_BL2_CopySharedData+0x2a>
  {
    BOOT_LOG_ERR("BL2 BOOT SEED generation Failed !!");
 c001d98:	4836      	ldr	r0, [pc, #216]	; (c001e74 <TFM_BL2_CopySharedData+0xfc>)
 c001d9a:	f006 fdd9 	bl	c008950 <puts>
    Error_Handler();
 c001d9e:	f7ff fc3b 	bl	c001618 <Error_Handler>
  }
#ifndef TFM_HUK_RANDOM_GENERATION
  enum shared_memory_err_t res;
  res = boot_add_data_to_shared_area(TLV_MAJOR_SST,
 c001da2:	4b35      	ldr	r3, [pc, #212]	; (c001e78 <TFM_BL2_CopySharedData+0x100>)
 c001da4:	2220      	movs	r2, #32
 c001da6:	f644 0155 	movw	r1, #18517	; 0x4855
 c001daa:	2002      	movs	r0, #2
 c001dac:	f005 f97a 	bl	c0070a4 <boot_add_data_to_shared_area>
                                     TLV_MINOR_CORE_HUK,
                                     sizeof(huk_value) - 1,
                                     (const uint8_t *)huk_value);
  if (res)
 c001db0:	b120      	cbz	r0, c001dbc <TFM_BL2_CopySharedData+0x44>
  {
    BOOT_LOG_ERR("BL2 HUK set BL2 SHARED DATA Failed !!");
 c001db2:	4832      	ldr	r0, [pc, #200]	; (c001e7c <TFM_BL2_CopySharedData+0x104>)
 c001db4:	f006 fdcc 	bl	c008950 <puts>
    Error_Handler();;
 c001db8:	f7ff fc2e 	bl	c001618 <Error_Handler>
  }
  BOOT_LOG_INF("BL2 HUK %s set to BL2 SHARED DATA", huk_value);

#endif /*TFM_HUK_RANDOM_GENERATION*/
  /* Add BOOT SEED to the shared data */
  boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c001dbc:	ab02      	add	r3, sp, #8
 c001dbe:	2220      	movs	r2, #32
 c001dc0:	2100      	movs	r1, #0
 c001dc2:	2001      	movs	r0, #1
 c001dc4:	f005 f96e 	bl	c0070a4 <boot_add_data_to_shared_area>
                               TLV_MINOR_IAS_BOOT_SEED,
                               sizeof(boot_seed),
                               (const uint8_t *)boot_seed);
  /* Add Hardocded Lifecycle value */
  boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c001dc8:	2202      	movs	r2, #2
  /* secure the read/write access to tamper backup register 0 to 7 */
  MODIFY_REG(TAMP->SMCR, TAMP_SMCR_BKPRWDPROT, 8U);
  TAMP->PRIVCR |= TAMP_PRIVCR_BKPRWPRIV;
  /* recopy priv key in back up 0 to 7  */

  for (i = 0; i < sizeof(initial_attestation_private_key); i += 4)
 c001dca:	2400      	movs	r4, #0
  boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c001dcc:	4611      	mov	r1, r2
 c001dce:	f10d 0302 	add.w	r3, sp, #2
 c001dd2:	2001      	movs	r0, #1
 c001dd4:	f005 f966 	bl	c0070a4 <boot_add_data_to_shared_area>
  boot_add_data_to_shared_area(TLV_MAJOR_CORE,
 c001dd8:	4b29      	ldr	r3, [pc, #164]	; (c001e80 <TFM_BL2_CopySharedData+0x108>)
 c001dda:	2220      	movs	r2, #32
 c001ddc:	f644 3158 	movw	r1, #19288	; 0x4b58
 c001de0:	2000      	movs	r0, #0
 c001de2:	f005 f95f 	bl	c0070a4 <boot_add_data_to_shared_area>
  boot_add_data_to_shared_area(TLV_MAJOR_CORE,
 c001de6:	4b27      	ldr	r3, [pc, #156]	; (c001e84 <TFM_BL2_CopySharedData+0x10c>)
 c001de8:	2220      	movs	r2, #32
 c001dea:	f644 3159 	movw	r1, #19289	; 0x4b59
 c001dee:	2000      	movs	r0, #0
 c001df0:	f005 f958 	bl	c0070a4 <boot_add_data_to_shared_area>
  boot_add_data_to_shared_area(TLV_MAJOR_CORE,
 c001df4:	4b24      	ldr	r3, [pc, #144]	; (c001e88 <TFM_BL2_CopySharedData+0x110>)
 c001df6:	2220      	movs	r2, #32
 c001df8:	f644 3148 	movw	r1, #19272	; 0x4b48
 c001dfc:	2000      	movs	r0, #0
 c001dfe:	f005 f951 	bl	c0070a4 <boot_add_data_to_shared_area>
  boot_add_data_to_shared_area(TLV_MAJOR_CORE,
 c001e02:	4b22      	ldr	r3, [pc, #136]	; (c001e8c <TFM_BL2_CopySharedData+0x114>)
 c001e04:	2201      	movs	r2, #1
 c001e06:	f644 3154 	movw	r1, #19284	; 0x4b54
 c001e0a:	2000      	movs	r0, #0
 c001e0c:	f005 f94a 	bl	c0070a4 <boot_add_data_to_shared_area>

typedef mbedtls_sha256_context bootutil_sha256_context;

static inline void bootutil_sha256_init(bootutil_sha256_context *ctx)
{
    mbedtls_sha256_init(ctx);
 c001e10:	a812      	add	r0, sp, #72	; 0x48
 c001e12:	f7ff fe53 	bl	c001abc <mbedtls_sha256_init>
    mbedtls_sha256_starts(ctx, 0);
 c001e16:	2100      	movs	r1, #0
 c001e18:	a812      	add	r0, sp, #72	; 0x48
 c001e1a:	f7ff fefe 	bl	c001c1a <mbedtls_sha256_starts>
  bootutil_sha256_context sha256_ctx;
  BOOT_LOG_INF("Code %x %x", (uint32_t)CODE_START
               , (uint32_t)CODE_LIMIT);
  bootutil_sha256_init(&sha256_ctx);
  /* compute write protect area set as excuteable */
  bootutil_sha256_update(&sha256_ctx,
 c001e1e:	491c      	ldr	r1, [pc, #112]	; (c001e90 <TFM_BL2_CopySharedData+0x118>)

static inline void bootutil_sha256_update(bootutil_sha256_context *ctx,
                                          const void *data,
                                          uint32_t data_len)
{
    mbedtls_sha256_update(ctx, data, data_len);
 c001e20:	4a1c      	ldr	r2, [pc, #112]	; (c001e94 <TFM_BL2_CopySharedData+0x11c>)
 c001e22:	a812      	add	r0, sp, #72	; 0x48
 c001e24:	1a52      	subs	r2, r2, r1
 c001e26:	f7ff fefa 	bl	c001c1e <mbedtls_sha256_update>
}

static inline void bootutil_sha256_finish(bootutil_sha256_context *ctx,
                                          uint8_t *output)
{
    mbedtls_sha256_finish(ctx, output);
 c001e2a:	a90a      	add	r1, sp, #40	; 0x28
 c001e2c:	a812      	add	r0, sp, #72	; 0x48
 c001e2e:	f7ff fef8 	bl	c001c22 <mbedtls_sha256_finish>
  boot_add_data_to_shared_area(TLV_MAJOR_CORE,
 c001e32:	ab0a      	add	r3, sp, #40	; 0x28
 c001e34:	2220      	movs	r2, #32
 c001e36:	f644 11cd 	movw	r1, #18893	; 0x49cd
 c001e3a:	2000      	movs	r0, #0
 c001e3c:	f005 f932 	bl	c0070a4 <boot_add_data_to_shared_area>
  MODIFY_REG(TAMP->SMCR, TAMP_SMCR_BKPRWDPROT, 8U);
 c001e40:	4a15      	ldr	r2, [pc, #84]	; (c001e98 <TFM_BL2_CopySharedData+0x120>)
    HAL_RTCEx_BKUPWrite(&RTCHandle, i / 4, *((uint32_t *)(&initial_attestation_private_key[i])));
 c001e42:	4e0d      	ldr	r6, [pc, #52]	; (c001e78 <TFM_BL2_CopySharedData+0x100>)
  MODIFY_REG(TAMP->SMCR, TAMP_SMCR_BKPRWDPROT, 8U);
 c001e44:	6a13      	ldr	r3, [r2, #32]
    HAL_RTCEx_BKUPWrite(&RTCHandle, i / 4, *((uint32_t *)(&initial_attestation_private_key[i])));
 c001e46:	4d15      	ldr	r5, [pc, #84]	; (c001e9c <TFM_BL2_CopySharedData+0x124>)
  MODIFY_REG(TAMP->SMCR, TAMP_SMCR_BKPRWDPROT, 8U);
 c001e48:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 c001e4c:	f043 0308 	orr.w	r3, r3, #8
 c001e50:	6213      	str	r3, [r2, #32]
  TAMP->PRIVCR |= TAMP_PRIVCR_BKPRWPRIV;
 c001e52:	6a53      	ldr	r3, [r2, #36]	; 0x24
 c001e54:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 c001e58:	6253      	str	r3, [r2, #36]	; 0x24
    HAL_RTCEx_BKUPWrite(&RTCHandle, i / 4, *((uint32_t *)(&initial_attestation_private_key[i])));
 c001e5a:	1933      	adds	r3, r6, r4
 c001e5c:	08a1      	lsrs	r1, r4, #2
 c001e5e:	f8d3 2082 	ldr.w	r2, [r3, #130]	; 0x82
 c001e62:	4628      	mov	r0, r5
  for (i = 0; i < sizeof(initial_attestation_private_key); i += 4)
 c001e64:	3404      	adds	r4, #4
    HAL_RTCEx_BKUPWrite(&RTCHandle, i / 4, *((uint32_t *)(&initial_attestation_private_key[i])));
 c001e66:	f002 fad3 	bl	c004410 <HAL_RTCEx_BKUPWrite>
  for (i = 0; i < sizeof(initial_attestation_private_key); i += 4)
 c001e6a:	2c20      	cmp	r4, #32
 c001e6c:	d1f5      	bne.n	c001e5a <TFM_BL2_CopySharedData+0xe2>
}
 c001e6e:	b06e      	add	sp, #440	; 0x1b8
 c001e70:	bd70      	pop	{r4, r5, r6, pc}
 c001e72:	bf00      	nop
 c001e74:	0c00a0d8 	.word	0x0c00a0d8
 c001e78:	0c000000 	.word	0x0c000000
 c001e7c:	0c00a102 	.word	0x0c00a102
 c001e80:	0c000021 	.word	0x0c000021
 c001e84:	0c000041 	.word	0x0c000041
 c001e88:	0c000061 	.word	0x0c000061
 c001e8c:	0c000081 	.word	0x0c000081
 c001e90:	0c000800 	.word	0x0c000800
 c001e94:	0c00ad78 	.word	0x0c00ad78
 c001e98:	50003400 	.word	0x50003400
 c001e9c:	3003396c 	.word	0x3003396c

0c001ea0 <TFM_LL_SECU_ApplyRunTimeProtections>:
  * @param  None
  * @note   By default, the best security protections are applied
  * @retval None
  */
void TFM_LL_SECU_ApplyRunTimeProtections(void)
{
 c001ea0:	b508      	push	{r3, lr}
#ifdef TFM_FLASH_PRIVONLY_ENABLE
  BOOT_LOG_INF("FLASH DRIVER ACCESS set to PRIVELEGED ONLY");
 c001ea2:	4804      	ldr	r0, [pc, #16]	; (c001eb4 <TFM_LL_SECU_ApplyRunTimeProtections+0x14>)
 c001ea4:	f006 fd54 	bl	c008950 <puts>
  HAL_FLASHEx_ConfigPrivMode(FLASH_PRIV_DENIED);
#endif /*  TFM_FLASH_PRIVONLY_ENABLE */
}
 c001ea8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_FLASHEx_ConfigPrivMode(FLASH_PRIV_DENIED);
 c001eac:	2001      	movs	r0, #1
 c001eae:	f000 bcbb 	b.w	c002828 <HAL_FLASHEx_ConfigPrivMode>
 c001eb2:	bf00      	nop
 c001eb4:	0c00a12f 	.word	0x0c00a12f

0c001eb8 <TFM_LL_SECU_CheckStaticProtections>:
  * @note   By default, the best security protections are applied to the different
  *         flash sections in order to maximize the security level for the specific MCU.
  * @retval None
  */
void TFM_LL_SECU_CheckStaticProtections(void)
{
 c001eb8:	b573      	push	{r0, r1, r4, r5, r6, lr}
  HAL_StatusTypeDef ret;
#endif  /* TFM_ENABLE_SET_OB  */
  uint32_t start;
  uint32_t end;
  /* Unlock the Flash to enable the flash control register access *************/
  HAL_FLASH_Unlock();
 c001eba:	f000 fa09 	bl	c0022d0 <HAL_FLASH_Unlock>
#endif /* TFM_NSBOOT_CHECK_ENABLE */

  /* get A and  bank1 OB  */
  flash_option_bytes_bank1.WRPArea = OB_WRPAREA_BANK1_AREAA;
  flash_option_bytes_bank1.WMSecConfig = OB_WMSEC_AREA1;
  flash_option_bytes_bank1.BootAddrConfig = OB_BOOTADDR_SEC0;
 c001ebe:	2604      	movs	r6, #4
  flash_option_bytes_bank1.WRPArea = OB_WRPAREA_BANK1_AREAA;
 c001ec0:	2301      	movs	r3, #1
 c001ec2:	4c94      	ldr	r4, [pc, #592]	; (c002114 <TFM_LL_SECU_CheckStaticProtections+0x25c>)
  HAL_FLASHEx_OBGetConfig(&flash_option_bytes_bank1);

  /* get B and  bank2 OB  */
  flash_option_bytes_bank2.WRPArea = OB_WRPAREA_BANK2_AREAA;
 c001ec4:	4d94      	ldr	r5, [pc, #592]	; (c002118 <TFM_LL_SECU_CheckStaticProtections+0x260>)
  HAL_FLASHEx_OBGetConfig(&flash_option_bytes_bank1);
 c001ec6:	4620      	mov	r0, r4
  flash_option_bytes_bank1.WRPArea = OB_WRPAREA_BANK1_AREAA;
 c001ec8:	6063      	str	r3, [r4, #4]
  flash_option_bytes_bank1.WMSecConfig = OB_WMSEC_AREA1;
 c001eca:	61e3      	str	r3, [r4, #28]
  flash_option_bytes_bank1.BootAddrConfig = OB_BOOTADDR_SEC0;
 c001ecc:	6326      	str	r6, [r4, #48]	; 0x30
  HAL_FLASHEx_OBGetConfig(&flash_option_bytes_bank1);
 c001ece:	f000 fc27 	bl	c002720 <HAL_FLASHEx_OBGetConfig>
  flash_option_bytes_bank2.WMSecConfig = OB_WMSEC_AREA2;
 c001ed2:	2302      	movs	r3, #2
  HAL_FLASHEx_OBGetConfig(&flash_option_bytes_bank2);
 c001ed4:	4628      	mov	r0, r5
  flash_option_bytes_bank2.WMSecConfig = OB_WMSEC_AREA2;
 c001ed6:	61eb      	str	r3, [r5, #28]
  flash_option_bytes_bank2.WRPArea = OB_WRPAREA_BANK2_AREAA;
 c001ed8:	606e      	str	r6, [r5, #4]
  HAL_FLASHEx_OBGetConfig(&flash_option_bytes_bank2);
 c001eda:	f000 fc21 	bl	c002720 <HAL_FLASHEx_OBGetConfig>


  /* Lock the Flash to disable the flash control register access (recommended
     to protect the FLASH memory against possible unwanted operation) *********/
  HAL_FLASH_Lock();
 c001ede:	f000 fa17 	bl	c002310 <HAL_FLASH_Lock>

#ifdef TFM_ENABLE_SET_OB
  /*  clean the option configuration */
  flash_option_bytes_bank1.OptionType = 0;
 c001ee2:	2300      	movs	r3, #0
 c001ee4:	6023      	str	r3, [r4, #0]
  flash_option_bytes_bank2.OptionType = 0;
  flash_option_bytes_bank2.WRPArea = 0;
 c001ee6:	e9c5 3300 	strd	r3, r3, [r5]
  flash_option_bytes_bank1.WRPArea = 0;
 c001eea:	6063      	str	r3, [r4, #4]
#endif /*   TFM_ENABLE_SET_OB */
  /* check TZEN = 1 , we are in secure */
  if (!(flash_option_bytes_bank1.USERConfig & FLASH_OPTR_TZEN))
 c001eec:	69a3      	ldr	r3, [r4, #24]
 c001eee:	2b00      	cmp	r3, #0
 c001ef0:	db04      	blt.n	c001efc <TFM_LL_SECU_CheckStaticProtections+0x44>
  {
    BOOT_LOG_ERR("Error while checking TZEN value");
 c001ef2:	488a      	ldr	r0, [pc, #552]	; (c00211c <TFM_LL_SECU_CheckStaticProtections+0x264>)
 c001ef4:	f006 fd2c 	bl	c008950 <puts>
    Error_Handler();
 c001ef8:	f7ff fb8e 	bl	c001618 <Error_Handler>
  }

  /* check if dual bank is set */
  if (!(flash_option_bytes_bank1.USERConfig & FLASH_OPTR_DBANK))
 c001efc:	69a3      	ldr	r3, [r4, #24]
 c001efe:	025b      	lsls	r3, r3, #9
 c001f00:	d404      	bmi.n	c001f0c <TFM_LL_SECU_CheckStaticProtections+0x54>
  {
    BOOT_LOG_ERR("Error while checking dual bank configuration");
 c001f02:	4887      	ldr	r0, [pc, #540]	; (c002120 <TFM_LL_SECU_CheckStaticProtections+0x268>)
 c001f04:	f006 fd24 	bl	c008950 <puts>
    Error_Handler();
 c001f08:	f7ff fb86 	bl	c001618 <Error_Handler>
  }

  BOOT_LOG_INF("BootAddr 0x%x", flash_option_bytes_bank1.BootAddr);
 c001f0c:	6b61      	ldr	r1, [r4, #52]	; 0x34
 c001f0e:	4885      	ldr	r0, [pc, #532]	; (c002124 <TFM_LL_SECU_CheckStaticProtections+0x26c>)
 c001f10:	f006 fcaa 	bl	c008868 <iprintf>
  if (flash_option_bytes_bank1.BootAddr != SBSFU_BOOT_VTOR_ADDR)
 c001f14:	6b62      	ldr	r2, [r4, #52]	; 0x34
 c001f16:	4b84      	ldr	r3, [pc, #528]	; (c002128 <TFM_LL_SECU_CheckStaticProtections+0x270>)
 c001f18:	429a      	cmp	r2, r3
 c001f1a:	d004      	beq.n	c001f26 <TFM_LL_SECU_CheckStaticProtections+0x6e>
  {
    BOOT_LOG_ERR("Error while checking SEC BOOT Address");
 c001f1c:	4883      	ldr	r0, [pc, #524]	; (c00212c <TFM_LL_SECU_CheckStaticProtections+0x274>)
 c001f1e:	f006 fd17 	bl	c008950 <puts>
    Error_Handler();
 c001f22:	f7ff fb79 	bl	c001618 <Error_Handler>
  end = (FLASH_AREA_0_OFFSET + FLASH_AREA_0_SIZE - 1) / PAGE_SIZE;
  if (end > PAGE_MAX_NUMBER_IN_BANK)
  {
    end = PAGE_MAX_NUMBER_IN_BANK;
  }
  BOOT_LOG_INF("BANK 1 secure flash [%d, %d] : OB [%d, %d]",
 c001f26:	6a63      	ldr	r3, [r4, #36]	; 0x24
 c001f28:	226f      	movs	r2, #111	; 0x6f
 c001f2a:	9300      	str	r3, [sp, #0]
 c001f2c:	6a23      	ldr	r3, [r4, #32]
 c001f2e:	2100      	movs	r1, #0
 c001f30:	487f      	ldr	r0, [pc, #508]	; (c002130 <TFM_LL_SECU_CheckStaticProtections+0x278>)
 c001f32:	f006 fc99 	bl	c008868 <iprintf>
               start, end, flash_option_bytes_bank1.WMSecStartPage, flash_option_bytes_bank1.WMSecEndPage);
  if ((flash_option_bytes_bank1.WMSecStartPage > flash_option_bytes_bank1.WMSecEndPage)
 c001f36:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
 c001f3a:	429a      	cmp	r2, r3
 c001f3c:	d802      	bhi.n	c001f44 <TFM_LL_SECU_CheckStaticProtections+0x8c>
      || (start != flash_option_bytes_bank1.WMSecStartPage)
 c001f3e:	b90a      	cbnz	r2, c001f44 <TFM_LL_SECU_CheckStaticProtections+0x8c>
      || (end != flash_option_bytes_bank1.WMSecEndPage))
 c001f40:	2b6f      	cmp	r3, #111	; 0x6f
 c001f42:	d00f      	beq.n	c001f64 <TFM_LL_SECU_CheckStaticProtections+0xac>
  {
#ifndef TFM_ENABLE_SET_OB
    BOOT_LOG_ERR("Error while checking secure flash protection");
    Error_Handler();
#else
    BOOT_LOG_ERR("Error while checking secure flash protection :set wmsec1");
 c001f44:	487b      	ldr	r0, [pc, #492]	; (c002134 <TFM_LL_SECU_CheckStaticProtections+0x27c>)
 c001f46:	f006 fd03 	bl	c008950 <puts>
    flash_option_bytes_bank1.WMSecStartPage = start;
    flash_option_bytes_bank1.WMSecEndPage = end;
 c001f4a:	236f      	movs	r3, #111	; 0x6f
 c001f4c:	f04f 0e00 	mov.w	lr, #0
 c001f50:	e9c4 e308 	strd	lr, r3, [r4, #32]
    flash_option_bytes_bank1.OptionType |= OPTIONBYTE_WMSEC;
 c001f54:	6823      	ldr	r3, [r4, #0]
 c001f56:	f043 0310 	orr.w	r3, r3, #16
 c001f5a:	6023      	str	r3, [r4, #0]
    flash_option_bytes_bank1.WMSecConfig |= OB_WMSEC_AREA1 | OB_WMSEC_SECURE_AREA_CONFIG;
 c001f5c:	69e3      	ldr	r3, [r4, #28]
 c001f5e:	f043 0311 	orr.w	r3, r3, #17
 c001f62:	61e3      	str	r3, [r4, #28]

#ifdef  TFM_WRP_PROTECT_ENABLE

  start = FLASH_AREA_PERSO_OFFSET / PAGE_SIZE;
  end = (FLASH_AREA_PERSO_OFFSET + FLASH_AREA_BL2_SIZE - 1) / PAGE_SIZE;
  BOOT_LOG_INF("BANK 1 flash write protection [%d, %d] : OB[%d, %d]", start, end,
 c001f64:	68e3      	ldr	r3, [r4, #12]
 c001f66:	2217      	movs	r2, #23
 c001f68:	9300      	str	r3, [sp, #0]
 c001f6a:	68a3      	ldr	r3, [r4, #8]
 c001f6c:	2100      	movs	r1, #0
 c001f6e:	4872      	ldr	r0, [pc, #456]	; (c002138 <TFM_LL_SECU_CheckStaticProtections+0x280>)
 c001f70:	f006 fc7a 	bl	c008868 <iprintf>
               flash_option_bytes_bank1.WRPStartOffset,
               flash_option_bytes_bank1.WRPEndOffset);
  if ((flash_option_bytes_bank1.WRPStartOffset > flash_option_bytes_bank1.WRPEndOffset)
 c001f74:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 c001f78:	429a      	cmp	r2, r3
 c001f7a:	d802      	bhi.n	c001f82 <TFM_LL_SECU_CheckStaticProtections+0xca>
      || (start != flash_option_bytes_bank1.WRPStartOffset)
 c001f7c:	b90a      	cbnz	r2, c001f82 <TFM_LL_SECU_CheckStaticProtections+0xca>
      || (end != flash_option_bytes_bank1.WRPEndOffset))
 c001f7e:	2b17      	cmp	r3, #23
 c001f80:	d00f      	beq.n	c001fa2 <TFM_LL_SECU_CheckStaticProtections+0xea>
#ifndef TFM_ENABLE_SET_OB
    BOOT_LOG_ERR("Error while checking write protection ");
    Error_Handler();
#else
    flash_option_bytes_bank1.WRPStartOffset = start;
    flash_option_bytes_bank1.WRPEndOffset = end;
 c001f82:	f04f 0c00 	mov.w	ip, #0
 c001f86:	2317      	movs	r3, #23
 c001f88:	e9c4 c302 	strd	ip, r3, [r4, #8]
    flash_option_bytes_bank1.WRPArea |= OB_WRPAREA_BANK1_AREAA;
 c001f8c:	6863      	ldr	r3, [r4, #4]

    BOOT_LOG_ERR("Error while checking write protection : set wrp1");
 c001f8e:	486b      	ldr	r0, [pc, #428]	; (c00213c <TFM_LL_SECU_CheckStaticProtections+0x284>)
    flash_option_bytes_bank1.WRPArea |= OB_WRPAREA_BANK1_AREAA;
 c001f90:	f043 0301 	orr.w	r3, r3, #1
 c001f94:	6063      	str	r3, [r4, #4]
    BOOT_LOG_ERR("Error while checking write protection : set wrp1");
 c001f96:	f006 fcdb 	bl	c008950 <puts>
    flash_option_bytes_bank1.OptionType |= OPTIONBYTE_WRP;
 c001f9a:	6823      	ldr	r3, [r4, #0]
 c001f9c:	f043 0301 	orr.w	r3, r3, #1
 c001fa0:	6023      	str	r3, [r4, #0]
#endif /* TFM_WRP_PROTECT_ENABLE */
#ifdef  TFM_HDP_PROTECT_ENABLE

  start = FLASH_AREA_PERSO_OFFSET / PAGE_SIZE;
  end = (FLASH_BL2_HDP_END) / PAGE_SIZE;
  BOOT_LOG_INF("BANK 1 secure user flash [%d, %d] :OB [%d, %d]",
 c001fa2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 c001fa4:	221d      	movs	r2, #29
 c001fa6:	9300      	str	r3, [sp, #0]
 c001fa8:	6a23      	ldr	r3, [r4, #32]
 c001faa:	2100      	movs	r1, #0
 c001fac:	4864      	ldr	r0, [pc, #400]	; (c002140 <TFM_LL_SECU_CheckStaticProtections+0x288>)
 c001fae:	f006 fc5b 	bl	c008868 <iprintf>
               end,
               flash_option_bytes_bank1.WMSecStartPage,
               flash_option_bytes_bank1.WMHDPEndPage);

  if (
    (flash_option_bytes_bank1.WMSecStartPage > flash_option_bytes_bank1.WMHDPEndPage)
 c001fb2:	6a22      	ldr	r2, [r4, #32]
 c001fb4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  if (
 c001fb6:	429a      	cmp	r2, r3
 c001fb8:	d805      	bhi.n	c001fc6 <TFM_LL_SECU_CheckStaticProtections+0x10e>
    || (start < flash_option_bytes_bank1.WMSecStartPage)
 c001fba:	b922      	cbnz	r2, c001fc6 <TFM_LL_SECU_CheckStaticProtections+0x10e>
    || (end > flash_option_bytes_bank1.WMHDPEndPage)
 c001fbc:	2b1c      	cmp	r3, #28
 c001fbe:	d902      	bls.n	c001fc6 <TFM_LL_SECU_CheckStaticProtections+0x10e>
    || (flash_option_bytes_bank1.WMSecConfig & OB_WMSEC_HDP_AREA_DISABLE))
 c001fc0:	69e3      	ldr	r3, [r4, #28]
 c001fc2:	05de      	lsls	r6, r3, #23
 c001fc4:	d510      	bpl.n	c001fe8 <TFM_LL_SECU_CheckStaticProtections+0x130>
  {
#ifndef TFM_ENABLE_SET_OB
    BOOT_LOG_ERR("Error while checking secure user flash protection");
    Error_Handler();
#else
    BOOT_LOG_ERR("Error while checking secure user flash protection : set hdp1");
 c001fc6:	485f      	ldr	r0, [pc, #380]	; (c002144 <TFM_LL_SECU_CheckStaticProtections+0x28c>)
 c001fc8:	f006 fcc2 	bl	c008950 <puts>
    flash_option_bytes_bank1.WMSecStartPage = start;
 c001fcc:	2300      	movs	r3, #0
 c001fce:	6223      	str	r3, [r4, #32]
    flash_option_bytes_bank1.WMHDPEndPage = end;
 c001fd0:	231d      	movs	r3, #29
 c001fd2:	62a3      	str	r3, [r4, #40]	; 0x28
    flash_option_bytes_bank1.OptionType |= OPTIONBYTE_WMSEC;
 c001fd4:	6823      	ldr	r3, [r4, #0]
 c001fd6:	f043 0310 	orr.w	r3, r3, #16
 c001fda:	6023      	str	r3, [r4, #0]
    /*  clean disable */
    flash_option_bytes_bank1.WMSecConfig &= ~OB_WMSEC_HDP_AREA_DISABLE;
 c001fdc:	69e3      	ldr	r3, [r4, #28]
 c001fde:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    /* enable */
    flash_option_bytes_bank1.WMSecConfig |= OB_WMSEC_HDP_AREA_CONFIG ;
    flash_option_bytes_bank1.WMSecConfig |= OB_WMSEC_HDP_AREA_ENABLE;
    flash_option_bytes_bank1.WMSecConfig |= OB_WMSEC_HDP_AREA_ENABLE;
    flash_option_bytes_bank1.WMSecConfig |= OB_WMSEC_AREA1;
 c001fe2:	f043 03a1 	orr.w	r3, r3, #161	; 0xa1
 c001fe6:	61e3      	str	r3, [r4, #28]
#else /* TFM_HDP_PROTECT_ENABLE */
  flash_option_bytes_bank1.WMSecConfig &= ~(OB_WMSEC_HDP_AREA_CONFIG | OB_WMSEC_HDP_AREA_ENABLE);
  flash_option_bytes_bank1.WMSecConfig |= OB_WMSEC_HDP_AREA_DISABLE;
#endif /* TFM_HDP_PROTECT_ENABLE */
#ifdef TFM_SECURE_USER_SRAM2_ERASE_AT_RESET
  if (flash_option_bytes_bank1.USERConfig & FLASH_OPTR_SRAM2_RST)
 c001fe8:	69a3      	ldr	r3, [r4, #24]
 c001fea:	0199      	lsls	r1, r3, #6
 c001fec:	d504      	bpl.n	c001ff8 <TFM_LL_SECU_CheckStaticProtections+0x140>
  {
    BOOT_LOG_ERR("Error while checking OB for SRAM2 ERASE at Reset");
 c001fee:	4856      	ldr	r0, [pc, #344]	; (c002148 <TFM_LL_SECU_CheckStaticProtections+0x290>)
 c001ff0:	f006 fcae 	bl	c008950 <puts>
    Error_Handler();
 c001ff4:	f7ff fb10 	bl	c001618 <Error_Handler>
  }
#endif /*TFM_SECURE_USER_SRAM2_RST */
#ifdef TFM_ENABLE_SET_OB
  if ((flash_option_bytes_bank1.OptionType) || (flash_option_bytes_bank2.OptionType))
 c001ff8:	6823      	ldr	r3, [r4, #0]
 c001ffa:	b913      	cbnz	r3, c002002 <TFM_LL_SECU_CheckStaticProtections+0x14a>
 c001ffc:	682b      	ldr	r3, [r5, #0]
 c001ffe:	2b00      	cmp	r3, #0
 c002000:	d043      	beq.n	c00208a <TFM_LL_SECU_CheckStaticProtections+0x1d2>
  {
    /* Unlock the Flash to enable the flash control register access *************/
    HAL_FLASH_Unlock();
 c002002:	f000 f965 	bl	c0022d0 <HAL_FLASH_Unlock>


    /* Unlock the Options Bytes *************************************************/
    HAL_FLASH_OB_Unlock();
 c002006:	f000 f997 	bl	c002338 <HAL_FLASH_OB_Unlock>
    /* verify RDP  level 0 */
    if (flash_option_bytes_bank1.OptionType & OPTIONBYTE_RDP)
 c00200a:	6823      	ldr	r3, [r4, #0]
 c00200c:	079a      	lsls	r2, r3, #30
 c00200e:	d504      	bpl.n	c00201a <TFM_LL_SECU_CheckStaticProtections+0x162>
    {
      BOOT_LOG_ERR("Error while checking OB RDP to programm");
 c002010:	484e      	ldr	r0, [pc, #312]	; (c00214c <TFM_LL_SECU_CheckStaticProtections+0x294>)
 c002012:	f006 fc9d 	bl	c008950 <puts>
      Error_Handler();
 c002016:	f7ff faff 	bl	c001618 <Error_Handler>
    }
    if (flash_option_bytes_bank2.OptionType & OPTIONBYTE_RDP)
 c00201a:	682b      	ldr	r3, [r5, #0]
 c00201c:	079b      	lsls	r3, r3, #30
 c00201e:	d504      	bpl.n	c00202a <TFM_LL_SECU_CheckStaticProtections+0x172>
    {
      BOOT_LOG_ERR("Error while checking OB RDP to programm");
 c002020:	484a      	ldr	r0, [pc, #296]	; (c00214c <TFM_LL_SECU_CheckStaticProtections+0x294>)
 c002022:	f006 fc95 	bl	c008950 <puts>
      Error_Handler();
 c002026:	f7ff faf7 	bl	c001618 <Error_Handler>
    }
    if (flash_option_bytes_bank2.WRPArea)
 c00202a:	686b      	ldr	r3, [r5, #4]
 c00202c:	b123      	cbz	r3, c002038 <TFM_LL_SECU_CheckStaticProtections+0x180>
    {
      BOOT_LOG_ERR("Error while checking bank 2 OB WRP AREA  to programm");
 c00202e:	4848      	ldr	r0, [pc, #288]	; (c002150 <TFM_LL_SECU_CheckStaticProtections+0x298>)
 c002030:	f006 fc8e 	bl	c008950 <puts>
      Error_Handler();
 c002034:	f7ff faf0 	bl	c001618 <Error_Handler>
    }

    if (flash_option_bytes_bank1.WRPArea & ~OB_WRPAREA_BANK1_AREAA)
 c002038:	6863      	ldr	r3, [r4, #4]
 c00203a:	f033 0301 	bics.w	r3, r3, #1
 c00203e:	d004      	beq.n	c00204a <TFM_LL_SECU_CheckStaticProtections+0x192>
    {
      BOOT_LOG_ERR("Error while checking bank 1 OB WRP AREA  to programm");
 c002040:	4844      	ldr	r0, [pc, #272]	; (c002154 <TFM_LL_SECU_CheckStaticProtections+0x29c>)
 c002042:	f006 fc85 	bl	c008950 <puts>
      Error_Handler();
 c002046:	f7ff fae7 	bl	c001618 <Error_Handler>
    }
    if (flash_option_bytes_bank1.OptionType)
 c00204a:	6823      	ldr	r3, [r4, #0]
 c00204c:	b143      	cbz	r3, c002060 <TFM_LL_SECU_CheckStaticProtections+0x1a8>
    {


      ret = HAL_FLASHEx_OBProgram(&flash_option_bytes_bank1);
 c00204e:	4831      	ldr	r0, [pc, #196]	; (c002114 <TFM_LL_SECU_CheckStaticProtections+0x25c>)
 c002050:	f000 fa34 	bl	c0024bc <HAL_FLASHEx_OBProgram>
      if (ret != HAL_OK)
 c002054:	b120      	cbz	r0, c002060 <TFM_LL_SECU_CheckStaticProtections+0x1a8>
      {
        BOOT_LOG_ERR("Error while setting OB Bank1 config");
 c002056:	4840      	ldr	r0, [pc, #256]	; (c002158 <TFM_LL_SECU_CheckStaticProtections+0x2a0>)
 c002058:	f006 fc7a 	bl	c008950 <puts>
        Error_Handler();
 c00205c:	f7ff fadc 	bl	c001618 <Error_Handler>
      }
    }
    if (flash_option_bytes_bank2.OptionType)
 c002060:	682b      	ldr	r3, [r5, #0]
 c002062:	b143      	cbz	r3, c002076 <TFM_LL_SECU_CheckStaticProtections+0x1be>
    {

      ret = HAL_FLASHEx_OBProgram(&flash_option_bytes_bank2);
 c002064:	482c      	ldr	r0, [pc, #176]	; (c002118 <TFM_LL_SECU_CheckStaticProtections+0x260>)
 c002066:	f000 fa29 	bl	c0024bc <HAL_FLASHEx_OBProgram>
      if (ret != HAL_OK)
 c00206a:	b120      	cbz	r0, c002076 <TFM_LL_SECU_CheckStaticProtections+0x1be>
      {
        BOOT_LOG_ERR("Error while setting OB Bank1 config");
 c00206c:	483a      	ldr	r0, [pc, #232]	; (c002158 <TFM_LL_SECU_CheckStaticProtections+0x2a0>)
 c00206e:	f006 fc6f 	bl	c008950 <puts>
        Error_Handler();
 c002072:	f7ff fad1 	bl	c001618 <Error_Handler>
      }
    }

    ret = HAL_FLASH_OB_Launch();
 c002076:	f000 f971 	bl	c00235c <HAL_FLASH_OB_Launch>
    if (ret != HAL_OK)
 c00207a:	b120      	cbz	r0, c002086 <TFM_LL_SECU_CheckStaticProtections+0x1ce>
    {
      BOOT_LOG_ERR("Error while execution OB_Launch");
 c00207c:	4837      	ldr	r0, [pc, #220]	; (c00215c <TFM_LL_SECU_CheckStaticProtections+0x2a4>)
 c00207e:	f006 fc67 	bl	c008950 <puts>
      Error_Handler();
 c002082:	f7ff fac9 	bl	c001618 <Error_Handler>
    }
    /*  reset the board to apply protection */
    HAL_NVIC_SystemReset();
 c002086:	f000 f8f3 	bl	c002270 <HAL_NVIC_SystemReset>
  }
#endif /*   TFM_ENABLE_SET_OB */

#ifdef TFM_OB_BOOT_LOCK
  {
    BOOT_LOG_INF("BootLock 0x%x", flash_option_bytes_bank1.BootLock);
 c00208a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 c00208c:	4834      	ldr	r0, [pc, #208]	; (c002160 <TFM_LL_SECU_CheckStaticProtections+0x2a8>)
 c00208e:	f006 fbeb 	bl	c008868 <iprintf>
    if (flash_option_bytes_bank1.BootLock != TFM_OB_BOOT_LOCK)
 c002092:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 c002094:	b123      	cbz	r3, c0020a0 <TFM_LL_SECU_CheckStaticProtections+0x1e8>
    {
      BOOT_LOG_ERR("Error while checking SEC BOOT LOCK");
 c002096:	4833      	ldr	r0, [pc, #204]	; (c002164 <TFM_LL_SECU_CheckStaticProtections+0x2ac>)
 c002098:	f006 fc5a 	bl	c008950 <puts>
      Error_Handler();
 c00209c:	f7ff fabc 	bl	c001618 <Error_Handler>
    }
  }
#endif /* TFM_OB_BOOT_LOCK_ENABLE   */

#ifdef TFM_OB_RDP_LEVEL_VALUE
  BOOT_LOG_INF("RDPLevel 0x%x (0x%x)", flash_option_bytes_bank1.RDPLevel, TFM_OB_RDP_LEVEL_VALUE);
 c0020a0:	22bb      	movs	r2, #187	; 0xbb
 c0020a2:	6921      	ldr	r1, [r4, #16]
 c0020a4:	4830      	ldr	r0, [pc, #192]	; (c002168 <TFM_LL_SECU_CheckStaticProtections+0x2b0>)
 c0020a6:	f006 fbdf 	bl	c008868 <iprintf>
  if (flash_option_bytes_bank1.RDPLevel != TFM_OB_RDP_LEVEL_VALUE)
 c0020aa:	6923      	ldr	r3, [r4, #16]
 c0020ac:	2bbb      	cmp	r3, #187	; 0xbb
 c0020ae:	d02f      	beq.n	c002110 <TFM_LL_SECU_CheckStaticProtections+0x258>
  {
    BOOT_LOG_ERR("Error while checking RDP level");
 c0020b0:	482e      	ldr	r0, [pc, #184]	; (c00216c <TFM_LL_SECU_CheckStaticProtections+0x2b4>)
 c0020b2:	f006 fc4d 	bl	c008950 <puts>
static void rdp_level(uint32_t rdplevel)
{
#ifdef TFM_ENABLE_SET_OB
  static FLASH_OBProgramInitTypeDef flash_option_bytes_bank = {0};
  HAL_StatusTypeDef ret;
  flash_option_bytes_bank.OptionType = OPTIONBYTE_RDP;
 c0020b6:	2302      	movs	r3, #2

  flash_option_bytes_bank.RDPLevel = rdplevel;
 c0020b8:	21bb      	movs	r1, #187	; 0xbb
  flash_option_bytes_bank.OptionType = OPTIONBYTE_RDP;
 c0020ba:	4c2d      	ldr	r4, [pc, #180]	; (c002170 <TFM_LL_SECU_CheckStaticProtections+0x2b8>)
  BOOT_LOG_INF("Programming RDP to %x", rdplevel);
 c0020bc:	482d      	ldr	r0, [pc, #180]	; (c002174 <TFM_LL_SECU_CheckStaticProtections+0x2bc>)
  flash_option_bytes_bank.OptionType = OPTIONBYTE_RDP;
 c0020be:	6023      	str	r3, [r4, #0]
  flash_option_bytes_bank.RDPLevel = rdplevel;
 c0020c0:	6121      	str	r1, [r4, #16]
  BOOT_LOG_INF("Programming RDP to %x", rdplevel);
 c0020c2:	f006 fbd1 	bl	c008868 <iprintf>
  /* Unlock the Flash to enable the flash control register access *************/
  HAL_FLASH_Unlock();
 c0020c6:	f000 f903 	bl	c0022d0 <HAL_FLASH_Unlock>

  /* Unlock the Options Bytes *************************************************/
  HAL_FLASH_OB_Unlock();
 c0020ca:	f000 f935 	bl	c002338 <HAL_FLASH_OB_Unlock>

  HAL_FLASH_OB_Unlock();
 c0020ce:	f000 f933 	bl	c002338 <HAL_FLASH_OB_Unlock>
  ret = HAL_FLASHEx_OBProgram(&flash_option_bytes_bank);
 c0020d2:	4620      	mov	r0, r4
 c0020d4:	f000 f9f2 	bl	c0024bc <HAL_FLASHEx_OBProgram>
  if (ret != HAL_OK)
 c0020d8:	b158      	cbz	r0, c0020f2 <TFM_LL_SECU_CheckStaticProtections+0x23a>
  {
    BOOT_LOG_ERR("Error while setting OB Bank config retry");
 c0020da:	4827      	ldr	r0, [pc, #156]	; (c002178 <TFM_LL_SECU_CheckStaticProtections+0x2c0>)
 c0020dc:	f006 fc38 	bl	c008950 <puts>
    ret = HAL_FLASHEx_OBProgram(&flash_option_bytes_bank);
 c0020e0:	4620      	mov	r0, r4
 c0020e2:	f000 f9eb 	bl	c0024bc <HAL_FLASHEx_OBProgram>
    if (ret != HAL_OK)
 c0020e6:	b120      	cbz	r0, c0020f2 <TFM_LL_SECU_CheckStaticProtections+0x23a>
    {
      BOOT_LOG_ERR("Error while setting OB Bank config");
 c0020e8:	4824      	ldr	r0, [pc, #144]	; (c00217c <TFM_LL_SECU_CheckStaticProtections+0x2c4>)
 c0020ea:	f006 fc31 	bl	c008950 <puts>
      Error_Handler();
 c0020ee:	f7ff fa93 	bl	c001618 <Error_Handler>
    }
  }
  ret = HAL_FLASH_OB_Launch();
 c0020f2:	f000 f933 	bl	c00235c <HAL_FLASH_OB_Launch>
  if (ret != HAL_OK)
 c0020f6:	b120      	cbz	r0, c002102 <TFM_LL_SECU_CheckStaticProtections+0x24a>
  {
    BOOT_LOG_ERR("Error while execution OB_Launch");
 c0020f8:	4818      	ldr	r0, [pc, #96]	; (c00215c <TFM_LL_SECU_CheckStaticProtections+0x2a4>)
 c0020fa:	f006 fc29 	bl	c008950 <puts>
    Error_Handler();
 c0020fe:	f7ff fa8b 	bl	c001618 <Error_Handler>
  }
  /*  reset the board to apply protection */
  HAL_NVIC_SystemReset();
 c002102:	f000 f8b5 	bl	c002270 <HAL_NVIC_SystemReset>
}
 c002106:	b002      	add	sp, #8
 c002108:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Error_Handler();
 c00210c:	f7ff ba84 	b.w	c001618 <Error_Handler>
}
 c002110:	b002      	add	sp, #8
 c002112:	bd70      	pop	{r4, r5, r6, pc}
 c002114:	3003021c 	.word	0x3003021c
 c002118:	30030254 	.word	0x30030254
 c00211c:	0c00a161 	.word	0x0c00a161
 c002120:	0c00a188 	.word	0x0c00a188
 c002124:	0c00a1bc 	.word	0x0c00a1bc
 c002128:	0c000800 	.word	0x0c000800
 c00212c:	0c00a1d2 	.word	0x0c00a1d2
 c002130:	0c00a1ff 	.word	0x0c00a1ff
 c002134:	0c00a232 	.word	0x0c00a232
 c002138:	0c00a272 	.word	0x0c00a272
 c00213c:	0c00a2ae 	.word	0x0c00a2ae
 c002140:	0c00a2e6 	.word	0x0c00a2e6
 c002144:	0c00a31d 	.word	0x0c00a31d
 c002148:	0c00a361 	.word	0x0c00a361
 c00214c:	0c00a399 	.word	0x0c00a399
 c002150:	0c00a3c8 	.word	0x0c00a3c8
 c002154:	0c00a404 	.word	0x0c00a404
 c002158:	0c00a440 	.word	0x0c00a440
 c00215c:	0c00a46b 	.word	0x0c00a46b
 c002160:	0c00a492 	.word	0x0c00a492
 c002164:	0c00a4a8 	.word	0x0c00a4a8
 c002168:	0c00a4d2 	.word	0x0c00a4d2
 c00216c:	0c00a4ef 	.word	0x0c00a4ef
 c002170:	300301e4 	.word	0x300301e4
 c002174:	0c00a515 	.word	0x0c00a515
 c002178:	0c00a533 	.word	0x0c00a533
 c00217c:	0c00a563 	.word	0x0c00a563

0c002180 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 c002180:	4770      	bx	lr

0c002182 <HAL_Init>:
{
 c002182:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 c002184:	2004      	movs	r0, #4
 c002186:	f000 f81f 	bl	c0021c8 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
 c00218a:	f7ff fda3 	bl	c001cd4 <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 c00218e:	2007      	movs	r0, #7
 c002190:	f7ff fa08 	bl	c0015a4 <HAL_InitTick>
 c002194:	4604      	mov	r4, r0
 c002196:	b918      	cbnz	r0, c0021a0 <HAL_Init+0x1e>
    HAL_MspInit();
 c002198:	f7ff fff2 	bl	c002180 <HAL_MspInit>
}
 c00219c:	4620      	mov	r0, r4
 c00219e:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 c0021a0:	2401      	movs	r4, #1
 c0021a2:	e7fb      	b.n	c00219c <HAL_Init+0x1a>

0c0021a4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 c0021a4:	b538      	push	{r3, r4, r5, lr}
 c0021a6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 c0021a8:	f7ff fa0a 	bl	c0015c0 <HAL_GetTick>
 c0021ac:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 c0021ae:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 c0021b0:	bf1e      	ittt	ne
 c0021b2:	4b04      	ldrne	r3, [pc, #16]	; (c0021c4 <HAL_Delay+0x20>)
 c0021b4:	681b      	ldrne	r3, [r3, #0]
 c0021b6:	18e4      	addne	r4, r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 c0021b8:	f7ff fa02 	bl	c0015c0 <HAL_GetTick>
 c0021bc:	1b40      	subs	r0, r0, r5
 c0021be:	42a0      	cmp	r0, r4
 c0021c0:	d3fa      	bcc.n	c0021b8 <HAL_Delay+0x14>
  {
  }
}
 c0021c2:	bd38      	pop	{r3, r4, r5, pc}
 c0021c4:	3003000c 	.word	0x3003000c

0c0021c8 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 c0021c8:	4a07      	ldr	r2, [pc, #28]	; (c0021e8 <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priority group */
 c0021ca:	0200      	lsls	r0, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 c0021cc:	68d3      	ldr	r3, [r2, #12]
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priority group */
 c0021ce:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 c0021d2:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 c0021d6:	041b      	lsls	r3, r3, #16
 c0021d8:	0c1b      	lsrs	r3, r3, #16
 c0021da:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 c0021de:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 c0021e2:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 c0021e4:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 c0021e6:	4770      	bx	lr
 c0021e8:	e000ed00 	.word	0xe000ed00

0c0021ec <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 c0021ec:	4b17      	ldr	r3, [pc, #92]	; (c00224c <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 7
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 c0021ee:	b570      	push	{r4, r5, r6, lr}
 c0021f0:	68dc      	ldr	r4, [r3, #12]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 c0021f2:	f04f 36ff 	mov.w	r6, #4294967295
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 c0021f6:	f3c4 2402 	ubfx	r4, r4, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 c0021fa:	f1c4 0507 	rsb	r5, r4, #7
 c0021fe:	2d03      	cmp	r5, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 c002200:	f104 0303 	add.w	r3, r4, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 c002204:	bf28      	it	cs
 c002206:	2503      	movcs	r5, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 c002208:	2b06      	cmp	r3, #6
 c00220a:	bf98      	it	ls
 c00220c:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 c00220e:	fa06 f305 	lsl.w	r3, r6, r5
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 c002212:	bf88      	it	hi
 c002214:	3c04      	subhi	r4, #4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 c002216:	ea21 0303 	bic.w	r3, r1, r3
 c00221a:	40a3      	lsls	r3, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 c00221c:	fa06 f404 	lsl.w	r4, r6, r4
 c002220:	ea22 0404 	bic.w	r4, r2, r4
  if ((int32_t)(IRQn) >= 0)
 c002224:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 c002226:	ea43 0304 	orr.w	r3, r3, r4
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c00222a:	bfa8      	it	ge
 c00222c:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 c002230:	ea4f 1343 	mov.w	r3, r3, lsl #5
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c002234:	bfb8      	it	lt
 c002236:	4a06      	ldrlt	r2, [pc, #24]	; (c002250 <HAL_NVIC_SetPriority+0x64>)
 c002238:	b2db      	uxtb	r3, r3
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c00223a:	bfab      	itete	ge
 c00223c:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c002240:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c002244:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c002248:	5413      	strblt	r3, [r2, r0]
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 c00224a:	bd70      	pop	{r4, r5, r6, pc}
 c00224c:	e000ed00 	.word	0xe000ed00
 c002250:	e000ed14 	.word	0xe000ed14

0c002254 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 c002254:	2800      	cmp	r0, #0
 c002256:	db08      	blt.n	c00226a <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 c002258:	2301      	movs	r3, #1
 c00225a:	0942      	lsrs	r2, r0, #5
 c00225c:	f000 001f 	and.w	r0, r0, #31
 c002260:	fa03 f000 	lsl.w	r0, r3, r0
 c002264:	4b01      	ldr	r3, [pc, #4]	; (c00226c <HAL_NVIC_EnableIRQ+0x18>)
 c002266:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 c00226a:	4770      	bx	lr
 c00226c:	e000e100 	.word	0xe000e100

0c002270 <HAL_NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 c002270:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 c002274:	4905      	ldr	r1, [pc, #20]	; (c00228c <HAL_NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 c002276:	4b06      	ldr	r3, [pc, #24]	; (c002290 <HAL_NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 c002278:	68ca      	ldr	r2, [r1, #12]
 c00227a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 c00227e:	4313      	orrs	r3, r2
 c002280:	60cb      	str	r3, [r1, #12]
 c002282:	f3bf 8f4f 	dsb	sy
    __NOP();
 c002286:	bf00      	nop
 c002288:	e7fd      	b.n	c002286 <HAL_NVIC_SystemReset+0x16>
 c00228a:	bf00      	nop
 c00228c:	e000ed00 	.word	0xe000ed00
 c002290:	05fa0004 	.word	0x05fa0004

0c002294 <FLASH_Program_DoubleWord>:
  __IO uint32_t *reg;
  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
  
  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c002294:	490b      	ldr	r1, [pc, #44]	; (c0022c4 <FLASH_Program_DoubleWord+0x30>)
{
 c002296:	b530      	push	{r4, r5, lr}
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c002298:	688d      	ldr	r5, [r1, #8]
 c00229a:	4c0b      	ldr	r4, [pc, #44]	; (c0022c8 <FLASH_Program_DoubleWord+0x34>)
 c00229c:	490b      	ldr	r1, [pc, #44]	; (c0022cc <FLASH_Program_DoubleWord+0x38>)
 c00229e:	ea31 0125 	bics.w	r1, r1, r5, asr #32
 c0022a2:	bf28      	it	cs
 c0022a4:	4621      	movcs	r1, r4
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c0022a6:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 c0022aa:	b672      	cpsid	i
  /* Disable interrupts to avoid any interruption during the double word programming */
  primask_bit = __get_PRIMASK();
  __disable_irq();

  /* Set PG bit */
  SET_BIT((*reg), FLASH_NSCR_NSPG);
 c0022ac:	680c      	ldr	r4, [r1, #0]
 c0022ae:	f044 0401 	orr.w	r4, r4, #1
 c0022b2:	600c      	str	r4, [r1, #0]

  /* Program first word */
  *(uint32_t*)Address = (uint32_t)Data;
 c0022b4:	6002      	str	r2, [r0, #0]
  __ASM volatile ("isb 0xF":::"memory");
 c0022b6:	f3bf 8f6f 	isb	sy
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(uint32_t*)(Address+4U) = (uint32_t)(Data >> 32U);
 c0022ba:	6043      	str	r3, [r0, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c0022bc:	f385 8810 	msr	PRIMASK, r5

  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
}
 c0022c0:	bd30      	pop	{r4, r5, pc}
 c0022c2:	bf00      	nop
 c0022c4:	30030010 	.word	0x30030010
 c0022c8:	40022028 	.word	0x40022028
 c0022cc:	5002202c 	.word	0x5002202c

0c0022d0 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c0022d0:	4b0d      	ldr	r3, [pc, #52]	; (c002308 <HAL_FLASH_Unlock+0x38>)
 c0022d2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 c0022d4:	2a00      	cmp	r2, #0
 c0022d6:	461a      	mov	r2, r3
 c0022d8:	db04      	blt.n	c0022e4 <HAL_FLASH_Unlock+0x14>
    if(READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c0022da:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 c0022dc:	2b00      	cmp	r3, #0
 c0022de:	db0b      	blt.n	c0022f8 <HAL_FLASH_Unlock+0x28>
 c0022e0:	2000      	movs	r0, #0
 c0022e2:	4770      	bx	lr
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY1);
 c0022e4:	4909      	ldr	r1, [pc, #36]	; (c00230c <HAL_FLASH_Unlock+0x3c>)
 c0022e6:	6099      	str	r1, [r3, #8]
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY2);
 c0022e8:	f101 3188 	add.w	r1, r1, #2290649224	; 0x88888888
 c0022ec:	6099      	str	r1, [r3, #8]
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c0022ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 c0022f0:	2b00      	cmp	r3, #0
 c0022f2:	daf2      	bge.n	c0022da <HAL_FLASH_Unlock+0xa>
      status = HAL_ERROR;
 c0022f4:	2001      	movs	r0, #1
}
 c0022f6:	4770      	bx	lr
      WRITE_REG(FLASH->SECKEYR, FLASH_KEY1);
 c0022f8:	4b04      	ldr	r3, [pc, #16]	; (c00230c <HAL_FLASH_Unlock+0x3c>)
 c0022fa:	60d3      	str	r3, [r2, #12]
      WRITE_REG(FLASH->SECKEYR, FLASH_KEY2);
 c0022fc:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
 c002300:	60d3      	str	r3, [r2, #12]
      if (READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c002302:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
      status = HAL_ERROR;
 c002304:	0fc0      	lsrs	r0, r0, #31
 c002306:	4770      	bx	lr
 c002308:	50022000 	.word	0x50022000
 c00230c:	45670123 	.word	0x45670123

0c002310 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
 c002310:	4b08      	ldr	r3, [pc, #32]	; (c002334 <HAL_FLASH_Lock+0x24>)
 c002312:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 c002314:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 c002318:	629a      	str	r2, [r3, #40]	; 0x28
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c00231a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 c00231c:	2a00      	cmp	r2, #0
    SET_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK);
 c00231e:	bfbf      	itttt	lt
 c002320:	6ada      	ldrlt	r2, [r3, #44]	; 0x2c
    status = HAL_OK;
 c002322:	2000      	movlt	r0, #0
    SET_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK);
 c002324:	f042 4200 	orrlt.w	r2, r2, #2147483648	; 0x80000000
 c002328:	62da      	strlt	r2, [r3, #44]	; 0x2c
    if (READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c00232a:	bfb4      	ite	lt
 c00232c:	6adb      	ldrlt	r3, [r3, #44]	; 0x2c
  HAL_StatusTypeDef status = HAL_ERROR;
 c00232e:	2001      	movge	r0, #1
}
 c002330:	4770      	bx	lr
 c002332:	bf00      	nop
 c002334:	50022000 	.word	0x50022000

0c002338 <HAL_FLASH_OB_Unlock>:
  if(READ_BIT(FLASH->NSCR, FLASH_NSCR_OPTLOCK) != 0u)
 c002338:	4b06      	ldr	r3, [pc, #24]	; (c002354 <HAL_FLASH_OB_Unlock+0x1c>)
 c00233a:	6a98      	ldr	r0, [r3, #40]	; 0x28
 c00233c:	f010 4080 	ands.w	r0, r0, #1073741824	; 0x40000000
 c002340:	d007      	beq.n	c002352 <HAL_FLASH_OB_Unlock+0x1a>
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
 c002342:	4a05      	ldr	r2, [pc, #20]	; (c002358 <HAL_FLASH_OB_Unlock+0x20>)
 c002344:	611a      	str	r2, [r3, #16]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
 c002346:	f102 3244 	add.w	r2, r2, #1145324612	; 0x44444444
 c00234a:	611a      	str	r2, [r3, #16]
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_OPTLOCK) != 0u)
 c00234c:	6a98      	ldr	r0, [r3, #40]	; 0x28
      return HAL_ERROR;
 c00234e:	f3c0 7080 	ubfx	r0, r0, #30, #1
}
 c002352:	4770      	bx	lr
 c002354:	50022000 	.word	0x50022000
 c002358:	08192a3b 	.word	0x08192a3b

0c00235c <HAL_FLASH_OB_Launch>:
  SET_BIT(FLASH->NSCR, FLASH_NSCR_OBL_LAUNCH);
 c00235c:	4a03      	ldr	r2, [pc, #12]	; (c00236c <HAL_FLASH_OB_Launch+0x10>)
}
 c00235e:	2001      	movs	r0, #1
  SET_BIT(FLASH->NSCR, FLASH_NSCR_OBL_LAUNCH);
 c002360:	6a93      	ldr	r3, [r2, #40]	; 0x28
 c002362:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 c002366:	6293      	str	r3, [r2, #40]	; 0x28
}
 c002368:	4770      	bx	lr
 c00236a:	bf00      	nop
 c00236c:	50022000 	.word	0x50022000

0c002370 <FLASH_WaitForLastOperation>:
{
 c002370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 c002372:	4d1a      	ldr	r5, [pc, #104]	; (c0023dc <FLASH_WaitForLastOperation+0x6c>)
{
 c002374:	4606      	mov	r6, r0
  uint32_t timeout = HAL_GetTick() + Timeout;
 c002376:	f7ff f923 	bl	c0015c0 <HAL_GetTick>
 c00237a:	462c      	mov	r4, r5
 c00237c:	1987      	adds	r7, r0, r6
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 c00237e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 c002380:	03da      	lsls	r2, r3, #15
 c002382:	d41a      	bmi.n	c0023ba <FLASH_WaitForLastOperation+0x4a>
  reg_sr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECSR) : &(FLASH_NS->NSSR);
 c002384:	4b16      	ldr	r3, [pc, #88]	; (c0023e0 <FLASH_WaitForLastOperation+0x70>)
 c002386:	4a17      	ldr	r2, [pc, #92]	; (c0023e4 <FLASH_WaitForLastOperation+0x74>)
 c002388:	6898      	ldr	r0, [r3, #8]
 c00238a:	4917      	ldr	r1, [pc, #92]	; (c0023e8 <FLASH_WaitForLastOperation+0x78>)
 c00238c:	ea31 0120 	bics.w	r1, r1, r0, asr #32
 c002390:	bf28      	it	cs
 c002392:	4611      	movcs	r1, r2
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 c002394:	680a      	ldr	r2, [r1, #0]
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
 c002396:	6a20      	ldr	r0, [r4, #32]
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 c002398:	f002 02fa 	and.w	r2, r2, #250	; 0xfa
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
 c00239c:	f400 5000 	and.w	r0, r0, #8192	; 0x2000
  if(error != 0u)
 c0023a0:	4302      	orrs	r2, r0
 c0023a2:	d012      	beq.n	c0023ca <FLASH_WaitForLastOperation+0x5a>
    pFlash.ErrorCode |= error;
 c0023a4:	6858      	ldr	r0, [r3, #4]
 c0023a6:	4310      	orrs	r0, r2
 c0023a8:	6058      	str	r0, [r3, #4]
    if ((error & FLASH_FLAG_OPTWERR) != 0U)
 c0023aa:	0493      	lsls	r3, r2, #18
    (*reg_sr) = error;
 c0023ac:	600a      	str	r2, [r1, #0]
    if ((error & FLASH_FLAG_OPTWERR) != 0U)
 c0023ae:	d502      	bpl.n	c0023b6 <FLASH_WaitForLastOperation+0x46>
      FLASH->NSSR = FLASH_FLAG_OPTWERR;
 c0023b0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 c0023b4:	6223      	str	r3, [r4, #32]
    return HAL_ERROR;
 c0023b6:	2001      	movs	r0, #1
 c0023b8:	e00e      	b.n	c0023d8 <FLASH_WaitForLastOperation+0x68>
    if(Timeout != HAL_MAX_DELAY)
 c0023ba:	1c71      	adds	r1, r6, #1
 c0023bc:	d0df      	beq.n	c00237e <FLASH_WaitForLastOperation+0xe>
      if(HAL_GetTick() >= timeout)
 c0023be:	f7ff f8ff 	bl	c0015c0 <HAL_GetTick>
 c0023c2:	42b8      	cmp	r0, r7
 c0023c4:	d3db      	bcc.n	c00237e <FLASH_WaitForLastOperation+0xe>
        return HAL_TIMEOUT;
 c0023c6:	2003      	movs	r0, #3
 c0023c8:	e006      	b.n	c0023d8 <FLASH_WaitForLastOperation+0x68>
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
 c0023ca:	6808      	ldr	r0, [r1, #0]
 c0023cc:	f010 0001 	ands.w	r0, r0, #1
 c0023d0:	d002      	beq.n	c0023d8 <FLASH_WaitForLastOperation+0x68>
    (*reg_sr) = FLASH_FLAG_EOP;
 c0023d2:	2301      	movs	r3, #1
  return HAL_OK;
 c0023d4:	4610      	mov	r0, r2
    (*reg_sr) = FLASH_FLAG_EOP;
 c0023d6:	600b      	str	r3, [r1, #0]
}
 c0023d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c0023da:	bf00      	nop
 c0023dc:	50022000 	.word	0x50022000
 c0023e0:	30030010 	.word	0x30030010
 c0023e4:	40022020 	.word	0x40022020
 c0023e8:	50022024 	.word	0x50022024

0c0023ec <HAL_FLASH_Program>:
{
 c0023ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 c0023f0:	4c16      	ldr	r4, [pc, #88]	; (c00244c <HAL_FLASH_Program+0x60>)
{
 c0023f2:	461f      	mov	r7, r3
  __HAL_LOCK(&pFlash);
 c0023f4:	7823      	ldrb	r3, [r4, #0]
{
 c0023f6:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 c0023f8:	2b01      	cmp	r3, #1
{
 c0023fa:	4688      	mov	r8, r1
 c0023fc:	4616      	mov	r6, r2
  __HAL_LOCK(&pFlash);
 c0023fe:	d023      	beq.n	c002448 <HAL_FLASH_Program+0x5c>
 c002400:	2301      	movs	r3, #1
 c002402:	7023      	strb	r3, [r4, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c002404:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c002406:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c00240a:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c00240c:	f7ff ffb0 	bl	c002370 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 c002410:	b9b0      	cbnz	r0, c002440 <HAL_FLASH_Program+0x54>
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c002412:	4a0f      	ldr	r2, [pc, #60]	; (c002450 <HAL_FLASH_Program+0x64>)
 c002414:	4b0f      	ldr	r3, [pc, #60]	; (c002454 <HAL_FLASH_Program+0x68>)
    pFlash.ProcedureOnGoing = TypeProgram;
 c002416:	60a5      	str	r5, [r4, #8]
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c002418:	ea32 0525 	bics.w	r5, r2, r5, asr #32
 c00241c:	bf28      	it	cs
 c00241e:	461d      	movcs	r5, r3
    FLASH_Program_DoubleWord(Address, Data);
 c002420:	4640      	mov	r0, r8
 c002422:	4632      	mov	r2, r6
 c002424:	463b      	mov	r3, r7
 c002426:	f7ff ff35 	bl	c002294 <FLASH_Program_DoubleWord>
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c00242a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 c00242e:	f7ff ff9f 	bl	c002370 <FLASH_WaitForLastOperation>
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 c002432:	68a2      	ldr	r2, [r4, #8]
 c002434:	682b      	ldr	r3, [r5, #0]
 c002436:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 c00243a:	ea23 0302 	bic.w	r3, r3, r2
 c00243e:	602b      	str	r3, [r5, #0]
  __HAL_UNLOCK(&pFlash);
 c002440:	2300      	movs	r3, #0
 c002442:	7023      	strb	r3, [r4, #0]
}
 c002444:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  __HAL_LOCK(&pFlash);
 c002448:	2002      	movs	r0, #2
 c00244a:	e7fb      	b.n	c002444 <HAL_FLASH_Program+0x58>
 c00244c:	30030010 	.word	0x30030010
 c002450:	5002202c 	.word	0x5002202c
 c002454:	40022028 	.word	0x40022028

0c002458 <FLASH_MassErase>:
  *            @arg FLASH_BANK_2: Bank2 to be erased
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  * @retval None
  */
static void FLASH_MassErase(uint32_t Banks)
{
 c002458:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c00245a:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 c00245e:	b672      	cpsid	i
  primask_bit = __get_PRIMASK();
  __disable_irq();
#endif
  
  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c002460:	4b12      	ldr	r3, [pc, #72]	; (c0024ac <FLASH_MassErase+0x54>)
 c002462:	4a13      	ldr	r2, [pc, #76]	; (c0024b0 <FLASH_MassErase+0x58>)
 c002464:	689c      	ldr	r4, [r3, #8]
 c002466:	4b13      	ldr	r3, [pc, #76]	; (c0024b4 <FLASH_MassErase+0x5c>)
 c002468:	ea33 0324 	bics.w	r3, r3, r4, asr #32
 c00246c:	bf28      	it	cs
 c00246e:	4613      	movcs	r3, r2

  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) != 0U)
 c002470:	4a11      	ldr	r2, [pc, #68]	; (c0024b8 <FLASH_MassErase+0x60>)
 c002472:	6c12      	ldr	r2, [r2, #64]	; 0x40
 c002474:	0252      	lsls	r2, r2, #9
 c002476:	d512      	bpl.n	c00249e <FLASH_MassErase+0x46>
  {
    /* Check the parameters */
    assert_param(IS_FLASH_BANK(Banks));

    /* Set the Mass Erase Bit for the bank 1 if requested */
    if((Banks & FLASH_BANK_1) != 0U)
 c002478:	07c4      	lsls	r4, r0, #31
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER1);
 c00247a:	bf42      	ittt	mi
 c00247c:	681a      	ldrmi	r2, [r3, #0]
 c00247e:	f042 0204 	orrmi.w	r2, r2, #4
 c002482:	601a      	strmi	r2, [r3, #0]
    }

    /* Set the Mass Erase Bit for the bank 2 if requested */
    if((Banks & FLASH_BANK_2) != 0U)
 c002484:	0782      	lsls	r2, r0, #30
 c002486:	d503      	bpl.n	c002490 <FLASH_MassErase+0x38>
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER2);
 c002488:	681a      	ldr	r2, [r3, #0]
 c00248a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    }
  }
  else
  {
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
 c00248e:	601a      	str	r2, [r3, #0]
  }

  /* Proceed to erase all sectors */
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 c002490:	681a      	ldr	r2, [r3, #0]
 c002492:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 c002496:	601a      	str	r2, [r3, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c002498:	f381 8810 	msr	PRIMASK, r1

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
#endif
}
 c00249c:	bd10      	pop	{r4, pc}
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
 c00249e:	681a      	ldr	r2, [r3, #0]
 c0024a0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 c0024a4:	f042 0204 	orr.w	r2, r2, #4
 c0024a8:	e7f1      	b.n	c00248e <FLASH_MassErase+0x36>
 c0024aa:	bf00      	nop
 c0024ac:	30030010 	.word	0x30030010
 c0024b0:	40022028 	.word	0x40022028
 c0024b4:	5002202c 	.word	0x5002202c
 c0024b8:	50022000 	.word	0x50022000

0c0024bc <HAL_FLASHEx_OBProgram>:
{
 c0024bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
 c0024be:	4d96      	ldr	r5, [pc, #600]	; (c002718 <HAL_FLASHEx_OBProgram+0x25c>)
{
 c0024c0:	4604      	mov	r4, r0
  __HAL_LOCK(&pFlash);
 c0024c2:	782b      	ldrb	r3, [r5, #0]
 c0024c4:	2b01      	cmp	r3, #1
 c0024c6:	f000 8124 	beq.w	c002712 <HAL_FLASHEx_OBProgram+0x256>
 c0024ca:	2301      	movs	r3, #1
 c0024cc:	702b      	strb	r3, [r5, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0024ce:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0024d0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0024d4:	606b      	str	r3, [r5, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0024d6:	f7ff ff4b 	bl	c002370 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 c0024da:	2800      	cmp	r0, #0
 c0024dc:	f040 80db 	bne.w	c002696 <HAL_FLASHEx_OBProgram+0x1da>
    if((pOBInit->OptionType & OPTIONBYTE_WRP) != 0U)
 c0024e0:	6826      	ldr	r6, [r4, #0]
 c0024e2:	07f1      	lsls	r1, r6, #31
 c0024e4:	d50d      	bpl.n	c002502 <HAL_FLASHEx_OBProgram+0x46>
      FLASH_OB_WRPConfig(pOBInit->WRPArea, pOBInit->WRPStartOffset, pOBInit->WRPEndOffset);
 c0024e6:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
  assert_param(IS_OB_WRPAREA(WRPArea));
  assert_param(IS_FLASH_PAGE(WRPStartOffset));
  assert_param(IS_FLASH_PAGE(WRPEndOffset));

  /* Configure the write protected area */
  if(WRPArea == OB_WRPAREA_BANK1_AREAA)
 c0024ea:	2a01      	cmp	r2, #1
      FLASH_OB_WRPConfig(pOBInit->WRPArea, pOBInit->WRPStartOffset, pOBInit->WRPEndOffset);
 c0024ec:	68e1      	ldr	r1, [r4, #12]
 c0024ee:	4b8b      	ldr	r3, [pc, #556]	; (c00271c <HAL_FLASHEx_OBProgram+0x260>)
  if(WRPArea == OB_WRPAREA_BANK1_AREAA)
 c0024f0:	f040 80d4 	bne.w	c00269c <HAL_FLASHEx_OBProgram+0x1e0>
  {
    MODIFY_REG(FLASH->WRP1AR, (FLASH_WRP1AR_WRP1A_PSTRT | FLASH_WRP1AR_WRP1A_PEND),
 c0024f4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c0024f6:	f022 127f 	bic.w	r2, r2, #8323199	; 0x7f007f
 c0024fa:	4302      	orrs	r2, r0
 c0024fc:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 c002500:	659a      	str	r2, [r3, #88]	; 0x58
    if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
 c002502:	07b2      	lsls	r2, r6, #30
 c002504:	d506      	bpl.n	c002514 <HAL_FLASHEx_OBProgram+0x58>
{
  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));

  /* Configure the RDP level in the option bytes register */
  MODIFY_REG(FLASH->OPTR, FLASH_OPTR_RDP, RDPLevel);
 c002506:	4a85      	ldr	r2, [pc, #532]	; (c00271c <HAL_FLASHEx_OBProgram+0x260>)
 c002508:	6921      	ldr	r1, [r4, #16]
 c00250a:	6c13      	ldr	r3, [r2, #64]	; 0x40
 c00250c:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 c002510:	430b      	orrs	r3, r1
 c002512:	6413      	str	r3, [r2, #64]	; 0x40
    if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
 c002514:	0773      	lsls	r3, r6, #29
 c002516:	d579      	bpl.n	c00260c <HAL_FLASHEx_OBProgram+0x150>
      FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig);
 c002518:	e9d4 0105 	ldrd	r0, r1, [r4, #20]
  uint32_t optr_reg_mask = 0;

  /* Check the parameters */
  assert_param(IS_OB_USER_TYPE(UserType));

  if((UserType & OB_USER_BOR_LEV) != 0U)
 c00251c:	f010 0301 	ands.w	r3, r0, #1
  uint32_t optr_reg_val = 0;
 c002520:	bf0e      	itee	eq
 c002522:	461a      	moveq	r2, r3
    /* BOR level option byte should be modified */
    assert_param(IS_OB_USER_BOR_LEVEL(UserConfig & FLASH_OPTR_BOR_LEV));

    /* Set value and mask for BOR level option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_BOR_LEV);
    optr_reg_mask |= FLASH_OPTR_BOR_LEV;
 c002524:	f44f 63e0 	movne.w	r3, #1792	; 0x700
    optr_reg_val |= (UserConfig & FLASH_OPTR_BOR_LEV);
 c002528:	f401 62e0 	andne.w	r2, r1, #1792	; 0x700
  }

  if((UserType & OB_USER_nRST_STOP) != 0U)
 c00252c:	0787      	lsls	r7, r0, #30
  {
    /* nRST_STOP option byte should be modified */
    assert_param(IS_OB_USER_STOP(UserConfig & FLASH_OPTR_nRST_STOP));

    /* Set value and mask for nRST_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_STOP);
 c00252e:	bf42      	ittt	mi
 c002530:	f401 5780 	andmi.w	r7, r1, #4096	; 0x1000
 c002534:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_nRST_STOP;
 c002536:	f443 5380 	orrmi.w	r3, r3, #4096	; 0x1000
  }

  if((UserType & OB_USER_nRST_STDBY) != 0U)
 c00253a:	0747      	lsls	r7, r0, #29
  {
    /* nRST_STDBY option byte should be modified */
    assert_param(IS_OB_USER_STANDBY(UserConfig & FLASH_OPTR_nRST_STDBY));

    /* Set value and mask for nRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_STDBY);
 c00253c:	bf42      	ittt	mi
 c00253e:	f401 5700 	andmi.w	r7, r1, #8192	; 0x2000
 c002542:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_nRST_STDBY;
 c002544:	f443 5300 	orrmi.w	r3, r3, #8192	; 0x2000
  }

  if((UserType & OB_USER_nRST_SHDW) != 0U)
 c002548:	0707      	lsls	r7, r0, #28
  {
    /* nRST_SHDW option byte should be modified */
    assert_param(IS_OB_USER_SHUTDOWN(UserConfig & FLASH_OPTR_nRST_SHDW));

    /* Set value and mask for nRST_SHDW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_SHDW);
 c00254a:	bf42      	ittt	mi
 c00254c:	f401 4780 	andmi.w	r7, r1, #16384	; 0x4000
 c002550:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_nRST_SHDW;
 c002552:	f443 4380 	orrmi.w	r3, r3, #16384	; 0x4000
  }

  if((UserType & OB_USER_IWDG_SW) != 0U)
 c002556:	06c7      	lsls	r7, r0, #27
  {
    /* IWDG_SW option byte should be modified */
    assert_param(IS_OB_USER_IWDG(UserConfig & FLASH_OPTR_IWDG_SW));

    /* Set value and mask for IWDG_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_SW);
 c002558:	bf42      	ittt	mi
 c00255a:	f401 3780 	andmi.w	r7, r1, #65536	; 0x10000
 c00255e:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_IWDG_SW;
 c002560:	f443 3380 	orrmi.w	r3, r3, #65536	; 0x10000
  }

  if((UserType & OB_USER_IWDG_STOP) != 0U)
 c002564:	0687      	lsls	r7, r0, #26
  {
    /* IWDG_STOP option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTR_IWDG_STOP));

    /* Set value and mask for IWDG_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_STOP);
 c002566:	bf42      	ittt	mi
 c002568:	f401 3700 	andmi.w	r7, r1, #131072	; 0x20000
 c00256c:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_IWDG_STOP;
 c00256e:	f443 3300 	orrmi.w	r3, r3, #131072	; 0x20000
  }

  if((UserType & OB_USER_IWDG_STDBY) != 0U)
 c002572:	0647      	lsls	r7, r0, #25
  {
    /* IWDG_STDBY option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTR_IWDG_STDBY));

    /* Set value and mask for IWDG_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_STDBY);
 c002574:	bf42      	ittt	mi
 c002576:	f401 2780 	andmi.w	r7, r1, #262144	; 0x40000
 c00257a:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_IWDG_STDBY;
 c00257c:	f443 2380 	orrmi.w	r3, r3, #262144	; 0x40000
  }

  if((UserType & OB_USER_WWDG_SW) != 0U)
 c002580:	0607      	lsls	r7, r0, #24
  {
    /* WWDG_SW option byte should be modified */
    assert_param(IS_OB_USER_WWDG(UserConfig & FLASH_OPTR_WWDG_SW));

    /* Set value and mask for WWDG_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_WWDG_SW);
 c002582:	bf42      	ittt	mi
 c002584:	f401 2700 	andmi.w	r7, r1, #524288	; 0x80000
 c002588:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_WWDG_SW;
 c00258a:	f443 2300 	orrmi.w	r3, r3, #524288	; 0x80000
  }

  if((UserType & OB_USER_SWAP_BANK) != 0U)
 c00258e:	05c7      	lsls	r7, r0, #23
  {
    /* SWAP_BANK option byte should be modified */
    assert_param(IS_OB_USER_SWAP_BANK(UserConfig & FLASH_OPTR_SWAP_BANK));

    /* Set value and mask for SWAP_BANK option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_SWAP_BANK);
 c002590:	bf42      	ittt	mi
 c002592:	f401 1780 	andmi.w	r7, r1, #1048576	; 0x100000
 c002596:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_SWAP_BANK;
 c002598:	f443 1380 	orrmi.w	r3, r3, #1048576	; 0x100000
  }

  if((UserType & OB_USER_DUALBANK) != 0U)
 c00259c:	0587      	lsls	r7, r0, #22
  {
    /* DUALBANK option byte should be modified */
    assert_param(IS_OB_USER_DUALBANK(UserConfig & FLASH_OPTR_DB256K));

    /* Set value and mask for DB256K option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_DB256K);
 c00259e:	bf42      	ittt	mi
 c0025a0:	f401 1700 	andmi.w	r7, r1, #2097152	; 0x200000
 c0025a4:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_DB256K;
 c0025a6:	f443 1300 	orrmi.w	r3, r3, #2097152	; 0x200000
  }

  if((UserType & OB_USER_SRAM2_PE) != 0U)
 c0025aa:	0507      	lsls	r7, r0, #20
  {
    /* SRAM2_PAR option byte should be modified */
    assert_param(IS_OB_USER_SRAM2_PARITY(UserConfig & FLASH_OPTR_SRAM2_PE));

    /* Set value and mask for SRAM2_PAR option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_SRAM2_PE);
 c0025ac:	bf42      	ittt	mi
 c0025ae:	f001 7780 	andmi.w	r7, r1, #16777216	; 0x1000000
 c0025b2:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_SRAM2_PE;
 c0025b4:	f043 7380 	orrmi.w	r3, r3, #16777216	; 0x1000000
  }

  if((UserType & OB_USER_SRAM2_RST) != 0U)
 c0025b8:	04c7      	lsls	r7, r0, #19
  {
    /* SRAM2_RST option byte should be modified */
    assert_param(IS_OB_USER_SRAM2_RST(UserConfig & FLASH_OPTR_SRAM2_RST));

    /* Set value and mask for SRAM2_RST option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_SRAM2_RST);
 c0025ba:	bf42      	ittt	mi
 c0025bc:	f001 7700 	andmi.w	r7, r1, #33554432	; 0x2000000
 c0025c0:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_SRAM2_RST;
 c0025c2:	f043 7300 	orrmi.w	r3, r3, #33554432	; 0x2000000
  }

  if((UserType & OB_USER_nSWBOOT0) != 0U)
 c0025c6:	0487      	lsls	r7, r0, #18
  {
    /* nSWBOOT0 option byte should be modified */
    assert_param(IS_OB_USER_SWBOOT0(UserConfig & FLASH_OPTR_nSWBOOT0));

    /* Set value and mask for nSWBOOT0 option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nSWBOOT0);
 c0025c8:	bf42      	ittt	mi
 c0025ca:	f001 6780 	andmi.w	r7, r1, #67108864	; 0x4000000
 c0025ce:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_nSWBOOT0;
 c0025d0:	f043 6380 	orrmi.w	r3, r3, #67108864	; 0x4000000
  }

  if((UserType & OB_USER_nBOOT0) != 0U)
 c0025d4:	0447      	lsls	r7, r0, #17
  {
    /* nBOOT0 option byte should be modified */
    assert_param(IS_OB_USER_BOOT0(UserConfig & FLASH_OPTR_nBOOT0));

    /* Set value and mask for nBOOT0 option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nBOOT0);
 c0025d6:	bf42      	ittt	mi
 c0025d8:	f001 6700 	andmi.w	r7, r1, #134217728	; 0x8000000
 c0025dc:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_nBOOT0;
 c0025de:	f043 6300 	orrmi.w	r3, r3, #134217728	; 0x8000000
  }

  if((UserType & OB_USER_PA15_PUPEN) != 0U)
 c0025e2:	0407      	lsls	r7, r0, #16
  {
    /* nBOOT0 option byte should be modified */
    assert_param(IS_OB_USER_PA15_PUPEN(UserConfig & FLASH_OPTR_PA15_PUPEN));

    /* Set value and mask for nBOOT0 option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_PA15_PUPEN);
 c0025e4:	bf42      	ittt	mi
 c0025e6:	f001 5780 	andmi.w	r7, r1, #268435456	; 0x10000000
 c0025ea:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_PA15_PUPEN;
 c0025ec:	f043 5380 	orrmi.w	r3, r3, #268435456	; 0x10000000
  }

  if((UserType & OB_USER_TZEN) != 0U)
 c0025f0:	03c0      	lsls	r0, r0, #15
    optr_reg_val |= (UserConfig & FLASH_OPTR_TZEN);
    optr_reg_mask |= FLASH_OPTR_TZEN;
  }

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->OPTR, optr_reg_mask, optr_reg_val);
 c0025f2:	484a      	ldr	r0, [pc, #296]	; (c00271c <HAL_FLASHEx_OBProgram+0x260>)
    optr_reg_val |= (UserConfig & FLASH_OPTR_TZEN);
 c0025f4:	bf44      	itt	mi
 c0025f6:	f001 4100 	andmi.w	r1, r1, #2147483648	; 0x80000000
 c0025fa:	430a      	orrmi	r2, r1
  MODIFY_REG(FLASH->OPTR, optr_reg_mask, optr_reg_val);
 c0025fc:	6c01      	ldr	r1, [r0, #64]	; 0x40
    optr_reg_mask |= FLASH_OPTR_TZEN;
 c0025fe:	bf48      	it	mi
 c002600:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
  MODIFY_REG(FLASH->OPTR, optr_reg_mask, optr_reg_val);
 c002604:	ea21 0303 	bic.w	r3, r1, r3
 c002608:	431a      	orrs	r2, r3
 c00260a:	6402      	str	r2, [r0, #64]	; 0x40
    if((pOBInit->OptionType & OPTIONBYTE_WMSEC) != 0U)
 c00260c:	06f1      	lsls	r1, r6, #27
 c00260e:	d524      	bpl.n	c00265a <HAL_FLASHEx_OBProgram+0x19e>
      FLASH_OB_WMSECConfig(pOBInit->WMSecConfig, pOBInit->WMSecStartPage, pOBInit->WMSecEndPage, pOBInit->WMHDPEndPage);
 c002610:	e9d4 1007 	ldrd	r1, r0, [r4, #28]
 c002614:	e9d4 ec09 	ldrd	lr, ip, [r4, #36]	; 0x24
  assert_param(IS_FLASH_PAGE(WMSecStartPage));
  assert_param(IS_FLASH_PAGE(WMSecEndPage));
  assert_param(IS_FLASH_PAGE(WMHDPEndPage));

  /* Read SECWM registers */
  if ((WMSecConfig & OB_WMSEC_AREA1) != 0U)
 c002618:	f011 0701 	ands.w	r7, r1, #1
 c00261c:	4b3f      	ldr	r3, [pc, #252]	; (c00271c <HAL_FLASHEx_OBProgram+0x260>)
 c00261e:	d05c      	beq.n	c0026da <HAL_FLASHEx_OBProgram+0x21e>
  {
    tmp_secwm1 = FLASH->SECWM1R1;
 c002620:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    tmp_secwm2 = FLASH->SECWM1R2;
 c002622:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  {
    /* Nothing to do */
  }

  /* Configure Secure Area */
  if ((WMSecConfig & OB_WMSEC_SECURE_AREA_CONFIG) != 0U)
 c002624:	f011 0f10 	tst.w	r1, #16
  {
    MODIFY_REG(tmp_secwm1, (FLASH_SECWM1R1_SECWM1_PSTRT | FLASH_SECWM1R1_SECWM1_PEND),
 c002628:	bf1e      	ittt	ne
 c00262a:	ea40 400e 	orrne.w	r0, r0, lr, lsl #16
 c00262e:	f022 127f 	bicne.w	r2, r2, #8323199	; 0x7f007f
 c002632:	4302      	orrne	r2, r0
               ((WMSecEndPage << FLASH_SECWM1R1_SECWM1_PEND_Pos) | WMSecStartPage));
  }

  /* Configure Secure Hide Area */
  if ((WMSecConfig & OB_WMSEC_HDP_AREA_CONFIG) != 0U)
 c002634:	0688      	lsls	r0, r1, #26
  {
    tmp_secwm2 &= (~(FLASH_SECWM1R2_HDP1_PEND));
 c002636:	bf44      	itt	mi
 c002638:	f423 03fe 	bicmi.w	r3, r3, #8323072	; 0x7f0000
    tmp_secwm2 |= (WMHDPEndPage << FLASH_SECWM1R2_HDP1_PEND_Pos);
 c00263c:	ea43 430c 	orrmi.w	r3, r3, ip, lsl #16
  }

  /* Enable Secure Hide Area */
  if ((WMSecConfig & OB_WMSEC_HDP_AREA_ENABLE) != 0U)
 c002640:	0608      	lsls	r0, r1, #24
  {
    tmp_secwm2 |= FLASH_SECWM1R2_HDP1EN;
 c002642:	bf48      	it	mi
 c002644:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
  }

  /* Disable Secure Hide Area */
  if ((WMSecConfig & OB_WMSEC_HDP_AREA_DISABLE) != 0U)
 c002648:	05c8      	lsls	r0, r1, #23
  {
    tmp_secwm2 &= (~FLASH_SECWM1R2_HDP1EN);
 c00264a:	bf48      	it	mi
 c00264c:	f023 4300 	bicmi.w	r3, r3, #2147483648	; 0x80000000
 c002650:	4832      	ldr	r0, [pc, #200]	; (c00271c <HAL_FLASHEx_OBProgram+0x260>)
  }

  /* Write SECWM registers */
  if ((WMSecConfig & OB_WMSEC_AREA1) != 0U)
 c002652:	2f00      	cmp	r7, #0
 c002654:	d048      	beq.n	c0026e8 <HAL_FLASHEx_OBProgram+0x22c>
  {
    FLASH->SECWM1R1 = tmp_secwm1;
 c002656:	6502      	str	r2, [r0, #80]	; 0x50
    FLASH->SECWM1R2 = tmp_secwm2;
 c002658:	6543      	str	r3, [r0, #84]	; 0x54
    if((pOBInit->OptionType & OPTIONBYTE_BOOT_LOCK) != 0U)
 c00265a:	06b2      	lsls	r2, r6, #26
 c00265c:	d506      	bpl.n	c00266c <HAL_FLASHEx_OBProgram+0x1b0>
{
  /* Check the parameters */
  assert_param(IS_OB_BOOT_LOCK(BootLockConfig));

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->SECBOOTADD0R, FLASH_SECBOOTADD0R_BOOT_LOCK, BootLockConfig);
 c00265e:	4a2f      	ldr	r2, [pc, #188]	; (c00271c <HAL_FLASHEx_OBProgram+0x260>)
 c002660:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 c002662:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 c002664:	f023 0301 	bic.w	r3, r3, #1
 c002668:	430b      	orrs	r3, r1
 c00266a:	64d3      	str	r3, [r2, #76]	; 0x4c
    if((pOBInit->OptionType & OPTIONBYTE_BOOTADDR) != 0U)
 c00266c:	0733      	lsls	r3, r6, #28
 c00266e:	d509      	bpl.n	c002684 <HAL_FLASHEx_OBProgram+0x1c8>
      FLASH_OB_BootAddrConfig(pOBInit->BootAddrConfig, pOBInit->BootAddr);
 c002670:	e9d4 210c 	ldrd	r2, r1, [r4, #48]	; 0x30
static void FLASH_OB_BootAddrConfig(uint32_t BootAddrConfig, uint32_t BootAddr)
{
  /* Check the parameters */
  assert_param(IS_OB_BOOTADDR_CONFIG(BootAddrConfig));

  if (BootAddrConfig == OB_BOOTADDR_NS0)
 c002674:	2a01      	cmp	r2, #1
 c002676:	4b29      	ldr	r3, [pc, #164]	; (c00271c <HAL_FLASHEx_OBProgram+0x260>)
 c002678:	d13b      	bne.n	c0026f2 <HAL_FLASHEx_OBProgram+0x236>
  {
    MODIFY_REG(FLASH->NSBOOTADD0R, FLASH_NSBOOTADD0R_NSBOOTADD0, BootAddr);
 c00267a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 c00267c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c002680:	430a      	orrs	r2, r1
 c002682:	645a      	str	r2, [r3, #68]	; 0x44
    SET_BIT(FLASH->NSCR, FLASH_NSCR_OPTSTRT);
 c002684:	4a25      	ldr	r2, [pc, #148]	; (c00271c <HAL_FLASHEx_OBProgram+0x260>)
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c002686:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    SET_BIT(FLASH->NSCR, FLASH_NSCR_OPTSTRT);
 c00268a:	6a93      	ldr	r3, [r2, #40]	; 0x28
 c00268c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 c002690:	6293      	str	r3, [r2, #40]	; 0x28
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c002692:	f7ff fe6d 	bl	c002370 <FLASH_WaitForLastOperation>
  __HAL_UNLOCK(&pFlash);
 c002696:	2300      	movs	r3, #0
 c002698:	702b      	strb	r3, [r5, #0]
}
 c00269a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if(WRPArea == OB_WRPAREA_BANK1_AREAB)
 c00269c:	2a02      	cmp	r2, #2
 c00269e:	d107      	bne.n	c0026b0 <HAL_FLASHEx_OBProgram+0x1f4>
    MODIFY_REG(FLASH->WRP1BR, (FLASH_WRP1BR_WRP1B_PSTRT | FLASH_WRP1BR_WRP1B_PEND),
 c0026a0:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 c0026a2:	f022 127f 	bic.w	r2, r2, #8323199	; 0x7f007f
 c0026a6:	4302      	orrs	r2, r0
 c0026a8:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 c0026ac:	65da      	str	r2, [r3, #92]	; 0x5c
 c0026ae:	e728      	b.n	c002502 <HAL_FLASHEx_OBProgram+0x46>
  else if(WRPArea == OB_WRPAREA_BANK2_AREAA)
 c0026b0:	2a04      	cmp	r2, #4
 c0026b2:	d107      	bne.n	c0026c4 <HAL_FLASHEx_OBProgram+0x208>
    MODIFY_REG(FLASH->WRP2AR, (FLASH_WRP2AR_WRP2A_PSTRT | FLASH_WRP2AR_WRP2A_PEND),
 c0026b4:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 c0026b6:	f022 127f 	bic.w	r2, r2, #8323199	; 0x7f007f
 c0026ba:	4302      	orrs	r2, r0
 c0026bc:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 c0026c0:	669a      	str	r2, [r3, #104]	; 0x68
 c0026c2:	e71e      	b.n	c002502 <HAL_FLASHEx_OBProgram+0x46>
  else if(WRPArea == OB_WRPAREA_BANK2_AREAB)
 c0026c4:	2a08      	cmp	r2, #8
 c0026c6:	f47f af1c 	bne.w	c002502 <HAL_FLASHEx_OBProgram+0x46>
    MODIFY_REG(FLASH->WRP2BR, (FLASH_WRP2BR_WRP2B_PSTRT | FLASH_WRP2BR_WRP2B_PEND),
 c0026ca:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 c0026cc:	f022 127f 	bic.w	r2, r2, #8323199	; 0x7f007f
 c0026d0:	4302      	orrs	r2, r0
 c0026d2:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 c0026d6:	66da      	str	r2, [r3, #108]	; 0x6c
 c0026d8:	e713      	b.n	c002502 <HAL_FLASHEx_OBProgram+0x46>
  else if ((WMSecConfig & OB_WMSEC_AREA2) != 0U)
 c0026da:	078a      	lsls	r2, r1, #30
    tmp_secwm1 = FLASH->SECWM2R1;
 c0026dc:	bf4b      	itete	mi
 c0026de:	6e1a      	ldrmi	r2, [r3, #96]	; 0x60
  uint32_t tmp_secwm1 = 0U, tmp_secwm2 = 0U;
 c0026e0:	463b      	movpl	r3, r7
    tmp_secwm2 = FLASH->SECWM2R2;
 c0026e2:	6e5b      	ldrmi	r3, [r3, #100]	; 0x64
  uint32_t tmp_secwm1 = 0U, tmp_secwm2 = 0U;
 c0026e4:	463a      	movpl	r2, r7
 c0026e6:	e79d      	b.n	c002624 <HAL_FLASHEx_OBProgram+0x168>
  else if ((WMSecConfig & OB_WMSEC_AREA2) != 0U)
 c0026e8:	0789      	lsls	r1, r1, #30
    FLASH->SECWM2R1 = tmp_secwm1;
 c0026ea:	bf44      	itt	mi
 c0026ec:	6602      	strmi	r2, [r0, #96]	; 0x60
    FLASH->SECWM2R2 = tmp_secwm2;
 c0026ee:	6643      	strmi	r3, [r0, #100]	; 0x64
 c0026f0:	e7b3      	b.n	c00265a <HAL_FLASHEx_OBProgram+0x19e>
  }
  else if (BootAddrConfig == OB_BOOTADDR_NS1)
 c0026f2:	2a02      	cmp	r2, #2
 c0026f4:	d105      	bne.n	c002702 <HAL_FLASHEx_OBProgram+0x246>
  {
    MODIFY_REG(FLASH->NSBOOTADD1R, FLASH_NSBOOTADD1R_NSBOOTADD1, BootAddr);
 c0026f6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 c0026f8:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c0026fc:	430a      	orrs	r2, r1
 c0026fe:	649a      	str	r2, [r3, #72]	; 0x48
 c002700:	e7c0      	b.n	c002684 <HAL_FLASHEx_OBProgram+0x1c8>
  }
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  else if (BootAddrConfig == OB_BOOTADDR_SEC0)
 c002702:	2a04      	cmp	r2, #4
  {
    MODIFY_REG(FLASH->SECBOOTADD0R, FLASH_SECBOOTADD0R_SECBOOTADD0, BootAddr);
 c002704:	bf01      	itttt	eq
 c002706:	6cda      	ldreq	r2, [r3, #76]	; 0x4c
 c002708:	f002 027f 	andeq.w	r2, r2, #127	; 0x7f
 c00270c:	430a      	orreq	r2, r1
 c00270e:	64da      	streq	r2, [r3, #76]	; 0x4c
 c002710:	e7b8      	b.n	c002684 <HAL_FLASHEx_OBProgram+0x1c8>
  __HAL_LOCK(&pFlash);
 c002712:	2002      	movs	r0, #2
 c002714:	e7c1      	b.n	c00269a <HAL_FLASHEx_OBProgram+0x1de>
 c002716:	bf00      	nop
 c002718:	30030010 	.word	0x30030010
 c00271c:	50022000 	.word	0x50022000

0c002720 <HAL_FLASHEx_OBGetConfig>:
  pOBInit->OptionType = (OPTIONBYTE_RDP | OPTIONBYTE_USER);
 c002720:	2306      	movs	r3, #6
  if((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||
 c002722:	6842      	ldr	r2, [r0, #4]
{
 c002724:	b510      	push	{r4, lr}
  if((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||
 c002726:	2a08      	cmp	r2, #8
  pOBInit->OptionType = (OPTIONBYTE_RDP | OPTIONBYTE_USER);
 c002728:	6003      	str	r3, [r0, #0]
  if((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||
 c00272a:	d811      	bhi.n	c002750 <HAL_FLASHEx_OBGetConfig+0x30>
 c00272c:	f44f 738b 	mov.w	r3, #278	; 0x116
 c002730:	40d3      	lsrs	r3, r2
 c002732:	07db      	lsls	r3, r3, #31
 c002734:	d50c      	bpl.n	c002750 <HAL_FLASHEx_OBGetConfig+0x30>
    pOBInit->OptionType |= OPTIONBYTE_WRP;
 c002736:	2307      	movs	r3, #7
  * @retval None
  */
static void FLASH_OB_GetWRP(uint32_t WRPArea, uint32_t * WRPStartOffset, uint32_t * WRPEndOffset)
{
  /* Get the configuration of the write protected area */
  if(WRPArea == OB_WRPAREA_BANK1_AREAA)
 c002738:	2a01      	cmp	r2, #1
    pOBInit->OptionType |= OPTIONBYTE_WRP;
 c00273a:	6003      	str	r3, [r0, #0]
 c00273c:	4b39      	ldr	r3, [pc, #228]	; (c002824 <HAL_FLASHEx_OBGetConfig+0x104>)
  if(WRPArea == OB_WRPAREA_BANK1_AREAA)
 c00273e:	d14e      	bne.n	c0027de <HAL_FLASHEx_OBGetConfig+0xbe>
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_PSTRT);
 c002740:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c002742:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c002746:	6082      	str	r2, [r0, #8]
    *WRPEndOffset = (READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_PEND) >> FLASH_WRP1AR_WRP1A_PEND_Pos);
 c002748:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    *WRPEndOffset = (READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_WRP2A_PEND) >> FLASH_WRP2AR_WRP2A_PEND_Pos);
  }
  else if(WRPArea == OB_WRPAREA_BANK2_AREAB)
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PSTRT);
    *WRPEndOffset = (READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PEND) >> FLASH_WRP2BR_WRP2B_PEND_Pos);
 c00274a:	f3c3 4306 	ubfx	r3, r3, #16, #7
 c00274e:	60c3      	str	r3, [r0, #12]
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
  uint32_t rdp_level = READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP);
 c002750:	4a34      	ldr	r2, [pc, #208]	; (c002824 <HAL_FLASHEx_OBGetConfig+0x104>)
 c002752:	6c13      	ldr	r3, [r2, #64]	; 0x40
 c002754:	b2db      	uxtb	r3, r3

  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_0_5) && (rdp_level != OB_RDP_LEVEL_2))
 c002756:	2baa      	cmp	r3, #170	; 0xaa
 c002758:	d004      	beq.n	c002764 <HAL_FLASHEx_OBGetConfig+0x44>
 c00275a:	2b55      	cmp	r3, #85	; 0x55
 c00275c:	d002      	beq.n	c002764 <HAL_FLASHEx_OBGetConfig+0x44>
  {
    return (OB_RDP_LEVEL_1);
 c00275e:	2bcc      	cmp	r3, #204	; 0xcc
 c002760:	bf18      	it	ne
 c002762:	23bb      	movne	r3, #187	; 0xbb
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
 c002764:	6103      	str	r3, [r0, #16]
  *         @ref OB_USER_nSWBOOT0, @ref OB_USER_nBOOT0, @ref FLASH_OB_USER_PA15_PUPEN
  *         and @ref OB_USER_TZEN
  */
static uint32_t FLASH_OB_GetUser(void)
{
  uint32_t user_config = READ_REG(FLASH->OPTR);
 c002766:	6c13      	ldr	r3, [r2, #64]	; 0x40
  CLEAR_BIT(user_config, FLASH_OPTR_RDP);
 c002768:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  pOBInit->USERConfig = FLASH_OB_GetUser();
 c00276c:	6183      	str	r3, [r0, #24]
  if ((pOBInit->WMSecConfig == OB_WMSEC_AREA1) || (pOBInit->WMSecConfig == OB_WMSEC_AREA2))
 c00276e:	69c3      	ldr	r3, [r0, #28]
 c002770:	1e59      	subs	r1, r3, #1
 c002772:	2901      	cmp	r1, #1
 c002774:	d81a      	bhi.n	c0027ac <HAL_FLASHEx_OBGetConfig+0x8c>
    pOBInit->OptionType |= OPTIONBYTE_WMSEC;
 c002776:	6801      	ldr	r1, [r0, #0]
  /* Check the parameters */
  assert_param(IS_OB_WMSEC_CONFIG(*WMSecConfig));
  assert_param(IS_FLASH_BANK_EXCLUSIVE((*WMSecConfig) & 0x3U));

  /* Read SECWM registers */
  if (((*WMSecConfig) & OB_WMSEC_AREA1) != 0U)
 c002778:	2b01      	cmp	r3, #1
    pOBInit->OptionType |= OPTIONBYTE_WMSEC;
 c00277a:	f041 0110 	orr.w	r1, r1, #16
 c00277e:	6001      	str	r1, [r0, #0]
  {
    tmp_secwm1 = FLASH->SECWM1R1;
 c002780:	bf0b      	itete	eq
 c002782:	6d11      	ldreq	r1, [r2, #80]	; 0x50
    tmp_secwm2 = FLASH->SECWM1R2;
  }
  else if (((*WMSecConfig) & OB_WMSEC_AREA2) != 0U)
  {
    tmp_secwm1 = FLASH->SECWM2R1;
 c002784:	6e11      	ldrne	r1, [r2, #96]	; 0x60
    tmp_secwm2 = FLASH->SECWM1R2;
 c002786:	6d52      	ldreq	r2, [r2, #84]	; 0x54
    tmp_secwm2 = FLASH->SECWM2R2;
 c002788:	6e52      	ldrne	r2, [r2, #100]	; 0x64
  {
    /* Nothing to do */
  }

  /* Configuration of secure area */
  *WMSecStartPage = (tmp_secwm1 & FLASH_SECWM1R1_SECWM1_PSTRT);
 c00278a:	f001 047f 	and.w	r4, r1, #127	; 0x7f
  *WMSecEndPage = ((tmp_secwm1 & FLASH_SECWM1R1_SECWM1_PEND) >> FLASH_SECWM1R1_SECWM1_PEND_Pos);

  /* Configuration of secure hide area */
  *WMHDPEndPage = ((tmp_secwm2 & FLASH_SECWM1R2_HDP1_PEND) >> FLASH_SECWM1R2_HDP1_PEND_Pos);

  if ((tmp_secwm2 & FLASH_SECWM1R2_HDP1EN) == 0U)
 c00278e:	2a00      	cmp	r2, #0
  *WMSecEndPage = ((tmp_secwm1 & FLASH_SECWM1R1_SECWM1_PEND) >> FLASH_SECWM1R1_SECWM1_PEND_Pos);
 c002790:	f3c1 4106 	ubfx	r1, r1, #16, #7
 c002794:	6241      	str	r1, [r0, #36]	; 0x24
  {
    *WMSecConfig = ((*WMSecConfig) | OB_WMSEC_HDP_AREA_DISABLE);
 c002796:	bfa8      	it	ge
 c002798:	f443 7380 	orrge.w	r3, r3, #256	; 0x100
  *WMHDPEndPage = ((tmp_secwm2 & FLASH_SECWM1R2_HDP1_PEND) >> FLASH_SECWM1R2_HDP1_PEND_Pos);
 c00279c:	f3c2 4106 	ubfx	r1, r2, #16, #7
  }
  else
  {
    *WMSecConfig = ((*WMSecConfig) | OB_WMSEC_HDP_AREA_ENABLE);
 c0027a0:	bfb8      	it	lt
 c0027a2:	f043 0380 	orrlt.w	r3, r3, #128	; 0x80
  *WMSecStartPage = (tmp_secwm1 & FLASH_SECWM1R1_SECWM1_PSTRT);
 c0027a6:	6204      	str	r4, [r0, #32]
  *WMHDPEndPage = ((tmp_secwm2 & FLASH_SECWM1R2_HDP1_PEND) >> FLASH_SECWM1R2_HDP1_PEND_Pos);
 c0027a8:	6281      	str	r1, [r0, #40]	; 0x28
    *WMSecConfig = ((*WMSecConfig) | OB_WMSEC_HDP_AREA_ENABLE);
 c0027aa:	61c3      	str	r3, [r0, #28]
  pOBInit->OptionType |= OPTIONBYTE_BOOT_LOCK;
 c0027ac:	6801      	ldr	r1, [r0, #0]
  *            @arg OB_BOOT_LOCK_DISABLE: Boot Lock mode deactivated
  *            @arg OB_BOOT_LOCK_ENABLE: Boot Lock mode activated
  */
static uint32_t FLASH_OB_GetBootLock(void)
{
  return (FLASH->SECBOOTADD0R & FLASH_SECBOOTADD0R_BOOT_LOCK);
 c0027ae:	4a1d      	ldr	r2, [pc, #116]	; (c002824 <HAL_FLASHEx_OBGetConfig+0x104>)
  pOBInit->OptionType |= OPTIONBYTE_BOOT_LOCK;
 c0027b0:	f041 0320 	orr.w	r3, r1, #32
 c0027b4:	6003      	str	r3, [r0, #0]
  return (FLASH->SECBOOTADD0R & FLASH_SECBOOTADD0R_BOOT_LOCK);
 c0027b6:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 c0027b8:	f003 0301 	and.w	r3, r3, #1
  pOBInit->BootLock = FLASH_OB_GetBootLock();
 c0027bc:	62c3      	str	r3, [r0, #44]	; 0x2c
  if ((pOBInit->BootAddrConfig == OB_BOOTADDR_NS0) || (pOBInit->BootAddrConfig == OB_BOOTADDR_NS1) ||
 c0027be:	6b03      	ldr	r3, [r0, #48]	; 0x30
 c0027c0:	1e5c      	subs	r4, r3, #1
 c0027c2:	2c01      	cmp	r4, #1
 c0027c4:	d901      	bls.n	c0027ca <HAL_FLASHEx_OBGetConfig+0xaa>
 c0027c6:	2b04      	cmp	r3, #4
 c0027c8:	d108      	bne.n	c0027dc <HAL_FLASHEx_OBGetConfig+0xbc>
    pOBInit->OptionType |= OPTIONBYTE_BOOTADDR;
 c0027ca:	f041 0128 	orr.w	r1, r1, #40	; 0x28
  *
  * @retval None
  */
static void FLASH_OB_GetBootAddr(uint32_t BootAddrConfig, uint32_t * BootAddr)
{
  if (BootAddrConfig == OB_BOOTADDR_NS0)
 c0027ce:	2b01      	cmp	r3, #1
    pOBInit->OptionType |= OPTIONBYTE_BOOTADDR;
 c0027d0:	6001      	str	r1, [r0, #0]
  if (BootAddrConfig == OB_BOOTADDR_NS0)
 c0027d2:	d11c      	bne.n	c00280e <HAL_FLASHEx_OBGetConfig+0xee>
  {
    *BootAddr = (FLASH->NSBOOTADD0R & FLASH_NSBOOTADD0R_NSBOOTADD0);
 c0027d4:	6c53      	ldr	r3, [r2, #68]	; 0x44
    *BootAddr = (FLASH->NSBOOTADD1R & FLASH_NSBOOTADD1R_NSBOOTADD1);
  }
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  else if (BootAddrConfig == OB_BOOTADDR_SEC0)
  {
    *BootAddr = (FLASH->SECBOOTADD0R & FLASH_SECBOOTADD0R_SECBOOTADD0);
 c0027d6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 c0027da:	6343      	str	r3, [r0, #52]	; 0x34
}
 c0027dc:	bd10      	pop	{r4, pc}
  else if(WRPArea == OB_WRPAREA_BANK1_AREAB)
 c0027de:	2a02      	cmp	r2, #2
 c0027e0:	d105      	bne.n	c0027ee <HAL_FLASHEx_OBGetConfig+0xce>
    *WRPStartOffset = READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_PSTRT);
 c0027e2:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 c0027e4:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c0027e8:	6082      	str	r2, [r0, #8]
    *WRPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_PEND) >> FLASH_WRP1BR_WRP1B_PEND_Pos);
 c0027ea:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 c0027ec:	e7ad      	b.n	c00274a <HAL_FLASHEx_OBGetConfig+0x2a>
  else if(WRPArea == OB_WRPAREA_BANK2_AREAA)
 c0027ee:	2a04      	cmp	r2, #4
 c0027f0:	d105      	bne.n	c0027fe <HAL_FLASHEx_OBGetConfig+0xde>
    *WRPStartOffset = READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_WRP2A_PSTRT);
 c0027f2:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 c0027f4:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c0027f8:	6082      	str	r2, [r0, #8]
    *WRPEndOffset = (READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_WRP2A_PEND) >> FLASH_WRP2AR_WRP2A_PEND_Pos);
 c0027fa:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 c0027fc:	e7a5      	b.n	c00274a <HAL_FLASHEx_OBGetConfig+0x2a>
  else if(WRPArea == OB_WRPAREA_BANK2_AREAB)
 c0027fe:	2a08      	cmp	r2, #8
 c002800:	d1a6      	bne.n	c002750 <HAL_FLASHEx_OBGetConfig+0x30>
    *WRPStartOffset = READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PSTRT);
 c002802:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 c002804:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c002808:	6082      	str	r2, [r0, #8]
    *WRPEndOffset = (READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PEND) >> FLASH_WRP2BR_WRP2B_PEND_Pos);
 c00280a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 c00280c:	e79d      	b.n	c00274a <HAL_FLASHEx_OBGetConfig+0x2a>
  else if (BootAddrConfig == OB_BOOTADDR_NS1)
 c00280e:	2b02      	cmp	r3, #2
 c002810:	d102      	bne.n	c002818 <HAL_FLASHEx_OBGetConfig+0xf8>
    *BootAddr = (FLASH->NSBOOTADD1R & FLASH_NSBOOTADD1R_NSBOOTADD1);
 c002812:	4b04      	ldr	r3, [pc, #16]	; (c002824 <HAL_FLASHEx_OBGetConfig+0x104>)
 c002814:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 c002816:	e7de      	b.n	c0027d6 <HAL_FLASHEx_OBGetConfig+0xb6>
  else if (BootAddrConfig == OB_BOOTADDR_SEC0)
 c002818:	2b04      	cmp	r3, #4
 c00281a:	d1df      	bne.n	c0027dc <HAL_FLASHEx_OBGetConfig+0xbc>
    *BootAddr = (FLASH->SECBOOTADD0R & FLASH_SECBOOTADD0R_SECBOOTADD0);
 c00281c:	4b01      	ldr	r3, [pc, #4]	; (c002824 <HAL_FLASHEx_OBGetConfig+0x104>)
 c00281e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 c002820:	e7d9      	b.n	c0027d6 <HAL_FLASHEx_OBGetConfig+0xb6>
 c002822:	bf00      	nop
 c002824:	50022000 	.word	0x50022000

0c002828 <HAL_FLASHEx_ConfigPrivMode>:
  MODIFY_REG(FLASH->PRIVCFGR, FLASH_PRIVCFGR_PRIV, PrivMode);
 c002828:	4a04      	ldr	r2, [pc, #16]	; (c00283c <HAL_FLASHEx_ConfigPrivMode+0x14>)
 c00282a:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 c00282e:	f023 0301 	bic.w	r3, r3, #1
 c002832:	4318      	orrs	r0, r3
 c002834:	f8c2 00c4 	str.w	r0, [r2, #196]	; 0xc4
}
 c002838:	4770      	bx	lr
 c00283a:	bf00      	nop
 c00283c:	50022000 	.word	0x50022000

0c002840 <FLASH_PageErase>:
{
 c002840:	b530      	push	{r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c002842:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 c002846:	b672      	cpsid	i
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c002848:	4b13      	ldr	r3, [pc, #76]	; (c002898 <FLASH_PageErase+0x58>)
 c00284a:	4a14      	ldr	r2, [pc, #80]	; (c00289c <FLASH_PageErase+0x5c>)
 c00284c:	689d      	ldr	r5, [r3, #8]
 c00284e:	4b14      	ldr	r3, [pc, #80]	; (c0028a0 <FLASH_PageErase+0x60>)
 c002850:	ea33 0325 	bics.w	r3, r3, r5, asr #32
 c002854:	bf28      	it	cs
 c002856:	4613      	movcs	r3, r2
  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
 c002858:	4a12      	ldr	r2, [pc, #72]	; (c0028a4 <FLASH_PageErase+0x64>)
 c00285a:	6c12      	ldr	r2, [r2, #64]	; 0x40
 c00285c:	f412 0f80 	tst.w	r2, #4194304	; 0x400000
    CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 c002860:	681a      	ldr	r2, [r3, #0]
  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
 c002862:	d113      	bne.n	c00288c <FLASH_PageErase+0x4c>
      CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 c002864:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
 c002868:	601a      	str	r2, [r3, #0]
  MODIFY_REG((*reg), (FLASH_NSCR_NSPNB | FLASH_NSCR_NSPER), ((Page << FLASH_NSCR_NSPNB_Pos) | FLASH_NSCR_NSPER));
 c00286a:	681a      	ldr	r2, [r3, #0]
 c00286c:	00c0      	lsls	r0, r0, #3
 c00286e:	f422 727e 	bic.w	r2, r2, #1016	; 0x3f8
 c002872:	f022 0202 	bic.w	r2, r2, #2
 c002876:	f040 0002 	orr.w	r0, r0, #2
 c00287a:	4310      	orrs	r0, r2
 c00287c:	6018      	str	r0, [r3, #0]
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 c00287e:	681a      	ldr	r2, [r3, #0]
 c002880:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 c002884:	601a      	str	r2, [r3, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c002886:	f384 8810 	msr	PRIMASK, r4
}
 c00288a:	bd30      	pop	{r4, r5, pc}
    if((Banks & FLASH_BANK_1) != 0U)
 c00288c:	07c9      	lsls	r1, r1, #31
 c00288e:	d4e9      	bmi.n	c002864 <FLASH_PageErase+0x24>
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
 c002890:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 c002894:	e7e8      	b.n	c002868 <FLASH_PageErase+0x28>
 c002896:	bf00      	nop
 c002898:	30030010 	.word	0x30030010
 c00289c:	40022028 	.word	0x40022028
 c0028a0:	5002202c 	.word	0x5002202c
 c0028a4:	50022000 	.word	0x50022000

0c0028a8 <HAL_FLASHEx_Erase>:
{
 c0028a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  __HAL_LOCK(&pFlash);
 c0028ac:	4c26      	ldr	r4, [pc, #152]	; (c002948 <HAL_FLASHEx_Erase+0xa0>)
{
 c0028ae:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 c0028b0:	7823      	ldrb	r3, [r4, #0]
{
 c0028b2:	4689      	mov	r9, r1
  __HAL_LOCK(&pFlash);
 c0028b4:	2b01      	cmp	r3, #1
 c0028b6:	d045      	beq.n	c002944 <HAL_FLASHEx_Erase+0x9c>
 c0028b8:	2301      	movs	r3, #1
 c0028ba:	7023      	strb	r3, [r4, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0028bc:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0028be:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0028c2:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0028c4:	f7ff fd54 	bl	c002370 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 c0028c8:	4606      	mov	r6, r0
 c0028ca:	b9f0      	cbnz	r0, c00290a <HAL_FLASHEx_Erase+0x62>
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 c0028cc:	682b      	ldr	r3, [r5, #0]
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c0028ce:	4a1f      	ldr	r2, [pc, #124]	; (c00294c <HAL_FLASHEx_Erase+0xa4>)
 c0028d0:	491f      	ldr	r1, [pc, #124]	; (c002950 <HAL_FLASHEx_Erase+0xa8>)
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 c0028d2:	60a3      	str	r3, [r4, #8]
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c0028d4:	ea31 0823 	bics.w	r8, r1, r3, asr #32
 c0028d8:	bf28      	it	cs
 c0028da:	4690      	movcs	r8, r2
    if ((pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
 c0028dc:	f248 0204 	movw	r2, #32772	; 0x8004
 c0028e0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 c0028e4:	4293      	cmp	r3, r2
 c0028e6:	d115      	bne.n	c002914 <HAL_FLASHEx_Erase+0x6c>
      FLASH_MassErase(pEraseInit->Banks);
 c0028e8:	6868      	ldr	r0, [r5, #4]
 c0028ea:	f7ff fdb5 	bl	c002458 <FLASH_MassErase>
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0028ee:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 c0028f2:	f7ff fd3d 	bl	c002370 <FLASH_WaitForLastOperation>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 c0028f6:	4606      	mov	r6, r0
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 c0028f8:	68a2      	ldr	r2, [r4, #8]
 c0028fa:	f8d8 3000 	ldr.w	r3, [r8]
 c0028fe:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 c002902:	ea23 0302 	bic.w	r3, r3, r2
 c002906:	f8c8 3000 	str.w	r3, [r8]
  __HAL_UNLOCK(&pFlash);
 c00290a:	2300      	movs	r3, #0
 c00290c:	7023      	strb	r3, [r4, #0]
}
 c00290e:	4630      	mov	r0, r6
 c002910:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      *PageError = 0xFFFFFFFFU;
 c002914:	f04f 33ff 	mov.w	r3, #4294967295
 c002918:	f8c9 3000 	str.w	r3, [r9]
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 c00291c:	68af      	ldr	r7, [r5, #8]
 c00291e:	e9d5 3202 	ldrd	r3, r2, [r5, #8]
 c002922:	4413      	add	r3, r2
 c002924:	42bb      	cmp	r3, r7
 c002926:	d9e7      	bls.n	c0028f8 <HAL_FLASHEx_Erase+0x50>
        FLASH_PageErase(page_index, pEraseInit->Banks);
 c002928:	4638      	mov	r0, r7
 c00292a:	6869      	ldr	r1, [r5, #4]
 c00292c:	f7ff ff88 	bl	c002840 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 c002930:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 c002934:	f7ff fd1c 	bl	c002370 <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 c002938:	b110      	cbz	r0, c002940 <HAL_FLASHEx_Erase+0x98>
          *PageError = page_index;
 c00293a:	f8c9 7000 	str.w	r7, [r9]
 c00293e:	e7da      	b.n	c0028f6 <HAL_FLASHEx_Erase+0x4e>
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 c002940:	3701      	adds	r7, #1
 c002942:	e7ec      	b.n	c00291e <HAL_FLASHEx_Erase+0x76>
  __HAL_LOCK(&pFlash);
 c002944:	2602      	movs	r6, #2
 c002946:	e7e2      	b.n	c00290e <HAL_FLASHEx_Erase+0x66>
 c002948:	30030010 	.word	0x30030010
 c00294c:	40022028 	.word	0x40022028
 c002950:	5002202c 	.word	0x5002202c

0c002954 <HAL_GPIO_Init>:
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0U;
 c002954:	2300      	movs	r3, #0
{
 c002956:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
        EXTI->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 c00295a:	4a5f      	ldr	r2, [pc, #380]	; (c002ad8 <HAL_GPIO_Init+0x184>)
  while (((GPIO_Init->Pin) >> position) != 0U)
 c00295c:	f8d1 8000 	ldr.w	r8, [r1]
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c002960:	f8df 917c 	ldr.w	r9, [pc, #380]	; c002ae0 <HAL_GPIO_Init+0x18c>
  while (((GPIO_Init->Pin) >> position) != 0U)
 c002964:	fa38 f403 	lsrs.w	r4, r8, r3
 c002968:	d101      	bne.n	c00296e <HAL_GPIO_Init+0x1a>
      }
    }

    position++;
  }
}
 c00296a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 c00296e:	f04f 0c01 	mov.w	ip, #1
 c002972:	fa0c fc03 	lsl.w	ip, ip, r3
    if(iocurrent != 0U)
 c002976:	ea1c 0608 	ands.w	r6, ip, r8
 c00297a:	f000 809f 	beq.w	c002abc <HAL_GPIO_Init+0x168>
 c00297e:	2503      	movs	r5, #3
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 c002980:	684c      	ldr	r4, [r1, #4]
 c002982:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 c002986:	f024 0a10 	bic.w	sl, r4, #16
 c00298a:	f10a 37ff 	add.w	r7, sl, #4294967295
 c00298e:	fa05 f50e 	lsl.w	r5, r5, lr
 c002992:	2f01      	cmp	r7, #1
 c002994:	ea6f 0505 	mvn.w	r5, r5
 c002998:	d811      	bhi.n	c0029be <HAL_GPIO_Init+0x6a>
        temp = GPIOx->OSPEEDR;
 c00299a:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 c00299c:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
 c0029a0:	68cf      	ldr	r7, [r1, #12]
 c0029a2:	fa07 f70e 	lsl.w	r7, r7, lr
 c0029a6:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->OSPEEDR = temp;
 c0029aa:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 c0029ac:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 c0029ae:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 c0029b2:	f3c4 1700 	ubfx	r7, r4, #4, #1
 c0029b6:	409f      	lsls	r7, r3
 c0029b8:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->OTYPER = temp;
 c0029bc:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 c0029be:	68c7      	ldr	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 c0029c0:	f1ba 0f02 	cmp.w	sl, #2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 c0029c4:	ea07 0c05 	and.w	ip, r7, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 c0029c8:	688f      	ldr	r7, [r1, #8]
 c0029ca:	fa07 f70e 	lsl.w	r7, r7, lr
 c0029ce:	ea47 070c 	orr.w	r7, r7, ip
      GPIOx->PUPDR = temp;
 c0029d2:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 c0029d4:	d116      	bne.n	c002a04 <HAL_GPIO_Init+0xb0>
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 c0029d6:	f04f 0c0f 	mov.w	ip, #15
        temp = GPIOx->AFR[position >> 3U];
 c0029da:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 c0029de:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 c0029e2:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 c0029e6:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 c0029ea:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 c0029ee:	fa0c fc0b 	lsl.w	ip, ip, fp
 c0029f2:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 c0029f6:	690f      	ldr	r7, [r1, #16]
 c0029f8:	fa07 f70b 	lsl.w	r7, r7, fp
 c0029fc:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->AFR[position >> 3U] = temp;
 c002a00:	f8ca 7020 	str.w	r7, [sl, #32]
      temp = GPIOx->MODER;
 c002a04:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 c002a06:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 c002a08:	f004 0703 	and.w	r7, r4, #3
 c002a0c:	fa07 fe0e 	lsl.w	lr, r7, lr
 c002a10:	ea4e 0505 	orr.w	r5, lr, r5
      GPIOx->MODER = temp;
 c002a14:	6005      	str	r5, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 c002a16:	00e5      	lsls	r5, r4, #3
 c002a18:	d550      	bpl.n	c002abc <HAL_GPIO_Init+0x168>
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 c002a1a:	f04f 0c0f 	mov.w	ip, #15
 c002a1e:	f023 0703 	bic.w	r7, r3, #3
 c002a22:	f107 47a0 	add.w	r7, r7, #1342177280	; 0x50000000
 c002a26:	f507 373d 	add.w	r7, r7, #193536	; 0x2f400
 c002a2a:	f003 0e03 	and.w	lr, r3, #3
        temp = EXTI->EXTICR[position >> 2U];
 c002a2e:	6e3d      	ldr	r5, [r7, #96]	; 0x60
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 c002a30:	ea4f 0ece 	mov.w	lr, lr, lsl #3
 c002a34:	fa0c fc0e 	lsl.w	ip, ip, lr
 c002a38:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c002a3c:	4d27      	ldr	r5, [pc, #156]	; (c002adc <HAL_GPIO_Init+0x188>)
 c002a3e:	42a8      	cmp	r0, r5
 c002a40:	d03e      	beq.n	c002ac0 <HAL_GPIO_Init+0x16c>
 c002a42:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 c002a46:	42a8      	cmp	r0, r5
 c002a48:	d03c      	beq.n	c002ac4 <HAL_GPIO_Init+0x170>
 c002a4a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 c002a4e:	42a8      	cmp	r0, r5
 c002a50:	d03a      	beq.n	c002ac8 <HAL_GPIO_Init+0x174>
 c002a52:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 c002a56:	42a8      	cmp	r0, r5
 c002a58:	d038      	beq.n	c002acc <HAL_GPIO_Init+0x178>
 c002a5a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 c002a5e:	42a8      	cmp	r0, r5
 c002a60:	d036      	beq.n	c002ad0 <HAL_GPIO_Init+0x17c>
 c002a62:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 c002a66:	42a8      	cmp	r0, r5
 c002a68:	d034      	beq.n	c002ad4 <HAL_GPIO_Init+0x180>
 c002a6a:	4548      	cmp	r0, r9
 c002a6c:	bf14      	ite	ne
 c002a6e:	2507      	movne	r5, #7
 c002a70:	2506      	moveq	r5, #6
 c002a72:	fa05 f50e 	lsl.w	r5, r5, lr
 c002a76:	ea45 050c 	orr.w	r5, r5, ip
        EXTI->EXTICR[position >> 2U] = temp;
 c002a7a:	663d      	str	r5, [r7, #96]	; 0x60
        temp &= ~(iocurrent);
 c002a7c:	43f7      	mvns	r7, r6
        temp = EXTI->IMR1;
 c002a7e:	f8d2 5080 	ldr.w	r5, [r2, #128]	; 0x80
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 c002a82:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~(iocurrent);
 c002a86:	bf0c      	ite	eq
 c002a88:	403d      	andeq	r5, r7
          temp |= iocurrent;
 c002a8a:	4335      	orrne	r5, r6
        EXTI->IMR1 = temp;
 c002a8c:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
        temp = EXTI->EMR1;
 c002a90:	f8d2 5084 	ldr.w	r5, [r2, #132]	; 0x84
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 c002a94:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~(iocurrent);
 c002a98:	bf0c      	ite	eq
 c002a9a:	403d      	andeq	r5, r7
          temp |= iocurrent;
 c002a9c:	4335      	orrne	r5, r6
        EXTI->EMR1 = temp;
 c002a9e:	f8c2 5084 	str.w	r5, [r2, #132]	; 0x84
        temp = EXTI->RTSR1;
 c002aa2:	6815      	ldr	r5, [r2, #0]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 c002aa4:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~(iocurrent);
 c002aa8:	bf0c      	ite	eq
 c002aaa:	403d      	andeq	r5, r7
          temp |= iocurrent;
 c002aac:	4335      	orrne	r5, r6
        EXTI->RTSR1 = temp;
 c002aae:	6015      	str	r5, [r2, #0]
        temp = EXTI->FTSR1;
 c002ab0:	6855      	ldr	r5, [r2, #4]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 c002ab2:	02a4      	lsls	r4, r4, #10
        temp &= ~(iocurrent);
 c002ab4:	bf54      	ite	pl
 c002ab6:	403d      	andpl	r5, r7
          temp |= iocurrent;
 c002ab8:	4335      	orrmi	r5, r6
        EXTI->FTSR1 = temp;
 c002aba:	6055      	str	r5, [r2, #4]
    position++;
 c002abc:	3301      	adds	r3, #1
 c002abe:	e751      	b.n	c002964 <HAL_GPIO_Init+0x10>
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c002ac0:	2500      	movs	r5, #0
 c002ac2:	e7d6      	b.n	c002a72 <HAL_GPIO_Init+0x11e>
 c002ac4:	2501      	movs	r5, #1
 c002ac6:	e7d4      	b.n	c002a72 <HAL_GPIO_Init+0x11e>
 c002ac8:	2502      	movs	r5, #2
 c002aca:	e7d2      	b.n	c002a72 <HAL_GPIO_Init+0x11e>
 c002acc:	2503      	movs	r5, #3
 c002ace:	e7d0      	b.n	c002a72 <HAL_GPIO_Init+0x11e>
 c002ad0:	2504      	movs	r5, #4
 c002ad2:	e7ce      	b.n	c002a72 <HAL_GPIO_Init+0x11e>
 c002ad4:	2505      	movs	r5, #5
 c002ad6:	e7cc      	b.n	c002a72 <HAL_GPIO_Init+0x11e>
 c002ad8:	5002f400 	.word	0x5002f400
 c002adc:	52020000 	.word	0x52020000
 c002ae0:	52021800 	.word	0x52021800

0c002ae4 <HAL_GTZC_MPCBB_ConfigMem>:
  uint32_t size_mask;
  uint32_t size_in_superblocks;
  uint32_t i;

  /* check entry parameters */
  if (   (     !(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c002ae4:	f020 5080 	bic.w	r0, r0, #268435456	; 0x10000000
 c002ae8:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
{
 c002aec:	b530      	push	{r4, r5, lr}
  if (   (     !(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c002aee:	d002      	beq.n	c002af6 <HAL_GTZC_MPCBB_ConfigMem+0x12>
           &&  !(IS_GTZC_BASE_ADDRESS(SRAM2, MemBaseAddress)))
 c002af0:	4b19      	ldr	r3, [pc, #100]	; (c002b58 <HAL_GTZC_MPCBB_ConfigMem+0x74>)
 c002af2:	4298      	cmp	r0, r3
 c002af4:	d12e      	bne.n	c002b54 <HAL_GTZC_MPCBB_ConfigMem+0x70>
      || (   (    pMPCBB_desc->SecureRWIllegalMode
 c002af6:	680b      	ldr	r3, [r1, #0]
 c002af8:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 c002afc:	d12a      	bne.n	c002b54 <HAL_GTZC_MPCBB_ConfigMem+0x70>
               != GTZC_MPCBB_SRWILADIS_ENABLE)
          && (    pMPCBB_desc->SecureRWIllegalMode
               != GTZC_MPCBB_SRWILADIS_DISABLE))
      || (   (    pMPCBB_desc->InvertSecureState
 c002afe:	684c      	ldr	r4, [r1, #4]
 c002b00:	f034 4280 	bics.w	r2, r4, #1073741824	; 0x40000000
 c002b04:	d126      	bne.n	c002b54 <HAL_GTZC_MPCBB_ConfigMem+0x70>
  reg_value = pMPCBB_desc->InvertSecureState;
  reg_value |= pMPCBB_desc->SecureRWIllegalMode;
  if (IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
  {
    mpcbb_ptr = GTZC_MPCBB1_S;
    mem_size = GTZC_MEM_SIZE(SRAM1);
 c002b06:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
 c002b0a:	4814      	ldr	r0, [pc, #80]	; (c002b5c <HAL_GTZC_MPCBB_ConfigMem+0x78>)
  reg_value |= pMPCBB_desc->SecureRWIllegalMode;
 c002b0c:	ea44 0403 	orr.w	r4, r4, r3
    mem_size = GTZC_MEM_SIZE(SRAM1);
 c002b10:	4b13      	ldr	r3, [pc, #76]	; (c002b60 <HAL_GTZC_MPCBB_ConfigMem+0x7c>)
 c002b12:	bf18      	it	ne
 c002b14:	4603      	movne	r3, r0
    mpcbb_ptr = GTZC_MPCBB2_S;
    mem_size = GTZC_MEM_SIZE(SRAM2);
  }

  /* write configuration and lock register information */
  MODIFY_REG(mpcbb_ptr->CR,
 c002b16:	6818      	ldr	r0, [r3, #0]
 c002b18:	f101 0108 	add.w	r1, r1, #8
 c002b1c:	f020 4040 	bic.w	r0, r0, #3221225472	; 0xc0000000
 c002b20:	ea40 0004 	orr.w	r0, r0, r4
 c002b24:	6018      	str	r0, [r3, #0]
             GTZC_MPCBB_CR_INVSECSTATE_Msk | GTZC_MPCBB_CR_SRWILADIS_Msk, reg_value);
  size_mask = (1UL << (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE)) - 1U;
  /* limitation: code not portable with memory > 256K */
  MODIFY_REG(mpcbb_ptr->LCKVTR1, size_mask, pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0]);
 c002b26:	bf15      	itete	ne
 c002b28:	f06f 00ff 	mvnne.w	r0, #255	; 0xff
 c002b2c:	f04f 407f 	moveq.w	r0, #4278190080	; 0xff000000
  size_mask = (1UL << (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE)) - 1U;
 c002b30:	2408      	movne	r4, #8
 c002b32:	2418      	moveq	r4, #24
  MODIFY_REG(mpcbb_ptr->LCKVTR1, size_mask, pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0]);
 c002b34:	691d      	ldr	r5, [r3, #16]
 c002b36:	4028      	ands	r0, r5
 c002b38:	6e0d      	ldr	r5, [r1, #96]	; 0x60
 c002b3a:	4328      	orrs	r0, r5
 c002b3c:	6118      	str	r0, [r3, #16]

  /* write vector register information */
  size_in_superblocks = (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE);
  for (i = 0U; i < size_in_superblocks; i++)
  {
    WRITE_REG(mpcbb_ptr->VCTR[i],
 c002b3e:	f102 0040 	add.w	r0, r2, #64	; 0x40
 c002b42:	f851 5b04 	ldr.w	r5, [r1], #4
  for (i = 0U; i < size_in_superblocks; i++)
 c002b46:	3201      	adds	r2, #1
 c002b48:	4294      	cmp	r4, r2
    WRITE_REG(mpcbb_ptr->VCTR[i],
 c002b4a:	f843 5020 	str.w	r5, [r3, r0, lsl #2]
  for (i = 0U; i < size_in_superblocks; i++)
 c002b4e:	d1f6      	bne.n	c002b3e <HAL_GTZC_MPCBB_ConfigMem+0x5a>
              pMPCBB_desc->AttributeConfig.MPCBB_SecConfig_array[i]);
  }

  return HAL_OK;
 c002b50:	2000      	movs	r0, #0
}
 c002b52:	bd30      	pop	{r4, r5, pc}
    return HAL_ERROR;
 c002b54:	2001      	movs	r0, #1
 c002b56:	e7fc      	b.n	c002b52 <HAL_GTZC_MPCBB_ConfigMem+0x6e>
 c002b58:	20030000 	.word	0x20030000
 c002b5c:	50033000 	.word	0x50033000
 c002b60:	50032c00 	.word	0x50032c00

0c002b64 <HAL_GTZC_MPCBB_GetConfigMem>:
  uint32_t size_mask;
  uint32_t size_in_superblocks;
  uint32_t i;

  /* check entry parameters */
  if (    !(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c002b64:	f020 5080 	bic.w	r0, r0, #268435456	; 0x10000000
 c002b68:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
{
 c002b6c:	b510      	push	{r4, lr}
  if (    !(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c002b6e:	d021      	beq.n	c002bb4 <HAL_GTZC_MPCBB_GetConfigMem+0x50>
       && !(IS_GTZC_BASE_ADDRESS(SRAM2, MemBaseAddress)))
 c002b70:	4b13      	ldr	r3, [pc, #76]	; (c002bc0 <HAL_GTZC_MPCBB_GetConfigMem+0x5c>)
 c002b72:	4298      	cmp	r0, r3
 c002b74:	d122      	bne.n	c002bbc <HAL_GTZC_MPCBB_GetConfigMem+0x58>
    mem_size = GTZC_MEM_SIZE(SRAM1);
  }
  else
  {
    mpcbb_ptr = GTZC_MPCBB2_S;
    mem_size = GTZC_MEM_SIZE(SRAM2);
 c002b76:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    mpcbb_ptr = GTZC_MPCBB2_S;
 c002b7a:	4812      	ldr	r0, [pc, #72]	; (c002bc4 <HAL_GTZC_MPCBB_GetConfigMem+0x60>)
  }

  /* read configuration and lock register information */
  reg_value = READ_REG(mpcbb_ptr->CR);
 c002b7c:	6802      	ldr	r2, [r0, #0]
  pMPCBB_desc->InvertSecureState = (reg_value & GTZC_MPCBB_CR_INVSECSTATE_Msk);
  pMPCBB_desc->SecureRWIllegalMode = (reg_value & GTZC_MPCBB_CR_SRWILADIS_Msk);
  size_mask = (1UL << (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE)) - 1U;
 c002b7e:	0b5b      	lsrs	r3, r3, #13
  pMPCBB_desc->InvertSecureState = (reg_value & GTZC_MPCBB_CR_INVSECSTATE_Msk);
 c002b80:	f002 4480 	and.w	r4, r2, #1073741824	; 0x40000000
 c002b84:	604c      	str	r4, [r1, #4]
  /* limitation: code not portable with memory > 256K */
  pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0] = READ_REG(mpcbb_ptr->LCKVTR1)
                                                         & size_mask;
 c002b86:	f04f 34ff 	mov.w	r4, #4294967295
  pMPCBB_desc->SecureRWIllegalMode = (reg_value & GTZC_MPCBB_CR_SRWILADIS_Msk);
 c002b8a:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
 c002b8e:	600a      	str	r2, [r1, #0]
  pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0] = READ_REG(mpcbb_ptr->LCKVTR1)
 c002b90:	6902      	ldr	r2, [r0, #16]
                                                         & size_mask;
 c002b92:	409c      	lsls	r4, r3
 c002b94:	ea22 0204 	bic.w	r2, r2, r4
  pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0] = READ_REG(mpcbb_ptr->LCKVTR1)
 c002b98:	668a      	str	r2, [r1, #104]	; 0x68

  /* read vector register information */
  size_in_superblocks = (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE);
  for (i = 0U; i < size_in_superblocks; i++)
 c002b9a:	2200      	movs	r2, #0
 c002b9c:	3108      	adds	r1, #8
  {
    pMPCBB_desc->AttributeConfig.MPCBB_SecConfig_array[i] = mpcbb_ptr->VCTR[i];
 c002b9e:	f102 0440 	add.w	r4, r2, #64	; 0x40
 c002ba2:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
  for (i = 0U; i < size_in_superblocks; i++)
 c002ba6:	3201      	adds	r2, #1
 c002ba8:	4293      	cmp	r3, r2
    pMPCBB_desc->AttributeConfig.MPCBB_SecConfig_array[i] = mpcbb_ptr->VCTR[i];
 c002baa:	f841 4b04 	str.w	r4, [r1], #4
  for (i = 0U; i < size_in_superblocks; i++)
 c002bae:	d1f6      	bne.n	c002b9e <HAL_GTZC_MPCBB_GetConfigMem+0x3a>
  }

  return HAL_OK;
 c002bb0:	2000      	movs	r0, #0
}
 c002bb2:	bd10      	pop	{r4, pc}
    mem_size = GTZC_MEM_SIZE(SRAM1);
 c002bb4:	f44f 3340 	mov.w	r3, #196608	; 0x30000
    mpcbb_ptr = GTZC_MPCBB1_S;
 c002bb8:	4803      	ldr	r0, [pc, #12]	; (c002bc8 <HAL_GTZC_MPCBB_GetConfigMem+0x64>)
 c002bba:	e7df      	b.n	c002b7c <HAL_GTZC_MPCBB_GetConfigMem+0x18>
    return HAL_ERROR;
 c002bbc:	2001      	movs	r0, #1
 c002bbe:	e7f8      	b.n	c002bb2 <HAL_GTZC_MPCBB_GetConfigMem+0x4e>
 c002bc0:	20030000 	.word	0x20030000
 c002bc4:	50033000 	.word	0x50033000
 c002bc8:	50032c00 	.word	0x50032c00

0c002bcc <HASH_GetDigest>:
  */
static void HASH_GetDigest(uint8_t *pMsgDigest, uint8_t Size)
{
  uint32_t msgdigest = (uint32_t)pMsgDigest;

  switch(Size)
 c002bcc:	2914      	cmp	r1, #20
 c002bce:	d016      	beq.n	c002bfe <HASH_GetDigest+0x32>
 c002bd0:	d802      	bhi.n	c002bd8 <HASH_GetDigest+0xc>
 c002bd2:	2910      	cmp	r1, #16
 c002bd4:	d005      	beq.n	c002be2 <HASH_GetDigest+0x16>
 c002bd6:	4770      	bx	lr
 c002bd8:	291c      	cmp	r1, #28
 c002bda:	d021      	beq.n	c002c20 <HASH_GetDigest+0x54>
 c002bdc:	2920      	cmp	r1, #32
 c002bde:	d037      	beq.n	c002c50 <HASH_GetDigest+0x84>
 c002be0:	4770      	bx	lr
  {
    /* Read the message digest */
    case 16:  /* MD5 */
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 c002be2:	4b29      	ldr	r3, [pc, #164]	; (c002c88 <HASH_GetDigest+0xbc>)
 c002be4:	68da      	ldr	r2, [r3, #12]
  return __builtin_bswap32(value);
 c002be6:	ba12      	rev	r2, r2
 c002be8:	6002      	str	r2, [r0, #0]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 c002bea:	691a      	ldr	r2, [r3, #16]
 c002bec:	ba12      	rev	r2, r2
 c002bee:	6042      	str	r2, [r0, #4]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 c002bf0:	695a      	ldr	r2, [r3, #20]
 c002bf2:	ba12      	rev	r2, r2
 c002bf4:	6082      	str	r2, [r0, #8]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 c002bf6:	699b      	ldr	r3, [r3, #24]
 c002bf8:	ba1b      	rev	r3, r3
 c002bfa:	60c3      	str	r3, [r0, #12]
    break;
 c002bfc:	4770      	bx	lr
    case 20:  /* SHA1 */
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 c002bfe:	4b22      	ldr	r3, [pc, #136]	; (c002c88 <HASH_GetDigest+0xbc>)
 c002c00:	68da      	ldr	r2, [r3, #12]
 c002c02:	ba12      	rev	r2, r2
 c002c04:	6002      	str	r2, [r0, #0]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 c002c06:	691a      	ldr	r2, [r3, #16]
 c002c08:	ba12      	rev	r2, r2
 c002c0a:	6042      	str	r2, [r0, #4]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 c002c0c:	695a      	ldr	r2, [r3, #20]
 c002c0e:	ba12      	rev	r2, r2
 c002c10:	6082      	str	r2, [r0, #8]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 c002c12:	699a      	ldr	r2, [r3, #24]
 c002c14:	ba12      	rev	r2, r2
 c002c16:	60c2      	str	r2, [r0, #12]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 c002c18:	69db      	ldr	r3, [r3, #28]
 c002c1a:	ba1b      	rev	r3, r3
 c002c1c:	6103      	str	r3, [r0, #16]
    break;
 c002c1e:	4770      	bx	lr
  case 28:  /* SHA224 */
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 c002c20:	4b19      	ldr	r3, [pc, #100]	; (c002c88 <HASH_GetDigest+0xbc>)
 c002c22:	68da      	ldr	r2, [r3, #12]
 c002c24:	ba12      	rev	r2, r2
 c002c26:	6002      	str	r2, [r0, #0]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 c002c28:	691a      	ldr	r2, [r3, #16]
 c002c2a:	ba12      	rev	r2, r2
 c002c2c:	6042      	str	r2, [r0, #4]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 c002c2e:	695a      	ldr	r2, [r3, #20]
 c002c30:	ba12      	rev	r2, r2
 c002c32:	6082      	str	r2, [r0, #8]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 c002c34:	699a      	ldr	r2, [r3, #24]
 c002c36:	ba12      	rev	r2, r2
 c002c38:	60c2      	str	r2, [r0, #12]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 c002c3a:	69db      	ldr	r3, [r3, #28]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 c002c3c:	4a13      	ldr	r2, [pc, #76]	; (c002c8c <HASH_GetDigest+0xc0>)
 c002c3e:	ba1b      	rev	r3, r3
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 c002c40:	6103      	str	r3, [r0, #16]
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 c002c42:	6953      	ldr	r3, [r2, #20]
 c002c44:	ba1b      	rev	r3, r3
 c002c46:	6143      	str	r3, [r0, #20]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[6]);
 c002c48:	6993      	ldr	r3, [r2, #24]
 c002c4a:	ba1b      	rev	r3, r3
 c002c4c:	6183      	str	r3, [r0, #24]
    break;
 c002c4e:	4770      	bx	lr
  case 32:   /* SHA256 */
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 c002c50:	4b0d      	ldr	r3, [pc, #52]	; (c002c88 <HASH_GetDigest+0xbc>)
 c002c52:	68da      	ldr	r2, [r3, #12]
 c002c54:	ba12      	rev	r2, r2
 c002c56:	6002      	str	r2, [r0, #0]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 c002c58:	691a      	ldr	r2, [r3, #16]
 c002c5a:	ba12      	rev	r2, r2
 c002c5c:	6042      	str	r2, [r0, #4]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 c002c5e:	695a      	ldr	r2, [r3, #20]
 c002c60:	ba12      	rev	r2, r2
 c002c62:	6082      	str	r2, [r0, #8]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 c002c64:	699a      	ldr	r2, [r3, #24]
 c002c66:	ba12      	rev	r2, r2
 c002c68:	60c2      	str	r2, [r0, #12]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 c002c6a:	69db      	ldr	r3, [r3, #28]
 c002c6c:	ba1b      	rev	r3, r3
 c002c6e:	6103      	str	r3, [r0, #16]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 c002c70:	4b06      	ldr	r3, [pc, #24]	; (c002c8c <HASH_GetDigest+0xc0>)
 c002c72:	695a      	ldr	r2, [r3, #20]
 c002c74:	ba12      	rev	r2, r2
 c002c76:	6142      	str	r2, [r0, #20]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[6]);
 c002c78:	699a      	ldr	r2, [r3, #24]
 c002c7a:	ba12      	rev	r2, r2
 c002c7c:	6182      	str	r2, [r0, #24]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[7]);
 c002c7e:	69db      	ldr	r3, [r3, #28]
 c002c80:	ba1b      	rev	r3, r3
 c002c82:	61c3      	str	r3, [r0, #28]
    break;
    default:
    break;
  }
}
 c002c84:	4770      	bx	lr
 c002c86:	bf00      	nop
 c002c88:	520c0400 	.word	0x520c0400
 c002c8c:	520c0710 	.word	0x520c0710

0c002c90 <HASH_WaitOnFlagUntilTimeout>:
  * @param  Status the Flag status (SET or RESET).
  * @param  Timeout Timeout duration.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_WaitOnFlagUntilTimeout(HASH_HandleTypeDef *hhash, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
{
 c002c90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c002c94:	4604      	mov	r4, r0
 c002c96:	460e      	mov	r6, r1
 c002c98:	4691      	mov	r9, r2
 c002c9a:	461d      	mov	r5, r3
  uint32_t tickstart = HAL_GetTick();
 c002c9c:	f7fe fc90 	bl	c0015c0 <HAL_GetTick>
 c002ca0:	4f16      	ldr	r7, [pc, #88]	; (c002cfc <HASH_WaitOnFlagUntilTimeout+0x6c>)
 c002ca2:	4680      	mov	r8, r0

  /* Wait until flag is set */
  if(Status == RESET)
 c002ca4:	f1b9 0f00 	cmp.w	r9, #0
 c002ca8:	d021      	beq.n	c002cee <HASH_WaitOnFlagUntilTimeout+0x5e>
      }
    }
  }
  else
  {
    while(__HAL_HASH_GET_FLAG(Flag) != RESET)
 c002caa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 c002cac:	ea36 0303 	bics.w	r3, r6, r3
 c002cb0:	d121      	bne.n	c002cf6 <HASH_WaitOnFlagUntilTimeout+0x66>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 c002cb2:	1c6b      	adds	r3, r5, #1
 c002cb4:	d0f9      	beq.n	c002caa <HASH_WaitOnFlagUntilTimeout+0x1a>
      {
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
 c002cb6:	f7fe fc83 	bl	c0015c0 <HAL_GetTick>
 c002cba:	eba0 0008 	sub.w	r0, r0, r8
 c002cbe:	42a8      	cmp	r0, r5
 c002cc0:	d80b      	bhi.n	c002cda <HASH_WaitOnFlagUntilTimeout+0x4a>
 c002cc2:	2d00      	cmp	r5, #0
 c002cc4:	d1f1      	bne.n	c002caa <HASH_WaitOnFlagUntilTimeout+0x1a>
 c002cc6:	e008      	b.n	c002cda <HASH_WaitOnFlagUntilTimeout+0x4a>
      if(Timeout != HAL_MAX_DELAY)
 c002cc8:	1c6a      	adds	r2, r5, #1
 c002cca:	d010      	beq.n	c002cee <HASH_WaitOnFlagUntilTimeout+0x5e>
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
 c002ccc:	f7fe fc78 	bl	c0015c0 <HAL_GetTick>
 c002cd0:	eba0 0008 	sub.w	r0, r0, r8
 c002cd4:	42a8      	cmp	r0, r5
 c002cd6:	d800      	bhi.n	c002cda <HASH_WaitOnFlagUntilTimeout+0x4a>
 c002cd8:	b94d      	cbnz	r5, c002cee <HASH_WaitOnFlagUntilTimeout+0x5e>
        {
          /* Set State to Ready to be able to restart later on */
          hhash->State  = HAL_HASH_STATE_READY;
 c002cda:	2301      	movs	r3, #1
          /* Store time out issue in handle status */
          hhash->Status = HAL_TIMEOUT;
 c002cdc:	2003      	movs	r0, #3
          hhash->State  = HAL_HASH_STATE_READY;
 c002cde:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hhash);
 c002ce2:	2300      	movs	r3, #0
          hhash->Status = HAL_TIMEOUT;
 c002ce4:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
          __HAL_UNLOCK(hhash);
 c002ce8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

          return HAL_TIMEOUT;
 c002cec:	e004      	b.n	c002cf8 <HASH_WaitOnFlagUntilTimeout+0x68>
    while(__HAL_HASH_GET_FLAG(Flag) == RESET)
 c002cee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 c002cf0:	ea36 0303 	bics.w	r3, r6, r3
 c002cf4:	d1e8      	bne.n	c002cc8 <HASH_WaitOnFlagUntilTimeout+0x38>
        }
      }
    }
  }
  return HAL_OK;
 c002cf6:	2000      	movs	r0, #0
}
 c002cf8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c002cfc:	520c0400 	.word	0x520c0400

0c002d00 <HASH_WriteData>:
{
 c002d00:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c002d04:	4605      	mov	r5, r0
 c002d06:	4614      	mov	r4, r2
  for(buffercounter = 0U; buffercounter < Size; buffercounter+=4U)
 c002d08:	2600      	movs	r6, #0
    HASH->DIN = *(uint32_t*)inputaddr;
 c002d0a:	f8df 80a4 	ldr.w	r8, [pc, #164]	; c002db0 <HASH_WriteData+0xb0>
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
 c002d0e:	9101      	str	r1, [sp, #4]
  for(buffercounter = 0U; buffercounter < Size; buffercounter+=4U)
 c002d10:	42a6      	cmp	r6, r4
 c002d12:	d301      	bcc.n	c002d18 <HASH_WriteData+0x18>
  return  HAL_OK;
 c002d14:	2000      	movs	r0, #0
 c002d16:	e046      	b.n	c002da6 <HASH_WriteData+0xa6>
    HASH->DIN = *(uint32_t*)inputaddr;
 c002d18:	9b01      	ldr	r3, [sp, #4]
 c002d1a:	f106 0904 	add.w	r9, r6, #4
 c002d1e:	681b      	ldr	r3, [r3, #0]
 c002d20:	f8c8 3004 	str.w	r3, [r8, #4]
    inputaddr+=4U;
 c002d24:	9b01      	ldr	r3, [sp, #4]
 c002d26:	3304      	adds	r3, #4
 c002d28:	9301      	str	r3, [sp, #4]
    if ((HASH_NBW_PUSHED() == 0U)                     /* If Peripheral FIFO is empty (condition for DINIS to raise) */ \
 c002d2a:	f8d8 3000 	ldr.w	r3, [r8]
 c002d2e:	f413 6f70 	tst.w	r3, #3840	; 0xf00
 c002d32:	d13b      	bne.n	c002dac <HASH_WriteData+0xac>
     && (buffercounter != 0U)                         /* and if at least one word has been written                  */ \
 c002d34:	2e00      	cmp	r6, #0
 c002d36:	d039      	beq.n	c002dac <HASH_WriteData+0xac>
     && ((buffercounter+4U) < Size)                   /* and if the processing is not about to end                  */ \
 c002d38:	454c      	cmp	r4, r9
 c002d3a:	d937      	bls.n	c002dac <HASH_WriteData+0xac>
     && (hhash->SuspendRequest == HAL_HASH_SUSPEND) ) /* and if suspension is requested                             */
 c002d3c:	f895 7036 	ldrb.w	r7, [r5, #54]	; 0x36
 c002d40:	2f01      	cmp	r7, #1
 c002d42:	d133      	bne.n	c002dac <HASH_WriteData+0xac>
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_BUSY, SET, HASH_TIMEOUTVALUE) == HAL_OK)
 c002d44:	463a      	mov	r2, r7
 c002d46:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 c002d4a:	2108      	movs	r1, #8
 c002d4c:	4628      	mov	r0, r5
 c002d4e:	f7ff ff9f 	bl	c002c90 <HASH_WaitOnFlagUntilTimeout>
 c002d52:	4602      	mov	r2, r0
 c002d54:	bb50      	cbnz	r0, c002dac <HASH_WriteData+0xac>
        if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DINIS, RESET, HASH_TIMEOUTVALUE) == HAL_OK)
 c002d56:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 c002d5a:	4639      	mov	r1, r7
 c002d5c:	4628      	mov	r0, r5
 c002d5e:	f7ff ff97 	bl	c002c90 <HASH_WaitOnFlagUntilTimeout>
 c002d62:	bb18      	cbnz	r0, c002dac <HASH_WriteData+0xac>
          if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 c002d64:	f895 302d 	ldrb.w	r3, [r5, #45]	; 0x2d
          hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 c002d68:	f885 0036 	strb.w	r0, [r5, #54]	; 0x36
          if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 c002d6c:	2b02      	cmp	r3, #2
 c002d6e:	d001      	beq.n	c002d74 <HASH_WriteData+0x74>
 c002d70:	2b04      	cmp	r3, #4
 c002d72:	d108      	bne.n	c002d86 <HASH_WriteData+0x86>
            hhash->pHashInBuffPtr =  (uint8_t *)inputaddr;
 c002d74:	9b01      	ldr	r3, [sp, #4]
            hhash->HashInCount    =  Size - (buffercounter + 4U);
 c002d76:	3c04      	subs	r4, #4
 c002d78:	1ba4      	subs	r4, r4, r6
            hhash->pHashInBuffPtr =  (uint8_t *)inputaddr;
 c002d7a:	60eb      	str	r3, [r5, #12]
            hhash->HashInCount    =  Size - (buffercounter + 4U);
 c002d7c:	622c      	str	r4, [r5, #32]
          hhash->State = HAL_HASH_STATE_SUSPENDED;
 c002d7e:	2308      	movs	r3, #8
 c002d80:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
          return HAL_OK;
 c002d84:	e00f      	b.n	c002da6 <HASH_WriteData+0xa6>
          else if ((hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_3))
 c002d86:	2b03      	cmp	r3, #3
 c002d88:	d001      	beq.n	c002d8e <HASH_WriteData+0x8e>
 c002d8a:	2b05      	cmp	r3, #5
 c002d8c:	d105      	bne.n	c002d9a <HASH_WriteData+0x9a>
            hhash->pHashKeyBuffPtr  =  (uint8_t *)inputaddr;
 c002d8e:	9b01      	ldr	r3, [sp, #4]
            hhash->HashKeyCount  =  Size - (buffercounter + 4U);
 c002d90:	3c04      	subs	r4, #4
 c002d92:	1ba4      	subs	r4, r4, r6
            hhash->pHashKeyBuffPtr  =  (uint8_t *)inputaddr;
 c002d94:	616b      	str	r3, [r5, #20]
            hhash->HashKeyCount  =  Size - (buffercounter + 4U);
 c002d96:	62ac      	str	r4, [r5, #40]	; 0x28
 c002d98:	e7f1      	b.n	c002d7e <HASH_WriteData+0x7e>
            hhash->State = HAL_HASH_STATE_READY;
 c002d9a:	2001      	movs	r0, #1
            __HAL_UNLOCK(hhash);
 c002d9c:	2300      	movs	r3, #0
            hhash->State = HAL_HASH_STATE_READY;
 c002d9e:	f885 0035 	strb.w	r0, [r5, #53]	; 0x35
            __HAL_UNLOCK(hhash);
 c002da2:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
}
 c002da6:	b003      	add	sp, #12
 c002da8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  for(buffercounter = 0U; buffercounter < Size; buffercounter+=4U)
 c002dac:	464e      	mov	r6, r9
 c002dae:	e7af      	b.n	c002d10 <HASH_WriteData+0x10>
 c002db0:	520c0400 	.word	0x520c0400

0c002db4 <HAL_HASH_MspInit>:
}
 c002db4:	4770      	bx	lr
	...

0c002db8 <HAL_HASH_Init>:
{
 c002db8:	b538      	push	{r3, r4, r5, lr}
  if(hhash == NULL)
 c002dba:	4604      	mov	r4, r0
 c002dbc:	b340      	cbz	r0, c002e10 <HAL_HASH_Init+0x58>
  if(hhash->State == HAL_HASH_STATE_RESET)
 c002dbe:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 c002dc2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 c002dc6:	b91b      	cbnz	r3, c002dd0 <HAL_HASH_Init+0x18>
    hhash->Lock = HAL_UNLOCKED;
 c002dc8:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
    HAL_HASH_MspInit(hhash);
 c002dcc:	f7ff fff2 	bl	c002db4 <HAL_HASH_MspInit>
  hhash->HashInCount = 0;
 c002dd0:	2000      	movs	r0, #0
  hhash->State = HAL_HASH_STATE_BUSY;
 c002dd2:	2302      	movs	r3, #2
  hhash->Phase = HAL_HASH_PHASE_READY;
 c002dd4:	2101      	movs	r1, #1
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 c002dd6:	4a0f      	ldr	r2, [pc, #60]	; (c002e14 <HAL_HASH_Init+0x5c>)
  hhash->State = HAL_HASH_STATE_BUSY;
 c002dd8:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  hhash->HashBuffSize = 0;
 c002ddc:	61e0      	str	r0, [r4, #28]
  hhash->HashInCount = 0;
 c002dde:	6220      	str	r0, [r4, #32]
  hhash->HashITCounter = 0;
 c002de0:	6260      	str	r0, [r4, #36]	; 0x24
  hhash->NbWordsAlreadyPushed = 0;
 c002de2:	63a0      	str	r0, [r4, #56]	; 0x38
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 c002de4:	6813      	ldr	r3, [r2, #0]
 c002de6:	6825      	ldr	r5, [r4, #0]
 c002de8:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 c002dec:	432b      	orrs	r3, r5
  hhash->DigestCalculationDisable = RESET;
 c002dee:	f884 0037 	strb.w	r0, [r4, #55]	; 0x37
  hhash->Phase = HAL_HASH_PHASE_READY;
 c002df2:	f884 102d 	strb.w	r1, [r4, #45]	; 0x2d
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 c002df6:	f884 0036 	strb.w	r0, [r4, #54]	; 0x36
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 c002dfa:	6013      	str	r3, [r2, #0]
__HAL_HASH_RESET_MDMAT();
 c002dfc:	6813      	ldr	r3, [r2, #0]
 c002dfe:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 c002e02:	6013      	str	r3, [r2, #0]
  hhash->State = HAL_HASH_STATE_READY;
 c002e04:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
  hhash->Status = HAL_OK;
 c002e08:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
  hhash->ErrorCode = HAL_HASH_ERROR_NONE;
 c002e0c:	63e0      	str	r0, [r4, #60]	; 0x3c
}
 c002e0e:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 c002e10:	2001      	movs	r0, #1
 c002e12:	e7fc      	b.n	c002e0e <HAL_HASH_Init+0x56>
 c002e14:	520c0400 	.word	0x520c0400

0c002e18 <HAL_HASH_MspDeInit>:
 c002e18:	4770      	bx	lr

0c002e1a <HAL_HASH_DeInit>:
{
 c002e1a:	b538      	push	{r3, r4, r5, lr}
  if(hhash == NULL)
 c002e1c:	4605      	mov	r5, r0
 c002e1e:	2401      	movs	r4, #1
 c002e20:	b190      	cbz	r0, c002e48 <HAL_HASH_DeInit+0x2e>
  hhash->State = HAL_HASH_STATE_BUSY;
 c002e22:	2302      	movs	r3, #2
  hhash->Phase = HAL_HASH_PHASE_READY;
 c002e24:	f880 402d 	strb.w	r4, [r0, #45]	; 0x2d
  hhash->HashInCount = 0;
 c002e28:	2400      	movs	r4, #0
  hhash->State = HAL_HASH_STATE_BUSY;
 c002e2a:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
  hhash->HashBuffSize = 0;
 c002e2e:	61c4      	str	r4, [r0, #28]
  hhash->HashInCount = 0;
 c002e30:	6204      	str	r4, [r0, #32]
  hhash->DigestCalculationDisable = RESET;
 c002e32:	f880 4037 	strb.w	r4, [r0, #55]	; 0x37
  hhash->HashITCounter = 0;
 c002e36:	6244      	str	r4, [r0, #36]	; 0x24
  HAL_HASH_MspDeInit(hhash);
 c002e38:	f7ff ffee 	bl	c002e18 <HAL_HASH_MspDeInit>
  hhash->State = HAL_HASH_STATE_RESET;
 c002e3c:	f885 4035 	strb.w	r4, [r5, #53]	; 0x35
  hhash->Status = HAL_OK;
 c002e40:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
  hhash->ErrorCode = HAL_HASH_ERROR_NONE;
 c002e44:	63ec      	str	r4, [r5, #60]	; 0x3c
  hhash->Accumulation = 0U;
 c002e46:	642c      	str	r4, [r5, #64]	; 0x40
    return HAL_ERROR;
 c002e48:	4620      	mov	r0, r4
}
 c002e4a:	bd38      	pop	{r3, r4, r5, pc}

0c002e4c <HAL_HASH_ContextSaving>:
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->IMR,HASH_IT_DINI|HASH_IT_DCI);
 c002e4c:	4b0e      	ldr	r3, [pc, #56]	; (c002e88 <HAL_HASH_ContextSaving+0x3c>)
{
 c002e4e:	b530      	push	{r4, r5, lr}
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->IMR,HASH_IT_DINI|HASH_IT_DCI);
 c002e50:	6a1a      	ldr	r2, [r3, #32]
    *(uint32_t*)(mem_ptr) = *(uint32_t*)(csr_ptr);
 c002e52:	480e      	ldr	r0, [pc, #56]	; (c002e8c <HAL_HASH_ContextSaving+0x40>)
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->IMR,HASH_IT_DINI|HASH_IT_DCI);
 c002e54:	f002 0203 	and.w	r2, r2, #3
 c002e58:	600a      	str	r2, [r1, #0]
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->STR,HASH_STR_NBLW);
 c002e5a:	689a      	ldr	r2, [r3, #8]
 c002e5c:	f002 021f 	and.w	r2, r2, #31
 c002e60:	604a      	str	r2, [r1, #4]
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->CR,HASH_CR_DMAE|HASH_CR_DATATYPE|HASH_CR_MODE|HASH_CR_ALGO|HASH_CR_LKEY|HASH_CR_MDMAT);
 c002e62:	681b      	ldr	r3, [r3, #0]
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
 c002e64:	4a0a      	ldr	r2, [pc, #40]	; (c002e90 <HAL_HASH_ContextSaving+0x44>)
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->CR,HASH_CR_DMAE|HASH_CR_DATATYPE|HASH_CR_MODE|HASH_CR_ALGO|HASH_CR_LKEY|HASH_CR_MDMAT);
 c002e66:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 c002e6a:	f423 037a 	bic.w	r3, r3, #16384000	; 0xfa0000
 c002e6e:	f423 435f 	bic.w	r3, r3, #57088	; 0xdf00
 c002e72:	f023 0307 	bic.w	r3, r3, #7
 c002e76:	608b      	str	r3, [r1, #8]
  uint32_t csr_ptr = (uint32_t)HASH->CSR;
 c002e78:	4b06      	ldr	r3, [pc, #24]	; (c002e94 <HAL_HASH_ContextSaving+0x48>)
    *(uint32_t*)(mem_ptr) = *(uint32_t*)(csr_ptr);
 c002e7a:	681d      	ldr	r5, [r3, #0]
 c002e7c:	18cc      	adds	r4, r1, r3
    csr_ptr+=4U;
 c002e7e:	3304      	adds	r3, #4
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
 c002e80:	4293      	cmp	r3, r2
    *(uint32_t*)(mem_ptr) = *(uint32_t*)(csr_ptr);
 c002e82:	5025      	str	r5, [r4, r0]
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
 c002e84:	d1f9      	bne.n	c002e7a <HAL_HASH_ContextSaving+0x2e>
}
 c002e86:	bd30      	pop	{r4, r5, pc}
 c002e88:	520c0400 	.word	0x520c0400
 c002e8c:	adf3fb14 	.word	0xadf3fb14
 c002e90:	520c05d0 	.word	0x520c05d0
 c002e94:	520c04f8 	.word	0x520c04f8

0c002e98 <HAL_HASH_ContextRestoring>:
  WRITE_REG(HASH->IMR, (*(uint32_t*)(mem_ptr)));
 c002e98:	4b0c      	ldr	r3, [pc, #48]	; (c002ecc <HAL_HASH_ContextRestoring+0x34>)
 c002e9a:	680a      	ldr	r2, [r1, #0]
{
 c002e9c:	b510      	push	{r4, lr}
  WRITE_REG(HASH->IMR, (*(uint32_t*)(mem_ptr)));
 c002e9e:	621a      	str	r2, [r3, #32]
  WRITE_REG(HASH->STR, (*(uint32_t*)(mem_ptr)));
 c002ea0:	684a      	ldr	r2, [r1, #4]
    WRITE_REG((*(uint32_t*)(csr_ptr)), (*(uint32_t*)(mem_ptr)));
 c002ea2:	4c0b      	ldr	r4, [pc, #44]	; (c002ed0 <HAL_HASH_ContextRestoring+0x38>)
  WRITE_REG(HASH->STR, (*(uint32_t*)(mem_ptr)));
 c002ea4:	609a      	str	r2, [r3, #8]
  WRITE_REG(HASH->CR, (*(uint32_t*)(mem_ptr)));
 c002ea6:	688a      	ldr	r2, [r1, #8]
  uint32_t csr_ptr = (uint32_t)HASH->CSR;
 c002ea8:	33f8      	adds	r3, #248	; 0xf8
  WRITE_REG(HASH->CR, (*(uint32_t*)(mem_ptr)));
 c002eaa:	f843 2cf8 	str.w	r2, [r3, #-248]
  __HAL_HASH_INIT();
 c002eae:	f853 2cf8 	ldr.w	r2, [r3, #-248]
 c002eb2:	f042 0204 	orr.w	r2, r2, #4
 c002eb6:	f843 2cf8 	str.w	r2, [r3, #-248]
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
 c002eba:	4a06      	ldr	r2, [pc, #24]	; (c002ed4 <HAL_HASH_ContextRestoring+0x3c>)
    WRITE_REG((*(uint32_t*)(csr_ptr)), (*(uint32_t*)(mem_ptr)));
 c002ebc:	18c8      	adds	r0, r1, r3
 c002ebe:	5900      	ldr	r0, [r0, r4]
 c002ec0:	f843 0b04 	str.w	r0, [r3], #4
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
 c002ec4:	4293      	cmp	r3, r2
 c002ec6:	d1f9      	bne.n	c002ebc <HAL_HASH_ContextRestoring+0x24>
}
 c002ec8:	bd10      	pop	{r4, pc}
 c002eca:	bf00      	nop
 c002ecc:	520c0400 	.word	0x520c0400
 c002ed0:	adf3fb14 	.word	0xadf3fb14
 c002ed4:	520c05d0 	.word	0x520c05d0

0c002ed8 <HASH_Start>:
  * @param  Timeout Timeout value.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout, uint32_t Algorithm)
{
 c002ed8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c002eda:	461f      	mov	r7, r3
  uint8_t *pInBuffer_tmp;  /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp; /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c002edc:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
{
 c002ee0:	4604      	mov	r4, r0
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c002ee2:	b2db      	uxtb	r3, r3


  /* Initiate HASH processing in case of start or resumption */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 c002ee4:	2b01      	cmp	r3, #1
 c002ee6:	d001      	beq.n	c002eec <HASH_Start+0x14>
 c002ee8:	2b08      	cmp	r3, #8
 c002eea:	d17b      	bne.n	c002fe4 <HASH_Start+0x10c>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (pOutBuffer == NULL))
 c002eec:	b101      	cbz	r1, c002ef0 <HASH_Start+0x18>
 c002eee:	b927      	cbnz	r7, c002efa <HASH_Start+0x22>
    {
      hhash->State = HAL_HASH_STATE_READY;
 c002ef0:	2501      	movs	r5, #1
 c002ef2:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
  }
  else
  {
    return HAL_BUSY;
  }
}
 c002ef6:	4628      	mov	r0, r5
 c002ef8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_LOCK(hhash);
 c002efa:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 c002efe:	2b01      	cmp	r3, #1
 c002f00:	d070      	beq.n	c002fe4 <HASH_Start+0x10c>
 c002f02:	2501      	movs	r5, #1
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 c002f04:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
    __HAL_LOCK(hhash);
 c002f08:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 c002f0c:	42ab      	cmp	r3, r5
 c002f0e:	d147      	bne.n	c002fa0 <HASH_Start+0xc8>
      hhash->State = HAL_HASH_STATE_BUSY;
 c002f10:	2602      	movs	r6, #2
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 c002f12:	4d36      	ldr	r5, [pc, #216]	; (c002fec <HASH_Start+0x114>)
      hhash->State = HAL_HASH_STATE_BUSY;
 c002f14:	f884 6035 	strb.w	r6, [r4, #53]	; 0x35
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 c002f18:	682b      	ldr	r3, [r5, #0]
 c002f1a:	9807      	ldr	r0, [sp, #28]
 c002f1c:	f423 23a0 	bic.w	r3, r3, #327680	; 0x50000
 c002f20:	f023 03c4 	bic.w	r3, r3, #196	; 0xc4
 c002f24:	f043 0304 	orr.w	r3, r3, #4
 c002f28:	4303      	orrs	r3, r0
 c002f2a:	602b      	str	r3, [r5, #0]
      __HAL_HASH_SET_NBVALIDBITS(Size);
 c002f2c:	68a8      	ldr	r0, [r5, #8]
 c002f2e:	f002 0303 	and.w	r3, r2, #3
 c002f32:	f020 001f 	bic.w	r0, r0, #31
 c002f36:	ea40 03c3 	orr.w	r3, r0, r3, lsl #3
 c002f3a:	60ab      	str	r3, [r5, #8]
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 c002f3c:	f884 602d 	strb.w	r6, [r4, #45]	; 0x2d
    hhash->Status = HASH_WriteData(hhash, pInBuffer_tmp, Size_tmp);
 c002f40:	4620      	mov	r0, r4
 c002f42:	f7ff fedd 	bl	c002d00 <HASH_WriteData>
 c002f46:	4605      	mov	r5, r0
 c002f48:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 c002f4c:	2800      	cmp	r0, #0
 c002f4e:	d1d2      	bne.n	c002ef6 <HASH_Start+0x1e>
    if (hhash->State != HAL_HASH_STATE_SUSPENDED)
 c002f50:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 c002f54:	2b08      	cmp	r3, #8
 c002f56:	d03d      	beq.n	c002fd4 <HASH_Start+0xfc>
      __HAL_HASH_START_DIGEST();
 c002f58:	4e24      	ldr	r6, [pc, #144]	; (c002fec <HASH_Start+0x114>)
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 c002f5a:	4602      	mov	r2, r0
      __HAL_HASH_START_DIGEST();
 c002f5c:	68b3      	ldr	r3, [r6, #8]
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 c002f5e:	2102      	movs	r1, #2
      __HAL_HASH_START_DIGEST();
 c002f60:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 c002f64:	60b3      	str	r3, [r6, #8]
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 c002f66:	9b06      	ldr	r3, [sp, #24]
 c002f68:	4620      	mov	r0, r4
 c002f6a:	f7ff fe91 	bl	c002c90 <HASH_WaitOnFlagUntilTimeout>
 c002f6e:	2800      	cmp	r0, #0
 c002f70:	d13a      	bne.n	c002fe8 <HASH_Start+0x110>
      HASH_GetDigest(pOutBuffer, HASH_DIGEST_LENGTH());
 c002f72:	6832      	ldr	r2, [r6, #0]
 c002f74:	4b1e      	ldr	r3, [pc, #120]	; (c002ff0 <HASH_Start+0x118>)
 c002f76:	421a      	tst	r2, r3
 c002f78:	d030      	beq.n	c002fdc <HASH_Start+0x104>
 c002f7a:	6832      	ldr	r2, [r6, #0]
 c002f7c:	401a      	ands	r2, r3
 c002f7e:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 c002f82:	d02d      	beq.n	c002fe0 <HASH_Start+0x108>
 c002f84:	6832      	ldr	r2, [r6, #0]
 c002f86:	4393      	bics	r3, r2
 c002f88:	bf0c      	ite	eq
 c002f8a:	2120      	moveq	r1, #32
 c002f8c:	2110      	movne	r1, #16
 c002f8e:	4638      	mov	r0, r7
 c002f90:	f7ff fe1c 	bl	c002bcc <HASH_GetDigest>
      hhash->State = HAL_HASH_STATE_READY;
 c002f94:	2301      	movs	r3, #1
 c002f96:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      hhash->Phase = HAL_HASH_PHASE_READY;
 c002f9a:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
 c002f9e:	e019      	b.n	c002fd4 <HASH_Start+0xfc>
    else if (hhash->Phase == HAL_HASH_PHASE_PROCESS)
 c002fa0:	2b02      	cmp	r3, #2
 c002fa2:	d115      	bne.n	c002fd0 <HASH_Start+0xf8>
      if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 c002fa4:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 c002fa8:	2b08      	cmp	r3, #8
        __HAL_HASH_SET_NBVALIDBITS(Size);
 c002faa:	bf1d      	ittte	ne
 c002fac:	4d0f      	ldrne	r5, [pc, #60]	; (c002fec <HASH_Start+0x114>)
 c002fae:	f002 0303 	andne.w	r3, r2, #3
 c002fb2:	68a8      	ldrne	r0, [r5, #8]
        Size_tmp = hhash->HashInCount;
 c002fb4:	6a22      	ldreq	r2, [r4, #32]
        __HAL_HASH_SET_NBVALIDBITS(Size);
 c002fb6:	bf1e      	ittt	ne
 c002fb8:	f020 001f 	bicne.w	r0, r0, #31
 c002fbc:	ea40 03c3 	orrne.w	r3, r0, r3, lsl #3
 c002fc0:	60ab      	strne	r3, [r5, #8]
      hhash->State = HAL_HASH_STATE_BUSY;
 c002fc2:	f04f 0302 	mov.w	r3, #2
        pInBuffer_tmp = hhash->pHashInBuffPtr;
 c002fc6:	bf08      	it	eq
 c002fc8:	68e1      	ldreq	r1, [r4, #12]
      hhash->State = HAL_HASH_STATE_BUSY;
 c002fca:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 c002fce:	e7b7      	b.n	c002f40 <HASH_Start+0x68>
      hhash->State = HAL_HASH_STATE_READY;
 c002fd0:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
    __HAL_UNLOCK(hhash);
 c002fd4:	2300      	movs	r3, #0
 c002fd6:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 c002fda:	e78c      	b.n	c002ef6 <HASH_Start+0x1e>
      HASH_GetDigest(pOutBuffer, HASH_DIGEST_LENGTH());
 c002fdc:	2114      	movs	r1, #20
 c002fde:	e7d6      	b.n	c002f8e <HASH_Start+0xb6>
 c002fe0:	211c      	movs	r1, #28
 c002fe2:	e7d4      	b.n	c002f8e <HASH_Start+0xb6>
    return HAL_BUSY;
 c002fe4:	2502      	movs	r5, #2
 c002fe6:	e786      	b.n	c002ef6 <HASH_Start+0x1e>
        return HAL_TIMEOUT;
 c002fe8:	2503      	movs	r5, #3
 c002fea:	e784      	b.n	c002ef6 <HASH_Start+0x1e>
 c002fec:	520c0400 	.word	0x520c0400
 c002ff0:	00040080 	.word	0x00040080

0c002ff4 <HASH_Accumulate>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Accumulate(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
 c002ff4:	b538      	push	{r3, r4, r5, lr}
  uint8_t *pInBuffer_tmp;   /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp;  /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c002ff6:	f890 5035 	ldrb.w	r5, [r0, #53]	; 0x35
{
 c002ffa:	4604      	mov	r4, r0

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
 c002ffc:	0790      	lsls	r0, r2, #30
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c002ffe:	b2ed      	uxtb	r5, r5
  if ((Size % 4U) != 0U)
 c003000:	d13d      	bne.n	c00307e <HASH_Accumulate+0x8a>
  {
    return  HAL_ERROR;
  }

  /* Initiate HASH processing in case of start or resumption */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 c003002:	2d01      	cmp	r5, #1
 c003004:	d001      	beq.n	c00300a <HASH_Accumulate+0x16>
 c003006:	2d08      	cmp	r5, #8
 c003008:	d13b      	bne.n	c003082 <HASH_Accumulate+0x8e>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (Size == 0U))
 c00300a:	b101      	cbz	r1, c00300e <HASH_Accumulate+0x1a>
 c00300c:	b91a      	cbnz	r2, c003016 <HASH_Accumulate+0x22>
    {
      hhash->State = HAL_HASH_STATE_READY;
 c00300e:	2001      	movs	r0, #1
 c003010:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
  {
    return HAL_BUSY;
  }


}
 c003014:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_LOCK(hhash);
 c003016:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 c00301a:	2801      	cmp	r0, #1
 c00301c:	d031      	beq.n	c003082 <HASH_Accumulate+0x8e>
 c00301e:	2001      	movs	r0, #1
 c003020:	2502      	movs	r5, #2
 c003022:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 c003026:	f894 0035 	ldrb.w	r0, [r4, #53]	; 0x35
      hhash->State = HAL_HASH_STATE_BUSY;
 c00302a:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 c00302e:	2808      	cmp	r0, #8
 c003030:	d113      	bne.n	c00305a <HASH_Accumulate+0x66>
      pInBuffer_tmp = hhash->pHashInBuffPtr;  /* pInBuffer_tmp is set to the input data address */
 c003032:	68e1      	ldr	r1, [r4, #12]
      Size_tmp = hhash->HashInCount;          /* Size_tmp contains the input data size in bytes */
 c003034:	6a22      	ldr	r2, [r4, #32]
    hhash->Status = HASH_WriteData(hhash, pInBuffer_tmp, Size_tmp);
 c003036:	4620      	mov	r0, r4
 c003038:	f7ff fe62 	bl	c002d00 <HASH_WriteData>
 c00303c:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 c003040:	2800      	cmp	r0, #0
 c003042:	d1e7      	bne.n	c003014 <HASH_Accumulate+0x20>
    if (hhash->State != HAL_HASH_STATE_SUSPENDED)
 c003044:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 c003048:	2b08      	cmp	r3, #8
      hhash->State = HAL_HASH_STATE_READY;
 c00304a:	bf1c      	itt	ne
 c00304c:	2301      	movne	r3, #1
 c00304e:	f884 3035 	strbne.w	r3, [r4, #53]	; 0x35
    __HAL_UNLOCK(hhash);
 c003052:	2300      	movs	r3, #0
 c003054:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 c003058:	e7dc      	b.n	c003014 <HASH_Accumulate+0x20>
      if(hhash->Phase == HAL_HASH_PHASE_READY)
 c00305a:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
 c00305e:	2801      	cmp	r0, #1
 c003060:	d109      	bne.n	c003076 <HASH_Accumulate+0x82>
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 c003062:	4d09      	ldr	r5, [pc, #36]	; (c003088 <HASH_Accumulate+0x94>)
 c003064:	6828      	ldr	r0, [r5, #0]
 c003066:	f420 20a0 	bic.w	r0, r0, #327680	; 0x50000
 c00306a:	f020 00c4 	bic.w	r0, r0, #196	; 0xc4
 c00306e:	f040 0004 	orr.w	r0, r0, #4
 c003072:	4303      	orrs	r3, r0
 c003074:	602b      	str	r3, [r5, #0]
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 c003076:	2302      	movs	r3, #2
 c003078:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
 c00307c:	e7db      	b.n	c003036 <HASH_Accumulate+0x42>
    return  HAL_ERROR;
 c00307e:	2001      	movs	r0, #1
 c003080:	e7c8      	b.n	c003014 <HASH_Accumulate+0x20>
    return HAL_BUSY;
 c003082:	2002      	movs	r0, #2
 c003084:	e7c6      	b.n	c003014 <HASH_Accumulate+0x20>
 c003086:	bf00      	nop
 c003088:	520c0400 	.word	0x520c0400

0c00308c <HAL_HASHEx_SHA224_Start>:
  * @param  pOutBuffer pointer to the computed digest. Digest size is 28 bytes.
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA224_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 c00308c:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA224);
 c00308e:	f44f 2480 	mov.w	r4, #262144	; 0x40000
 c003092:	9401      	str	r4, [sp, #4]
 c003094:	9c04      	ldr	r4, [sp, #16]
 c003096:	9400      	str	r4, [sp, #0]
 c003098:	f7ff ff1e 	bl	c002ed8 <HASH_Start>
}
 c00309c:	b002      	add	sp, #8
 c00309e:	bd10      	pop	{r4, pc}

0c0030a0 <HAL_HASHEx_SHA224_Accmlt>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA224_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate(hhash, pInBuffer, Size,HASH_ALGOSELECTION_SHA224);
 c0030a0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 c0030a4:	f7ff bfa6 	b.w	c002ff4 <HASH_Accumulate>

0c0030a8 <HAL_HASHEx_SHA224_Accmlt_End>:
 c0030a8:	f7ff bff0 	b.w	c00308c <HAL_HASHEx_SHA224_Start>

0c0030ac <HAL_HASHEx_SHA256_Start>:
  * @param  pOutBuffer pointer to the computed digest. Digest size is 32 bytes.
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA256_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 c0030ac:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA256);
 c0030ae:	4c04      	ldr	r4, [pc, #16]	; (c0030c0 <HAL_HASHEx_SHA256_Start+0x14>)
 c0030b0:	9401      	str	r4, [sp, #4]
 c0030b2:	9c04      	ldr	r4, [sp, #16]
 c0030b4:	9400      	str	r4, [sp, #0]
 c0030b6:	f7ff ff0f 	bl	c002ed8 <HASH_Start>
}
 c0030ba:	b002      	add	sp, #8
 c0030bc:	bd10      	pop	{r4, pc}
 c0030be:	bf00      	nop
 c0030c0:	00040080 	.word	0x00040080

0c0030c4 <HAL_HASHEx_SHA256_Accmlt>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA256_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate(hhash, pInBuffer, Size,HASH_ALGOSELECTION_SHA256);
 c0030c4:	4b01      	ldr	r3, [pc, #4]	; (c0030cc <HAL_HASHEx_SHA256_Accmlt+0x8>)
 c0030c6:	f7ff bf95 	b.w	c002ff4 <HASH_Accumulate>
 c0030ca:	bf00      	nop
 c0030cc:	00040080 	.word	0x00040080

0c0030d0 <HAL_HASHEx_SHA256_Accmlt_End>:
 c0030d0:	f7ff bfec 	b.w	c0030ac <HAL_HASHEx_SHA256_Start>

0c0030d4 <HAL_PWR_EnableBkUpAccess>:
  *        back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 c0030d4:	4a02      	ldr	r2, [pc, #8]	; (c0030e0 <HAL_PWR_EnableBkUpAccess+0xc>)
 c0030d6:	6813      	ldr	r3, [r2, #0]
 c0030d8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 c0030dc:	6013      	str	r3, [r2, #0]
}
 c0030de:	4770      	bx	lr
 c0030e0:	50007000 	.word	0x50007000

0c0030e4 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE0, PWR_REGULATOR_VOLTAGE_SCALE1 or PWR_REGULATOR_VOLTAGE_SCALE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return (PWR->CR1 & PWR_CR1_VOS);
 c0030e4:	4b02      	ldr	r3, [pc, #8]	; (c0030f0 <HAL_PWREx_GetVoltageRange+0xc>)
 c0030e6:	6818      	ldr	r0, [r3, #0]
}
 c0030e8:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 c0030ec:	4770      	bx	lr
 c0030ee:	bf00      	nop
 c0030f0:	50007000 	.word	0x50007000

0c0030f4 <HAL_PWREx_EnableVddIO2>:
  * @note  Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply is present.
  * @retval None
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_IOSV);
 c0030f4:	4a02      	ldr	r2, [pc, #8]	; (c003100 <HAL_PWREx_EnableVddIO2+0xc>)
 c0030f6:	6853      	ldr	r3, [r2, #4]
 c0030f8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 c0030fc:	6053      	str	r3, [r2, #4]
}
 c0030fe:	4770      	bx	lr
 c003100:	50007000 	.word	0x50007000

0c003104 <HAL_PWREx_ConfigSRAM2ContentRetention>:
{
  /* Check the parameters */
  assert_param(IS_PWR_SRAM2CONTENT_RETENTION(SRAM2ContentRetention));

  /* Set RRS bits */
  MODIFY_REG(PWR->CR3, PWR_CR3_RRS, SRAM2ContentRetention);
 c003104:	4a03      	ldr	r2, [pc, #12]	; (c003114 <HAL_PWREx_ConfigSRAM2ContentRetention+0x10>)
 c003106:	6893      	ldr	r3, [r2, #8]
 c003108:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 c00310c:	4318      	orrs	r0, r3
 c00310e:	6090      	str	r0, [r2, #8]

  return HAL_OK;
}
 c003110:	2000      	movs	r0, #0
 c003112:	4770      	bx	lr
 c003114:	50007000 	.word	0x50007000

0c003118 <HAL_PWREx_EnableSRAM2ContentRetention>:
  *         Standby mode and its content is kept.
  * @retval None
  */
void HAL_PWREx_EnableSRAM2ContentRetention(void)
{
  (void) HAL_PWREx_ConfigSRAM2ContentRetention(PWR_FULL_SRAM2_RETENTION);
 c003118:	f44f 7080 	mov.w	r0, #256	; 0x100
 c00311c:	f7ff bff2 	b.w	c003104 <HAL_PWREx_ConfigSRAM2ContentRetention>

0c003120 <HAL_PWREx_SMPS_GetEffectiveMode>:
uint32_t HAL_PWREx_SMPS_GetEffectiveMode(void)
{
  uint32_t mode;
  uint32_t pwr_sr1;

  pwr_sr1 = READ_REG(PWR->SR1);
 c003120:	4b06      	ldr	r3, [pc, #24]	; (c00313c <HAL_PWREx_SMPS_GetEffectiveMode+0x1c>)
 c003122:	691b      	ldr	r3, [r3, #16]
  if (READ_BIT(pwr_sr1, PWR_SR1_SMPSBYPRDY) != 0U)
 c003124:	04da      	lsls	r2, r3, #19
 c003126:	d406      	bmi.n	c003136 <HAL_PWREx_SMPS_GetEffectiveMode+0x16>
  {
    mode = PWR_SMPS_BYPASS;
  }
  else if (READ_BIT(pwr_sr1, PWR_SR1_SMPSHPRDY) == 0U)
 c003128:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  {
    mode = PWR_SMPS_LOW_POWER;
  }
  else
  {
    mode = PWR_SMPS_HIGH_POWER;
 c00312c:	bf0c      	ite	eq
 c00312e:	f44f 4000 	moveq.w	r0, #32768	; 0x8000
 c003132:	2000      	movne	r0, #0
 c003134:	4770      	bx	lr
    mode = PWR_SMPS_BYPASS;
 c003136:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  }

  return mode;
}
 c00313a:	4770      	bx	lr
 c00313c:	50007000 	.word	0x50007000

0c003140 <HAL_PWREx_ControlVoltageScaling>:
  uint32_t vos_old = READ_BIT(PWR->CR1, PWR_CR1_VOS);
 c003140:	4917      	ldr	r1, [pc, #92]	; (c0031a0 <HAL_PWREx_ControlVoltageScaling+0x60>)
{
 c003142:	b538      	push	{r3, r4, r5, lr}
 c003144:	4605      	mov	r5, r0
  uint32_t vos_old = READ_BIT(PWR->CR1, PWR_CR1_VOS);
 c003146:	680c      	ldr	r4, [r1, #0]
  if (HAL_PWREx_SMPS_GetEffectiveMode() == PWR_SMPS_LOW_POWER)
 c003148:	f7ff ffea 	bl	c003120 <HAL_PWREx_SMPS_GetEffectiveMode>
 c00314c:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 c003150:	d022      	beq.n	c003198 <HAL_PWREx_ControlVoltageScaling+0x58>
  if (READ_BIT(PWR->CR4, PWR_CR4_SMPSLPEN) == PWR_CR4_SMPSLPEN)
 c003152:	68cb      	ldr	r3, [r1, #12]
 c003154:	041b      	lsls	r3, r3, #16
 c003156:	d41f      	bmi.n	c003198 <HAL_PWREx_ControlVoltageScaling+0x58>
  uint32_t vos_old = READ_BIT(PWR->CR1, PWR_CR1_VOS);
 c003158:	f404 64c0 	and.w	r4, r4, #1536	; 0x600
  if (vos_old == VoltageScaling)
 c00315c:	42ac      	cmp	r4, r5
 c00315e:	d017      	beq.n	c003190 <HAL_PWREx_ControlVoltageScaling+0x50>
  MODIFY_REG(PWR->CR1, PWR_CR1_VOS, VoltageScaling);
 c003160:	6808      	ldr	r0, [r1, #0]
  wait_loop_index = ((PWR_VOSF_SETTING_DELAY_VALUE * (SystemCoreClock / 100000U)) / 10U) + 1U;
 c003162:	4b10      	ldr	r3, [pc, #64]	; (c0031a4 <HAL_PWREx_ControlVoltageScaling+0x64>)
  MODIFY_REG(PWR->CR1, PWR_CR1_VOS, VoltageScaling);
 c003164:	f420 60c0 	bic.w	r0, r0, #1536	; 0x600
 c003168:	4328      	orrs	r0, r5
 c00316a:	6008      	str	r0, [r1, #0]
  wait_loop_index = ((PWR_VOSF_SETTING_DELAY_VALUE * (SystemCoreClock / 100000U)) / 10U) + 1U;
 c00316c:	681b      	ldr	r3, [r3, #0]
 c00316e:	4a0e      	ldr	r2, [pc, #56]	; (c0031a8 <HAL_PWREx_ControlVoltageScaling+0x68>)
 c003170:	fbb3 f2f2 	udiv	r2, r3, r2
 c003174:	2332      	movs	r3, #50	; 0x32
 c003176:	4353      	muls	r3, r2
 c003178:	220a      	movs	r2, #10
 c00317a:	fbb3 f3f2 	udiv	r3, r3, r2
 c00317e:	460a      	mov	r2, r1
 c003180:	3301      	adds	r3, #1
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 c003182:	6948      	ldr	r0, [r1, #20]
 c003184:	0540      	lsls	r0, r0, #21
 c003186:	d500      	bpl.n	c00318a <HAL_PWREx_ControlVoltageScaling+0x4a>
 c003188:	b923      	cbnz	r3, c003194 <HAL_PWREx_ControlVoltageScaling+0x54>
  if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 c00318a:	6953      	ldr	r3, [r2, #20]
 c00318c:	055b      	lsls	r3, r3, #21
 c00318e:	d405      	bmi.n	c00319c <HAL_PWREx_ControlVoltageScaling+0x5c>
  return HAL_OK;
 c003190:	2000      	movs	r0, #0
}
 c003192:	bd38      	pop	{r3, r4, r5, pc}
    wait_loop_index--;
 c003194:	3b01      	subs	r3, #1
 c003196:	e7f4      	b.n	c003182 <HAL_PWREx_ControlVoltageScaling+0x42>
    return HAL_ERROR;
 c003198:	2001      	movs	r0, #1
 c00319a:	e7fa      	b.n	c003192 <HAL_PWREx_ControlVoltageScaling+0x52>
    return HAL_TIMEOUT;
 c00319c:	2003      	movs	r0, #3
 c00319e:	e7f8      	b.n	c003192 <HAL_PWREx_ControlVoltageScaling+0x52>
 c0031a0:	50007000 	.word	0x50007000
 c0031a4:	30030008 	.word	0x30030008
 c0031a8:	000186a0 	.word	0x000186a0

0c0031ac <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 c0031ac:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  uint32_t vos;

  if (__HAL_RCC_PWR_IS_CLK_ENABLED())
 c0031ae:	4c1d      	ldr	r4, [pc, #116]	; (c003224 <RCC_SetFlashLatencyFromMSIRange+0x78>)
{
 c0031b0:	4605      	mov	r5, r0
  if (__HAL_RCC_PWR_IS_CLK_ENABLED())
 c0031b2:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c0031b4:	00da      	lsls	r2, r3, #3
 c0031b6:	d518      	bpl.n	c0031ea <RCC_SetFlashLatencyFromMSIRange+0x3e>
  {
    vos = HAL_PWREx_GetVoltageRange();
 c0031b8:	f7ff ff94 	bl	c0030e4 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }

  if ((vos == PWR_REGULATOR_VOLTAGE_SCALE0) || (vos == PWR_REGULATOR_VOLTAGE_SCALE1))
 c0031bc:	f430 7000 	bics.w	r0, r0, #512	; 0x200
 c0031c0:	d123      	bne.n	c00320a <RCC_SetFlashLatencyFromMSIRange+0x5e>
  {
    if (msirange > RCC_MSIRANGE_8)
 c0031c2:	2d80      	cmp	r5, #128	; 0x80
 c0031c4:	d903      	bls.n	c0031ce <RCC_SetFlashLatencyFromMSIRange+0x22>
    {
      /* MSI > 16Mhz */
      if (msirange > RCC_MSIRANGE_10)
 c0031c6:	2da0      	cmp	r5, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 c0031c8:	bf8c      	ite	hi
 c0031ca:	2002      	movhi	r0, #2
 c0031cc:	2001      	movls	r0, #1
        /* MSI < 8Mhz default FLASH_LATENCY_0 0WS */
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 c0031ce:	4a16      	ldr	r2, [pc, #88]	; (c003228 <RCC_SetFlashLatencyFromMSIRange+0x7c>)
 c0031d0:	6813      	ldr	r3, [r2, #0]
 c0031d2:	f023 030f 	bic.w	r3, r3, #15
 c0031d6:	4303      	orrs	r3, r0
 c0031d8:	6013      	str	r3, [r2, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if ((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 c0031da:	6813      	ldr	r3, [r2, #0]
 c0031dc:	f003 030f 	and.w	r3, r3, #15
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 c0031e0:	1a18      	subs	r0, r3, r0
 c0031e2:	bf18      	it	ne
 c0031e4:	2001      	movne	r0, #1
 c0031e6:	b003      	add	sp, #12
 c0031e8:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 c0031ea:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c0031ec:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 c0031f0:	65a3      	str	r3, [r4, #88]	; 0x58
 c0031f2:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c0031f4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c0031f8:	9301      	str	r3, [sp, #4]
 c0031fa:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 c0031fc:	f7ff ff72 	bl	c0030e4 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 c003200:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c003202:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 c003206:	65a3      	str	r3, [r4, #88]	; 0x58
 c003208:	e7d8      	b.n	c0031bc <RCC_SetFlashLatencyFromMSIRange+0x10>
    if (msirange > RCC_MSIRANGE_8)
 c00320a:	2d80      	cmp	r5, #128	; 0x80
 c00320c:	d805      	bhi.n	c00321a <RCC_SetFlashLatencyFromMSIRange+0x6e>
      if (msirange == RCC_MSIRANGE_8)
 c00320e:	d006      	beq.n	c00321e <RCC_SetFlashLatencyFromMSIRange+0x72>
      else if (msirange == RCC_MSIRANGE_7)
 c003210:	f1a5 0370 	sub.w	r3, r5, #112	; 0x70
 c003214:	4258      	negs	r0, r3
 c003216:	4158      	adcs	r0, r3
 c003218:	e7d9      	b.n	c0031ce <RCC_SetFlashLatencyFromMSIRange+0x22>
      latency = FLASH_LATENCY_3; /* 3WS */
 c00321a:	2003      	movs	r0, #3
 c00321c:	e7d7      	b.n	c0031ce <RCC_SetFlashLatencyFromMSIRange+0x22>
        latency = FLASH_LATENCY_2; /* 2WS */
 c00321e:	2002      	movs	r0, #2
 c003220:	e7d5      	b.n	c0031ce <RCC_SetFlashLatencyFromMSIRange+0x22>
 c003222:	bf00      	nop
 c003224:	50021000 	.word	0x50021000
 c003228:	50022000 	.word	0x50022000

0c00322c <HAL_RCC_GetSysClockFreq>:
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 c00322c:	4a24      	ldr	r2, [pc, #144]	; (c0032c0 <HAL_RCC_GetSysClockFreq+0x94>)
 c00322e:	6893      	ldr	r3, [r2, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 c003230:	68d1      	ldr	r1, [r2, #12]
  if ((sysclk_source == RCC_CFGR_SWS_MSI) ||
 c003232:	f013 030c 	ands.w	r3, r3, #12
 c003236:	d005      	beq.n	c003244 <HAL_RCC_GetSysClockFreq+0x18>
 c003238:	2b0c      	cmp	r3, #12
 c00323a:	d116      	bne.n	c00326a <HAL_RCC_GetSysClockFreq+0x3e>
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 c00323c:	f001 0103 	and.w	r1, r1, #3
      ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 c003240:	2901      	cmp	r1, #1
 c003242:	d119      	bne.n	c003278 <HAL_RCC_GetSysClockFreq+0x4c>
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 c003244:	6811      	ldr	r1, [r2, #0]
 c003246:	0709      	lsls	r1, r1, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 c003248:	bf54      	ite	pl
 c00324a:	f8d2 2094 	ldrpl.w	r2, [r2, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 c00324e:	6812      	ldrmi	r2, [r2, #0]
    msirange = MSIRangeTable[msirange];
 c003250:	491c      	ldr	r1, [pc, #112]	; (c0032c4 <HAL_RCC_GetSysClockFreq+0x98>)
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 c003252:	bf54      	ite	pl
 c003254:	f3c2 2203 	ubfxpl	r2, r2, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 c003258:	f3c2 1203 	ubfxmi	r2, r2, #4, #4
    msirange = MSIRangeTable[msirange];
 c00325c:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
    if (sysclk_source == RCC_CFGR_SWS_MSI)
 c003260:	b113      	cbz	r3, c003268 <HAL_RCC_GetSysClockFreq+0x3c>
  if (sysclk_source == RCC_CFGR_SWS_PLL)
 c003262:	2b0c      	cmp	r3, #12
 c003264:	d009      	beq.n	c00327a <HAL_RCC_GetSysClockFreq+0x4e>
 c003266:	2000      	movs	r0, #0
}
 c003268:	4770      	bx	lr
  else if (sysclk_source == RCC_CFGR_SWS_HSI)
 c00326a:	2b04      	cmp	r3, #4
 c00326c:	d026      	beq.n	c0032bc <HAL_RCC_GetSysClockFreq+0x90>
  else if (sysclk_source == RCC_CFGR_SWS_HSE)
 c00326e:	2b08      	cmp	r3, #8
 c003270:	4815      	ldr	r0, [pc, #84]	; (c0032c8 <HAL_RCC_GetSysClockFreq+0x9c>)
 c003272:	bf18      	it	ne
 c003274:	2000      	movne	r0, #0
 c003276:	4770      	bx	lr
  uint32_t msirange = 0U, sysclockfreq = 0U;
 c003278:	2000      	movs	r0, #0
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c00327a:	4a11      	ldr	r2, [pc, #68]	; (c0032c0 <HAL_RCC_GetSysClockFreq+0x94>)
 c00327c:	68d1      	ldr	r1, [r2, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 c00327e:	68d3      	ldr	r3, [r2, #12]
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c003280:	f001 0103 	and.w	r1, r1, #3
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 c003284:	f3c3 1303 	ubfx	r3, r3, #4, #4
    switch (pllsource)
 c003288:	2902      	cmp	r1, #2
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 c00328a:	f103 0301 	add.w	r3, r3, #1
    switch (pllsource)
 c00328e:	d005      	beq.n	c00329c <HAL_RCC_GetSysClockFreq+0x70>
 c003290:	2903      	cmp	r1, #3
 c003292:	d003      	beq.n	c00329c <HAL_RCC_GetSysClockFreq+0x70>
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c003294:	68d2      	ldr	r2, [r2, #12]
 c003296:	f3c2 2206 	ubfx	r2, r2, #8, #7
 c00329a:	e003      	b.n	c0032a4 <HAL_RCC_GetSysClockFreq+0x78>
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c00329c:	68d2      	ldr	r2, [r2, #12]
 c00329e:	480a      	ldr	r0, [pc, #40]	; (c0032c8 <HAL_RCC_GetSysClockFreq+0x9c>)
 c0032a0:	f3c2 2206 	ubfx	r2, r2, #8, #7
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c0032a4:	fbb0 f0f3 	udiv	r0, r0, r3
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 c0032a8:	4b05      	ldr	r3, [pc, #20]	; (c0032c0 <HAL_RCC_GetSysClockFreq+0x94>)
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c0032aa:	4350      	muls	r0, r2
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 c0032ac:	68db      	ldr	r3, [r3, #12]
 c0032ae:	f3c3 6341 	ubfx	r3, r3, #25, #2
 c0032b2:	3301      	adds	r3, #1
 c0032b4:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco / pllr;
 c0032b6:	fbb0 f0f3 	udiv	r0, r0, r3
 c0032ba:	4770      	bx	lr
 c0032bc:	4802      	ldr	r0, [pc, #8]	; (c0032c8 <HAL_RCC_GetSysClockFreq+0x9c>)
 c0032be:	4770      	bx	lr
 c0032c0:	50021000 	.word	0x50021000
 c0032c4:	0c00a098 	.word	0x0c00a098
 c0032c8:	00f42400 	.word	0x00f42400

0c0032cc <HAL_RCC_OscConfig>:
{
 c0032cc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  if (RCC_OscInitStruct == NULL)
 c0032d0:	4604      	mov	r4, r0
 c0032d2:	b908      	cbnz	r0, c0032d8 <HAL_RCC_OscConfig+0xc>
        return HAL_ERROR;
 c0032d4:	2001      	movs	r0, #1
 c0032d6:	e047      	b.n	c003368 <HAL_RCC_OscConfig+0x9c>
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 c0032d8:	4b9e      	ldr	r3, [pc, #632]	; (c003554 <HAL_RCC_OscConfig+0x288>)
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 c0032da:	6802      	ldr	r2, [r0, #0]
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 c0032dc:	689e      	ldr	r6, [r3, #8]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 c0032de:	68df      	ldr	r7, [r3, #12]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 c0032e0:	06d2      	lsls	r2, r2, #27
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 c0032e2:	f006 060c 	and.w	r6, r6, #12
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 c0032e6:	f007 0703 	and.w	r7, r7, #3
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 c0032ea:	d576      	bpl.n	c0033da <HAL_RCC_OscConfig+0x10e>
    if ((sysclk_source == RCC_CFGR_SWS_MSI) ||
 c0032ec:	b11e      	cbz	r6, c0032f6 <HAL_RCC_OscConfig+0x2a>
 c0032ee:	2e0c      	cmp	r6, #12
 c0032f0:	d154      	bne.n	c00339c <HAL_RCC_OscConfig+0xd0>
        ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_MSI)))
 c0032f2:	2f01      	cmp	r7, #1
 c0032f4:	d152      	bne.n	c00339c <HAL_RCC_OscConfig+0xd0>
      if ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 c0032f6:	681b      	ldr	r3, [r3, #0]
 c0032f8:	079b      	lsls	r3, r3, #30
 c0032fa:	d502      	bpl.n	c003302 <HAL_RCC_OscConfig+0x36>
 c0032fc:	69e3      	ldr	r3, [r4, #28]
 c0032fe:	2b00      	cmp	r3, #0
 c003300:	d0e8      	beq.n	c0032d4 <HAL_RCC_OscConfig+0x8>
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 c003302:	4b94      	ldr	r3, [pc, #592]	; (c003554 <HAL_RCC_OscConfig+0x288>)
 c003304:	6a60      	ldr	r0, [r4, #36]	; 0x24
 c003306:	681a      	ldr	r2, [r3, #0]
 c003308:	0715      	lsls	r5, r2, #28
 c00330a:	bf56      	itet	pl
 c00330c:	f8d3 2094 	ldrpl.w	r2, [r3, #148]	; 0x94
 c003310:	681a      	ldrmi	r2, [r3, #0]
 c003312:	0912      	lsrpl	r2, r2, #4
 c003314:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 c003318:	4290      	cmp	r0, r2
 c00331a:	d928      	bls.n	c00336e <HAL_RCC_OscConfig+0xa2>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 c00331c:	f7ff ff46 	bl	c0031ac <RCC_SetFlashLatencyFromMSIRange>
 c003320:	2800      	cmp	r0, #0
 c003322:	d1d7      	bne.n	c0032d4 <HAL_RCC_OscConfig+0x8>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 c003324:	4b8b      	ldr	r3, [pc, #556]	; (c003554 <HAL_RCC_OscConfig+0x288>)
 c003326:	681a      	ldr	r2, [r3, #0]
 c003328:	f042 0208 	orr.w	r2, r2, #8
 c00332c:	601a      	str	r2, [r3, #0]
 c00332e:	681a      	ldr	r2, [r3, #0]
 c003330:	6a61      	ldr	r1, [r4, #36]	; 0x24
 c003332:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 c003336:	430a      	orrs	r2, r1
 c003338:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 c00333a:	685a      	ldr	r2, [r3, #4]
 c00333c:	6a21      	ldr	r1, [r4, #32]
 c00333e:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 c003342:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 c003346:	605a      	str	r2, [r3, #4]
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 c003348:	f7ff ff70 	bl	c00322c <HAL_RCC_GetSysClockFreq>
 c00334c:	4b81      	ldr	r3, [pc, #516]	; (c003554 <HAL_RCC_OscConfig+0x288>)
 c00334e:	4a82      	ldr	r2, [pc, #520]	; (c003558 <HAL_RCC_OscConfig+0x28c>)
 c003350:	689b      	ldr	r3, [r3, #8]
 c003352:	f3c3 1303 	ubfx	r3, r3, #4, #4
 c003356:	5cd3      	ldrb	r3, [r2, r3]
 c003358:	40d8      	lsrs	r0, r3
 c00335a:	4b80      	ldr	r3, [pc, #512]	; (c00355c <HAL_RCC_OscConfig+0x290>)
 c00335c:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick(TICK_INT_PRIORITY);
 c00335e:	2007      	movs	r0, #7
 c003360:	f7fe f920 	bl	c0015a4 <HAL_InitTick>
        if (status != HAL_OK)
 c003364:	2800      	cmp	r0, #0
 c003366:	d038      	beq.n	c0033da <HAL_RCC_OscConfig+0x10e>
}
 c003368:	b002      	add	sp, #8
 c00336a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 c00336e:	681a      	ldr	r2, [r3, #0]
 c003370:	f042 0208 	orr.w	r2, r2, #8
 c003374:	601a      	str	r2, [r3, #0]
 c003376:	681a      	ldr	r2, [r3, #0]
 c003378:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 c00337c:	4302      	orrs	r2, r0
 c00337e:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 c003380:	685a      	ldr	r2, [r3, #4]
 c003382:	6a21      	ldr	r1, [r4, #32]
 c003384:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 c003388:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 c00338c:	605a      	str	r2, [r3, #4]
          if (sysclk_source == RCC_CFGR_SWS_MSI)
 c00338e:	2e00      	cmp	r6, #0
 c003390:	d1da      	bne.n	c003348 <HAL_RCC_OscConfig+0x7c>
            if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 c003392:	f7ff ff0b 	bl	c0031ac <RCC_SetFlashLatencyFromMSIRange>
 c003396:	2800      	cmp	r0, #0
 c003398:	d0d6      	beq.n	c003348 <HAL_RCC_OscConfig+0x7c>
 c00339a:	e79b      	b.n	c0032d4 <HAL_RCC_OscConfig+0x8>
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 c00339c:	69e3      	ldr	r3, [r4, #28]
 c00339e:	4d6d      	ldr	r5, [pc, #436]	; (c003554 <HAL_RCC_OscConfig+0x288>)
 c0033a0:	2b00      	cmp	r3, #0
 c0033a2:	d03a      	beq.n	c00341a <HAL_RCC_OscConfig+0x14e>
        __HAL_RCC_MSI_ENABLE();
 c0033a4:	682b      	ldr	r3, [r5, #0]
 c0033a6:	f043 0301 	orr.w	r3, r3, #1
 c0033aa:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 c0033ac:	f7fe f908 	bl	c0015c0 <HAL_GetTick>
 c0033b0:	4680      	mov	r8, r0
        while (READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 c0033b2:	682b      	ldr	r3, [r5, #0]
 c0033b4:	0798      	lsls	r0, r3, #30
 c0033b6:	d528      	bpl.n	c00340a <HAL_RCC_OscConfig+0x13e>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 c0033b8:	682b      	ldr	r3, [r5, #0]
 c0033ba:	f043 0308 	orr.w	r3, r3, #8
 c0033be:	602b      	str	r3, [r5, #0]
 c0033c0:	682b      	ldr	r3, [r5, #0]
 c0033c2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 c0033c4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 c0033c8:	4313      	orrs	r3, r2
 c0033ca:	602b      	str	r3, [r5, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 c0033cc:	686b      	ldr	r3, [r5, #4]
 c0033ce:	6a22      	ldr	r2, [r4, #32]
 c0033d0:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 c0033d4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 c0033d8:	606b      	str	r3, [r5, #4]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 c0033da:	6823      	ldr	r3, [r4, #0]
 c0033dc:	07da      	lsls	r2, r3, #31
 c0033de:	d42d      	bmi.n	c00343c <HAL_RCC_OscConfig+0x170>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 c0033e0:	6823      	ldr	r3, [r4, #0]
 c0033e2:	079b      	lsls	r3, r3, #30
 c0033e4:	d472      	bmi.n	c0034cc <HAL_RCC_OscConfig+0x200>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 c0033e6:	6823      	ldr	r3, [r4, #0]
 c0033e8:	071e      	lsls	r6, r3, #28
 c0033ea:	f100 80b9 	bmi.w	c003560 <HAL_RCC_OscConfig+0x294>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 c0033ee:	6823      	ldr	r3, [r4, #0]
 c0033f0:	075d      	lsls	r5, r3, #29
 c0033f2:	f100 80ee 	bmi.w	c0035d2 <HAL_RCC_OscConfig+0x306>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 c0033f6:	6823      	ldr	r3, [r4, #0]
 c0033f8:	069b      	lsls	r3, r3, #26
 c0033fa:	f100 8198 	bmi.w	c00372e <HAL_RCC_OscConfig+0x462>
  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 c0033fe:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 c003400:	2800      	cmp	r0, #0
 c003402:	f040 81bf 	bne.w	c003784 <HAL_RCC_OscConfig+0x4b8>
  return HAL_OK;
 c003406:	2000      	movs	r0, #0
 c003408:	e7ae      	b.n	c003368 <HAL_RCC_OscConfig+0x9c>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 c00340a:	f7fe f8d9 	bl	c0015c0 <HAL_GetTick>
 c00340e:	eba0 0008 	sub.w	r0, r0, r8
 c003412:	2802      	cmp	r0, #2
 c003414:	d9cd      	bls.n	c0033b2 <HAL_RCC_OscConfig+0xe6>
            return HAL_TIMEOUT;
 c003416:	2003      	movs	r0, #3
 c003418:	e7a6      	b.n	c003368 <HAL_RCC_OscConfig+0x9c>
        __HAL_RCC_MSI_DISABLE();
 c00341a:	682b      	ldr	r3, [r5, #0]
 c00341c:	f023 0301 	bic.w	r3, r3, #1
 c003420:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 c003422:	f7fe f8cd 	bl	c0015c0 <HAL_GetTick>
 c003426:	4680      	mov	r8, r0
        while (READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 c003428:	682b      	ldr	r3, [r5, #0]
 c00342a:	0799      	lsls	r1, r3, #30
 c00342c:	d5d5      	bpl.n	c0033da <HAL_RCC_OscConfig+0x10e>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 c00342e:	f7fe f8c7 	bl	c0015c0 <HAL_GetTick>
 c003432:	eba0 0008 	sub.w	r0, r0, r8
 c003436:	2802      	cmp	r0, #2
 c003438:	d9f6      	bls.n	c003428 <HAL_RCC_OscConfig+0x15c>
 c00343a:	e7ec      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
    if ((sysclk_source == RCC_CFGR_SWS_HSE) ||
 c00343c:	2e08      	cmp	r6, #8
 c00343e:	4a45      	ldr	r2, [pc, #276]	; (c003554 <HAL_RCC_OscConfig+0x288>)
 c003440:	d003      	beq.n	c00344a <HAL_RCC_OscConfig+0x17e>
 c003442:	2e0c      	cmp	r6, #12
 c003444:	d108      	bne.n	c003458 <HAL_RCC_OscConfig+0x18c>
        ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSE)))
 c003446:	2f03      	cmp	r7, #3
 c003448:	d106      	bne.n	c003458 <HAL_RCC_OscConfig+0x18c>
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 c00344a:	6813      	ldr	r3, [r2, #0]
 c00344c:	039d      	lsls	r5, r3, #14
 c00344e:	d5c7      	bpl.n	c0033e0 <HAL_RCC_OscConfig+0x114>
 c003450:	6863      	ldr	r3, [r4, #4]
 c003452:	2b00      	cmp	r3, #0
 c003454:	d1c4      	bne.n	c0033e0 <HAL_RCC_OscConfig+0x114>
 c003456:	e73d      	b.n	c0032d4 <HAL_RCC_OscConfig+0x8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 c003458:	6863      	ldr	r3, [r4, #4]
 c00345a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 c00345e:	d111      	bne.n	c003484 <HAL_RCC_OscConfig+0x1b8>
 c003460:	6813      	ldr	r3, [r2, #0]
 c003462:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 c003466:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 c003468:	f7fe f8aa 	bl	c0015c0 <HAL_GetTick>
 c00346c:	4680      	mov	r8, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 c00346e:	4d39      	ldr	r5, [pc, #228]	; (c003554 <HAL_RCC_OscConfig+0x288>)
 c003470:	682b      	ldr	r3, [r5, #0]
 c003472:	0398      	lsls	r0, r3, #14
 c003474:	d4b4      	bmi.n	c0033e0 <HAL_RCC_OscConfig+0x114>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 c003476:	f7fe f8a3 	bl	c0015c0 <HAL_GetTick>
 c00347a:	eba0 0008 	sub.w	r0, r0, r8
 c00347e:	2864      	cmp	r0, #100	; 0x64
 c003480:	d9f6      	bls.n	c003470 <HAL_RCC_OscConfig+0x1a4>
 c003482:	e7c8      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 c003484:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 c003488:	4d32      	ldr	r5, [pc, #200]	; (c003554 <HAL_RCC_OscConfig+0x288>)
 c00348a:	d108      	bne.n	c00349e <HAL_RCC_OscConfig+0x1d2>
 c00348c:	682b      	ldr	r3, [r5, #0]
 c00348e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 c003492:	602b      	str	r3, [r5, #0]
 c003494:	682b      	ldr	r3, [r5, #0]
 c003496:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 c00349a:	602b      	str	r3, [r5, #0]
 c00349c:	e7e4      	b.n	c003468 <HAL_RCC_OscConfig+0x19c>
 c00349e:	682a      	ldr	r2, [r5, #0]
 c0034a0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 c0034a4:	602a      	str	r2, [r5, #0]
 c0034a6:	682a      	ldr	r2, [r5, #0]
 c0034a8:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 c0034ac:	602a      	str	r2, [r5, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 c0034ae:	2b00      	cmp	r3, #0
 c0034b0:	d1da      	bne.n	c003468 <HAL_RCC_OscConfig+0x19c>
        tickstart = HAL_GetTick();
 c0034b2:	f7fe f885 	bl	c0015c0 <HAL_GetTick>
 c0034b6:	4680      	mov	r8, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 c0034b8:	682b      	ldr	r3, [r5, #0]
 c0034ba:	0399      	lsls	r1, r3, #14
 c0034bc:	d590      	bpl.n	c0033e0 <HAL_RCC_OscConfig+0x114>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 c0034be:	f7fe f87f 	bl	c0015c0 <HAL_GetTick>
 c0034c2:	eba0 0008 	sub.w	r0, r0, r8
 c0034c6:	2864      	cmp	r0, #100	; 0x64
 c0034c8:	d9f6      	bls.n	c0034b8 <HAL_RCC_OscConfig+0x1ec>
 c0034ca:	e7a4      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
    if ((sysclk_source == RCC_CFGR_SWS_HSI) ||
 c0034cc:	2e04      	cmp	r6, #4
 c0034ce:	4b21      	ldr	r3, [pc, #132]	; (c003554 <HAL_RCC_OscConfig+0x288>)
 c0034d0:	d003      	beq.n	c0034da <HAL_RCC_OscConfig+0x20e>
 c0034d2:	2e0c      	cmp	r6, #12
 c0034d4:	d111      	bne.n	c0034fa <HAL_RCC_OscConfig+0x22e>
        ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
 c0034d6:	2f02      	cmp	r7, #2
 c0034d8:	d10f      	bne.n	c0034fa <HAL_RCC_OscConfig+0x22e>
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 c0034da:	681b      	ldr	r3, [r3, #0]
 c0034dc:	055a      	lsls	r2, r3, #21
 c0034de:	d503      	bpl.n	c0034e8 <HAL_RCC_OscConfig+0x21c>
 c0034e0:	68e3      	ldr	r3, [r4, #12]
 c0034e2:	2b00      	cmp	r3, #0
 c0034e4:	f43f aef6 	beq.w	c0032d4 <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 c0034e8:	4a1a      	ldr	r2, [pc, #104]	; (c003554 <HAL_RCC_OscConfig+0x288>)
 c0034ea:	6921      	ldr	r1, [r4, #16]
 c0034ec:	6853      	ldr	r3, [r2, #4]
 c0034ee:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 c0034f2:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 c0034f6:	6053      	str	r3, [r2, #4]
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 c0034f8:	e775      	b.n	c0033e6 <HAL_RCC_OscConfig+0x11a>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 c0034fa:	68e2      	ldr	r2, [r4, #12]
 c0034fc:	b1c2      	cbz	r2, c003530 <HAL_RCC_OscConfig+0x264>
        __HAL_RCC_HSI_ENABLE();
 c0034fe:	681a      	ldr	r2, [r3, #0]
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 c003500:	4d14      	ldr	r5, [pc, #80]	; (c003554 <HAL_RCC_OscConfig+0x288>)
        __HAL_RCC_HSI_ENABLE();
 c003502:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 c003506:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 c003508:	f7fe f85a 	bl	c0015c0 <HAL_GetTick>
 c00350c:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 c00350e:	682b      	ldr	r3, [r5, #0]
 c003510:	055b      	lsls	r3, r3, #21
 c003512:	d507      	bpl.n	c003524 <HAL_RCC_OscConfig+0x258>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 c003514:	686b      	ldr	r3, [r5, #4]
 c003516:	6922      	ldr	r2, [r4, #16]
 c003518:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 c00351c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 c003520:	606b      	str	r3, [r5, #4]
 c003522:	e760      	b.n	c0033e6 <HAL_RCC_OscConfig+0x11a>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 c003524:	f7fe f84c 	bl	c0015c0 <HAL_GetTick>
 c003528:	1b80      	subs	r0, r0, r6
 c00352a:	2802      	cmp	r0, #2
 c00352c:	d9ef      	bls.n	c00350e <HAL_RCC_OscConfig+0x242>
 c00352e:	e772      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
        __HAL_RCC_HSI_DISABLE();
 c003530:	681a      	ldr	r2, [r3, #0]
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 c003532:	4d08      	ldr	r5, [pc, #32]	; (c003554 <HAL_RCC_OscConfig+0x288>)
        __HAL_RCC_HSI_DISABLE();
 c003534:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 c003538:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 c00353a:	f7fe f841 	bl	c0015c0 <HAL_GetTick>
 c00353e:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 c003540:	682b      	ldr	r3, [r5, #0]
 c003542:	055f      	lsls	r7, r3, #21
 c003544:	f57f af4f 	bpl.w	c0033e6 <HAL_RCC_OscConfig+0x11a>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 c003548:	f7fe f83a 	bl	c0015c0 <HAL_GetTick>
 c00354c:	1b80      	subs	r0, r0, r6
 c00354e:	2802      	cmp	r0, #2
 c003550:	d9f6      	bls.n	c003540 <HAL_RCC_OscConfig+0x274>
 c003552:	e760      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
 c003554:	50021000 	.word	0x50021000
 c003558:	0c00a080 	.word	0x0c00a080
 c00355c:	30030008 	.word	0x30030008
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 c003560:	6963      	ldr	r3, [r4, #20]
 c003562:	4dba      	ldr	r5, [pc, #744]	; (c00384c <HAL_RCC_OscConfig+0x580>)
 c003564:	b30b      	cbz	r3, c0035aa <HAL_RCC_OscConfig+0x2de>
      if (RCC_OscInitStruct->LSIDiv == RCC_LSI_DIV1)
 c003566:	69a3      	ldr	r3, [r4, #24]
 c003568:	b9d3      	cbnz	r3, c0035a0 <HAL_RCC_OscConfig+0x2d4>
        CLEAR_BIT(RCC->CSR, RCC_CSR_LSIPRE);
 c00356a:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c00356e:	f023 0310 	bic.w	r3, r3, #16
        SET_BIT(RCC->CSR, RCC_CSR_LSIPRE);
 c003572:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      __HAL_RCC_LSI_ENABLE();
 c003576:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c00357a:	f043 0301 	orr.w	r3, r3, #1
 c00357e:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 c003582:	f7fe f81d 	bl	c0015c0 <HAL_GetTick>
 c003586:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 c003588:	4db0      	ldr	r5, [pc, #704]	; (c00384c <HAL_RCC_OscConfig+0x580>)
 c00358a:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c00358e:	0798      	lsls	r0, r3, #30
 c003590:	f53f af2d 	bmi.w	c0033ee <HAL_RCC_OscConfig+0x122>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 c003594:	f7fe f814 	bl	c0015c0 <HAL_GetTick>
 c003598:	1b80      	subs	r0, r0, r6
 c00359a:	2807      	cmp	r0, #7
 c00359c:	d9f5      	bls.n	c00358a <HAL_RCC_OscConfig+0x2be>
 c00359e:	e73a      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
        SET_BIT(RCC->CSR, RCC_CSR_LSIPRE);
 c0035a0:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c0035a4:	f043 0310 	orr.w	r3, r3, #16
 c0035a8:	e7e3      	b.n	c003572 <HAL_RCC_OscConfig+0x2a6>
      __HAL_RCC_LSI_DISABLE();
 c0035aa:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c0035ae:	f023 0301 	bic.w	r3, r3, #1
 c0035b2:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 c0035b6:	f7fe f803 	bl	c0015c0 <HAL_GetTick>
 c0035ba:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 c0035bc:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c0035c0:	0799      	lsls	r1, r3, #30
 c0035c2:	f57f af14 	bpl.w	c0033ee <HAL_RCC_OscConfig+0x122>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 c0035c6:	f7fd fffb 	bl	c0015c0 <HAL_GetTick>
 c0035ca:	1b80      	subs	r0, r0, r6
 c0035cc:	2807      	cmp	r0, #7
 c0035ce:	d9f5      	bls.n	c0035bc <HAL_RCC_OscConfig+0x2f0>
 c0035d0:	e721      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
    if (HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 c0035d2:	4b9e      	ldr	r3, [pc, #632]	; (c00384c <HAL_RCC_OscConfig+0x580>)
 c0035d4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c0035d6:	00d2      	lsls	r2, r2, #3
 c0035d8:	d440      	bmi.n	c00365c <HAL_RCC_OscConfig+0x390>
      pwrclkchanged = SET;
 c0035da:	2601      	movs	r6, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 c0035dc:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c0035de:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 c0035e2:	659a      	str	r2, [r3, #88]	; 0x58
 c0035e4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 c0035e6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c0035ea:	9301      	str	r3, [sp, #4]
 c0035ec:	9b01      	ldr	r3, [sp, #4]
    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 c0035ee:	4d98      	ldr	r5, [pc, #608]	; (c003850 <HAL_RCC_OscConfig+0x584>)
 c0035f0:	682b      	ldr	r3, [r5, #0]
 c0035f2:	05df      	lsls	r7, r3, #23
 c0035f4:	d534      	bpl.n	c003660 <HAL_RCC_OscConfig+0x394>
    if ((RCC_OscInitStruct->LSEState & RCC_BDCR_LSEON) != 0U)
 c0035f6:	68a3      	ldr	r3, [r4, #8]
 c0035f8:	4d94      	ldr	r5, [pc, #592]	; (c00384c <HAL_RCC_OscConfig+0x580>)
 c0035fa:	f013 0f01 	tst.w	r3, #1
 c0035fe:	d13f      	bne.n	c003680 <HAL_RCC_OscConfig+0x3b4>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 c003600:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 c003604:	f022 0201 	bic.w	r2, r2, #1
 c003608:	f8c5 2090 	str.w	r2, [r5, #144]	; 0x90
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 c00360c:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 c003610:	f022 0204 	bic.w	r2, r2, #4
 c003614:	f8c5 2090 	str.w	r2, [r5, #144]	; 0x90
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 c003618:	2b00      	cmp	r3, #0
 c00361a:	d140      	bne.n	c00369e <HAL_RCC_OscConfig+0x3d2>
      tickstart = HAL_GetTick();
 c00361c:	f7fd ffd0 	bl	c0015c0 <HAL_GetTick>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c003620:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 c003624:	4607      	mov	r7, r0
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 c003626:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c00362a:	0798      	lsls	r0, r3, #30
 c00362c:	d478      	bmi.n	c003720 <HAL_RCC_OscConfig+0x454>
      if (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN) != 0U)
 c00362e:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c003632:	0619      	lsls	r1, r3, #24
 c003634:	d54e      	bpl.n	c0036d4 <HAL_RCC_OscConfig+0x408>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c003636:	f241 3888 	movw	r8, #5000	; 0x1388
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 c00363a:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c00363e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 c003642:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 c003646:	4d81      	ldr	r5, [pc, #516]	; (c00384c <HAL_RCC_OscConfig+0x580>)
 c003648:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c00364c:	051a      	lsls	r2, r3, #20
 c00364e:	d541      	bpl.n	c0036d4 <HAL_RCC_OscConfig+0x408>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c003650:	f7fd ffb6 	bl	c0015c0 <HAL_GetTick>
 c003654:	1bc0      	subs	r0, r0, r7
 c003656:	4540      	cmp	r0, r8
 c003658:	d9f6      	bls.n	c003648 <HAL_RCC_OscConfig+0x37c>
 c00365a:	e6dc      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
    FlagStatus       pwrclkchanged = RESET;
 c00365c:	2600      	movs	r6, #0
 c00365e:	e7c6      	b.n	c0035ee <HAL_RCC_OscConfig+0x322>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 c003660:	682b      	ldr	r3, [r5, #0]
 c003662:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 c003666:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 c003668:	f7fd ffaa 	bl	c0015c0 <HAL_GetTick>
 c00366c:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 c00366e:	682b      	ldr	r3, [r5, #0]
 c003670:	05d8      	lsls	r0, r3, #23
 c003672:	d4c0      	bmi.n	c0035f6 <HAL_RCC_OscConfig+0x32a>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 c003674:	f7fd ffa4 	bl	c0015c0 <HAL_GetTick>
 c003678:	1bc0      	subs	r0, r0, r7
 c00367a:	2802      	cmp	r0, #2
 c00367c:	d9f7      	bls.n	c00366e <HAL_RCC_OscConfig+0x3a2>
 c00367e:	e6ca      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
      if ((RCC_OscInitStruct->LSEState & RCC_BDCR_LSEBYP) != 0U)
 c003680:	f013 0f04 	tst.w	r3, #4
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 c003684:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c003688:	bf1e      	ittt	ne
 c00368a:	f043 0304 	orrne.w	r3, r3, #4
 c00368e:	f8c5 3090 	strne.w	r3, [r5, #144]	; 0x90
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 c003692:	f8d5 3090 	ldrne.w	r3, [r5, #144]	; 0x90
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 c003696:	f043 0301 	orr.w	r3, r3, #1
 c00369a:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
      tickstart = HAL_GetTick();
 c00369e:	f7fd ff8f 	bl	c0015c0 <HAL_GetTick>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c0036a2:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 c0036a6:	4607      	mov	r7, r0
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 c0036a8:	4d68      	ldr	r5, [pc, #416]	; (c00384c <HAL_RCC_OscConfig+0x580>)
 c0036aa:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c0036ae:	0799      	lsls	r1, r3, #30
 c0036b0:	d519      	bpl.n	c0036e6 <HAL_RCC_OscConfig+0x41a>
      if ((RCC_OscInitStruct->LSEState & RCC_BDCR_LSESYSEN) != 0U)
 c0036b2:	68a3      	ldr	r3, [r4, #8]
 c0036b4:	f013 0f80 	tst.w	r3, #128	; 0x80
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 c0036b8:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
      if ((RCC_OscInitStruct->LSEState & RCC_BDCR_LSESYSEN) != 0U)
 c0036bc:	d01f      	beq.n	c0036fe <HAL_RCC_OscConfig+0x432>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c0036be:	f241 3888 	movw	r8, #5000	; 0x1388
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 c0036c2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 c0036c6:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 c0036ca:	4d60      	ldr	r5, [pc, #384]	; (c00384c <HAL_RCC_OscConfig+0x580>)
 c0036cc:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c0036d0:	051a      	lsls	r2, r3, #20
 c0036d2:	d50e      	bpl.n	c0036f2 <HAL_RCC_OscConfig+0x426>
    if (pwrclkchanged == SET)
 c0036d4:	2e00      	cmp	r6, #0
 c0036d6:	f43f ae8e 	beq.w	c0033f6 <HAL_RCC_OscConfig+0x12a>
      __HAL_RCC_PWR_CLK_DISABLE();
 c0036da:	4a5c      	ldr	r2, [pc, #368]	; (c00384c <HAL_RCC_OscConfig+0x580>)
 c0036dc:	6d93      	ldr	r3, [r2, #88]	; 0x58
 c0036de:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 c0036e2:	6593      	str	r3, [r2, #88]	; 0x58
 c0036e4:	e687      	b.n	c0033f6 <HAL_RCC_OscConfig+0x12a>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c0036e6:	f7fd ff6b 	bl	c0015c0 <HAL_GetTick>
 c0036ea:	1bc0      	subs	r0, r0, r7
 c0036ec:	4540      	cmp	r0, r8
 c0036ee:	d9dc      	bls.n	c0036aa <HAL_RCC_OscConfig+0x3de>
 c0036f0:	e691      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c0036f2:	f7fd ff65 	bl	c0015c0 <HAL_GetTick>
 c0036f6:	1bc0      	subs	r0, r0, r7
 c0036f8:	4540      	cmp	r0, r8
 c0036fa:	d9e7      	bls.n	c0036cc <HAL_RCC_OscConfig+0x400>
 c0036fc:	e68b      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c0036fe:	f241 3888 	movw	r8, #5000	; 0x1388
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 c003702:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 c003706:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 c00370a:	4d50      	ldr	r5, [pc, #320]	; (c00384c <HAL_RCC_OscConfig+0x580>)
 c00370c:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c003710:	051b      	lsls	r3, r3, #20
 c003712:	d5df      	bpl.n	c0036d4 <HAL_RCC_OscConfig+0x408>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c003714:	f7fd ff54 	bl	c0015c0 <HAL_GetTick>
 c003718:	1bc0      	subs	r0, r0, r7
 c00371a:	4540      	cmp	r0, r8
 c00371c:	d9f6      	bls.n	c00370c <HAL_RCC_OscConfig+0x440>
 c00371e:	e67a      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c003720:	f7fd ff4e 	bl	c0015c0 <HAL_GetTick>
 c003724:	1bc0      	subs	r0, r0, r7
 c003726:	4540      	cmp	r0, r8
 c003728:	f67f af7d 	bls.w	c003626 <HAL_RCC_OscConfig+0x35a>
 c00372c:	e673      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
    if (RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 c00372e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 c003730:	4d46      	ldr	r5, [pc, #280]	; (c00384c <HAL_RCC_OscConfig+0x580>)
 c003732:	b19b      	cbz	r3, c00375c <HAL_RCC_OscConfig+0x490>
      __HAL_RCC_HSI48_ENABLE();
 c003734:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 c003738:	f043 0301 	orr.w	r3, r3, #1
 c00373c:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98
      tickstart = HAL_GetTick();
 c003740:	f7fd ff3e 	bl	c0015c0 <HAL_GetTick>
 c003744:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 c003746:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 c00374a:	079f      	lsls	r7, r3, #30
 c00374c:	f53f ae57 	bmi.w	c0033fe <HAL_RCC_OscConfig+0x132>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 c003750:	f7fd ff36 	bl	c0015c0 <HAL_GetTick>
 c003754:	1b80      	subs	r0, r0, r6
 c003756:	2802      	cmp	r0, #2
 c003758:	d9f5      	bls.n	c003746 <HAL_RCC_OscConfig+0x47a>
 c00375a:	e65c      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
      __HAL_RCC_HSI48_DISABLE();
 c00375c:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 c003760:	f023 0301 	bic.w	r3, r3, #1
 c003764:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98
      tickstart = HAL_GetTick();
 c003768:	f7fd ff2a 	bl	c0015c0 <HAL_GetTick>
 c00376c:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 c00376e:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 c003772:	0798      	lsls	r0, r3, #30
 c003774:	f57f ae43 	bpl.w	c0033fe <HAL_RCC_OscConfig+0x132>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 c003778:	f7fd ff22 	bl	c0015c0 <HAL_GetTick>
 c00377c:	1b80      	subs	r0, r0, r6
 c00377e:	2802      	cmp	r0, #2
 c003780:	d9f5      	bls.n	c00376e <HAL_RCC_OscConfig+0x4a2>
 c003782:	e648      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 c003784:	4d31      	ldr	r5, [pc, #196]	; (c00384c <HAL_RCC_OscConfig+0x580>)
 c003786:	68ab      	ldr	r3, [r5, #8]
 c003788:	f003 030c 	and.w	r3, r3, #12
 c00378c:	2b0c      	cmp	r3, #12
 c00378e:	d063      	beq.n	c003858 <HAL_RCC_OscConfig+0x58c>
        __HAL_RCC_PLL_DISABLE();
 c003790:	682b      	ldr	r3, [r5, #0]
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 c003792:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 c003794:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 c003798:	602b      	str	r3, [r5, #0]
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 c00379a:	d13b      	bne.n	c003814 <HAL_RCC_OscConfig+0x548>
        tickstart = HAL_GetTick();
 c00379c:	f7fd ff10 	bl	c0015c0 <HAL_GetTick>
 c0037a0:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 c0037a2:	682b      	ldr	r3, [r5, #0]
 c0037a4:	0199      	lsls	r1, r3, #6
 c0037a6:	d42f      	bmi.n	c003808 <HAL_RCC_OscConfig+0x53c>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 c0037a8:	68ea      	ldr	r2, [r5, #12]
 c0037aa:	4b2a      	ldr	r3, [pc, #168]	; (c003854 <HAL_RCC_OscConfig+0x588>)
 c0037ac:	4013      	ands	r3, r2
 c0037ae:	6b22      	ldr	r2, [r4, #48]	; 0x30
 c0037b0:	4313      	orrs	r3, r2
 c0037b2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 c0037b4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 c0037b8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 c0037ba:	ea43 63c2 	orr.w	r3, r3, r2, lsl #27
 c0037be:	6b62      	ldr	r2, [r4, #52]	; 0x34
 c0037c0:	3a01      	subs	r2, #1
 c0037c2:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 c0037c6:	6c22      	ldr	r2, [r4, #64]	; 0x40
 c0037c8:	0852      	lsrs	r2, r2, #1
 c0037ca:	3a01      	subs	r2, #1
 c0037cc:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 c0037d0:	6c62      	ldr	r2, [r4, #68]	; 0x44
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 c0037d2:	4c1e      	ldr	r4, [pc, #120]	; (c00384c <HAL_RCC_OscConfig+0x580>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 c0037d4:	0852      	lsrs	r2, r2, #1
 c0037d6:	3a01      	subs	r2, #1
 c0037d8:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 c0037dc:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLL_ENABLE();
 c0037de:	682b      	ldr	r3, [r5, #0]
 c0037e0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 c0037e4:	602b      	str	r3, [r5, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 c0037e6:	68eb      	ldr	r3, [r5, #12]
 c0037e8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 c0037ec:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
 c0037ee:	f7fd fee7 	bl	c0015c0 <HAL_GetTick>
 c0037f2:	4605      	mov	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 c0037f4:	6823      	ldr	r3, [r4, #0]
 c0037f6:	019a      	lsls	r2, r3, #6
 c0037f8:	f53f ae05 	bmi.w	c003406 <HAL_RCC_OscConfig+0x13a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 c0037fc:	f7fd fee0 	bl	c0015c0 <HAL_GetTick>
 c003800:	1b40      	subs	r0, r0, r5
 c003802:	2802      	cmp	r0, #2
 c003804:	d9f6      	bls.n	c0037f4 <HAL_RCC_OscConfig+0x528>
 c003806:	e606      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 c003808:	f7fd feda 	bl	c0015c0 <HAL_GetTick>
 c00380c:	1b80      	subs	r0, r0, r6
 c00380e:	2802      	cmp	r0, #2
 c003810:	d9c7      	bls.n	c0037a2 <HAL_RCC_OscConfig+0x4d6>
 c003812:	e600      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
        if (READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 c003814:	682b      	ldr	r3, [r5, #0]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 c003816:	4c0d      	ldr	r4, [pc, #52]	; (c00384c <HAL_RCC_OscConfig+0x580>)
        if (READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 c003818:	f013 5f20 	tst.w	r3, #671088640	; 0x28000000
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 c00381c:	bf02      	ittt	eq
 c00381e:	68eb      	ldreq	r3, [r5, #12]
 c003820:	f023 0303 	biceq.w	r3, r3, #3
 c003824:	60eb      	streq	r3, [r5, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 c003826:	68e3      	ldr	r3, [r4, #12]
 c003828:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 c00382c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 c003830:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 c003832:	f7fd fec5 	bl	c0015c0 <HAL_GetTick>
 c003836:	4605      	mov	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 c003838:	6823      	ldr	r3, [r4, #0]
 c00383a:	019b      	lsls	r3, r3, #6
 c00383c:	f57f ade3 	bpl.w	c003406 <HAL_RCC_OscConfig+0x13a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 c003840:	f7fd febe 	bl	c0015c0 <HAL_GetTick>
 c003844:	1b40      	subs	r0, r0, r5
 c003846:	2802      	cmp	r0, #2
 c003848:	d9f6      	bls.n	c003838 <HAL_RCC_OscConfig+0x56c>
 c00384a:	e5e4      	b.n	c003416 <HAL_RCC_OscConfig+0x14a>
 c00384c:	50021000 	.word	0x50021000
 c003850:	50007000 	.word	0x50007000
 c003854:	019f800c 	.word	0x019f800c
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_OFF)
 c003858:	2801      	cmp	r0, #1
 c00385a:	f43f ad85 	beq.w	c003368 <HAL_RCC_OscConfig+0x9c>
        pll_config = RCC->PLLCFGR;
 c00385e:	68eb      	ldr	r3, [r5, #12]
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 c003860:	6b22      	ldr	r2, [r4, #48]	; 0x30
 c003862:	f003 0103 	and.w	r1, r3, #3
 c003866:	4291      	cmp	r1, r2
 c003868:	f47f ad34 	bne.w	c0032d4 <HAL_RCC_OscConfig+0x8>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 c00386c:	6b61      	ldr	r1, [r4, #52]	; 0x34
 c00386e:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 c003872:	3901      	subs	r1, #1
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 c003874:	ebb2 1f01 	cmp.w	r2, r1, lsl #4
 c003878:	f47f ad2c 	bne.w	c0032d4 <HAL_RCC_OscConfig+0x8>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 c00387c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 c00387e:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 c003882:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 c003886:	f47f ad25 	bne.w	c0032d4 <HAL_RCC_OscConfig+0x8>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 c00388a:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 c00388c:	f003 4278 	and.w	r2, r3, #4160749568	; 0xf8000000
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 c003890:	ebb2 6fc1 	cmp.w	r2, r1, lsl #27
 c003894:	f47f ad1e 	bne.w	c0032d4 <HAL_RCC_OscConfig+0x8>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 c003898:	6c22      	ldr	r2, [r4, #64]	; 0x40
 c00389a:	f403 01c0 	and.w	r1, r3, #6291456	; 0x600000
 c00389e:	0852      	lsrs	r2, r2, #1
 c0038a0:	3a01      	subs	r2, #1
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 c0038a2:	ebb1 5f42 	cmp.w	r1, r2, lsl #21
 c0038a6:	f47f ad15 	bne.w	c0032d4 <HAL_RCC_OscConfig+0x8>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 c0038aa:	6c62      	ldr	r2, [r4, #68]	; 0x44
 c0038ac:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 c0038b0:	0852      	lsrs	r2, r2, #1
 c0038b2:	3a01      	subs	r2, #1
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 c0038b4:	ebb3 6f42 	cmp.w	r3, r2, lsl #25
    return HAL_ERROR;
 c0038b8:	bf14      	ite	ne
 c0038ba:	2001      	movne	r0, #1
 c0038bc:	2000      	moveq	r0, #0
 c0038be:	e553      	b.n	c003368 <HAL_RCC_OscConfig+0x9c>

0c0038c0 <HAL_RCC_ClockConfig>:
{
 c0038c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c0038c4:	460d      	mov	r5, r1
  if (RCC_ClkInitStruct == NULL)
 c0038c6:	4604      	mov	r4, r0
 c0038c8:	b910      	cbnz	r0, c0038d0 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 c0038ca:	2001      	movs	r0, #1
}
 c0038cc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 c0038d0:	4a75      	ldr	r2, [pc, #468]	; (c003aa8 <HAL_RCC_ClockConfig+0x1e8>)
 c0038d2:	6813      	ldr	r3, [r2, #0]
 c0038d4:	f003 030f 	and.w	r3, r3, #15
 c0038d8:	428b      	cmp	r3, r1
 c0038da:	d332      	bcc.n	c003942 <HAL_RCC_ClockConfig+0x82>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 c0038dc:	6821      	ldr	r1, [r4, #0]
 c0038de:	f011 0601 	ands.w	r6, r1, #1
 c0038e2:	d139      	bne.n	c003958 <HAL_RCC_ClockConfig+0x98>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 c0038e4:	6821      	ldr	r1, [r4, #0]
 c0038e6:	0788      	lsls	r0, r1, #30
 c0038e8:	f140 80c1 	bpl.w	c003a6e <HAL_RCC_ClockConfig+0x1ae>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 c0038ec:	4a6f      	ldr	r2, [pc, #444]	; (c003aac <HAL_RCC_ClockConfig+0x1ec>)
 c0038ee:	68a0      	ldr	r0, [r4, #8]
 c0038f0:	6893      	ldr	r3, [r2, #8]
 c0038f2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 c0038f6:	4303      	orrs	r3, r0
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 c0038f8:	6093      	str	r3, [r2, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 c0038fa:	4a6b      	ldr	r2, [pc, #428]	; (c003aa8 <HAL_RCC_ClockConfig+0x1e8>)
 c0038fc:	6813      	ldr	r3, [r2, #0]
 c0038fe:	f003 030f 	and.w	r3, r3, #15
 c003902:	42ab      	cmp	r3, r5
 c003904:	f200 80bb 	bhi.w	c003a7e <HAL_RCC_ClockConfig+0x1be>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 c003908:	074a      	lsls	r2, r1, #29
 c00390a:	f100 80c4 	bmi.w	c003a96 <HAL_RCC_ClockConfig+0x1d6>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 c00390e:	070b      	lsls	r3, r1, #28
 c003910:	d507      	bpl.n	c003922 <HAL_RCC_ClockConfig+0x62>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 c003912:	4a66      	ldr	r2, [pc, #408]	; (c003aac <HAL_RCC_ClockConfig+0x1ec>)
 c003914:	6921      	ldr	r1, [r4, #16]
 c003916:	6893      	ldr	r3, [r2, #8]
 c003918:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 c00391c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 c003920:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 c003922:	f7ff fc83 	bl	c00322c <HAL_RCC_GetSysClockFreq>
 c003926:	4b61      	ldr	r3, [pc, #388]	; (c003aac <HAL_RCC_ClockConfig+0x1ec>)
 c003928:	4a61      	ldr	r2, [pc, #388]	; (c003ab0 <HAL_RCC_ClockConfig+0x1f0>)
 c00392a:	689b      	ldr	r3, [r3, #8]
 c00392c:	f3c3 1303 	ubfx	r3, r3, #4, #4
 c003930:	5cd3      	ldrb	r3, [r2, r3]
 c003932:	40d8      	lsrs	r0, r3
 c003934:	4b5f      	ldr	r3, [pc, #380]	; (c003ab4 <HAL_RCC_ClockConfig+0x1f4>)
 c003936:	6018      	str	r0, [r3, #0]
  status = HAL_InitTick(TICK_INT_PRIORITY);
 c003938:	2007      	movs	r0, #7
}
 c00393a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  status = HAL_InitTick(TICK_INT_PRIORITY);
 c00393e:	f7fd be31 	b.w	c0015a4 <HAL_InitTick>
    __HAL_FLASH_SET_LATENCY(FLatency);
 c003942:	6813      	ldr	r3, [r2, #0]
 c003944:	f023 030f 	bic.w	r3, r3, #15
 c003948:	430b      	orrs	r3, r1
 c00394a:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 c00394c:	6813      	ldr	r3, [r2, #0]
 c00394e:	f003 030f 	and.w	r3, r3, #15
 c003952:	428b      	cmp	r3, r1
 c003954:	d1b9      	bne.n	c0038ca <HAL_RCC_ClockConfig+0xa>
 c003956:	e7c1      	b.n	c0038dc <HAL_RCC_ClockConfig+0x1c>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 c003958:	6862      	ldr	r2, [r4, #4]
 c00395a:	4b54      	ldr	r3, [pc, #336]	; (c003aac <HAL_RCC_ClockConfig+0x1ec>)
 c00395c:	2a03      	cmp	r2, #3
 c00395e:	d16b      	bne.n	c003a38 <HAL_RCC_ClockConfig+0x178>
      if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 c003960:	681a      	ldr	r2, [r3, #0]
 c003962:	0192      	lsls	r2, r2, #6
 c003964:	d5b1      	bpl.n	c0038ca <HAL_RCC_ClockConfig+0xa>
static uint32_t RCC_GetSysClockFreqFromPLLSource(void)
{
  uint32_t msirange = 0U;
  uint32_t pllvco, pllsource, pllr, pllm, sysclockfreq;    /* no init needed */

  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
 c003966:	68da      	ldr	r2, [r3, #12]
 c003968:	f002 0203 	and.w	r2, r2, #3
 c00396c:	2a01      	cmp	r2, #1
 c00396e:	d120      	bne.n	c0039b2 <HAL_RCC_ClockConfig+0xf2>
  {
    /* Get MSI range source */
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 c003970:	681a      	ldr	r2, [r3, #0]
 c003972:	0717      	lsls	r7, r2, #28
    {
      /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 c003974:	bf54      	ite	pl
 c003976:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
    }
    else
    {
      /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 c00397a:	681b      	ldrmi	r3, [r3, #0]
    }
    /*MSI frequency range in Hz*/
    msirange = MSIRangeTable[msirange];
 c00397c:	4a4e      	ldr	r2, [pc, #312]	; (c003ab8 <HAL_RCC_ClockConfig+0x1f8>)
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 c00397e:	bf54      	ite	pl
 c003980:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 c003984:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
    msirange = MSIRangeTable[msirange];
 c003988:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  }

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 c00398c:	4e47      	ldr	r6, [pc, #284]	; (c003aac <HAL_RCC_ClockConfig+0x1ec>)
 c00398e:	68f7      	ldr	r7, [r6, #12]
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 c003990:	68f3      	ldr	r3, [r6, #12]
 c003992:	f3c3 1303 	ubfx	r3, r3, #4, #4
 c003996:	1c58      	adds	r0, r3, #1
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 c003998:	f007 0303 	and.w	r3, r7, #3

  switch (pllsource)
 c00399c:	2b02      	cmp	r3, #2
 c00399e:	d00a      	beq.n	c0039b6 <HAL_RCC_ClockConfig+0xf6>
 c0039a0:	2b03      	cmp	r3, #3
 c0039a2:	d008      	beq.n	c0039b6 <HAL_RCC_ClockConfig+0xf6>
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
      break;

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c0039a4:	fbb2 f3f0 	udiv	r3, r2, r0
 c0039a8:	68f6      	ldr	r6, [r6, #12]
 c0039aa:	f3c6 2606 	ubfx	r6, r6, #8, #7
 c0039ae:	4373      	muls	r3, r6
 c0039b0:	e008      	b.n	c0039c4 <HAL_RCC_ClockConfig+0x104>
  uint32_t msirange = 0U;
 c0039b2:	2200      	movs	r2, #0
 c0039b4:	e7ea      	b.n	c00398c <HAL_RCC_ClockConfig+0xcc>
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c0039b6:	4b41      	ldr	r3, [pc, #260]	; (c003abc <HAL_RCC_ClockConfig+0x1fc>)
 c0039b8:	68f2      	ldr	r2, [r6, #12]
 c0039ba:	fbb3 f3f0 	udiv	r3, r3, r0
 c0039be:	f3c2 2206 	ubfx	r2, r2, #8, #7
 c0039c2:	4353      	muls	r3, r2
      break;
  }

  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 c0039c4:	4839      	ldr	r0, [pc, #228]	; (c003aac <HAL_RCC_ClockConfig+0x1ec>)
 c0039c6:	68c2      	ldr	r2, [r0, #12]
 c0039c8:	f3c2 6241 	ubfx	r2, r2, #25, #2
 c0039cc:	3201      	adds	r2, #1
 c0039ce:	0052      	lsls	r2, r2, #1
  sysclockfreq = pllvco / pllr;
 c0039d0:	fbb3 f3f2 	udiv	r3, r3, r2
      if (pllfreq > 80000000U)
 c0039d4:	4a3a      	ldr	r2, [pc, #232]	; (c003ac0 <HAL_RCC_ClockConfig+0x200>)
 c0039d6:	4293      	cmp	r3, r2
 c0039d8:	d81c      	bhi.n	c003a14 <HAL_RCC_ClockConfig+0x154>
  uint32_t hpre = RCC_SYSCLK_DIV1;
 c0039da:	2600      	movs	r6, #0
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 c0039dc:	4f33      	ldr	r7, [pc, #204]	; (c003aac <HAL_RCC_ClockConfig+0x1ec>)
 c0039de:	6862      	ldr	r2, [r4, #4]
 c0039e0:	68bb      	ldr	r3, [r7, #8]
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 c0039e2:	f241 3988 	movw	r9, #5000	; 0x1388
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 c0039e6:	f023 0303 	bic.w	r3, r3, #3
 c0039ea:	4313      	orrs	r3, r2
 c0039ec:	60bb      	str	r3, [r7, #8]
    tickstart = HAL_GetTick();
 c0039ee:	f7fd fde7 	bl	c0015c0 <HAL_GetTick>
 c0039f2:	4680      	mov	r8, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 c0039f4:	68bb      	ldr	r3, [r7, #8]
 c0039f6:	6862      	ldr	r2, [r4, #4]
 c0039f8:	f003 030c 	and.w	r3, r3, #12
 c0039fc:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 c003a00:	f43f af70 	beq.w	c0038e4 <HAL_RCC_ClockConfig+0x24>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 c003a04:	f7fd fddc 	bl	c0015c0 <HAL_GetTick>
 c003a08:	eba0 0008 	sub.w	r0, r0, r8
 c003a0c:	4548      	cmp	r0, r9
 c003a0e:	d9f1      	bls.n	c0039f4 <HAL_RCC_ClockConfig+0x134>
        return HAL_TIMEOUT;
 c003a10:	2003      	movs	r0, #3
 c003a12:	e75b      	b.n	c0038cc <HAL_RCC_ClockConfig+0xc>
        if (READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 c003a14:	6883      	ldr	r3, [r0, #8]
 c003a16:	f013 0ff0 	tst.w	r3, #240	; 0xf0
 c003a1a:	d107      	bne.n	c003a2c <HAL_RCC_ClockConfig+0x16c>
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 c003a1c:	6883      	ldr	r3, [r0, #8]
 c003a1e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 c003a22:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 c003a26:	6083      	str	r3, [r0, #8]
        hpre = RCC_SYSCLK_DIV2;
 c003a28:	2680      	movs	r6, #128	; 0x80
 c003a2a:	e7d7      	b.n	c0039dc <HAL_RCC_ClockConfig+0x11c>
        else if ((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) &&
 c003a2c:	078e      	lsls	r6, r1, #30
 c003a2e:	d5d4      	bpl.n	c0039da <HAL_RCC_ClockConfig+0x11a>
 c003a30:	68a3      	ldr	r3, [r4, #8]
 c003a32:	2b00      	cmp	r3, #0
 c003a34:	d1d1      	bne.n	c0039da <HAL_RCC_ClockConfig+0x11a>
 c003a36:	e7f1      	b.n	c003a1c <HAL_RCC_ClockConfig+0x15c>
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 c003a38:	2a02      	cmp	r2, #2
        if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 c003a3a:	681b      	ldr	r3, [r3, #0]
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 c003a3c:	d110      	bne.n	c003a60 <HAL_RCC_ClockConfig+0x1a0>
        if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 c003a3e:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 c003a42:	f43f af42 	beq.w	c0038ca <HAL_RCC_ClockConfig+0xa>
      pllfreq = HAL_RCC_GetSysClockFreq();
 c003a46:	f7ff fbf1 	bl	c00322c <HAL_RCC_GetSysClockFreq>
      if (pllfreq > 80000000U)
 c003a4a:	4b1d      	ldr	r3, [pc, #116]	; (c003ac0 <HAL_RCC_ClockConfig+0x200>)
 c003a4c:	4298      	cmp	r0, r3
 c003a4e:	d9c4      	bls.n	c0039da <HAL_RCC_ClockConfig+0x11a>
        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 c003a50:	4a16      	ldr	r2, [pc, #88]	; (c003aac <HAL_RCC_ClockConfig+0x1ec>)
 c003a52:	6893      	ldr	r3, [r2, #8]
 c003a54:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 c003a58:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 c003a5c:	6093      	str	r3, [r2, #8]
 c003a5e:	e7e3      	b.n	c003a28 <HAL_RCC_ClockConfig+0x168>
      else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 c003a60:	b912      	cbnz	r2, c003a68 <HAL_RCC_ClockConfig+0x1a8>
        if (READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 c003a62:	f013 0f02 	tst.w	r3, #2
 c003a66:	e7ec      	b.n	c003a42 <HAL_RCC_ClockConfig+0x182>
        if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 c003a68:	f413 6f80 	tst.w	r3, #1024	; 0x400
 c003a6c:	e7e9      	b.n	c003a42 <HAL_RCC_ClockConfig+0x182>
    if (hpre == RCC_SYSCLK_DIV2)
 c003a6e:	2e80      	cmp	r6, #128	; 0x80
 c003a70:	f47f af43 	bne.w	c0038fa <HAL_RCC_ClockConfig+0x3a>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 c003a74:	4a0d      	ldr	r2, [pc, #52]	; (c003aac <HAL_RCC_ClockConfig+0x1ec>)
 c003a76:	6893      	ldr	r3, [r2, #8]
 c003a78:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 c003a7c:	e73c      	b.n	c0038f8 <HAL_RCC_ClockConfig+0x38>
    __HAL_FLASH_SET_LATENCY(FLatency);
 c003a7e:	6813      	ldr	r3, [r2, #0]
 c003a80:	f023 030f 	bic.w	r3, r3, #15
 c003a84:	432b      	orrs	r3, r5
 c003a86:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 c003a88:	6813      	ldr	r3, [r2, #0]
 c003a8a:	f003 030f 	and.w	r3, r3, #15
 c003a8e:	42ab      	cmp	r3, r5
 c003a90:	f47f af1b 	bne.w	c0038ca <HAL_RCC_ClockConfig+0xa>
 c003a94:	e738      	b.n	c003908 <HAL_RCC_ClockConfig+0x48>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 c003a96:	4a05      	ldr	r2, [pc, #20]	; (c003aac <HAL_RCC_ClockConfig+0x1ec>)
 c003a98:	68e0      	ldr	r0, [r4, #12]
 c003a9a:	6893      	ldr	r3, [r2, #8]
 c003a9c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 c003aa0:	4303      	orrs	r3, r0
 c003aa2:	6093      	str	r3, [r2, #8]
 c003aa4:	e733      	b.n	c00390e <HAL_RCC_ClockConfig+0x4e>
 c003aa6:	bf00      	nop
 c003aa8:	50022000 	.word	0x50022000
 c003aac:	50021000 	.word	0x50021000
 c003ab0:	0c00a080 	.word	0x0c00a080
 c003ab4:	30030008 	.word	0x30030008
 c003ab8:	0c00a098 	.word	0x0c00a098
 c003abc:	00f42400 	.word	0x00f42400
 c003ac0:	04c4b400 	.word	0x04c4b400

0c003ac4 <HAL_RCC_GetPCLK1Freq>:
{
 c003ac4:	b508      	push	{r3, lr}
  SystemCoreClockUpdate();
 c003ac6:	f7fe f905 	bl	c001cd4 <SystemCoreClockUpdate>
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 c003aca:	4b05      	ldr	r3, [pc, #20]	; (c003ae0 <HAL_RCC_GetPCLK1Freq+0x1c>)
 c003acc:	4a05      	ldr	r2, [pc, #20]	; (c003ae4 <HAL_RCC_GetPCLK1Freq+0x20>)
 c003ace:	689b      	ldr	r3, [r3, #8]
 c003ad0:	f3c3 2302 	ubfx	r3, r3, #8, #3
 c003ad4:	5cd3      	ldrb	r3, [r2, r3]
 c003ad6:	4a04      	ldr	r2, [pc, #16]	; (c003ae8 <HAL_RCC_GetPCLK1Freq+0x24>)
 c003ad8:	6810      	ldr	r0, [r2, #0]
}
 c003ada:	40d8      	lsrs	r0, r3
 c003adc:	bd08      	pop	{r3, pc}
 c003ade:	bf00      	nop
 c003ae0:	50021000 	.word	0x50021000
 c003ae4:	0c00a090 	.word	0x0c00a090
 c003ae8:	30030008 	.word	0x30030008

0c003aec <HAL_RCC_GetPCLK2Freq>:
{
 c003aec:	b508      	push	{r3, lr}
  SystemCoreClockUpdate();
 c003aee:	f7fe f8f1 	bl	c001cd4 <SystemCoreClockUpdate>
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 c003af2:	4b05      	ldr	r3, [pc, #20]	; (c003b08 <HAL_RCC_GetPCLK2Freq+0x1c>)
 c003af4:	4a05      	ldr	r2, [pc, #20]	; (c003b0c <HAL_RCC_GetPCLK2Freq+0x20>)
 c003af6:	689b      	ldr	r3, [r3, #8]
 c003af8:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 c003afc:	5cd3      	ldrb	r3, [r2, r3]
 c003afe:	4a04      	ldr	r2, [pc, #16]	; (c003b10 <HAL_RCC_GetPCLK2Freq+0x24>)
 c003b00:	6810      	ldr	r0, [r2, #0]
}
 c003b02:	40d8      	lsrs	r0, r3
 c003b04:	bd08      	pop	{r3, pc}
 c003b06:	bf00      	nop
 c003b08:	50021000 	.word	0x50021000
 c003b0c:	0c00a090 	.word	0x0c00a090
 c003b10:	30030008 	.word	0x30030008

0c003b14 <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *pPllSai1, uint32_t Divider)
{
 c003b14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c003b16:	4605      	mov	r5, r0
  assert_param(IS_RCC_PLLSAI1M_VALUE(pPllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(pPllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(pPllSai1->PLLSAI1ClockOut));

  /* Check PLLSAI1 clock source availability */
  switch (pPllSai1->PLLSAI1Source)
 c003b18:	6800      	ldr	r0, [r0, #0]
{
 c003b1a:	460f      	mov	r7, r1
  switch (pPllSai1->PLLSAI1Source)
 c003b1c:	2802      	cmp	r0, #2
 c003b1e:	d008      	beq.n	c003b32 <RCCEx_PLLSAI1_Config+0x1e>
 c003b20:	2803      	cmp	r0, #3
 c003b22:	d02d      	beq.n	c003b80 <RCCEx_PLLSAI1_Config+0x6c>
 c003b24:	2801      	cmp	r0, #1
 c003b26:	d166      	bne.n	c003bf6 <RCCEx_PLLSAI1_Config+0xe2>
  {
    case RCC_PLLSOURCE_MSI:
      if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 c003b28:	4b34      	ldr	r3, [pc, #208]	; (c003bfc <RCCEx_PLLSAI1_Config+0xe8>)
 c003b2a:	681b      	ldr	r3, [r3, #0]
 c003b2c:	0799      	lsls	r1, r3, #30
 c003b2e:	d405      	bmi.n	c003b3c <RCCEx_PLLSAI1_Config+0x28>
      }
    }
  }

  return status;
}
 c003b30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 c003b32:	4b32      	ldr	r3, [pc, #200]	; (c003bfc <RCCEx_PLLSAI1_Config+0xe8>)
 c003b34:	681b      	ldr	r3, [r3, #0]
 c003b36:	f413 6f80 	tst.w	r3, #1024	; 0x400
      if (HAL_IS_BIT_CLR(RCC->CR, (RCC_CR_HSERDY | RCC_CR_HSEBYP)))
 c003b3a:	d05c      	beq.n	c003bf6 <RCCEx_PLLSAI1_Config+0xe2>
    __HAL_RCC_PLLSAI1_DISABLE();
 c003b3c:	4c2f      	ldr	r4, [pc, #188]	; (c003bfc <RCCEx_PLLSAI1_Config+0xe8>)
 c003b3e:	6823      	ldr	r3, [r4, #0]
 c003b40:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 c003b44:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 c003b46:	f7fd fd3b 	bl	c0015c0 <HAL_GetTick>
 c003b4a:	4606      	mov	r6, r0
    while (READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 c003b4c:	6823      	ldr	r3, [r4, #0]
 c003b4e:	011a      	lsls	r2, r3, #4
 c003b50:	d41b      	bmi.n	c003b8a <RCCEx_PLLSAI1_Config+0x76>
 c003b52:	68ab      	ldr	r3, [r5, #8]
 c003b54:	f8d5 c000 	ldr.w	ip, [r5]
 c003b58:	021e      	lsls	r6, r3, #8
 c003b5a:	686b      	ldr	r3, [r5, #4]
 c003b5c:	3b01      	subs	r3, #1
 c003b5e:	0118      	lsls	r0, r3, #4
      if (Divider == DIVIDER_P_UPDATE)
 c003b60:	b1d7      	cbz	r7, c003b98 <RCCEx_PLLSAI1_Config+0x84>
      else if (Divider == DIVIDER_Q_UPDATE)
 c003b62:	2f01      	cmp	r7, #1
 c003b64:	d134      	bne.n	c003bd0 <RCCEx_PLLSAI1_Config+0xbc>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 c003b66:	6923      	ldr	r3, [r4, #16]
 c003b68:	4a25      	ldr	r2, [pc, #148]	; (c003c00 <RCCEx_PLLSAI1_Config+0xec>)
 c003b6a:	692f      	ldr	r7, [r5, #16]
 c003b6c:	401a      	ands	r2, r3
 c003b6e:	ea42 030c 	orr.w	r3, r2, ip
 c003b72:	087f      	lsrs	r7, r7, #1
 c003b74:	4333      	orrs	r3, r6
 c003b76:	3f01      	subs	r7, #1
 c003b78:	4303      	orrs	r3, r0
 c003b7a:	ea43 5347 	orr.w	r3, r3, r7, lsl #21
 c003b7e:	e015      	b.n	c003bac <RCCEx_PLLSAI1_Config+0x98>
      if (HAL_IS_BIT_CLR(RCC->CR, (RCC_CR_HSERDY | RCC_CR_HSEBYP)))
 c003b80:	4b1e      	ldr	r3, [pc, #120]	; (c003bfc <RCCEx_PLLSAI1_Config+0xe8>)
 c003b82:	681b      	ldr	r3, [r3, #0]
 c003b84:	f413 2fc0 	tst.w	r3, #393216	; 0x60000
 c003b88:	e7d7      	b.n	c003b3a <RCCEx_PLLSAI1_Config+0x26>
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 c003b8a:	f7fd fd19 	bl	c0015c0 <HAL_GetTick>
 c003b8e:	1b80      	subs	r0, r0, r6
 c003b90:	2802      	cmp	r0, #2
 c003b92:	d9db      	bls.n	c003b4c <RCCEx_PLLSAI1_Config+0x38>
        status = HAL_TIMEOUT;
 c003b94:	2003      	movs	r0, #3
 c003b96:	e7cb      	b.n	c003b30 <RCCEx_PLLSAI1_Config+0x1c>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 c003b98:	6923      	ldr	r3, [r4, #16]
 c003b9a:	491a      	ldr	r1, [pc, #104]	; (c003c04 <RCCEx_PLLSAI1_Config+0xf0>)
 c003b9c:	4019      	ands	r1, r3
 c003b9e:	ea41 030c 	orr.w	r3, r1, ip
 c003ba2:	68e9      	ldr	r1, [r5, #12]
 c003ba4:	4333      	orrs	r3, r6
 c003ba6:	ea43 63c1 	orr.w	r3, r3, r1, lsl #27
 c003baa:	4303      	orrs	r3, r0
        MODIFY_REG(RCC->PLLSAI1CFGR,
 c003bac:	6123      	str	r3, [r4, #16]
      __HAL_RCC_PLLSAI1_ENABLE();
 c003bae:	4c13      	ldr	r4, [pc, #76]	; (c003bfc <RCCEx_PLLSAI1_Config+0xe8>)
 c003bb0:	6823      	ldr	r3, [r4, #0]
 c003bb2:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 c003bb6:	6023      	str	r3, [r4, #0]
      tickstart = HAL_GetTick();
 c003bb8:	f7fd fd02 	bl	c0015c0 <HAL_GetTick>
 c003bbc:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 c003bbe:	6823      	ldr	r3, [r4, #0]
 c003bc0:	011b      	lsls	r3, r3, #4
 c003bc2:	d512      	bpl.n	c003bea <RCCEx_PLLSAI1_Config+0xd6>
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(pPllSai1->PLLSAI1ClockOut);
 c003bc4:	6923      	ldr	r3, [r4, #16]
 c003bc6:	69aa      	ldr	r2, [r5, #24]
 c003bc8:	2000      	movs	r0, #0
 c003bca:	4313      	orrs	r3, r2
 c003bcc:	6123      	str	r3, [r4, #16]
  return status;
 c003bce:	e7af      	b.n	c003b30 <RCCEx_PLLSAI1_Config+0x1c>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 c003bd0:	6922      	ldr	r2, [r4, #16]
 c003bd2:	4b0d      	ldr	r3, [pc, #52]	; (c003c08 <RCCEx_PLLSAI1_Config+0xf4>)
 c003bd4:	696f      	ldr	r7, [r5, #20]
 c003bd6:	4013      	ands	r3, r2
 c003bd8:	ea43 030c 	orr.w	r3, r3, ip
 c003bdc:	087f      	lsrs	r7, r7, #1
 c003bde:	4333      	orrs	r3, r6
 c003be0:	3f01      	subs	r7, #1
 c003be2:	4303      	orrs	r3, r0
 c003be4:	ea43 6347 	orr.w	r3, r3, r7, lsl #25
 c003be8:	e7e0      	b.n	c003bac <RCCEx_PLLSAI1_Config+0x98>
        if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 c003bea:	f7fd fce9 	bl	c0015c0 <HAL_GetTick>
 c003bee:	1b80      	subs	r0, r0, r6
 c003bf0:	2802      	cmp	r0, #2
 c003bf2:	d9e4      	bls.n	c003bbe <RCCEx_PLLSAI1_Config+0xaa>
 c003bf4:	e7ce      	b.n	c003b94 <RCCEx_PLLSAI1_Config+0x80>
        status = HAL_ERROR;
 c003bf6:	2001      	movs	r0, #1
 c003bf8:	e79a      	b.n	c003b30 <RCCEx_PLLSAI1_Config+0x1c>
 c003bfa:	bf00      	nop
 c003bfc:	50021000 	.word	0x50021000
 c003c00:	ff9f800c 	.word	0xff9f800c
 c003c04:	07ff800c 	.word	0x07ff800c
 c003c08:	f9ff800c 	.word	0xf9ff800c

0c003c0c <RCCEx_PLLSAI2_Config.constprop.4>:
  *
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *pPllSai2, uint32_t Divider)
 c003c0c:	b570      	push	{r4, r5, r6, lr}
 c003c0e:	4605      	mov	r5, r0
  assert_param(IS_RCC_PLLSAI2M_VALUE(pPllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(pPllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(pPllSai2->PLLSAI2ClockOut));

  /* Check PLLSAI2 clock source availability */
  switch (pPllSai2->PLLSAI2Source)
 c003c10:	6800      	ldr	r0, [r0, #0]
 c003c12:	2802      	cmp	r0, #2
 c003c14:	d008      	beq.n	c003c28 <RCCEx_PLLSAI2_Config.constprop.4+0x1c>
 c003c16:	2803      	cmp	r0, #3
 c003c18:	d02f      	beq.n	c003c7a <RCCEx_PLLSAI2_Config.constprop.4+0x6e>
 c003c1a:	2801      	cmp	r0, #1
 c003c1c:	d147      	bne.n	c003cae <RCCEx_PLLSAI2_Config.constprop.4+0xa2>
  {
    case RCC_PLLSOURCE_MSI:
      if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 c003c1e:	4b25      	ldr	r3, [pc, #148]	; (c003cb4 <RCCEx_PLLSAI2_Config.constprop.4+0xa8>)
 c003c20:	681b      	ldr	r3, [r3, #0]
 c003c22:	0799      	lsls	r1, r3, #30
 c003c24:	d405      	bmi.n	c003c32 <RCCEx_PLLSAI2_Config.constprop.4+0x26>
      }
    }
  }

  return status;
}
 c003c26:	bd70      	pop	{r4, r5, r6, pc}
      if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 c003c28:	4b22      	ldr	r3, [pc, #136]	; (c003cb4 <RCCEx_PLLSAI2_Config.constprop.4+0xa8>)
 c003c2a:	681b      	ldr	r3, [r3, #0]
 c003c2c:	f413 6f80 	tst.w	r3, #1024	; 0x400
      if (HAL_IS_BIT_CLR(RCC->CR, (RCC_CR_HSERDY | RCC_CR_HSEBYP)))
 c003c30:	d03d      	beq.n	c003cae <RCCEx_PLLSAI2_Config.constprop.4+0xa2>
    __HAL_RCC_PLLSAI2_DISABLE();
 c003c32:	4c20      	ldr	r4, [pc, #128]	; (c003cb4 <RCCEx_PLLSAI2_Config.constprop.4+0xa8>)
 c003c34:	6823      	ldr	r3, [r4, #0]
 c003c36:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 c003c3a:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 c003c3c:	f7fd fcc0 	bl	c0015c0 <HAL_GetTick>
 c003c40:	4606      	mov	r6, r0
    while (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 c003c42:	6823      	ldr	r3, [r4, #0]
 c003c44:	009a      	lsls	r2, r3, #2
 c003c46:	d41d      	bmi.n	c003c84 <RCCEx_PLLSAI2_Config.constprop.4+0x78>
        MODIFY_REG(RCC->PLLSAI2CFGR,
 c003c48:	6962      	ldr	r2, [r4, #20]
 c003c4a:	4b1b      	ldr	r3, [pc, #108]	; (c003cb8 <RCCEx_PLLSAI2_Config.constprop.4+0xac>)
 c003c4c:	4013      	ands	r3, r2
 c003c4e:	682a      	ldr	r2, [r5, #0]
 c003c50:	4313      	orrs	r3, r2
 c003c52:	68aa      	ldr	r2, [r5, #8]
 c003c54:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 c003c58:	68ea      	ldr	r2, [r5, #12]
 c003c5a:	ea43 63c2 	orr.w	r3, r3, r2, lsl #27
 c003c5e:	686a      	ldr	r2, [r5, #4]
 c003c60:	3a01      	subs	r2, #1
 c003c62:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 c003c66:	6163      	str	r3, [r4, #20]
      __HAL_RCC_PLLSAI2_ENABLE();
 c003c68:	6823      	ldr	r3, [r4, #0]
 c003c6a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 c003c6e:	6023      	str	r3, [r4, #0]
      tickstart = HAL_GetTick();
 c003c70:	f7fd fca6 	bl	c0015c0 <HAL_GetTick>
      while (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 c003c74:	4c0f      	ldr	r4, [pc, #60]	; (c003cb4 <RCCEx_PLLSAI2_Config.constprop.4+0xa8>)
      tickstart = HAL_GetTick();
 c003c76:	4606      	mov	r6, r0
 c003c78:	e010      	b.n	c003c9c <RCCEx_PLLSAI2_Config.constprop.4+0x90>
      if (HAL_IS_BIT_CLR(RCC->CR, (RCC_CR_HSERDY | RCC_CR_HSEBYP)))
 c003c7a:	4b0e      	ldr	r3, [pc, #56]	; (c003cb4 <RCCEx_PLLSAI2_Config.constprop.4+0xa8>)
 c003c7c:	681b      	ldr	r3, [r3, #0]
 c003c7e:	f413 2fc0 	tst.w	r3, #393216	; 0x60000
 c003c82:	e7d5      	b.n	c003c30 <RCCEx_PLLSAI2_Config.constprop.4+0x24>
      if ((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 c003c84:	f7fd fc9c 	bl	c0015c0 <HAL_GetTick>
 c003c88:	1b80      	subs	r0, r0, r6
 c003c8a:	2802      	cmp	r0, #2
 c003c8c:	d9d9      	bls.n	c003c42 <RCCEx_PLLSAI2_Config.constprop.4+0x36>
        status = HAL_TIMEOUT;
 c003c8e:	2003      	movs	r0, #3
 c003c90:	e7c9      	b.n	c003c26 <RCCEx_PLLSAI2_Config.constprop.4+0x1a>
        if ((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 c003c92:	f7fd fc95 	bl	c0015c0 <HAL_GetTick>
 c003c96:	1b80      	subs	r0, r0, r6
 c003c98:	2802      	cmp	r0, #2
 c003c9a:	d8f8      	bhi.n	c003c8e <RCCEx_PLLSAI2_Config.constprop.4+0x82>
      while (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 c003c9c:	6823      	ldr	r3, [r4, #0]
 c003c9e:	009b      	lsls	r3, r3, #2
 c003ca0:	d5f7      	bpl.n	c003c92 <RCCEx_PLLSAI2_Config.constprop.4+0x86>
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(pPllSai2->PLLSAI2ClockOut);
 c003ca2:	6963      	ldr	r3, [r4, #20]
 c003ca4:	692a      	ldr	r2, [r5, #16]
 c003ca6:	2000      	movs	r0, #0
 c003ca8:	4313      	orrs	r3, r2
 c003caa:	6163      	str	r3, [r4, #20]
 c003cac:	e7bb      	b.n	c003c26 <RCCEx_PLLSAI2_Config.constprop.4+0x1a>
        status = HAL_ERROR;
 c003cae:	2001      	movs	r0, #1
 c003cb0:	e7b9      	b.n	c003c26 <RCCEx_PLLSAI2_Config.constprop.4+0x1a>
 c003cb2:	bf00      	nop
 c003cb4:	50021000 	.word	0x50021000
 c003cb8:	07ff800c 	.word	0x07ff800c

0c003cbc <HAL_RCCEx_PeriphCLKConfig>:
{
 c003cbc:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 c003cc0:	6805      	ldr	r5, [r0, #0]
{
 c003cc2:	4604      	mov	r4, r0
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 c003cc4:	f415 6500 	ands.w	r5, r5, #2048	; 0x800
 c003cc8:	d023      	beq.n	c003d12 <HAL_RCCEx_PeriphCLKConfig+0x56>
    switch (PeriphClkInit->Sai1ClockSelection)
 c003cca:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
 c003ccc:	2940      	cmp	r1, #64	; 0x40
 c003cce:	d014      	beq.n	c003cfa <HAL_RCCEx_PeriphCLKConfig+0x3e>
 c003cd0:	d804      	bhi.n	c003cdc <HAL_RCCEx_PeriphCLKConfig+0x20>
 c003cd2:	b1c1      	cbz	r1, c003d06 <HAL_RCCEx_PeriphCLKConfig+0x4a>
 c003cd4:	2920      	cmp	r1, #32
 c003cd6:	d02b      	beq.n	c003d30 <HAL_RCCEx_PeriphCLKConfig+0x74>
        ret = HAL_ERROR;
 c003cd8:	2501      	movs	r5, #1
 c003cda:	e01a      	b.n	c003d12 <HAL_RCCEx_PeriphCLKConfig+0x56>
    switch (PeriphClkInit->Sai1ClockSelection)
 c003cdc:	2960      	cmp	r1, #96	; 0x60
 c003cde:	d001      	beq.n	c003ce4 <HAL_RCCEx_PeriphCLKConfig+0x28>
 c003ce0:	2980      	cmp	r1, #128	; 0x80
 c003ce2:	d1f9      	bne.n	c003cd8 <HAL_RCCEx_PeriphCLKConfig+0x1c>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 c003ce4:	4a4e      	ldr	r2, [pc, #312]	; (c003e20 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 c003ce6:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 c003ce8:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 c003cec:	2500      	movs	r5, #0
 c003cee:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 c003cf2:	430b      	orrs	r3, r1
 c003cf4:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
 c003cf8:	e00b      	b.n	c003d12 <HAL_RCCEx_PeriphCLKConfig+0x56>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 c003cfa:	4a49      	ldr	r2, [pc, #292]	; (c003e20 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 c003cfc:	68d3      	ldr	r3, [r2, #12]
 c003cfe:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 c003d02:	60d3      	str	r3, [r2, #12]
 c003d04:	e7ee      	b.n	c003ce4 <HAL_RCCEx_PeriphCLKConfig+0x28>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 c003d06:	3004      	adds	r0, #4
 c003d08:	f7ff ff04 	bl	c003b14 <RCCEx_PLLSAI1_Config>
        ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 c003d0c:	4605      	mov	r5, r0
    if (ret == HAL_OK)
 c003d0e:	2800      	cmp	r0, #0
 c003d10:	d0e8      	beq.n	c003ce4 <HAL_RCCEx_PeriphCLKConfig+0x28>
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 c003d12:	6823      	ldr	r3, [r4, #0]
 c003d14:	04d8      	lsls	r0, r3, #19
 c003d16:	d509      	bpl.n	c003d2c <HAL_RCCEx_PeriphCLKConfig+0x70>
    switch (PeriphClkInit->Sai2ClockSelection)
 c003d18:	6f21      	ldr	r1, [r4, #112]	; 0x70
 c003d1a:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 c003d1e:	d013      	beq.n	c003d48 <HAL_RCCEx_PeriphCLKConfig+0x8c>
 c003d20:	d80a      	bhi.n	c003d38 <HAL_RCCEx_PeriphCLKConfig+0x7c>
 c003d22:	b1b9      	cbz	r1, c003d54 <HAL_RCCEx_PeriphCLKConfig+0x98>
 c003d24:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 c003d28:	d070      	beq.n	c003e0c <HAL_RCCEx_PeriphCLKConfig+0x150>
        ret = HAL_ERROR;
 c003d2a:	2501      	movs	r5, #1
 c003d2c:	462e      	mov	r6, r5
 c003d2e:	e020      	b.n	c003d72 <HAL_RCCEx_PeriphCLKConfig+0xb6>
        ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 c003d30:	3020      	adds	r0, #32
 c003d32:	f7ff ff6b 	bl	c003c0c <RCCEx_PLLSAI2_Config.constprop.4>
 c003d36:	e7e9      	b.n	c003d0c <HAL_RCCEx_PeriphCLKConfig+0x50>
    switch (PeriphClkInit->Sai2ClockSelection)
 c003d38:	f5b1 7f40 	cmp.w	r1, #768	; 0x300
 c003d3c:	d002      	beq.n	c003d44 <HAL_RCCEx_PeriphCLKConfig+0x88>
 c003d3e:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 c003d42:	d1f2      	bne.n	c003d2a <HAL_RCCEx_PeriphCLKConfig+0x6e>
 c003d44:	462e      	mov	r6, r5
 c003d46:	e009      	b.n	c003d5c <HAL_RCCEx_PeriphCLKConfig+0xa0>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 c003d48:	4a35      	ldr	r2, [pc, #212]	; (c003e20 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 c003d4a:	68d3      	ldr	r3, [r2, #12]
 c003d4c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 c003d50:	60d3      	str	r3, [r2, #12]
 c003d52:	e7f7      	b.n	c003d44 <HAL_RCCEx_PeriphCLKConfig+0x88>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 c003d54:	1d20      	adds	r0, r4, #4
 c003d56:	f7ff fedd 	bl	c003b14 <RCCEx_PLLSAI1_Config>
        ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 c003d5a:	4606      	mov	r6, r0
    if (ret == HAL_OK)
 c003d5c:	2e00      	cmp	r6, #0
 c003d5e:	d15a      	bne.n	c003e16 <HAL_RCCEx_PeriphCLKConfig+0x15a>
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 c003d60:	4a2f      	ldr	r2, [pc, #188]	; (c003e20 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 c003d62:	6f21      	ldr	r1, [r4, #112]	; 0x70
 c003d64:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 c003d68:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 c003d6c:	430b      	orrs	r3, r1
 c003d6e:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 c003d72:	6823      	ldr	r3, [r4, #0]
 c003d74:	0399      	lsls	r1, r3, #14
 c003d76:	d565      	bpl.n	c003e44 <HAL_RCCEx_PeriphCLKConfig+0x188>
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 c003d78:	4b29      	ldr	r3, [pc, #164]	; (c003e20 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 c003d7a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c003d7c:	00d2      	lsls	r2, r2, #3
 c003d7e:	d44c      	bmi.n	c003e1a <HAL_RCCEx_PeriphCLKConfig+0x15e>
      pwrclkchanged = SET;
 c003d80:	2701      	movs	r7, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 c003d82:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c003d84:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 c003d88:	659a      	str	r2, [r3, #88]	; 0x58
 c003d8a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 c003d8c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c003d90:	9301      	str	r3, [sp, #4]
 c003d92:	9b01      	ldr	r3, [sp, #4]
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 c003d94:	f8df 808c 	ldr.w	r8, [pc, #140]	; c003e24 <HAL_RCCEx_PeriphCLKConfig+0x168>
 c003d98:	f8d8 3000 	ldr.w	r3, [r8]
 c003d9c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 c003da0:	f8c8 3000 	str.w	r3, [r8]
    tickstart = HAL_GetTick();
 c003da4:	f7fd fc0c 	bl	c0015c0 <HAL_GetTick>
 c003da8:	4681      	mov	r9, r0
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 c003daa:	f8d8 3000 	ldr.w	r3, [r8]
 c003dae:	05db      	lsls	r3, r3, #23
 c003db0:	d53a      	bpl.n	c003e28 <HAL_RCCEx_PeriphCLKConfig+0x16c>
    if (ret == HAL_OK)
 c003db2:	2e00      	cmp	r6, #0
 c003db4:	f040 8126 	bne.w	c004004 <HAL_RCCEx_PeriphCLKConfig+0x348>
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 c003db8:	4a19      	ldr	r2, [pc, #100]	; (c003e20 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 c003dba:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
      if ((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 c003dbe:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 c003dc2:	d015      	beq.n	c003df0 <HAL_RCCEx_PeriphCLKConfig+0x134>
 c003dc4:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 c003dc8:	4299      	cmp	r1, r3
 c003dca:	d011      	beq.n	c003df0 <HAL_RCCEx_PeriphCLKConfig+0x134>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 c003dcc:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_FORCE();
 c003dd0:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 c003dd4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        __HAL_RCC_BACKUPRESET_FORCE();
 c003dd8:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 c003ddc:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 c003de0:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 c003de4:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 c003de8:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        RCC->BDCR = tmpregister;
 c003dec:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 c003df0:	07d8      	lsls	r0, r3, #31
 c003df2:	f100 80f4 	bmi.w	c003fde <HAL_RCCEx_PeriphCLKConfig+0x322>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 c003df6:	4a0a      	ldr	r2, [pc, #40]	; (c003e20 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 c003df8:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 c003dfc:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 c003e00:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 c003e04:	430b      	orrs	r3, r1
 c003e06:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 c003e0a:	e015      	b.n	c003e38 <HAL_RCCEx_PeriphCLKConfig+0x17c>
        ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 c003e0c:	f104 0020 	add.w	r0, r4, #32
 c003e10:	f7ff fefc 	bl	c003c0c <RCCEx_PLLSAI2_Config.constprop.4>
 c003e14:	e7a1      	b.n	c003d5a <HAL_RCCEx_PeriphCLKConfig+0x9e>
 c003e16:	4635      	mov	r5, r6
 c003e18:	e7ab      	b.n	c003d72 <HAL_RCCEx_PeriphCLKConfig+0xb6>
    FlagStatus       pwrclkchanged = RESET;
 c003e1a:	2700      	movs	r7, #0
 c003e1c:	e7ba      	b.n	c003d94 <HAL_RCCEx_PeriphCLKConfig+0xd8>
 c003e1e:	bf00      	nop
 c003e20:	50021000 	.word	0x50021000
 c003e24:	50007000 	.word	0x50007000
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 c003e28:	f7fd fbca 	bl	c0015c0 <HAL_GetTick>
 c003e2c:	eba0 0009 	sub.w	r0, r0, r9
 c003e30:	2802      	cmp	r0, #2
 c003e32:	d9ba      	bls.n	c003daa <HAL_RCCEx_PeriphCLKConfig+0xee>
        ret = HAL_TIMEOUT;
 c003e34:	2503      	movs	r5, #3
 c003e36:	462e      	mov	r6, r5
    if (pwrclkchanged == SET)
 c003e38:	b127      	cbz	r7, c003e44 <HAL_RCCEx_PeriphCLKConfig+0x188>
      __HAL_RCC_PWR_CLK_DISABLE();
 c003e3a:	4abb      	ldr	r2, [pc, #748]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003e3c:	6d93      	ldr	r3, [r2, #88]	; 0x58
 c003e3e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 c003e42:	6593      	str	r3, [r2, #88]	; 0x58
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 c003e44:	6823      	ldr	r3, [r4, #0]
 c003e46:	07da      	lsls	r2, r3, #31
 c003e48:	d508      	bpl.n	c003e5c <HAL_RCCEx_PeriphCLKConfig+0x1a0>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 c003e4a:	49b7      	ldr	r1, [pc, #732]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003e4c:	6b60      	ldr	r0, [r4, #52]	; 0x34
 c003e4e:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c003e52:	f022 0203 	bic.w	r2, r2, #3
 c003e56:	4302      	orrs	r2, r0
 c003e58:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 c003e5c:	079f      	lsls	r7, r3, #30
 c003e5e:	d508      	bpl.n	c003e72 <HAL_RCCEx_PeriphCLKConfig+0x1b6>
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 c003e60:	49b1      	ldr	r1, [pc, #708]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003e62:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 c003e64:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c003e68:	f022 020c 	bic.w	r2, r2, #12
 c003e6c:	4302      	orrs	r2, r0
 c003e6e:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 c003e72:	0758      	lsls	r0, r3, #29
 c003e74:	d508      	bpl.n	c003e88 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 c003e76:	49ac      	ldr	r1, [pc, #688]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003e78:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 c003e7a:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c003e7e:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 c003e82:	4302      	orrs	r2, r0
 c003e84:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 c003e88:	0719      	lsls	r1, r3, #28
 c003e8a:	d508      	bpl.n	c003e9e <HAL_RCCEx_PeriphCLKConfig+0x1e2>
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 c003e8c:	49a6      	ldr	r1, [pc, #664]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003e8e:	6c20      	ldr	r0, [r4, #64]	; 0x40
 c003e90:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c003e94:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 c003e98:	4302      	orrs	r2, r0
 c003e9a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 c003e9e:	06da      	lsls	r2, r3, #27
 c003ea0:	d508      	bpl.n	c003eb4 <HAL_RCCEx_PeriphCLKConfig+0x1f8>
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 c003ea2:	49a1      	ldr	r1, [pc, #644]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003ea4:	6c60      	ldr	r0, [r4, #68]	; 0x44
 c003ea6:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c003eaa:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 c003eae:	4302      	orrs	r2, r0
 c003eb0:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 c003eb4:	069f      	lsls	r7, r3, #26
 c003eb6:	d508      	bpl.n	c003eca <HAL_RCCEx_PeriphCLKConfig+0x20e>
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 c003eb8:	499b      	ldr	r1, [pc, #620]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003eba:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 c003ebc:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c003ec0:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 c003ec4:	4302      	orrs	r2, r0
 c003ec6:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 c003eca:	0598      	lsls	r0, r3, #22
 c003ecc:	d508      	bpl.n	c003ee0 <HAL_RCCEx_PeriphCLKConfig+0x224>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 c003ece:	4996      	ldr	r1, [pc, #600]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003ed0:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 c003ed2:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c003ed6:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 c003eda:	4302      	orrs	r2, r0
 c003edc:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 c003ee0:	0559      	lsls	r1, r3, #21
 c003ee2:	d508      	bpl.n	c003ef6 <HAL_RCCEx_PeriphCLKConfig+0x23a>
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 c003ee4:	4990      	ldr	r1, [pc, #576]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003ee6:	6e20      	ldr	r0, [r4, #96]	; 0x60
 c003ee8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c003eec:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 c003ef0:	4302      	orrs	r2, r0
 c003ef2:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 c003ef6:	025a      	lsls	r2, r3, #9
 c003ef8:	d508      	bpl.n	c003f0c <HAL_RCCEx_PeriphCLKConfig+0x250>
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 c003efa:	498b      	ldr	r1, [pc, #556]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003efc:	6e60      	ldr	r0, [r4, #100]	; 0x64
 c003efe:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c003f02:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 c003f06:	4302      	orrs	r2, r0
 c003f08:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == (RCC_PERIPHCLK_FDCAN))
 c003f0c:	019b      	lsls	r3, r3, #6
 c003f0e:	d513      	bpl.n	c003f38 <HAL_RCCEx_PeriphCLKConfig+0x27c>
    switch (PeriphClkInit->FdcanClockSelection)
 c003f10:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 c003f12:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 c003f16:	d077      	beq.n	c004008 <HAL_RCCEx_PeriphCLKConfig+0x34c>
 c003f18:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 c003f1c:	d07a      	beq.n	c004014 <HAL_RCCEx_PeriphCLKConfig+0x358>
 c003f1e:	2b00      	cmp	r3, #0
 c003f20:	d17e      	bne.n	c004020 <HAL_RCCEx_PeriphCLKConfig+0x364>
    if (ret == HAL_OK)
 c003f22:	2e00      	cmp	r6, #0
 c003f24:	d17e      	bne.n	c004024 <HAL_RCCEx_PeriphCLKConfig+0x368>
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 c003f26:	4a80      	ldr	r2, [pc, #512]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003f28:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 c003f2a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 c003f2e:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 c003f32:	430b      	orrs	r3, r1
 c003f34:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 c003f38:	6823      	ldr	r3, [r4, #0]
 c003f3a:	065f      	lsls	r7, r3, #25
 c003f3c:	d508      	bpl.n	c003f50 <HAL_RCCEx_PeriphCLKConfig+0x294>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 c003f3e:	497a      	ldr	r1, [pc, #488]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003f40:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 c003f42:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c003f46:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 c003f4a:	4302      	orrs	r2, r0
 c003f4c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 c003f50:	061e      	lsls	r6, r3, #24
 c003f52:	d508      	bpl.n	c003f66 <HAL_RCCEx_PeriphCLKConfig+0x2aa>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 c003f54:	4974      	ldr	r1, [pc, #464]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003f56:	6d20      	ldr	r0, [r4, #80]	; 0x50
 c003f58:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c003f5c:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 c003f60:	4302      	orrs	r2, r0
 c003f62:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 c003f66:	05d8      	lsls	r0, r3, #23
 c003f68:	d508      	bpl.n	c003f7c <HAL_RCCEx_PeriphCLKConfig+0x2c0>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 c003f6a:	496f      	ldr	r1, [pc, #444]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003f6c:	6d60      	ldr	r0, [r4, #84]	; 0x54
 c003f6e:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c003f72:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 c003f76:	4302      	orrs	r2, r0
 c003f78:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 c003f7c:	02d9      	lsls	r1, r3, #11
 c003f7e:	d508      	bpl.n	c003f92 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 c003f80:	4969      	ldr	r1, [pc, #420]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003f82:	6da0      	ldr	r0, [r4, #88]	; 0x58
 c003f84:	f8d1 209c 	ldr.w	r2, [r1, #156]	; 0x9c
 c003f88:	f022 0203 	bic.w	r2, r2, #3
 c003f8c:	4302      	orrs	r2, r0
 c003f8e:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 c003f92:	049a      	lsls	r2, r3, #18
 c003f94:	d510      	bpl.n	c003fb8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 c003f96:	4a64      	ldr	r2, [pc, #400]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003f98:	6f61      	ldr	r1, [r4, #116]	; 0x74
 c003f9a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
    if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 c003f9e:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 c003fa2:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 c003fa6:	ea43 0301 	orr.w	r3, r3, r1
 c003faa:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 c003fae:	d13b      	bne.n	c004028 <HAL_RCCEx_PeriphCLKConfig+0x36c>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 c003fb0:	68d3      	ldr	r3, [r2, #12]
 c003fb2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 c003fb6:	60d3      	str	r3, [r2, #12]
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 c003fb8:	6823      	ldr	r3, [r4, #0]
 c003fba:	031b      	lsls	r3, r3, #12
 c003fbc:	d557      	bpl.n	c00406e <HAL_RCCEx_PeriphCLKConfig+0x3b2>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 c003fbe:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 c003fc0:	4b59      	ldr	r3, [pc, #356]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c003fc2:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 c003fc6:	d13a      	bne.n	c00403e <HAL_RCCEx_PeriphCLKConfig+0x382>
 c003fc8:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 c003fcc:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 c003fd0:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 c003fd4:	68da      	ldr	r2, [r3, #12]
 c003fd6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 c003fda:	60da      	str	r2, [r3, #12]
 c003fdc:	e047      	b.n	c00406e <HAL_RCCEx_PeriphCLKConfig+0x3b2>
        tickstart = HAL_GetTick();
 c003fde:	f7fd faef 	bl	c0015c0 <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c003fe2:	f241 3a88 	movw	sl, #5000	; 0x1388
        tickstart = HAL_GetTick();
 c003fe6:	4681      	mov	r9, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 c003fe8:	f8df 813c 	ldr.w	r8, [pc, #316]	; c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>
 c003fec:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
 c003ff0:	0799      	lsls	r1, r3, #30
 c003ff2:	f53f af00 	bmi.w	c003df6 <HAL_RCCEx_PeriphCLKConfig+0x13a>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c003ff6:	f7fd fae3 	bl	c0015c0 <HAL_GetTick>
 c003ffa:	eba0 0009 	sub.w	r0, r0, r9
 c003ffe:	4550      	cmp	r0, sl
 c004000:	d9f4      	bls.n	c003fec <HAL_RCCEx_PeriphCLKConfig+0x330>
 c004002:	e717      	b.n	c003e34 <HAL_RCCEx_PeriphCLKConfig+0x178>
 c004004:	4635      	mov	r5, r6
 c004006:	e717      	b.n	c003e38 <HAL_RCCEx_PeriphCLKConfig+0x17c>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 c004008:	4a47      	ldr	r2, [pc, #284]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c00400a:	68d3      	ldr	r3, [r2, #12]
 c00400c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 c004010:	60d3      	str	r3, [r2, #12]
        break;
 c004012:	e786      	b.n	c003f22 <HAL_RCCEx_PeriphCLKConfig+0x266>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 c004014:	2100      	movs	r1, #0
 c004016:	1d20      	adds	r0, r4, #4
 c004018:	f7ff fd7c 	bl	c003b14 <RCCEx_PLLSAI1_Config>
 c00401c:	4606      	mov	r6, r0
        break;
 c00401e:	e780      	b.n	c003f22 <HAL_RCCEx_PeriphCLKConfig+0x266>
        ret = HAL_ERROR;
 c004020:	2501      	movs	r5, #1
 c004022:	e789      	b.n	c003f38 <HAL_RCCEx_PeriphCLKConfig+0x27c>
 c004024:	4635      	mov	r5, r6
 c004026:	e787      	b.n	c003f38 <HAL_RCCEx_PeriphCLKConfig+0x27c>
      if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 c004028:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 c00402c:	d1c4      	bne.n	c003fb8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 c00402e:	2101      	movs	r1, #1
 c004030:	1d20      	adds	r0, r4, #4
 c004032:	f7ff fd6f 	bl	c003b14 <RCCEx_PLLSAI1_Config>
 c004036:	2800      	cmp	r0, #0
 c004038:	bf18      	it	ne
 c00403a:	4605      	movne	r5, r0
 c00403c:	e7bc      	b.n	c003fb8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 c00403e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 c004042:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 c004046:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 c00404a:	ea42 0201 	orr.w	r2, r2, r1
 c00404e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 c004052:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 c004056:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 c00405a:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 c00405e:	d165      	bne.n	c00412c <HAL_RCCEx_PeriphCLKConfig+0x470>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 c004060:	2101      	movs	r1, #1
 c004062:	1d20      	adds	r0, r4, #4
 c004064:	f7ff fd56 	bl	c003b14 <RCCEx_PLLSAI1_Config>
 c004068:	2800      	cmp	r0, #0
 c00406a:	bf18      	it	ne
 c00406c:	4605      	movne	r5, r0
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 c00406e:	6823      	ldr	r3, [r4, #0]
 c004070:	035f      	lsls	r7, r3, #13
 c004072:	d510      	bpl.n	c004096 <HAL_RCCEx_PeriphCLKConfig+0x3da>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 c004074:	4a2c      	ldr	r2, [pc, #176]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c004076:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 c004078:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 c00407c:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 c004080:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 c004084:	ea43 0301 	orr.w	r3, r3, r1
 c004088:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 c00408c:	d155      	bne.n	c00413a <HAL_RCCEx_PeriphCLKConfig+0x47e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 c00408e:	68d3      	ldr	r3, [r2, #12]
 c004090:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 c004094:	60d3      	str	r3, [r2, #12]
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 c004096:	6823      	ldr	r3, [r4, #0]
 c004098:	045e      	lsls	r6, r3, #17
 c00409a:	d514      	bpl.n	c0040c6 <HAL_RCCEx_PeriphCLKConfig+0x40a>
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 c00409c:	4922      	ldr	r1, [pc, #136]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c00409e:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 c0040a2:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 c0040a6:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 c0040aa:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 c0040ae:	ea43 0302 	orr.w	r3, r3, r2
 c0040b2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 c0040b6:	d106      	bne.n	c0040c6 <HAL_RCCEx_PeriphCLKConfig+0x40a>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 c0040b8:	2102      	movs	r1, #2
 c0040ba:	1d20      	adds	r0, r4, #4
 c0040bc:	f7ff fd2a 	bl	c003b14 <RCCEx_PLLSAI1_Config>
 c0040c0:	2800      	cmp	r0, #0
 c0040c2:	bf18      	it	ne
 c0040c4:	4605      	movne	r5, r0
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 c0040c6:	6822      	ldr	r2, [r4, #0]
 c0040c8:	03d0      	lsls	r0, r2, #15
 c0040ca:	d509      	bpl.n	c0040e0 <HAL_RCCEx_PeriphCLKConfig+0x424>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 c0040cc:	4916      	ldr	r1, [pc, #88]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c0040ce:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 c0040d2:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 c0040d6:	f023 0304 	bic.w	r3, r3, #4
 c0040da:	4303      	orrs	r3, r0
 c0040dc:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1AUDIO) == RCC_PERIPHCLK_DFSDM1AUDIO)
 c0040e0:	0291      	lsls	r1, r2, #10
 c0040e2:	d509      	bpl.n	c0040f8 <HAL_RCCEx_PeriphCLKConfig+0x43c>
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 c0040e4:	4910      	ldr	r1, [pc, #64]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c0040e6:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 c0040ea:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 c0040ee:	f023 0318 	bic.w	r3, r3, #24
 c0040f2:	4303      	orrs	r3, r0
 c0040f4:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 c0040f8:	01d3      	lsls	r3, r2, #7
 c0040fa:	d511      	bpl.n	c004120 <HAL_RCCEx_PeriphCLKConfig+0x464>
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 c0040fc:	4a0a      	ldr	r2, [pc, #40]	; (c004128 <HAL_RCCEx_PeriphCLKConfig+0x46c>)
 c0040fe:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 c004102:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
    if (PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 c004106:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 c00410a:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 c00410e:	ea43 0301 	orr.w	r3, r3, r1
 c004112:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 c004116:	bf02      	ittt	eq
 c004118:	68d3      	ldreq	r3, [r2, #12]
 c00411a:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
 c00411e:	60d3      	streq	r3, [r2, #12]
}
 c004120:	4628      	mov	r0, r5
 c004122:	b002      	add	sp, #8
 c004124:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c004128:	50021000 	.word	0x50021000
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)
 c00412c:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
 c004130:	d19d      	bne.n	c00406e <HAL_RCCEx_PeriphCLKConfig+0x3b2>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 c004132:	68da      	ldr	r2, [r3, #12]
 c004134:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 c004138:	e74f      	b.n	c003fda <HAL_RCCEx_PeriphCLKConfig+0x31e>
    else if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 c00413a:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 c00413e:	d1aa      	bne.n	c004096 <HAL_RCCEx_PeriphCLKConfig+0x3da>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 c004140:	2101      	movs	r1, #1
 c004142:	1d20      	adds	r0, r4, #4
 c004144:	f7ff fce6 	bl	c003b14 <RCCEx_PLLSAI1_Config>
 c004148:	2800      	cmp	r0, #0
 c00414a:	bf18      	it	ne
 c00414c:	4605      	movne	r5, r0
 c00414e:	e7a2      	b.n	c004096 <HAL_RCCEx_PeriphCLKConfig+0x3da>

0c004150 <HAL_RNG_MspInit>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hrng);
  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_RNG_MspInit must be implemented in the user file.
   */
}
 c004150:	4770      	bx	lr

0c004152 <HAL_RNG_Init>:
{
 c004152:	b538      	push	{r3, r4, r5, lr}
  if (hrng == NULL)
 c004154:	4604      	mov	r4, r0
 c004156:	b358      	cbz	r0, c0041b0 <HAL_RNG_Init+0x5e>
  if (hrng->State == HAL_RNG_STATE_RESET)
 c004158:	7a43      	ldrb	r3, [r0, #9]
 c00415a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 c00415e:	b913      	cbnz	r3, c004166 <HAL_RNG_Init+0x14>
    hrng->Lock = HAL_UNLOCKED;
 c004160:	7202      	strb	r2, [r0, #8]
    HAL_RNG_MspInit(hrng);
 c004162:	f7ff fff5 	bl	c004150 <HAL_RNG_MspInit>
  hrng->State = HAL_RNG_STATE_BUSY;
 c004166:	2302      	movs	r3, #2
 c004168:	7263      	strb	r3, [r4, #9]
  __HAL_RNG_DISABLE(hrng);
 c00416a:	6823      	ldr	r3, [r4, #0]
 c00416c:	681a      	ldr	r2, [r3, #0]
 c00416e:	f022 0204 	bic.w	r2, r2, #4
 c004172:	601a      	str	r2, [r3, #0]
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED | RNG_CR_CONDRST, hrng->Init.ClockErrorDetection | RNG_CR_CONDRST);
 c004174:	6819      	ldr	r1, [r3, #0]
 c004176:	6862      	ldr	r2, [r4, #4]
 c004178:	f021 4180 	bic.w	r1, r1, #1073741824	; 0x40000000
 c00417c:	f021 0120 	bic.w	r1, r1, #32
 c004180:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 c004184:	430a      	orrs	r2, r1
 c004186:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(hrng->Instance->CR, RNG_CR_CONDRST);
 c004188:	681a      	ldr	r2, [r3, #0]
 c00418a:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 c00418e:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 c004190:	f7fd fa16 	bl	c0015c0 <HAL_GetTick>
 c004194:	4605      	mov	r5, r0
  while(HAL_IS_BIT_SET(hrng->Instance->CR, RNG_CR_CONDRST))
 c004196:	6823      	ldr	r3, [r4, #0]
 c004198:	681a      	ldr	r2, [r3, #0]
 c00419a:	0052      	lsls	r2, r2, #1
 c00419c:	d40a      	bmi.n	c0041b4 <HAL_RNG_Init+0x62>
  __HAL_RNG_ENABLE(hrng);
 c00419e:	681a      	ldr	r2, [r3, #0]
 c0041a0:	f042 0204 	orr.w	r2, r2, #4
 c0041a4:	601a      	str	r2, [r3, #0]
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 c0041a6:	685b      	ldr	r3, [r3, #4]
 c0041a8:	065b      	lsls	r3, r3, #25
 c0041aa:	d50d      	bpl.n	c0041c8 <HAL_RNG_Init+0x76>
    hrng->State = HAL_RNG_STATE_ERROR;
 c0041ac:	2304      	movs	r3, #4
 c0041ae:	7263      	strb	r3, [r4, #9]
    return HAL_ERROR;
 c0041b0:	2001      	movs	r0, #1
 c0041b2:	e008      	b.n	c0041c6 <HAL_RNG_Init+0x74>
    if((HAL_GetTick() - tickstart ) > RNG_TIMEOUT_VALUE)
 c0041b4:	f7fd fa04 	bl	c0015c0 <HAL_GetTick>
 c0041b8:	1b40      	subs	r0, r0, r5
 c0041ba:	2802      	cmp	r0, #2
 c0041bc:	d9eb      	bls.n	c004196 <HAL_RNG_Init+0x44>
      hrng->State = HAL_RNG_STATE_READY;
 c0041be:	2001      	movs	r0, #1
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c0041c0:	2302      	movs	r3, #2
      hrng->State = HAL_RNG_STATE_READY;
 c0041c2:	7260      	strb	r0, [r4, #9]
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c0041c4:	60e3      	str	r3, [r4, #12]
}
 c0041c6:	bd38      	pop	{r3, r4, r5, pc}
  tickstart = HAL_GetTick();
 c0041c8:	f7fd f9fa 	bl	c0015c0 <HAL_GetTick>
 c0041cc:	4605      	mov	r5, r0
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 c0041ce:	6823      	ldr	r3, [r4, #0]
 c0041d0:	6858      	ldr	r0, [r3, #4]
 c0041d2:	f010 0004 	ands.w	r0, r0, #4
 c0041d6:	d103      	bne.n	c0041e0 <HAL_RNG_Init+0x8e>
  hrng->State = HAL_RNG_STATE_READY;
 c0041d8:	2301      	movs	r3, #1
 c0041da:	7263      	strb	r3, [r4, #9]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 c0041dc:	60e0      	str	r0, [r4, #12]
  return HAL_OK;
 c0041de:	e7f2      	b.n	c0041c6 <HAL_RNG_Init+0x74>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 c0041e0:	f7fd f9ee 	bl	c0015c0 <HAL_GetTick>
 c0041e4:	1b40      	subs	r0, r0, r5
 c0041e6:	2802      	cmp	r0, #2
 c0041e8:	d9f1      	bls.n	c0041ce <HAL_RNG_Init+0x7c>
      hrng->State = HAL_RNG_STATE_ERROR;
 c0041ea:	2304      	movs	r3, #4
 c0041ec:	7263      	strb	r3, [r4, #9]
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c0041ee:	2302      	movs	r3, #2
 c0041f0:	60e3      	str	r3, [r4, #12]
 c0041f2:	e7dd      	b.n	c0041b0 <HAL_RNG_Init+0x5e>

0c0041f4 <HAL_RNG_MspDeInit>:
 c0041f4:	4770      	bx	lr

0c0041f6 <HAL_RNG_DeInit>:
{
 c0041f6:	b570      	push	{r4, r5, r6, lr}
  if (hrng == NULL)
 c0041f8:	4605      	mov	r5, r0
 c0041fa:	b370      	cbz	r0, c00425a <HAL_RNG_DeInit+0x64>
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED | RNG_CR_CONDRST, RNG_CED_ENABLE | RNG_CR_CONDRST);
 c0041fc:	6802      	ldr	r2, [r0, #0]
 c0041fe:	6813      	ldr	r3, [r2, #0]
 c004200:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 c004204:	f023 0320 	bic.w	r3, r3, #32
 c004208:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 c00420c:	6013      	str	r3, [r2, #0]
  CLEAR_BIT(hrng->Instance->CR, RNG_CR_CONDRST);
 c00420e:	6813      	ldr	r3, [r2, #0]
 c004210:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 c004214:	6013      	str	r3, [r2, #0]
  tickstart = HAL_GetTick();
 c004216:	f7fd f9d3 	bl	c0015c0 <HAL_GetTick>
 c00421a:	4606      	mov	r6, r0
  while(HAL_IS_BIT_SET(hrng->Instance->CR, RNG_CR_CONDRST))
 c00421c:	682b      	ldr	r3, [r5, #0]
 c00421e:	681c      	ldr	r4, [r3, #0]
 c004220:	f014 4480 	ands.w	r4, r4, #1073741824	; 0x40000000
 c004224:	d10f      	bne.n	c004246 <HAL_RNG_DeInit+0x50>
  CLEAR_BIT(hrng->Instance->CR, RNG_CR_IE | RNG_CR_RNGEN);
 c004226:	681a      	ldr	r2, [r3, #0]
  HAL_RNG_MspDeInit(hrng);
 c004228:	4628      	mov	r0, r5
  CLEAR_BIT(hrng->Instance->CR, RNG_CR_IE | RNG_CR_RNGEN);
 c00422a:	f022 020c 	bic.w	r2, r2, #12
 c00422e:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(hrng->Instance->SR, RNG_SR_CEIS | RNG_SR_SEIS);
 c004230:	685a      	ldr	r2, [r3, #4]
 c004232:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 c004236:	605a      	str	r2, [r3, #4]
  HAL_RNG_MspDeInit(hrng);
 c004238:	f7ff ffdc 	bl	c0041f4 <HAL_RNG_MspDeInit>
  hrng->State = HAL_RNG_STATE_RESET;
 c00423c:	726c      	strb	r4, [r5, #9]
  __HAL_UNLOCK(hrng);
 c00423e:	722c      	strb	r4, [r5, #8]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 c004240:	60ec      	str	r4, [r5, #12]
  return HAL_OK;
 c004242:	4620      	mov	r0, r4
 c004244:	e008      	b.n	c004258 <HAL_RNG_DeInit+0x62>
    if((HAL_GetTick() - tickstart ) > RNG_TIMEOUT_VALUE)
 c004246:	f7fd f9bb 	bl	c0015c0 <HAL_GetTick>
 c00424a:	1b80      	subs	r0, r0, r6
 c00424c:	2802      	cmp	r0, #2
 c00424e:	d9e5      	bls.n	c00421c <HAL_RNG_DeInit+0x26>
      hrng->State = HAL_RNG_STATE_READY;
 c004250:	2001      	movs	r0, #1
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c004252:	2302      	movs	r3, #2
      hrng->State = HAL_RNG_STATE_READY;
 c004254:	7268      	strb	r0, [r5, #9]
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c004256:	60eb      	str	r3, [r5, #12]
}
 c004258:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 c00425a:	2001      	movs	r0, #1
 c00425c:	e7fc      	b.n	c004258 <HAL_RNG_DeInit+0x62>

0c00425e <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
 c00425e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hrng);
 c004260:	7a03      	ldrb	r3, [r0, #8]
{
 c004262:	4604      	mov	r4, r0
  __HAL_LOCK(hrng);
 c004264:	2b01      	cmp	r3, #1
{
 c004266:	460e      	mov	r6, r1
  __HAL_LOCK(hrng);
 c004268:	d025      	beq.n	c0042b6 <HAL_RNG_GenerateRandomNumber+0x58>
 c00426a:	2001      	movs	r0, #1

  /* Check RNG peripheral state */
  if (hrng->State == HAL_RNG_STATE_READY)
 c00426c:	7a63      	ldrb	r3, [r4, #9]
  __HAL_LOCK(hrng);
 c00426e:	7220      	strb	r0, [r4, #8]
  if (hrng->State == HAL_RNG_STATE_READY)
 c004270:	4283      	cmp	r3, r0
 c004272:	d11d      	bne.n	c0042b0 <HAL_RNG_GenerateRandomNumber+0x52>
  {
    /* Change RNG peripheral state */
    hrng->State = HAL_RNG_STATE_BUSY;
 c004274:	2302      	movs	r3, #2
 c004276:	7263      	strb	r3, [r4, #9]

    /* Get tick */
    tickstart = HAL_GetTick();
 c004278:	f7fd f9a2 	bl	c0015c0 <HAL_GetTick>
 c00427c:	4607      	mov	r7, r0

    /* Check if data register contains valid random data */
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 c00427e:	6822      	ldr	r2, [r4, #0]
 c004280:	6855      	ldr	r5, [r2, #4]
 c004282:	f015 0501 	ands.w	r5, r5, #1
 c004286:	d008      	beq.n	c00429a <HAL_RNG_GenerateRandomNumber+0x3c>
        return HAL_ERROR;
      }
    }

    /* Get a 32bit Random number */
    hrng->RandomNumber = hrng->Instance->DR;
 c004288:	6893      	ldr	r3, [r2, #8]
  HAL_StatusTypeDef status = HAL_OK;
 c00428a:	2000      	movs	r0, #0
    hrng->RandomNumber = hrng->Instance->DR;
 c00428c:	6123      	str	r3, [r4, #16]
    *random32bit = hrng->RandomNumber;
 c00428e:	6033      	str	r3, [r6, #0]

    hrng->State = HAL_RNG_STATE_READY;
 c004290:	2301      	movs	r3, #1
 c004292:	7263      	strb	r3, [r4, #9]
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
    status = HAL_ERROR;
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 c004294:	2300      	movs	r3, #0
 c004296:	7223      	strb	r3, [r4, #8]

  return status;
 c004298:	e009      	b.n	c0042ae <HAL_RNG_GenerateRandomNumber+0x50>
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 c00429a:	f7fd f991 	bl	c0015c0 <HAL_GetTick>
 c00429e:	1bc0      	subs	r0, r0, r7
 c0042a0:	2802      	cmp	r0, #2
 c0042a2:	d9ec      	bls.n	c00427e <HAL_RNG_GenerateRandomNumber+0x20>
        hrng->State = HAL_RNG_STATE_READY;
 c0042a4:	2001      	movs	r0, #1
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c0042a6:	2302      	movs	r3, #2
        hrng->State = HAL_RNG_STATE_READY;
 c0042a8:	7260      	strb	r0, [r4, #9]
        __HAL_UNLOCK(hrng);
 c0042aa:	7225      	strb	r5, [r4, #8]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c0042ac:	60e3      	str	r3, [r4, #12]
}
 c0042ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
 c0042b0:	2304      	movs	r3, #4
 c0042b2:	60e3      	str	r3, [r4, #12]
 c0042b4:	e7ee      	b.n	c004294 <HAL_RNG_GenerateRandomNumber+0x36>
  __HAL_LOCK(hrng);
 c0042b6:	2002      	movs	r0, #2
 c0042b8:	e7f9      	b.n	c0042ae <HAL_RNG_GenerateRandomNumber+0x50>
	...

0c0042bc <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 c0042bc:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  UNUSED(hrtc);
  /* Clear RSF flag */
  SET_BIT(RTC->ICSR, RTC_RSF_MASK);
 c0042be:	4c0a      	ldr	r4, [pc, #40]	; (c0042e8 <HAL_RTC_WaitForSynchro+0x2c>)
 c0042c0:	68e3      	ldr	r3, [r4, #12]
 c0042c2:	f063 03a0 	orn	r3, r3, #160	; 0xa0
 c0042c6:	60e3      	str	r3, [r4, #12]

  tickstart = HAL_GetTick();
 c0042c8:	f7fd f97a 	bl	c0015c0 <HAL_GetTick>
 c0042cc:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 c0042ce:	68e3      	ldr	r3, [r4, #12]
 c0042d0:	069b      	lsls	r3, r3, #26
 c0042d2:	d501      	bpl.n	c0042d8 <HAL_RTC_WaitForSynchro+0x1c>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
 c0042d4:	2000      	movs	r0, #0
}
 c0042d6:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 c0042d8:	f7fd f972 	bl	c0015c0 <HAL_GetTick>
 c0042dc:	1b40      	subs	r0, r0, r5
 c0042de:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 c0042e2:	d9f4      	bls.n	c0042ce <HAL_RTC_WaitForSynchro+0x12>
      return HAL_TIMEOUT;
 c0042e4:	2003      	movs	r0, #3
 c0042e6:	e7f6      	b.n	c0042d6 <HAL_RTC_WaitForSynchro+0x1a>
 c0042e8:	50002800 	.word	0x50002800

0c0042ec <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 c0042ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  UNUSED(hrtc);
  /* Check if the Initialization mode is set */
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 c0042f0:	4d11      	ldr	r5, [pc, #68]	; (c004338 <RTC_EnterInitMode+0x4c>)
{
 c0042f2:	4606      	mov	r6, r0
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 c0042f4:	68ec      	ldr	r4, [r5, #12]
 c0042f6:	f014 0440 	ands.w	r4, r4, #64	; 0x40
 c0042fa:	d11a      	bne.n	c004332 <RTC_EnterInitMode+0x46>
  {
    /* Set the Initialization mode */
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 c0042fc:	68eb      	ldr	r3, [r5, #12]
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
    {
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
      {
        status = HAL_TIMEOUT;
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 c0042fe:	f04f 0803 	mov.w	r8, #3
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 c004302:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 c004306:	60eb      	str	r3, [r5, #12]
    tickstart = HAL_GetTick();
 c004308:	f7fd f95a 	bl	c0015c0 <HAL_GetTick>
 c00430c:	4607      	mov	r7, r0
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 c00430e:	68eb      	ldr	r3, [r5, #12]
 c004310:	065b      	lsls	r3, r3, #25
 c004312:	d401      	bmi.n	c004318 <RTC_EnterInitMode+0x2c>
 c004314:	2c03      	cmp	r4, #3
 c004316:	d102      	bne.n	c00431e <RTC_EnterInitMode+0x32>
      }
    }
  }

  return status;
}
 c004318:	4620      	mov	r0, r4
 c00431a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 c00431e:	f7fd f94f 	bl	c0015c0 <HAL_GetTick>
 c004322:	1bc0      	subs	r0, r0, r7
 c004324:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 c004328:	bf84      	itt	hi
 c00432a:	f886 8025 	strbhi.w	r8, [r6, #37]	; 0x25
        status = HAL_TIMEOUT;
 c00432e:	2403      	movhi	r4, #3
 c004330:	e7ed      	b.n	c00430e <RTC_EnterInitMode+0x22>
  HAL_StatusTypeDef status = HAL_OK;
 c004332:	2400      	movs	r4, #0
 c004334:	e7f0      	b.n	c004318 <RTC_EnterInitMode+0x2c>
 c004336:	bf00      	nop
 c004338:	50002800 	.word	0x50002800

0c00433c <RTC_ExitInitMode>:
  * @brief  Exit the RTC Initialization mode.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
 c00433c:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef status = HAL_OK;

  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 c00433e:	4c0f      	ldr	r4, [pc, #60]	; (c00437c <RTC_ExitInitMode+0x40>)
{
 c004340:	4605      	mov	r5, r0
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 c004342:	68e3      	ldr	r3, [r4, #12]
 c004344:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 c004348:	60e3      	str	r3, [r4, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 c00434a:	69a3      	ldr	r3, [r4, #24]
 c00434c:	069b      	lsls	r3, r3, #26
 c00434e:	d406      	bmi.n	c00435e <RTC_ExitInitMode+0x22>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 c004350:	f7ff ffb4 	bl	c0042bc <HAL_RTC_WaitForSynchro>
 c004354:	b110      	cbz	r0, c00435c <RTC_ExitInitMode+0x20>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 c004356:	2003      	movs	r0, #3
 c004358:	f885 0025 	strb.w	r0, [r5, #37]	; 0x25
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
  }

  return status;
}
 c00435c:	bd38      	pop	{r3, r4, r5, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 c00435e:	69a3      	ldr	r3, [r4, #24]
 c004360:	f023 0320 	bic.w	r3, r3, #32
 c004364:	61a3      	str	r3, [r4, #24]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 c004366:	f7ff ffa9 	bl	c0042bc <HAL_RTC_WaitForSynchro>
 c00436a:	b110      	cbz	r0, c004372 <RTC_ExitInitMode+0x36>
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 c00436c:	2003      	movs	r0, #3
 c00436e:	f885 0025 	strb.w	r0, [r5, #37]	; 0x25
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 c004372:	69a3      	ldr	r3, [r4, #24]
 c004374:	f043 0320 	orr.w	r3, r3, #32
 c004378:	61a3      	str	r3, [r4, #24]
 c00437a:	e7ef      	b.n	c00435c <RTC_ExitInitMode+0x20>
 c00437c:	50002800 	.word	0x50002800

0c004380 <HAL_RTC_Init>:
{
 c004380:	b538      	push	{r3, r4, r5, lr}
  if (hrtc != NULL)
 c004382:	4604      	mov	r4, r0
 c004384:	2800      	cmp	r0, #0
 c004386:	d03f      	beq.n	c004408 <HAL_RTC_Init+0x88>
    if (hrtc->State == HAL_RTC_STATE_RESET)
 c004388:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 c00438c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 c004390:	b91b      	cbnz	r3, c00439a <HAL_RTC_Init+0x1a>
      hrtc->Lock = HAL_UNLOCKED;
 c004392:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
      HAL_RTC_MspInit(hrtc);
 c004396:	f7fd fc47 	bl	c001c28 <HAL_RTC_MspInit>
    hrtc->State = HAL_RTC_STATE_BUSY;
 c00439a:	2302      	movs	r3, #2
 c00439c:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 c0043a0:	23ca      	movs	r3, #202	; 0xca
 c0043a2:	4d1a      	ldr	r5, [pc, #104]	; (c00440c <HAL_RTC_Init+0x8c>)
    status = RTC_EnterInitMode(hrtc);
 c0043a4:	4620      	mov	r0, r4
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 c0043a6:	626b      	str	r3, [r5, #36]	; 0x24
 c0043a8:	2353      	movs	r3, #83	; 0x53
 c0043aa:	626b      	str	r3, [r5, #36]	; 0x24
    status = RTC_EnterInitMode(hrtc);
 c0043ac:	f7ff ff9e 	bl	c0042ec <RTC_EnterInitMode>
    if (status == HAL_OK)
 c0043b0:	bb30      	cbnz	r0, c004400 <HAL_RTC_Init+0x80>
      CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 c0043b2:	69ab      	ldr	r3, [r5, #24]
      status = RTC_ExitInitMode(hrtc);
 c0043b4:	4620      	mov	r0, r4
      CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 c0043b6:	f023 638e 	bic.w	r3, r3, #74448896	; 0x4700000
 c0043ba:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 c0043be:	61ab      	str	r3, [r5, #24]
      SET_BIT(RTC->CR, (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity));
 c0043c0:	6863      	ldr	r3, [r4, #4]
 c0043c2:	6921      	ldr	r1, [r4, #16]
 c0043c4:	69aa      	ldr	r2, [r5, #24]
 c0043c6:	430b      	orrs	r3, r1
 c0043c8:	4313      	orrs	r3, r2
 c0043ca:	69a2      	ldr	r2, [r4, #24]
 c0043cc:	4313      	orrs	r3, r2
 c0043ce:	61ab      	str	r3, [r5, #24]
      WRITE_REG(RTC->PRER, ((hrtc->Init.SynchPrediv) | (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos)));
 c0043d0:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 c0043d4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 c0043d8:	612b      	str	r3, [r5, #16]
      status = RTC_ExitInitMode(hrtc);
 c0043da:	f7ff ffaf 	bl	c00433c <RTC_ExitInitMode>
      if (status == HAL_OK)
 c0043de:	b978      	cbnz	r0, c004400 <HAL_RTC_Init+0x80>
        MODIFY_REG(RTC->CR, \
 c0043e0:	e9d4 1307 	ldrd	r1, r3, [r4, #28]
 c0043e4:	69aa      	ldr	r2, [r5, #24]
 c0043e6:	430b      	orrs	r3, r1
 c0043e8:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 c0043ec:	4313      	orrs	r3, r2
 c0043ee:	6962      	ldr	r2, [r4, #20]
 c0043f0:	4313      	orrs	r3, r2
 c0043f2:	61ab      	str	r3, [r5, #24]
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 c0043f4:	23ff      	movs	r3, #255	; 0xff
 c0043f6:	626b      	str	r3, [r5, #36]	; 0x24
      hrtc->State = HAL_RTC_STATE_READY;
 c0043f8:	2301      	movs	r3, #1
 c0043fa:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
}
 c0043fe:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 c004400:	22ff      	movs	r2, #255	; 0xff
 c004402:	4b02      	ldr	r3, [pc, #8]	; (c00440c <HAL_RTC_Init+0x8c>)
 c004404:	625a      	str	r2, [r3, #36]	; 0x24
 c004406:	e7fa      	b.n	c0043fe <HAL_RTC_Init+0x7e>
  HAL_StatusTypeDef status = HAL_ERROR;
 c004408:	2001      	movs	r0, #1
 c00440a:	e7f8      	b.n	c0043fe <HAL_RTC_Init+0x7e>
 c00440c:	50002800 	.word	0x50002800

0c004410 <HAL_RTCEx_BKUPWrite>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 c004410:	0089      	lsls	r1, r1, #2
 c004412:	f101 41a0 	add.w	r1, r1, #1342177280	; 0x50000000
 c004416:	f501 5154 	add.w	r1, r1, #13568	; 0x3500

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 c00441a:	600a      	str	r2, [r1, #0]
}
 c00441c:	4770      	bx	lr

0c00441e <HAL_UART_MspInit>:
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
 c00441e:	4770      	bx	lr

0c004420 <HAL_UART_Receive_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 c004420:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 c004424:	b510      	push	{r4, lr}
  if (huart->RxState == HAL_UART_STATE_READY)
 c004426:	2b20      	cmp	r3, #32
 c004428:	d167      	bne.n	c0044fa <HAL_UART_Receive_IT+0xda>
  {
    if ((pData == NULL) || (Size == 0U))
 c00442a:	2900      	cmp	r1, #0
 c00442c:	d063      	beq.n	c0044f6 <HAL_UART_Receive_IT+0xd6>
 c00442e:	2a00      	cmp	r2, #0
 c004430:	d061      	beq.n	c0044f6 <HAL_UART_Receive_IT+0xd6>
    {
      return HAL_ERROR;
    }

    __HAL_LOCK(huart);
 c004432:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 c004436:	2b01      	cmp	r3, #1
 c004438:	d05f      	beq.n	c0044fa <HAL_UART_Receive_IT+0xda>
 c00443a:	2301      	movs	r3, #1

    huart->pRxBuffPtr  = pData;
 c00443c:	6581      	str	r1, [r0, #88]	; 0x58
    huart->RxXferSize  = Size;
    huart->RxXferCount = Size;
    huart->RxISR       = NULL;
 c00443e:	2100      	movs	r1, #0
    __HAL_LOCK(huart);
 c004440:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c

    /* Computation of UART mask to apply to RDR register */
    UART_MASK_COMPUTATION(huart);
 c004444:	6883      	ldr	r3, [r0, #8]
    huart->RxXferSize  = Size;
 c004446:	f8a0 205c 	strh.w	r2, [r0, #92]	; 0x5c
    UART_MASK_COMPUTATION(huart);
 c00444a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->RxXferCount = Size;
 c00444e:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
    huart->RxISR       = NULL;
 c004452:	66c1      	str	r1, [r0, #108]	; 0x6c
    UART_MASK_COMPUTATION(huart);
 c004454:	d12e      	bne.n	c0044b4 <HAL_UART_Receive_IT+0x94>
 c004456:	6901      	ldr	r1, [r0, #16]
 c004458:	bb51      	cbnz	r1, c0044b0 <HAL_UART_Receive_IT+0x90>
 c00445a:	f240 11ff 	movw	r1, #511	; 0x1ff
 c00445e:	f8a0 1060 	strh.w	r1, [r0, #96]	; 0x60

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 c004462:	2100      	movs	r1, #0
 c004464:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 c004468:	2122      	movs	r1, #34	; 0x22
 c00446a:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c00446e:	6801      	ldr	r1, [r0, #0]
 c004470:	688c      	ldr	r4, [r1, #8]
 c004472:	f044 0401 	orr.w	r4, r4, #1
 c004476:	608c      	str	r4, [r1, #8]

    /* Configure Rx interrupt processing*/
    if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 c004478:	6e44      	ldr	r4, [r0, #100]	; 0x64
 c00447a:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
 c00447e:	d129      	bne.n	c0044d4 <HAL_UART_Receive_IT+0xb4>
 c004480:	f8b0 4068 	ldrh.w	r4, [r0, #104]	; 0x68
 c004484:	4294      	cmp	r4, r2
 c004486:	d825      	bhi.n	c0044d4 <HAL_UART_Receive_IT+0xb4>
    {
      /* Set the Rx ISR function pointer according to the data word length */
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c004488:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 c00448c:	d120      	bne.n	c0044d0 <HAL_UART_Receive_IT+0xb0>
 c00448e:	6903      	ldr	r3, [r0, #16]
 c004490:	b9f3      	cbnz	r3, c0044d0 <HAL_UART_Receive_IT+0xb0>
      {
        huart->RxISR = UART_RxISR_16BIT_FIFOEN;
 c004492:	4b1b      	ldr	r3, [pc, #108]	; (c004500 <HAL_UART_Receive_IT+0xe0>)
      }
      else
      {
        huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 c004494:	66c3      	str	r3, [r0, #108]	; 0x6c
      }

      __HAL_UNLOCK(huart);
 c004496:	2300      	movs	r3, #0

      /* Enable the UART Parity Error interrupt and RX FIFO Threshold interrupt */
      SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c004498:	680a      	ldr	r2, [r1, #0]
      __HAL_UNLOCK(huart);
 c00449a:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
      SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c00449e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 c0044a2:	600a      	str	r2, [r1, #0]
      SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 c0044a4:	688a      	ldr	r2, [r1, #8]
 c0044a6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 c0044aa:	608a      	str	r2, [r1, #8]

      /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
      SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
    }

    return HAL_OK;
 c0044ac:	4618      	mov	r0, r3
  }
  else
  {
    return HAL_BUSY;
  }
}
 c0044ae:	bd10      	pop	{r4, pc}
    UART_MASK_COMPUTATION(huart);
 c0044b0:	21ff      	movs	r1, #255	; 0xff
 c0044b2:	e7d4      	b.n	c00445e <HAL_UART_Receive_IT+0x3e>
 c0044b4:	b923      	cbnz	r3, c0044c0 <HAL_UART_Receive_IT+0xa0>
 c0044b6:	6901      	ldr	r1, [r0, #16]
 c0044b8:	2900      	cmp	r1, #0
 c0044ba:	d0f9      	beq.n	c0044b0 <HAL_UART_Receive_IT+0x90>
 c0044bc:	217f      	movs	r1, #127	; 0x7f
 c0044be:	e7ce      	b.n	c00445e <HAL_UART_Receive_IT+0x3e>
 c0044c0:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 c0044c4:	d1cb      	bne.n	c00445e <HAL_UART_Receive_IT+0x3e>
 c0044c6:	6901      	ldr	r1, [r0, #16]
 c0044c8:	2900      	cmp	r1, #0
 c0044ca:	d0f7      	beq.n	c0044bc <HAL_UART_Receive_IT+0x9c>
 c0044cc:	213f      	movs	r1, #63	; 0x3f
 c0044ce:	e7c6      	b.n	c00445e <HAL_UART_Receive_IT+0x3e>
        huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 c0044d0:	4b0c      	ldr	r3, [pc, #48]	; (c004504 <HAL_UART_Receive_IT+0xe4>)
 c0044d2:	e7df      	b.n	c004494 <HAL_UART_Receive_IT+0x74>
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c0044d4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 c0044d8:	d10b      	bne.n	c0044f2 <HAL_UART_Receive_IT+0xd2>
 c0044da:	6903      	ldr	r3, [r0, #16]
 c0044dc:	b94b      	cbnz	r3, c0044f2 <HAL_UART_Receive_IT+0xd2>
        huart->RxISR = UART_RxISR_16BIT;
 c0044de:	4b0a      	ldr	r3, [pc, #40]	; (c004508 <HAL_UART_Receive_IT+0xe8>)
        huart->RxISR = UART_RxISR_8BIT;
 c0044e0:	66c3      	str	r3, [r0, #108]	; 0x6c
      __HAL_UNLOCK(huart);
 c0044e2:	2300      	movs	r3, #0
      SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 c0044e4:	680a      	ldr	r2, [r1, #0]
      __HAL_UNLOCK(huart);
 c0044e6:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
      SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 c0044ea:	f442 7290 	orr.w	r2, r2, #288	; 0x120
 c0044ee:	600a      	str	r2, [r1, #0]
 c0044f0:	e7dc      	b.n	c0044ac <HAL_UART_Receive_IT+0x8c>
        huart->RxISR = UART_RxISR_8BIT;
 c0044f2:	4b06      	ldr	r3, [pc, #24]	; (c00450c <HAL_UART_Receive_IT+0xec>)
 c0044f4:	e7f4      	b.n	c0044e0 <HAL_UART_Receive_IT+0xc0>
      return HAL_ERROR;
 c0044f6:	2001      	movs	r0, #1
 c0044f8:	e7d9      	b.n	c0044ae <HAL_UART_Receive_IT+0x8e>
    return HAL_BUSY;
 c0044fa:	2002      	movs	r0, #2
 c0044fc:	e7d7      	b.n	c0044ae <HAL_UART_Receive_IT+0x8e>
 c0044fe:	bf00      	nop
 c004500:	0c00466d 	.word	0x0c00466d
 c004504:	0c0045c9 	.word	0x0c0045c9
 c004508:	0c00456f 	.word	0x0c00456f
 c00450c:	0c004513 	.word	0x0c004513

0c004510 <HAL_UART_RxCpltCallback>:
 c004510:	4770      	bx	lr

0c004512 <UART_RxISR_8BIT>:
{
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c004512:	f8d0 1084 	ldr.w	r1, [r0, #132]	; 0x84
{
 c004516:	b510      	push	{r4, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c004518:	2922      	cmp	r1, #34	; 0x22
 c00451a:	6802      	ldr	r2, [r0, #0]
 c00451c:	d122      	bne.n	c004564 <UART_RxISR_8BIT+0x52>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c00451e:	6a52      	ldr	r2, [r2, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 c004520:	f890 4060 	ldrb.w	r4, [r0, #96]	; 0x60
 c004524:	6d81      	ldr	r1, [r0, #88]	; 0x58
 c004526:	4022      	ands	r2, r4
 c004528:	700a      	strb	r2, [r1, #0]
    huart->pRxBuffPtr++;
 c00452a:	6d82      	ldr	r2, [r0, #88]	; 0x58
 c00452c:	3201      	adds	r2, #1
 c00452e:	6582      	str	r2, [r0, #88]	; 0x58
    huart->RxXferCount--;
 c004530:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 c004534:	3a01      	subs	r2, #1
 c004536:	b292      	uxth	r2, r2
 c004538:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e

    if (huart->RxXferCount == 0U)
 c00453c:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 c004540:	b292      	uxth	r2, r2
 c004542:	b972      	cbnz	r2, c004562 <UART_RxISR_8BIT+0x50>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 c004544:	6801      	ldr	r1, [r0, #0]
 c004546:	680c      	ldr	r4, [r1, #0]
 c004548:	f424 7490 	bic.w	r4, r4, #288	; 0x120
 c00454c:	600c      	str	r4, [r1, #0]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c00454e:	688c      	ldr	r4, [r1, #8]
 c004550:	f024 0401 	bic.w	r4, r4, #1
 c004554:	608c      	str	r4, [r1, #8]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 c004556:	2120      	movs	r1, #32

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 c004558:	66c2      	str	r2, [r0, #108]	; 0x6c
      huart->RxState = HAL_UART_STATE_READY;
 c00455a:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
      /*Call registered Rx complete callback*/
      huart->RxCpltCallback(huart);
#else
      /*Call legacy weak Rx complete callback*/
      HAL_UART_RxCpltCallback(huart);
 c00455e:	f7ff ffd7 	bl	c004510 <HAL_UART_RxCpltCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c004562:	bd10      	pop	{r4, pc}
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c004564:	6993      	ldr	r3, [r2, #24]
 c004566:	f043 0308 	orr.w	r3, r3, #8
 c00456a:	6193      	str	r3, [r2, #24]
}
 c00456c:	e7f9      	b.n	c004562 <UART_RxISR_8BIT+0x50>

0c00456e <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c00456e:	f8d0 1084 	ldr.w	r1, [r0, #132]	; 0x84
{
 c004572:	b510      	push	{r4, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c004574:	2922      	cmp	r1, #34	; 0x22
 c004576:	6802      	ldr	r2, [r0, #0]
 c004578:	d120      	bne.n	c0045bc <UART_RxISR_16BIT+0x4e>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c00457a:	6a54      	ldr	r4, [r2, #36]	; 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
    *tmp = (uint16_t)(uhdata & uhMask);
 c00457c:	f8b0 1060 	ldrh.w	r1, [r0, #96]	; 0x60
 c004580:	400c      	ands	r4, r1
 c004582:	6d81      	ldr	r1, [r0, #88]	; 0x58
 c004584:	f821 4b02 	strh.w	r4, [r1], #2
    huart->pRxBuffPtr += 2U;
 c004588:	6581      	str	r1, [r0, #88]	; 0x58
    huart->RxXferCount--;
 c00458a:	f8b0 105e 	ldrh.w	r1, [r0, #94]	; 0x5e
 c00458e:	3901      	subs	r1, #1
 c004590:	b289      	uxth	r1, r1
 c004592:	f8a0 105e 	strh.w	r1, [r0, #94]	; 0x5e

    if (huart->RxXferCount == 0U)
 c004596:	f8b0 105e 	ldrh.w	r1, [r0, #94]	; 0x5e
 c00459a:	b289      	uxth	r1, r1
 c00459c:	b969      	cbnz	r1, c0045ba <UART_RxISR_16BIT+0x4c>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 c00459e:	6814      	ldr	r4, [r2, #0]
 c0045a0:	f424 7490 	bic.w	r4, r4, #288	; 0x120
 c0045a4:	6014      	str	r4, [r2, #0]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c0045a6:	6894      	ldr	r4, [r2, #8]
 c0045a8:	f024 0401 	bic.w	r4, r4, #1
 c0045ac:	6094      	str	r4, [r2, #8]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 c0045ae:	2220      	movs	r2, #32

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 c0045b0:	66c1      	str	r1, [r0, #108]	; 0x6c
      huart->RxState = HAL_UART_STATE_READY;
 c0045b2:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
      /*Call registered Rx complete callback*/
      huart->RxCpltCallback(huart);
#else
      /*Call legacy weak Rx complete callback*/
      HAL_UART_RxCpltCallback(huart);
 c0045b6:	f7ff ffab 	bl	c004510 <HAL_UART_RxCpltCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c0045ba:	bd10      	pop	{r4, pc}
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c0045bc:	6993      	ldr	r3, [r2, #24]
 c0045be:	f043 0308 	orr.w	r3, r3, #8
 c0045c2:	6193      	str	r3, [r2, #24]
}
 c0045c4:	e7f9      	b.n	c0045ba <UART_RxISR_16BIT+0x4c>
	...

0c0045c8 <UART_RxISR_8BIT_FIFOEN>:
  uint16_t  uhdata;
  uint16_t   nb_rx_data;
  uint16_t  rxdatacount;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c0045c8:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 c0045cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c0045d0:	2b22      	cmp	r3, #34	; 0x22
{
 c0045d2:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c0045d4:	d13f      	bne.n	c004656 <UART_RxISR_8BIT_FIFOEN+0x8e>

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) and RX FIFO Threshold interrupt */
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 c0045d6:	f04f 0820 	mov.w	r8, #32
  uint16_t  uhMask = huart->Mask;
 c0045da:	f8b0 6060 	ldrh.w	r6, [r0, #96]	; 0x60
    for (nb_rx_data = huart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
 c0045de:	f8b0 5068 	ldrh.w	r5, [r0, #104]	; 0x68
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c0045e2:	4f20      	ldr	r7, [pc, #128]	; (c004664 <UART_RxISR_8BIT_FIFOEN+0x9c>)
    for (nb_rx_data = huart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
 c0045e4:	b9a5      	cbnz	r5, c004610 <UART_RxISR_8BIT_FIFOEN+0x48>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 c0045e6:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 c0045ea:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 c0045ec:	b173      	cbz	r3, c00460c <UART_RxISR_8BIT_FIFOEN+0x44>
 c0045ee:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 c0045f2:	429a      	cmp	r2, r3
 c0045f4:	d90a      	bls.n	c00460c <UART_RxISR_8BIT_FIFOEN+0x44>
    {
      /* Disable the UART RXFT interrupt*/
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 c0045f6:	6823      	ldr	r3, [r4, #0]
 c0045f8:	689a      	ldr	r2, [r3, #8]
 c0045fa:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 c0045fe:	609a      	str	r2, [r3, #8]

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_8BIT;
 c004600:	4a19      	ldr	r2, [pc, #100]	; (c004668 <UART_RxISR_8BIT_FIFOEN+0xa0>)
 c004602:	66e2      	str	r2, [r4, #108]	; 0x6c

      /* Enable the UART Data Register Not Empty interrupt */
      SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 c004604:	681a      	ldr	r2, [r3, #0]
 c004606:	f042 0220 	orr.w	r2, r2, #32
 c00460a:	601a      	str	r2, [r3, #0]
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c00460c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c004610:	6823      	ldr	r3, [r4, #0]
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 c004612:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c004614:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 c004616:	4033      	ands	r3, r6
 c004618:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr++;
 c00461a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c00461c:	3301      	adds	r3, #1
 c00461e:	65a3      	str	r3, [r4, #88]	; 0x58
      huart->RxXferCount--;
 c004620:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 c004624:	3b01      	subs	r3, #1
 c004626:	b29b      	uxth	r3, r3
 c004628:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
      if (huart->RxXferCount == 0U)
 c00462c:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 c004630:	b29b      	uxth	r3, r3
 c004632:	b96b      	cbnz	r3, c004650 <UART_RxISR_8BIT_FIFOEN+0x88>
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c004634:	6822      	ldr	r2, [r4, #0]
        HAL_UART_RxCpltCallback(huart);
 c004636:	4620      	mov	r0, r4
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c004638:	6811      	ldr	r1, [r2, #0]
 c00463a:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 c00463e:	6011      	str	r1, [r2, #0]
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c004640:	6891      	ldr	r1, [r2, #8]
 c004642:	4039      	ands	r1, r7
 c004644:	6091      	str	r1, [r2, #8]
        huart->RxState = HAL_UART_STATE_READY;
 c004646:	f8c4 8084 	str.w	r8, [r4, #132]	; 0x84
        huart->RxISR = NULL;
 c00464a:	66e3      	str	r3, [r4, #108]	; 0x6c
        HAL_UART_RxCpltCallback(huart);
 c00464c:	f7ff ff60 	bl	c004510 <HAL_UART_RxCpltCallback>
    for (nb_rx_data = huart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
 c004650:	3d01      	subs	r5, #1
 c004652:	b2ad      	uxth	r5, r5
 c004654:	e7c6      	b.n	c0045e4 <UART_RxISR_8BIT_FIFOEN+0x1c>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c004656:	6802      	ldr	r2, [r0, #0]
 c004658:	6993      	ldr	r3, [r2, #24]
 c00465a:	f043 0308 	orr.w	r3, r3, #8
 c00465e:	6193      	str	r3, [r2, #24]
}
 c004660:	e7d4      	b.n	c00460c <UART_RxISR_8BIT_FIFOEN+0x44>
 c004662:	bf00      	nop
 c004664:	effffffe 	.word	0xeffffffe
 c004668:	0c004513 	.word	0x0c004513

0c00466c <UART_RxISR_16BIT_FIFOEN>:
  uint16_t  uhdata;
  uint16_t   nb_rx_data;
  uint16_t  rxdatacount;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c00466c:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 c004670:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c004674:	2b22      	cmp	r3, #34	; 0x22
{
 c004676:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c004678:	d13d      	bne.n	c0046f6 <UART_RxISR_16BIT_FIFOEN+0x8a>

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) and RX FIFO Threshold interrupt */
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 c00467a:	f04f 0820 	mov.w	r8, #32
  uint16_t  uhMask = huart->Mask;
 c00467e:	f8b0 6060 	ldrh.w	r6, [r0, #96]	; 0x60
    for (nb_rx_data = huart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
 c004682:	f8b0 5068 	ldrh.w	r5, [r0, #104]	; 0x68
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c004686:	4f1f      	ldr	r7, [pc, #124]	; (c004704 <UART_RxISR_16BIT_FIFOEN+0x98>)
    for (nb_rx_data = huart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
 c004688:	b9a5      	cbnz	r5, c0046b4 <UART_RxISR_16BIT_FIFOEN+0x48>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 c00468a:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 c00468e:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 c004690:	b173      	cbz	r3, c0046b0 <UART_RxISR_16BIT_FIFOEN+0x44>
 c004692:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 c004696:	429a      	cmp	r2, r3
 c004698:	d90a      	bls.n	c0046b0 <UART_RxISR_16BIT_FIFOEN+0x44>
    {
      /* Disable the UART RXFT interrupt*/
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 c00469a:	6823      	ldr	r3, [r4, #0]
 c00469c:	689a      	ldr	r2, [r3, #8]
 c00469e:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 c0046a2:	609a      	str	r2, [r3, #8]

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_16BIT;
 c0046a4:	4a18      	ldr	r2, [pc, #96]	; (c004708 <UART_RxISR_16BIT_FIFOEN+0x9c>)
 c0046a6:	66e2      	str	r2, [r4, #108]	; 0x6c

      /* Enable the UART Data Register Not Empty interrupt */
      SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 c0046a8:	681a      	ldr	r2, [r3, #0]
 c0046aa:	f042 0220 	orr.w	r2, r2, #32
 c0046ae:	601a      	str	r2, [r3, #0]
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c0046b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c0046b4:	6823      	ldr	r3, [r4, #0]
      *tmp = (uint16_t)(uhdata & uhMask);
 c0046b6:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c0046b8:	6a59      	ldr	r1, [r3, #36]	; 0x24
      *tmp = (uint16_t)(uhdata & uhMask);
 c0046ba:	4031      	ands	r1, r6
 c0046bc:	f822 1b02 	strh.w	r1, [r2], #2
      huart->pRxBuffPtr += 2U;
 c0046c0:	65a2      	str	r2, [r4, #88]	; 0x58
      huart->RxXferCount--;
 c0046c2:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 c0046c6:	3a01      	subs	r2, #1
 c0046c8:	b292      	uxth	r2, r2
 c0046ca:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
      if (huart->RxXferCount == 0U)
 c0046ce:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 c0046d2:	b292      	uxth	r2, r2
 c0046d4:	b962      	cbnz	r2, c0046f0 <UART_RxISR_16BIT_FIFOEN+0x84>
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c0046d6:	6819      	ldr	r1, [r3, #0]
        HAL_UART_RxCpltCallback(huart);
 c0046d8:	4620      	mov	r0, r4
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c0046da:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 c0046de:	6019      	str	r1, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c0046e0:	6899      	ldr	r1, [r3, #8]
 c0046e2:	4039      	ands	r1, r7
 c0046e4:	6099      	str	r1, [r3, #8]
        huart->RxState = HAL_UART_STATE_READY;
 c0046e6:	f8c4 8084 	str.w	r8, [r4, #132]	; 0x84
        huart->RxISR = NULL;
 c0046ea:	66e2      	str	r2, [r4, #108]	; 0x6c
        HAL_UART_RxCpltCallback(huart);
 c0046ec:	f7ff ff10 	bl	c004510 <HAL_UART_RxCpltCallback>
    for (nb_rx_data = huart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
 c0046f0:	3d01      	subs	r5, #1
 c0046f2:	b2ad      	uxth	r5, r5
 c0046f4:	e7c8      	b.n	c004688 <UART_RxISR_16BIT_FIFOEN+0x1c>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c0046f6:	6802      	ldr	r2, [r0, #0]
 c0046f8:	6993      	ldr	r3, [r2, #24]
 c0046fa:	f043 0308 	orr.w	r3, r3, #8
 c0046fe:	6193      	str	r3, [r2, #24]
}
 c004700:	e7d6      	b.n	c0046b0 <UART_RxISR_16BIT_FIFOEN+0x44>
 c004702:	bf00      	nop
 c004704:	effffffe 	.word	0xeffffffe
 c004708:	0c00456f 	.word	0x0c00456f
 c00470c:	00000000 	.word	0x00000000

0c004710 <UART_SetConfig>:
{
 c004710:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
 c004714:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
 c004716:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c004718:	69c1      	ldr	r1, [r0, #28]
 c00471a:	6882      	ldr	r2, [r0, #8]
 c00471c:	6900      	ldr	r0, [r0, #16]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 c00471e:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c004720:	4302      	orrs	r2, r0
 c004722:	6960      	ldr	r0, [r4, #20]
 c004724:	4302      	orrs	r2, r0
  tmpreg |= (uint32_t)huart->FifoMode;
 c004726:	6e60      	ldr	r0, [r4, #100]	; 0x64
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c004728:	430a      	orrs	r2, r1
  tmpreg |= (uint32_t)huart->FifoMode;
 c00472a:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 c00472c:	48ad      	ldr	r0, [pc, #692]	; (c0049e4 <UART_SetConfig+0x2d4>)
 c00472e:	4028      	ands	r0, r5
 c004730:	4302      	orrs	r2, r0
 c004732:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 c004734:	685a      	ldr	r2, [r3, #4]
 c004736:	68e0      	ldr	r0, [r4, #12]
 c004738:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 c00473c:	4302      	orrs	r2, r0
 c00473e:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 c004740:	4aa9      	ldr	r2, [pc, #676]	; (c0049e8 <UART_SetConfig+0x2d8>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 c004742:	69a0      	ldr	r0, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 c004744:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
 c004746:	bf1c      	itt	ne
 c004748:	6a22      	ldrne	r2, [r4, #32]
 c00474a:	4310      	orrne	r0, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 c00474c:	689a      	ldr	r2, [r3, #8]
 c00474e:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 c004752:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 c004756:	4302      	orrs	r2, r0
 c004758:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 c00475a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 c00475c:	6a60      	ldr	r0, [r4, #36]	; 0x24
 c00475e:	f022 020f 	bic.w	r2, r2, #15
 c004762:	4302      	orrs	r2, r0
 c004764:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 c004766:	4aa1      	ldr	r2, [pc, #644]	; (c0049ec <UART_SetConfig+0x2dc>)
 c004768:	4293      	cmp	r3, r2
 c00476a:	d118      	bne.n	c00479e <UART_SetConfig+0x8e>
 c00476c:	4ba0      	ldr	r3, [pc, #640]	; (c0049f0 <UART_SetConfig+0x2e0>)
 c00476e:	4aa1      	ldr	r2, [pc, #644]	; (c0049f4 <UART_SetConfig+0x2e4>)
 c004770:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 c004774:	f003 0303 	and.w	r3, r3, #3
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c004778:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 c00477c:	5cd3      	ldrb	r3, [r2, r3]
 c00477e:	f040 8494 	bne.w	c0050aa <UART_SetConfig+0x99a>
    switch (clocksource)
 c004782:	2b08      	cmp	r3, #8
 c004784:	f200 82a5 	bhi.w	c004cd2 <UART_SetConfig+0x5c2>
 c004788:	e8df f013 	tbh	[pc, r3, lsl #1]
 c00478c:	0253045d 	.word	0x0253045d
 c004790:	02a303b5 	.word	0x02a303b5
 c004794:	02a30425 	.word	0x02a30425
 c004798:	02a302a3 	.word	0x02a302a3
 c00479c:	042c      	.short	0x042c
  UART_GETCLOCKSOURCE(huart, clocksource);
 c00479e:	4a96      	ldr	r2, [pc, #600]	; (c0049f8 <UART_SetConfig+0x2e8>)
 c0047a0:	4293      	cmp	r3, r2
 c0047a2:	d106      	bne.n	c0047b2 <UART_SetConfig+0xa2>
 c0047a4:	4b92      	ldr	r3, [pc, #584]	; (c0049f0 <UART_SetConfig+0x2e0>)
 c0047a6:	4a95      	ldr	r2, [pc, #596]	; (c0049fc <UART_SetConfig+0x2ec>)
 c0047a8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 c0047ac:	f003 030c 	and.w	r3, r3, #12
 c0047b0:	e7e2      	b.n	c004778 <UART_SetConfig+0x68>
 c0047b2:	4a93      	ldr	r2, [pc, #588]	; (c004a00 <UART_SetConfig+0x2f0>)
 c0047b4:	4293      	cmp	r3, r2
 c0047b6:	d144      	bne.n	c004842 <UART_SetConfig+0x132>
 c0047b8:	f502 32e4 	add.w	r2, r2, #116736	; 0x1c800
 c0047bc:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 c0047c0:	f002 0230 	and.w	r2, r2, #48	; 0x30
 c0047c4:	2a10      	cmp	r2, #16
 c0047c6:	f000 83fe 	beq.w	c004fc6 <UART_SetConfig+0x8b6>
 c0047ca:	d82a      	bhi.n	c004822 <UART_SetConfig+0x112>
 c0047cc:	bb7a      	cbnz	r2, c00482e <UART_SetConfig+0x11e>
  if (UART_INSTANCE_LOWPOWER(huart))
 c0047ce:	4a86      	ldr	r2, [pc, #536]	; (c0049e8 <UART_SetConfig+0x2d8>)
 c0047d0:	4293      	cmp	r3, r2
 c0047d2:	f040 8434 	bne.w	c00503e <UART_SetConfig+0x92e>
        lpuart_ker_ck_pres = (HAL_RCC_GetPCLK1Freq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 c0047d6:	f7ff f975 	bl	c003ac4 <HAL_RCC_GetPCLK1Freq>
 c0047da:	6a63      	ldr	r3, [r4, #36]	; 0x24
 c0047dc:	2b00      	cmp	r3, #0
 c0047de:	d06b      	beq.n	c0048b8 <UART_SetConfig+0x1a8>
 c0047e0:	2b01      	cmp	r3, #1
 c0047e2:	d06b      	beq.n	c0048bc <UART_SetConfig+0x1ac>
 c0047e4:	2b02      	cmp	r3, #2
 c0047e6:	d06b      	beq.n	c0048c0 <UART_SetConfig+0x1b0>
 c0047e8:	2b03      	cmp	r3, #3
 c0047ea:	d06b      	beq.n	c0048c4 <UART_SetConfig+0x1b4>
 c0047ec:	2b04      	cmp	r3, #4
 c0047ee:	d06b      	beq.n	c0048c8 <UART_SetConfig+0x1b8>
 c0047f0:	2b05      	cmp	r3, #5
 c0047f2:	d06b      	beq.n	c0048cc <UART_SetConfig+0x1bc>
 c0047f4:	2b06      	cmp	r3, #6
 c0047f6:	d06b      	beq.n	c0048d0 <UART_SetConfig+0x1c0>
 c0047f8:	2b07      	cmp	r3, #7
 c0047fa:	d06b      	beq.n	c0048d4 <UART_SetConfig+0x1c4>
 c0047fc:	2b08      	cmp	r3, #8
 c0047fe:	d06b      	beq.n	c0048d8 <UART_SetConfig+0x1c8>
 c004800:	2b09      	cmp	r3, #9
 c004802:	d06b      	beq.n	c0048dc <UART_SetConfig+0x1cc>
 c004804:	2b0a      	cmp	r3, #10
 c004806:	d06b      	beq.n	c0048e0 <UART_SetConfig+0x1d0>
 c004808:	2b0b      	cmp	r3, #11
 c00480a:	bf14      	ite	ne
 c00480c:	2301      	movne	r3, #1
 c00480e:	f44f 7380 	moveq.w	r3, #256	; 0x100
 c004812:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 c004816:	2100      	movs	r1, #0
    if (lpuart_ker_ck_pres != 0U)
 c004818:	2800      	cmp	r0, #0
 c00481a:	f040 8082 	bne.w	c004922 <UART_SetConfig+0x212>
 c00481e:	4602      	mov	r2, r0
 c004820:	e086      	b.n	c004930 <UART_SetConfig+0x220>
  UART_GETCLOCKSOURCE(huart, clocksource);
 c004822:	2a20      	cmp	r2, #32
 c004824:	f000 835f 	beq.w	c004ee6 <UART_SetConfig+0x7d6>
 c004828:	2a30      	cmp	r2, #48	; 0x30
 c00482a:	f000 83a1 	beq.w	c004f70 <UART_SetConfig+0x860>
  if (UART_INSTANCE_LOWPOWER(huart))
 c00482e:	4a6e      	ldr	r2, [pc, #440]	; (c0049e8 <UART_SetConfig+0x2d8>)
 c004830:	4293      	cmp	r3, r2
 c004832:	d07c      	beq.n	c00492e <UART_SetConfig+0x21e>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c004834:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 c004838:	f000 824b 	beq.w	c004cd2 <UART_SetConfig+0x5c2>
        ret = HAL_ERROR;
 c00483c:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 c00483e:	2300      	movs	r3, #0
 c004840:	e2d7      	b.n	c004df2 <UART_SetConfig+0x6e2>
  UART_GETCLOCKSOURCE(huart, clocksource);
 c004842:	4a70      	ldr	r2, [pc, #448]	; (c004a04 <UART_SetConfig+0x2f4>)
 c004844:	4293      	cmp	r3, r2
 c004846:	d10e      	bne.n	c004866 <UART_SetConfig+0x156>
 c004848:	f502 32e2 	add.w	r2, r2, #115712	; 0x1c400
 c00484c:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 c004850:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 c004854:	2a40      	cmp	r2, #64	; 0x40
 c004856:	f000 83b6 	beq.w	c004fc6 <UART_SetConfig+0x8b6>
 c00485a:	d9b7      	bls.n	c0047cc <UART_SetConfig+0xbc>
 c00485c:	2a80      	cmp	r2, #128	; 0x80
 c00485e:	f000 8342 	beq.w	c004ee6 <UART_SetConfig+0x7d6>
 c004862:	2ac0      	cmp	r2, #192	; 0xc0
 c004864:	e7e1      	b.n	c00482a <UART_SetConfig+0x11a>
 c004866:	f1b3 2f50 	cmp.w	r3, #1342197760	; 0x50005000
 c00486a:	d110      	bne.n	c00488e <UART_SetConfig+0x17e>
 c00486c:	4a60      	ldr	r2, [pc, #384]	; (c0049f0 <UART_SetConfig+0x2e0>)
 c00486e:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 c004872:	f402 7240 	and.w	r2, r2, #768	; 0x300
 c004876:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 c00487a:	f000 83a4 	beq.w	c004fc6 <UART_SetConfig+0x8b6>
 c00487e:	d9a5      	bls.n	c0047cc <UART_SetConfig+0xbc>
 c004880:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 c004884:	f000 832f 	beq.w	c004ee6 <UART_SetConfig+0x7d6>
 c004888:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 c00488c:	e7cd      	b.n	c00482a <UART_SetConfig+0x11a>
 c00488e:	4a56      	ldr	r2, [pc, #344]	; (c0049e8 <UART_SetConfig+0x2d8>)
 c004890:	4293      	cmp	r3, r2
 c004892:	d1cf      	bne.n	c004834 <UART_SetConfig+0x124>
 c004894:	f502 32c8 	add.w	r2, r2, #102400	; 0x19000
 c004898:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 c00489c:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 c0048a0:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 c0048a4:	f000 838f 	beq.w	c004fc6 <UART_SetConfig+0x8b6>
 c0048a8:	d990      	bls.n	c0047cc <UART_SetConfig+0xbc>
 c0048aa:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 c0048ae:	f000 831a 	beq.w	c004ee6 <UART_SetConfig+0x7d6>
 c0048b2:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 c0048b6:	e7b8      	b.n	c00482a <UART_SetConfig+0x11a>
        lpuart_ker_ck_pres = (HAL_RCC_GetPCLK1Freq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 c0048b8:	2301      	movs	r3, #1
 c0048ba:	e7aa      	b.n	c004812 <UART_SetConfig+0x102>
 c0048bc:	2302      	movs	r3, #2
 c0048be:	e7a8      	b.n	c004812 <UART_SetConfig+0x102>
 c0048c0:	2304      	movs	r3, #4
 c0048c2:	e7a6      	b.n	c004812 <UART_SetConfig+0x102>
 c0048c4:	2306      	movs	r3, #6
 c0048c6:	e7a4      	b.n	c004812 <UART_SetConfig+0x102>
 c0048c8:	2308      	movs	r3, #8
 c0048ca:	e7a2      	b.n	c004812 <UART_SetConfig+0x102>
 c0048cc:	230a      	movs	r3, #10
 c0048ce:	e7a0      	b.n	c004812 <UART_SetConfig+0x102>
 c0048d0:	230c      	movs	r3, #12
 c0048d2:	e79e      	b.n	c004812 <UART_SetConfig+0x102>
 c0048d4:	2310      	movs	r3, #16
 c0048d6:	e79c      	b.n	c004812 <UART_SetConfig+0x102>
 c0048d8:	2320      	movs	r3, #32
 c0048da:	e79a      	b.n	c004812 <UART_SetConfig+0x102>
 c0048dc:	2340      	movs	r3, #64	; 0x40
 c0048de:	e798      	b.n	c004812 <UART_SetConfig+0x102>
 c0048e0:	2380      	movs	r3, #128	; 0x80
 c0048e2:	e796      	b.n	c004812 <UART_SetConfig+0x102>
        lpuart_ker_ck_pres = ((uint32_t)HSI_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 c0048e4:	2800      	cmp	r0, #0
 c0048e6:	d063      	beq.n	c0049b0 <UART_SetConfig+0x2a0>
 c0048e8:	2801      	cmp	r0, #1
 c0048ea:	d064      	beq.n	c0049b6 <UART_SetConfig+0x2a6>
 c0048ec:	2802      	cmp	r0, #2
 c0048ee:	d065      	beq.n	c0049bc <UART_SetConfig+0x2ac>
 c0048f0:	2803      	cmp	r0, #3
 c0048f2:	f04f 0102 	mov.w	r1, #2
 c0048f6:	d064      	beq.n	c0049c2 <UART_SetConfig+0x2b2>
 c0048f8:	2804      	cmp	r0, #4
 c0048fa:	d064      	beq.n	c0049c6 <UART_SetConfig+0x2b6>
 c0048fc:	2805      	cmp	r0, #5
 c0048fe:	d064      	beq.n	c0049ca <UART_SetConfig+0x2ba>
 c004900:	2806      	cmp	r0, #6
 c004902:	d064      	beq.n	c0049ce <UART_SetConfig+0x2be>
 c004904:	2807      	cmp	r0, #7
 c004906:	d064      	beq.n	c0049d2 <UART_SetConfig+0x2c2>
 c004908:	2808      	cmp	r0, #8
 c00490a:	d064      	beq.n	c0049d6 <UART_SetConfig+0x2c6>
 c00490c:	2809      	cmp	r0, #9
 c00490e:	d064      	beq.n	c0049da <UART_SetConfig+0x2ca>
 c004910:	280a      	cmp	r0, #10
 c004912:	d064      	beq.n	c0049de <UART_SetConfig+0x2ce>
 c004914:	f24f 4224 	movw	r2, #62500	; 0xf424
 c004918:	4b3b      	ldr	r3, [pc, #236]	; (c004a08 <UART_SetConfig+0x2f8>)
 c00491a:	280b      	cmp	r0, #11
 c00491c:	bf14      	ite	ne
 c00491e:	4618      	movne	r0, r3
 c004920:	4610      	moveq	r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 c004922:	6862      	ldr	r2, [r4, #4]
 c004924:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 c004928:	4283      	cmp	r3, r0
 c00492a:	f240 80a4 	bls.w	c004a76 <UART_SetConfig+0x366>
        ret = HAL_ERROR;
 c00492e:	2201      	movs	r2, #1
  huart->NbTxDataToProcess = 1;
 c004930:	2300      	movs	r3, #0
 c004932:	f04f 1101 	mov.w	r1, #65537	; 0x10001
  huart->RxISR = NULL;
 c004936:	6723      	str	r3, [r4, #112]	; 0x70
  huart->NbTxDataToProcess = 1;
 c004938:	e9c4 131a 	strd	r1, r3, [r4, #104]	; 0x68
}
 c00493c:	4610      	mov	r0, r2
 c00493e:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
        lpuart_ker_ck_pres = (HAL_RCC_GetSysClockFreq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 c004942:	f7fe fc73 	bl	c00322c <HAL_RCC_GetSysClockFreq>
 c004946:	6a63      	ldr	r3, [r4, #36]	; 0x24
 c004948:	b1e3      	cbz	r3, c004984 <UART_SetConfig+0x274>
 c00494a:	2b01      	cmp	r3, #1
 c00494c:	d01c      	beq.n	c004988 <UART_SetConfig+0x278>
 c00494e:	2b02      	cmp	r3, #2
 c004950:	d01c      	beq.n	c00498c <UART_SetConfig+0x27c>
 c004952:	2b03      	cmp	r3, #3
 c004954:	d01c      	beq.n	c004990 <UART_SetConfig+0x280>
 c004956:	2b04      	cmp	r3, #4
 c004958:	d01c      	beq.n	c004994 <UART_SetConfig+0x284>
 c00495a:	2b05      	cmp	r3, #5
 c00495c:	d01c      	beq.n	c004998 <UART_SetConfig+0x288>
 c00495e:	2b06      	cmp	r3, #6
 c004960:	d01c      	beq.n	c00499c <UART_SetConfig+0x28c>
 c004962:	2b07      	cmp	r3, #7
 c004964:	d01c      	beq.n	c0049a0 <UART_SetConfig+0x290>
 c004966:	2b08      	cmp	r3, #8
 c004968:	d01c      	beq.n	c0049a4 <UART_SetConfig+0x294>
 c00496a:	2b09      	cmp	r3, #9
 c00496c:	d01c      	beq.n	c0049a8 <UART_SetConfig+0x298>
 c00496e:	2b0a      	cmp	r3, #10
 c004970:	d01c      	beq.n	c0049ac <UART_SetConfig+0x29c>
 c004972:	2b0b      	cmp	r3, #11
 c004974:	bf14      	ite	ne
 c004976:	2301      	movne	r3, #1
 c004978:	f44f 7380 	moveq.w	r3, #256	; 0x100
 c00497c:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 c004980:	2104      	movs	r1, #4
 c004982:	e749      	b.n	c004818 <UART_SetConfig+0x108>
        lpuart_ker_ck_pres = (HAL_RCC_GetSysClockFreq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 c004984:	2301      	movs	r3, #1
 c004986:	e7f9      	b.n	c00497c <UART_SetConfig+0x26c>
 c004988:	2302      	movs	r3, #2
 c00498a:	e7f7      	b.n	c00497c <UART_SetConfig+0x26c>
 c00498c:	2304      	movs	r3, #4
 c00498e:	e7f5      	b.n	c00497c <UART_SetConfig+0x26c>
 c004990:	2306      	movs	r3, #6
 c004992:	e7f3      	b.n	c00497c <UART_SetConfig+0x26c>
 c004994:	2308      	movs	r3, #8
 c004996:	e7f1      	b.n	c00497c <UART_SetConfig+0x26c>
 c004998:	230a      	movs	r3, #10
 c00499a:	e7ef      	b.n	c00497c <UART_SetConfig+0x26c>
 c00499c:	230c      	movs	r3, #12
 c00499e:	e7ed      	b.n	c00497c <UART_SetConfig+0x26c>
 c0049a0:	2310      	movs	r3, #16
 c0049a2:	e7eb      	b.n	c00497c <UART_SetConfig+0x26c>
 c0049a4:	2320      	movs	r3, #32
 c0049a6:	e7e9      	b.n	c00497c <UART_SetConfig+0x26c>
 c0049a8:	2340      	movs	r3, #64	; 0x40
 c0049aa:	e7e7      	b.n	c00497c <UART_SetConfig+0x26c>
 c0049ac:	2380      	movs	r3, #128	; 0x80
 c0049ae:	e7e5      	b.n	c00497c <UART_SetConfig+0x26c>
 c0049b0:	2102      	movs	r1, #2
        lpuart_ker_ck_pres = ((uint32_t)HSI_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 c0049b2:	4815      	ldr	r0, [pc, #84]	; (c004a08 <UART_SetConfig+0x2f8>)
 c0049b4:	e7b5      	b.n	c004922 <UART_SetConfig+0x212>
 c0049b6:	2102      	movs	r1, #2
 c0049b8:	4814      	ldr	r0, [pc, #80]	; (c004a0c <UART_SetConfig+0x2fc>)
 c0049ba:	e7b2      	b.n	c004922 <UART_SetConfig+0x212>
 c0049bc:	4601      	mov	r1, r0
 c0049be:	4814      	ldr	r0, [pc, #80]	; (c004a10 <UART_SetConfig+0x300>)
 c0049c0:	e7af      	b.n	c004922 <UART_SetConfig+0x212>
 c0049c2:	4814      	ldr	r0, [pc, #80]	; (c004a14 <UART_SetConfig+0x304>)
 c0049c4:	e7ad      	b.n	c004922 <UART_SetConfig+0x212>
 c0049c6:	4814      	ldr	r0, [pc, #80]	; (c004a18 <UART_SetConfig+0x308>)
 c0049c8:	e7ab      	b.n	c004922 <UART_SetConfig+0x212>
 c0049ca:	4814      	ldr	r0, [pc, #80]	; (c004a1c <UART_SetConfig+0x30c>)
 c0049cc:	e7a9      	b.n	c004922 <UART_SetConfig+0x212>
 c0049ce:	4814      	ldr	r0, [pc, #80]	; (c004a20 <UART_SetConfig+0x310>)
 c0049d0:	e7a7      	b.n	c004922 <UART_SetConfig+0x212>
 c0049d2:	4814      	ldr	r0, [pc, #80]	; (c004a24 <UART_SetConfig+0x314>)
 c0049d4:	e7a5      	b.n	c004922 <UART_SetConfig+0x212>
 c0049d6:	4814      	ldr	r0, [pc, #80]	; (c004a28 <UART_SetConfig+0x318>)
 c0049d8:	e7a3      	b.n	c004922 <UART_SetConfig+0x212>
 c0049da:	4814      	ldr	r0, [pc, #80]	; (c004a2c <UART_SetConfig+0x31c>)
 c0049dc:	e7a1      	b.n	c004922 <UART_SetConfig+0x212>
 c0049de:	4814      	ldr	r0, [pc, #80]	; (c004a30 <UART_SetConfig+0x320>)
 c0049e0:	e79f      	b.n	c004922 <UART_SetConfig+0x212>
 c0049e2:	bf00      	nop
 c0049e4:	cfff69f3 	.word	0xcfff69f3
 c0049e8:	50008000 	.word	0x50008000
 c0049ec:	50013800 	.word	0x50013800
 c0049f0:	50021000 	.word	0x50021000
 c0049f4:	0c00a58d 	.word	0x0c00a58d
 c0049f8:	50004400 	.word	0x50004400
 c0049fc:	0c00a591 	.word	0x0c00a591
 c004a00:	50004800 	.word	0x50004800
 c004a04:	50004c00 	.word	0x50004c00
 c004a08:	00f42400 	.word	0x00f42400
 c004a0c:	007a1200 	.word	0x007a1200
 c004a10:	003d0900 	.word	0x003d0900
 c004a14:	0028b0aa 	.word	0x0028b0aa
 c004a18:	001e8480 	.word	0x001e8480
 c004a1c:	00186a00 	.word	0x00186a00
 c004a20:	00145855 	.word	0x00145855
 c004a24:	000f4240 	.word	0x000f4240
 c004a28:	0007a120 	.word	0x0007a120
 c004a2c:	0003d090 	.word	0x0003d090
 c004a30:	0001e848 	.word	0x0001e848
        lpuart_ker_ck_pres = ((uint32_t)LSE_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 c004a34:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 c004a38:	e773      	b.n	c004922 <UART_SetConfig+0x212>
 c004a3a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 c004a3e:	e770      	b.n	c004922 <UART_SetConfig+0x212>
 c004a40:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 c004a44:	e76d      	b.n	c004922 <UART_SetConfig+0x212>
 c004a46:	f241 5055 	movw	r0, #5461	; 0x1555
 c004a4a:	e76a      	b.n	c004922 <UART_SetConfig+0x212>
 c004a4c:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 c004a50:	e767      	b.n	c004922 <UART_SetConfig+0x212>
 c004a52:	f640 40cc 	movw	r0, #3276	; 0xccc
 c004a56:	e764      	b.n	c004922 <UART_SetConfig+0x212>
 c004a58:	f640 20aa 	movw	r0, #2730	; 0xaaa
 c004a5c:	e761      	b.n	c004922 <UART_SetConfig+0x212>
 c004a5e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 c004a62:	e75e      	b.n	c004922 <UART_SetConfig+0x212>
 c004a64:	f44f 6080 	mov.w	r0, #1024	; 0x400
 c004a68:	e75b      	b.n	c004922 <UART_SetConfig+0x212>
 c004a6a:	f44f 7000 	mov.w	r0, #512	; 0x200
 c004a6e:	e758      	b.n	c004922 <UART_SetConfig+0x212>
 c004a70:	f44f 7080 	mov.w	r0, #256	; 0x100
 c004a74:	e755      	b.n	c004922 <UART_SetConfig+0x212>
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 c004a76:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
 c004a7a:	f63f af58 	bhi.w	c00492e <UART_SetConfig+0x21e>
        switch (clocksource)
 c004a7e:	2908      	cmp	r1, #8
 c004a80:	f200 80d4 	bhi.w	c004c2c <UART_SetConfig+0x51c>
 c004a84:	e8df f001 	tbb	[pc, r1]
 c004a88:	d2444105 	.word	0xd2444105
 c004a8c:	d2d2d280 	.word	0xd2d2d280
 c004a90:	99          	.byte	0x99
 c004a91:	00          	.byte	0x00
            pclk = HAL_RCC_GetPCLK1Freq();
 c004a92:	f7ff f817 	bl	c003ac4 <HAL_RCC_GetPCLK1Freq>
            usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004a96:	6a63      	ldr	r3, [r4, #36]	; 0x24
 c004a98:	2b00      	cmp	r3, #0
 c004a9a:	f000 808c 	beq.w	c004bb6 <UART_SetConfig+0x4a6>
 c004a9e:	2b01      	cmp	r3, #1
 c004aa0:	d075      	beq.n	c004b8e <UART_SetConfig+0x47e>
 c004aa2:	2b02      	cmp	r3, #2
 c004aa4:	d075      	beq.n	c004b92 <UART_SetConfig+0x482>
 c004aa6:	2b03      	cmp	r3, #3
 c004aa8:	d075      	beq.n	c004b96 <UART_SetConfig+0x486>
 c004aaa:	2b04      	cmp	r3, #4
 c004aac:	d075      	beq.n	c004b9a <UART_SetConfig+0x48a>
 c004aae:	2b05      	cmp	r3, #5
 c004ab0:	d075      	beq.n	c004b9e <UART_SetConfig+0x48e>
 c004ab2:	2b06      	cmp	r3, #6
 c004ab4:	d075      	beq.n	c004ba2 <UART_SetConfig+0x492>
 c004ab6:	2b07      	cmp	r3, #7
 c004ab8:	d075      	beq.n	c004ba6 <UART_SetConfig+0x496>
 c004aba:	2b08      	cmp	r3, #8
 c004abc:	d075      	beq.n	c004baa <UART_SetConfig+0x49a>
 c004abe:	2b09      	cmp	r3, #9
 c004ac0:	d075      	beq.n	c004bae <UART_SetConfig+0x49e>
 c004ac2:	2b0a      	cmp	r3, #10
 c004ac4:	d075      	beq.n	c004bb2 <UART_SetConfig+0x4a2>
 c004ac6:	2b0b      	cmp	r3, #11
 c004ac8:	d175      	bne.n	c004bb6 <UART_SetConfig+0x4a6>
 c004aca:	f44f 7280 	mov.w	r2, #256	; 0x100
 c004ace:	2300      	movs	r3, #0
 c004ad0:	2100      	movs	r1, #0
 c004ad2:	f004 ff7b 	bl	c0099cc <__aeabi_uldivmod>
 c004ad6:	6865      	ldr	r5, [r4, #4]
 c004ad8:	020f      	lsls	r7, r1, #8
 c004ada:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 c004ade:	0206      	lsls	r6, r0, #8
 c004ae0:	0868      	lsrs	r0, r5, #1
 c004ae2:	eb16 0b00 	adds.w	fp, r6, r0
 c004ae6:	f147 0c00 	adc.w	ip, r7, #0
 c004aea:	462a      	mov	r2, r5
 c004aec:	2300      	movs	r3, #0
 c004aee:	4658      	mov	r0, fp
 c004af0:	4661      	mov	r1, ip
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004af2:	f004 ff6b 	bl	c0099cc <__aeabi_uldivmod>
            break;
 c004af6:	2200      	movs	r2, #0
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 c004af8:	4b95      	ldr	r3, [pc, #596]	; (c004d50 <UART_SetConfig+0x640>)
 c004afa:	f5a0 7140 	sub.w	r1, r0, #768	; 0x300
 c004afe:	4299      	cmp	r1, r3
 c004b00:	f63f af15 	bhi.w	c00492e <UART_SetConfig+0x21e>
          huart->Instance->BRR = usartdiv;
 c004b04:	6823      	ldr	r3, [r4, #0]
 c004b06:	60d8      	str	r0, [r3, #12]
 c004b08:	e712      	b.n	c004930 <UART_SetConfig+0x220>
            pclk = HAL_RCC_GetPCLK2Freq();
 c004b0a:	f7fe ffef 	bl	c003aec <HAL_RCC_GetPCLK2Freq>
 c004b0e:	e7c2      	b.n	c004a96 <UART_SetConfig+0x386>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004b10:	6a63      	ldr	r3, [r4, #36]	; 0x24
 c004b12:	2b00      	cmp	r3, #0
 c004b14:	d036      	beq.n	c004b84 <UART_SetConfig+0x474>
 c004b16:	2b01      	cmp	r3, #1
 c004b18:	d016      	beq.n	c004b48 <UART_SetConfig+0x438>
 c004b1a:	2b02      	cmp	r3, #2
 c004b1c:	d016      	beq.n	c004b4c <UART_SetConfig+0x43c>
 c004b1e:	2b03      	cmp	r3, #3
 c004b20:	d016      	beq.n	c004b50 <UART_SetConfig+0x440>
 c004b22:	2b04      	cmp	r3, #4
 c004b24:	d01e      	beq.n	c004b64 <UART_SetConfig+0x454>
 c004b26:	2b05      	cmp	r3, #5
 c004b28:	d01e      	beq.n	c004b68 <UART_SetConfig+0x458>
 c004b2a:	2b06      	cmp	r3, #6
 c004b2c:	d01e      	beq.n	c004b6c <UART_SetConfig+0x45c>
 c004b2e:	2b07      	cmp	r3, #7
 c004b30:	d020      	beq.n	c004b74 <UART_SetConfig+0x464>
 c004b32:	2b08      	cmp	r3, #8
 c004b34:	d020      	beq.n	c004b78 <UART_SetConfig+0x468>
 c004b36:	2b09      	cmp	r3, #9
 c004b38:	d020      	beq.n	c004b7c <UART_SetConfig+0x46c>
 c004b3a:	2b0a      	cmp	r3, #10
 c004b3c:	d020      	beq.n	c004b80 <UART_SetConfig+0x470>
 c004b3e:	2b0b      	cmp	r3, #11
 c004b40:	d120      	bne.n	c004b84 <UART_SetConfig+0x474>
 c004b42:	4e84      	ldr	r6, [pc, #528]	; (c004d54 <UART_SetConfig+0x644>)
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004b44:	2700      	movs	r7, #0
 c004b46:	e006      	b.n	c004b56 <UART_SetConfig+0x446>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004b48:	4e83      	ldr	r6, [pc, #524]	; (c004d58 <UART_SetConfig+0x648>)
 c004b4a:	e7fb      	b.n	c004b44 <UART_SetConfig+0x434>
 c004b4c:	4e83      	ldr	r6, [pc, #524]	; (c004d5c <UART_SetConfig+0x64c>)
 c004b4e:	e7f9      	b.n	c004b44 <UART_SetConfig+0x434>
 c004b50:	a77b      	add	r7, pc, #492	; (adr r7, c004d40 <UART_SetConfig+0x630>)
 c004b52:	e9d7 6700 	ldrd	r6, r7, [r7]
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004b56:	0855      	lsrs	r5, r2, #1
 c004b58:	1970      	adds	r0, r6, r5
 c004b5a:	f04f 0300 	mov.w	r3, #0
 c004b5e:	f147 0100 	adc.w	r1, r7, #0
 c004b62:	e7c6      	b.n	c004af2 <UART_SetConfig+0x3e2>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004b64:	4e7e      	ldr	r6, [pc, #504]	; (c004d60 <UART_SetConfig+0x650>)
 c004b66:	e7ed      	b.n	c004b44 <UART_SetConfig+0x434>
 c004b68:	4e7e      	ldr	r6, [pc, #504]	; (c004d64 <UART_SetConfig+0x654>)
 c004b6a:	e7eb      	b.n	c004b44 <UART_SetConfig+0x434>
 c004b6c:	a776      	add	r7, pc, #472	; (adr r7, c004d48 <UART_SetConfig+0x638>)
 c004b6e:	e9d7 6700 	ldrd	r6, r7, [r7]
 c004b72:	e7f0      	b.n	c004b56 <UART_SetConfig+0x446>
 c004b74:	4e7c      	ldr	r6, [pc, #496]	; (c004d68 <UART_SetConfig+0x658>)
 c004b76:	e7e5      	b.n	c004b44 <UART_SetConfig+0x434>
 c004b78:	4e7c      	ldr	r6, [pc, #496]	; (c004d6c <UART_SetConfig+0x65c>)
 c004b7a:	e7e3      	b.n	c004b44 <UART_SetConfig+0x434>
 c004b7c:	4e7c      	ldr	r6, [pc, #496]	; (c004d70 <UART_SetConfig+0x660>)
 c004b7e:	e7e1      	b.n	c004b44 <UART_SetConfig+0x434>
 c004b80:	4e7c      	ldr	r6, [pc, #496]	; (c004d74 <UART_SetConfig+0x664>)
 c004b82:	e7df      	b.n	c004b44 <UART_SetConfig+0x434>
 c004b84:	4e7c      	ldr	r6, [pc, #496]	; (c004d78 <UART_SetConfig+0x668>)
 c004b86:	e7dd      	b.n	c004b44 <UART_SetConfig+0x434>
            pclk = HAL_RCC_GetSysClockFreq();
 c004b88:	f7fe fb50 	bl	c00322c <HAL_RCC_GetSysClockFreq>
 c004b8c:	e783      	b.n	c004a96 <UART_SetConfig+0x386>
            usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004b8e:	2202      	movs	r2, #2
 c004b90:	e79d      	b.n	c004ace <UART_SetConfig+0x3be>
 c004b92:	2204      	movs	r2, #4
 c004b94:	e79b      	b.n	c004ace <UART_SetConfig+0x3be>
 c004b96:	2206      	movs	r2, #6
 c004b98:	e799      	b.n	c004ace <UART_SetConfig+0x3be>
 c004b9a:	2208      	movs	r2, #8
 c004b9c:	e797      	b.n	c004ace <UART_SetConfig+0x3be>
 c004b9e:	220a      	movs	r2, #10
 c004ba0:	e795      	b.n	c004ace <UART_SetConfig+0x3be>
 c004ba2:	220c      	movs	r2, #12
 c004ba4:	e793      	b.n	c004ace <UART_SetConfig+0x3be>
 c004ba6:	2210      	movs	r2, #16
 c004ba8:	e791      	b.n	c004ace <UART_SetConfig+0x3be>
 c004baa:	2220      	movs	r2, #32
 c004bac:	e78f      	b.n	c004ace <UART_SetConfig+0x3be>
 c004bae:	2240      	movs	r2, #64	; 0x40
 c004bb0:	e78d      	b.n	c004ace <UART_SetConfig+0x3be>
 c004bb2:	2280      	movs	r2, #128	; 0x80
 c004bb4:	e78b      	b.n	c004ace <UART_SetConfig+0x3be>
 c004bb6:	2201      	movs	r2, #1
 c004bb8:	e789      	b.n	c004ace <UART_SetConfig+0x3be>
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004bba:	6a63      	ldr	r3, [r4, #36]	; 0x24
 c004bbc:	b39b      	cbz	r3, c004c26 <UART_SetConfig+0x516>
 c004bbe:	2b01      	cmp	r3, #1
 c004bc0:	d016      	beq.n	c004bf0 <UART_SetConfig+0x4e0>
 c004bc2:	2b02      	cmp	r3, #2
 c004bc4:	d017      	beq.n	c004bf6 <UART_SetConfig+0x4e6>
 c004bc6:	2b03      	cmp	r3, #3
 c004bc8:	d018      	beq.n	c004bfc <UART_SetConfig+0x4ec>
 c004bca:	2b04      	cmp	r3, #4
 c004bcc:	d018      	beq.n	c004c00 <UART_SetConfig+0x4f0>
 c004bce:	2b05      	cmp	r3, #5
 c004bd0:	d019      	beq.n	c004c06 <UART_SetConfig+0x4f6>
 c004bd2:	2b06      	cmp	r3, #6
 c004bd4:	d019      	beq.n	c004c0a <UART_SetConfig+0x4fa>
 c004bd6:	2b07      	cmp	r3, #7
 c004bd8:	d019      	beq.n	c004c0e <UART_SetConfig+0x4fe>
 c004bda:	2b08      	cmp	r3, #8
 c004bdc:	d01a      	beq.n	c004c14 <UART_SetConfig+0x504>
 c004bde:	2b09      	cmp	r3, #9
 c004be0:	d01b      	beq.n	c004c1a <UART_SetConfig+0x50a>
 c004be2:	2b0a      	cmp	r3, #10
 c004be4:	d01c      	beq.n	c004c20 <UART_SetConfig+0x510>
 c004be6:	2b0b      	cmp	r3, #11
 c004be8:	d11d      	bne.n	c004c26 <UART_SetConfig+0x516>
 c004bea:	f44f 4600 	mov.w	r6, #32768	; 0x8000
 c004bee:	e7a9      	b.n	c004b44 <UART_SetConfig+0x434>
 c004bf0:	f44f 0680 	mov.w	r6, #4194304	; 0x400000
 c004bf4:	e7a6      	b.n	c004b44 <UART_SetConfig+0x434>
 c004bf6:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
 c004bfa:	e7a3      	b.n	c004b44 <UART_SetConfig+0x434>
 c004bfc:	4e5f      	ldr	r6, [pc, #380]	; (c004d7c <UART_SetConfig+0x66c>)
 c004bfe:	e7a1      	b.n	c004b44 <UART_SetConfig+0x434>
 c004c00:	f44f 1680 	mov.w	r6, #1048576	; 0x100000
 c004c04:	e79e      	b.n	c004b44 <UART_SetConfig+0x434>
 c004c06:	4e5e      	ldr	r6, [pc, #376]	; (c004d80 <UART_SetConfig+0x670>)
 c004c08:	e79c      	b.n	c004b44 <UART_SetConfig+0x434>
 c004c0a:	4e5e      	ldr	r6, [pc, #376]	; (c004d84 <UART_SetConfig+0x674>)
 c004c0c:	e79a      	b.n	c004b44 <UART_SetConfig+0x434>
 c004c0e:	f44f 2600 	mov.w	r6, #524288	; 0x80000
 c004c12:	e797      	b.n	c004b44 <UART_SetConfig+0x434>
 c004c14:	f44f 2680 	mov.w	r6, #262144	; 0x40000
 c004c18:	e794      	b.n	c004b44 <UART_SetConfig+0x434>
 c004c1a:	f44f 3600 	mov.w	r6, #131072	; 0x20000
 c004c1e:	e791      	b.n	c004b44 <UART_SetConfig+0x434>
 c004c20:	f44f 3680 	mov.w	r6, #65536	; 0x10000
 c004c24:	e78e      	b.n	c004b44 <UART_SetConfig+0x434>
 c004c26:	f44f 0600 	mov.w	r6, #8388608	; 0x800000
 c004c2a:	e78b      	b.n	c004b44 <UART_SetConfig+0x434>
            ret = HAL_ERROR;
 c004c2c:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 c004c2e:	2000      	movs	r0, #0
 c004c30:	e762      	b.n	c004af8 <UART_SetConfig+0x3e8>
        pclk = HAL_RCC_GetPCLK2Freq();
 c004c32:	f7fe ff5b 	bl	c003aec <HAL_RCC_GetPCLK2Freq>
 c004c36:	e208      	b.n	c00504a <UART_SetConfig+0x93a>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004c38:	484e      	ldr	r0, [pc, #312]	; (c004d74 <UART_SetConfig+0x664>)
 c004c3a:	e183      	b.n	c004f44 <UART_SetConfig+0x834>
 c004c3c:	4845      	ldr	r0, [pc, #276]	; (c004d54 <UART_SetConfig+0x644>)
 c004c3e:	e181      	b.n	c004f44 <UART_SetConfig+0x834>
 c004c40:	4851      	ldr	r0, [pc, #324]	; (c004d88 <UART_SetConfig+0x678>)
 c004c42:	e17f      	b.n	c004f44 <UART_SetConfig+0x834>
 c004c44:	4851      	ldr	r0, [pc, #324]	; (c004d8c <UART_SetConfig+0x67c>)
 c004c46:	e17d      	b.n	c004f44 <UART_SetConfig+0x834>
 c004c48:	4851      	ldr	r0, [pc, #324]	; (c004d90 <UART_SetConfig+0x680>)
 c004c4a:	e17b      	b.n	c004f44 <UART_SetConfig+0x834>
 c004c4c:	4851      	ldr	r0, [pc, #324]	; (c004d94 <UART_SetConfig+0x684>)
 c004c4e:	e179      	b.n	c004f44 <UART_SetConfig+0x834>
 c004c50:	4851      	ldr	r0, [pc, #324]	; (c004d98 <UART_SetConfig+0x688>)
 c004c52:	e177      	b.n	c004f44 <UART_SetConfig+0x834>
 c004c54:	4851      	ldr	r0, [pc, #324]	; (c004d9c <UART_SetConfig+0x68c>)
 c004c56:	e175      	b.n	c004f44 <UART_SetConfig+0x834>
 c004c58:	4851      	ldr	r0, [pc, #324]	; (c004da0 <UART_SetConfig+0x690>)
 c004c5a:	e173      	b.n	c004f44 <UART_SetConfig+0x834>
 c004c5c:	4851      	ldr	r0, [pc, #324]	; (c004da4 <UART_SetConfig+0x694>)
 c004c5e:	e171      	b.n	c004f44 <UART_SetConfig+0x834>
 c004c60:	4851      	ldr	r0, [pc, #324]	; (c004da8 <UART_SetConfig+0x698>)
 c004c62:	e16f      	b.n	c004f44 <UART_SetConfig+0x834>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004c64:	2201      	movs	r2, #1
 c004c66:	e217      	b.n	c005098 <UART_SetConfig+0x988>
 c004c68:	2202      	movs	r2, #2
 c004c6a:	e215      	b.n	c005098 <UART_SetConfig+0x988>
 c004c6c:	2204      	movs	r2, #4
 c004c6e:	e213      	b.n	c005098 <UART_SetConfig+0x988>
 c004c70:	2206      	movs	r2, #6
 c004c72:	e211      	b.n	c005098 <UART_SetConfig+0x988>
 c004c74:	2208      	movs	r2, #8
 c004c76:	e20f      	b.n	c005098 <UART_SetConfig+0x988>
 c004c78:	220a      	movs	r2, #10
 c004c7a:	e20d      	b.n	c005098 <UART_SetConfig+0x988>
 c004c7c:	220c      	movs	r2, #12
 c004c7e:	e20b      	b.n	c005098 <UART_SetConfig+0x988>
 c004c80:	2210      	movs	r2, #16
 c004c82:	e209      	b.n	c005098 <UART_SetConfig+0x988>
 c004c84:	2220      	movs	r2, #32
 c004c86:	e207      	b.n	c005098 <UART_SetConfig+0x988>
 c004c88:	2240      	movs	r2, #64	; 0x40
 c004c8a:	e205      	b.n	c005098 <UART_SetConfig+0x988>
 c004c8c:	2280      	movs	r2, #128	; 0x80
 c004c8e:	e203      	b.n	c005098 <UART_SetConfig+0x988>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004c90:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 c004c94:	e1cd      	b.n	c005032 <UART_SetConfig+0x922>
 c004c96:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 c004c9a:	e1ca      	b.n	c005032 <UART_SetConfig+0x922>
 c004c9c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 c004ca0:	e1c7      	b.n	c005032 <UART_SetConfig+0x922>
 c004ca2:	f642 23aa 	movw	r3, #10922	; 0x2aaa
 c004ca6:	e1c4      	b.n	c005032 <UART_SetConfig+0x922>
 c004ca8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 c004cac:	e1c1      	b.n	c005032 <UART_SetConfig+0x922>
 c004cae:	f641 1398 	movw	r3, #6552	; 0x1998
 c004cb2:	e1be      	b.n	c005032 <UART_SetConfig+0x922>
 c004cb4:	f241 5354 	movw	r3, #5460	; 0x1554
 c004cb8:	e1bb      	b.n	c005032 <UART_SetConfig+0x922>
 c004cba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 c004cbe:	e1b8      	b.n	c005032 <UART_SetConfig+0x922>
 c004cc0:	f44f 6300 	mov.w	r3, #2048	; 0x800
 c004cc4:	e1b5      	b.n	c005032 <UART_SetConfig+0x922>
 c004cc6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 c004cca:	e1b2      	b.n	c005032 <UART_SetConfig+0x922>
 c004ccc:	f44f 7300 	mov.w	r3, #512	; 0x200
 c004cd0:	e1af      	b.n	c005032 <UART_SetConfig+0x922>
        ret = HAL_ERROR;
 c004cd2:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 c004cd4:	2300      	movs	r3, #0
 c004cd6:	e13c      	b.n	c004f52 <UART_SetConfig+0x842>
        pclk = HAL_RCC_GetPCLK1Freq();
 c004cd8:	f7fe fef4 	bl	c003ac4 <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004cdc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 c004cde:	2b00      	cmp	r3, #0
 c004ce0:	f000 80aa 	beq.w	c004e38 <UART_SetConfig+0x728>
 c004ce4:	2b01      	cmp	r3, #1
 c004ce6:	f000 80a9 	beq.w	c004e3c <UART_SetConfig+0x72c>
 c004cea:	2b02      	cmp	r3, #2
 c004cec:	f000 80a8 	beq.w	c004e40 <UART_SetConfig+0x730>
 c004cf0:	2b03      	cmp	r3, #3
 c004cf2:	f000 80a7 	beq.w	c004e44 <UART_SetConfig+0x734>
 c004cf6:	2b04      	cmp	r3, #4
 c004cf8:	f000 80a6 	beq.w	c004e48 <UART_SetConfig+0x738>
 c004cfc:	2b05      	cmp	r3, #5
 c004cfe:	f000 80a5 	beq.w	c004e4c <UART_SetConfig+0x73c>
 c004d02:	2b06      	cmp	r3, #6
 c004d04:	f000 80a4 	beq.w	c004e50 <UART_SetConfig+0x740>
 c004d08:	2b07      	cmp	r3, #7
 c004d0a:	f000 80a3 	beq.w	c004e54 <UART_SetConfig+0x744>
 c004d0e:	2b08      	cmp	r3, #8
 c004d10:	f000 80a2 	beq.w	c004e58 <UART_SetConfig+0x748>
 c004d14:	2b09      	cmp	r3, #9
 c004d16:	f000 80a1 	beq.w	c004e5c <UART_SetConfig+0x74c>
 c004d1a:	2b0a      	cmp	r3, #10
 c004d1c:	f000 80a0 	beq.w	c004e60 <UART_SetConfig+0x750>
 c004d20:	2b0b      	cmp	r3, #11
 c004d22:	bf14      	ite	ne
 c004d24:	2301      	movne	r3, #1
 c004d26:	f44f 7380 	moveq.w	r3, #256	; 0x100
 c004d2a:	fbb0 f3f3 	udiv	r3, r0, r3
 c004d2e:	6862      	ldr	r2, [r4, #4]
 c004d30:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 c004d34:	fbb3 f3f2 	udiv	r3, r3, r2
 c004d38:	e059      	b.n	c004dee <UART_SetConfig+0x6de>
        pclk = HAL_RCC_GetPCLK2Freq();
 c004d3a:	f7fe fed7 	bl	c003aec <HAL_RCC_GetPCLK2Freq>
 c004d3e:	e7cd      	b.n	c004cdc <UART_SetConfig+0x5cc>
 c004d40:	28b0aa00 	.word	0x28b0aa00
 c004d44:	00000000 	.word	0x00000000
 c004d48:	14585500 	.word	0x14585500
 c004d4c:	00000000 	.word	0x00000000
 c004d50:	000ffcff 	.word	0x000ffcff
 c004d54:	00f42400 	.word	0x00f42400
 c004d58:	7a120000 	.word	0x7a120000
 c004d5c:	3d090000 	.word	0x3d090000
 c004d60:	1e848000 	.word	0x1e848000
 c004d64:	186a0000 	.word	0x186a0000
 c004d68:	0f424000 	.word	0x0f424000
 c004d6c:	07a12000 	.word	0x07a12000
 c004d70:	03d09000 	.word	0x03d09000
 c004d74:	01e84800 	.word	0x01e84800
 c004d78:	f4240000 	.word	0xf4240000
 c004d7c:	00155500 	.word	0x00155500
 c004d80:	000ccc00 	.word	0x000ccc00
 c004d84:	000aaa00 	.word	0x000aaa00
 c004d88:	007a1200 	.word	0x007a1200
 c004d8c:	00516154 	.word	0x00516154
 c004d90:	003d0900 	.word	0x003d0900
 c004d94:	0030d400 	.word	0x0030d400
 c004d98:	0028b0aa 	.word	0x0028b0aa
 c004d9c:	001e8480 	.word	0x001e8480
 c004da0:	000f4240 	.word	0x000f4240
 c004da4:	0007a120 	.word	0x0007a120
 c004da8:	0003d090 	.word	0x0003d090
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004dac:	b358      	cbz	r0, c004e06 <UART_SetConfig+0x6f6>
 c004dae:	2801      	cmp	r0, #1
 c004db0:	d02b      	beq.n	c004e0a <UART_SetConfig+0x6fa>
 c004db2:	2802      	cmp	r0, #2
 c004db4:	d02b      	beq.n	c004e0e <UART_SetConfig+0x6fe>
 c004db6:	2803      	cmp	r0, #3
 c004db8:	d02b      	beq.n	c004e12 <UART_SetConfig+0x702>
 c004dba:	2804      	cmp	r0, #4
 c004dbc:	d02b      	beq.n	c004e16 <UART_SetConfig+0x706>
 c004dbe:	2805      	cmp	r0, #5
 c004dc0:	d02b      	beq.n	c004e1a <UART_SetConfig+0x70a>
 c004dc2:	2806      	cmp	r0, #6
 c004dc4:	d02b      	beq.n	c004e1e <UART_SetConfig+0x70e>
 c004dc6:	2807      	cmp	r0, #7
 c004dc8:	d02b      	beq.n	c004e22 <UART_SetConfig+0x712>
 c004dca:	2808      	cmp	r0, #8
 c004dcc:	d02b      	beq.n	c004e26 <UART_SetConfig+0x716>
 c004dce:	2809      	cmp	r0, #9
 c004dd0:	d02b      	beq.n	c004e2a <UART_SetConfig+0x71a>
 c004dd2:	280a      	cmp	r0, #10
 c004dd4:	d02b      	beq.n	c004e2e <UART_SetConfig+0x71e>
 c004dd6:	f24f 4224 	movw	r2, #62500	; 0xf424
 c004dda:	4bc0      	ldr	r3, [pc, #768]	; (c0050dc <UART_SetConfig+0x9cc>)
 c004ddc:	280b      	cmp	r0, #11
 c004dde:	bf14      	ite	ne
 c004de0:	4618      	movne	r0, r3
 c004de2:	4610      	moveq	r0, r2
 c004de4:	6863      	ldr	r3, [r4, #4]
 c004de6:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 c004dea:	fbb0 f3f3 	udiv	r3, r0, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 c004dee:	2200      	movs	r2, #0
 c004df0:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 c004df2:	f64f 71ef 	movw	r1, #65519	; 0xffef
 c004df6:	f1a3 0010 	sub.w	r0, r3, #16
 c004dfa:	4288      	cmp	r0, r1
 c004dfc:	f63f ad97 	bhi.w	c00492e <UART_SetConfig+0x21e>
      huart->Instance->BRR = usartdiv;
 c004e00:	6821      	ldr	r1, [r4, #0]
 c004e02:	60cb      	str	r3, [r1, #12]
 c004e04:	e594      	b.n	c004930 <UART_SetConfig+0x220>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004e06:	48b5      	ldr	r0, [pc, #724]	; (c0050dc <UART_SetConfig+0x9cc>)
 c004e08:	e7ec      	b.n	c004de4 <UART_SetConfig+0x6d4>
 c004e0a:	48b5      	ldr	r0, [pc, #724]	; (c0050e0 <UART_SetConfig+0x9d0>)
 c004e0c:	e7ea      	b.n	c004de4 <UART_SetConfig+0x6d4>
 c004e0e:	48b5      	ldr	r0, [pc, #724]	; (c0050e4 <UART_SetConfig+0x9d4>)
 c004e10:	e7e8      	b.n	c004de4 <UART_SetConfig+0x6d4>
 c004e12:	48b5      	ldr	r0, [pc, #724]	; (c0050e8 <UART_SetConfig+0x9d8>)
 c004e14:	e7e6      	b.n	c004de4 <UART_SetConfig+0x6d4>
 c004e16:	48b5      	ldr	r0, [pc, #724]	; (c0050ec <UART_SetConfig+0x9dc>)
 c004e18:	e7e4      	b.n	c004de4 <UART_SetConfig+0x6d4>
 c004e1a:	48b5      	ldr	r0, [pc, #724]	; (c0050f0 <UART_SetConfig+0x9e0>)
 c004e1c:	e7e2      	b.n	c004de4 <UART_SetConfig+0x6d4>
 c004e1e:	48b5      	ldr	r0, [pc, #724]	; (c0050f4 <UART_SetConfig+0x9e4>)
 c004e20:	e7e0      	b.n	c004de4 <UART_SetConfig+0x6d4>
 c004e22:	48b5      	ldr	r0, [pc, #724]	; (c0050f8 <UART_SetConfig+0x9e8>)
 c004e24:	e7de      	b.n	c004de4 <UART_SetConfig+0x6d4>
 c004e26:	48b5      	ldr	r0, [pc, #724]	; (c0050fc <UART_SetConfig+0x9ec>)
 c004e28:	e7dc      	b.n	c004de4 <UART_SetConfig+0x6d4>
 c004e2a:	48b5      	ldr	r0, [pc, #724]	; (c005100 <UART_SetConfig+0x9f0>)
 c004e2c:	e7da      	b.n	c004de4 <UART_SetConfig+0x6d4>
 c004e2e:	48b5      	ldr	r0, [pc, #724]	; (c005104 <UART_SetConfig+0x9f4>)
 c004e30:	e7d8      	b.n	c004de4 <UART_SetConfig+0x6d4>
        pclk = HAL_RCC_GetSysClockFreq();
 c004e32:	f7fe f9fb 	bl	c00322c <HAL_RCC_GetSysClockFreq>
 c004e36:	e751      	b.n	c004cdc <UART_SetConfig+0x5cc>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004e38:	2301      	movs	r3, #1
 c004e3a:	e776      	b.n	c004d2a <UART_SetConfig+0x61a>
 c004e3c:	2302      	movs	r3, #2
 c004e3e:	e774      	b.n	c004d2a <UART_SetConfig+0x61a>
 c004e40:	2304      	movs	r3, #4
 c004e42:	e772      	b.n	c004d2a <UART_SetConfig+0x61a>
 c004e44:	2306      	movs	r3, #6
 c004e46:	e770      	b.n	c004d2a <UART_SetConfig+0x61a>
 c004e48:	2308      	movs	r3, #8
 c004e4a:	e76e      	b.n	c004d2a <UART_SetConfig+0x61a>
 c004e4c:	230a      	movs	r3, #10
 c004e4e:	e76c      	b.n	c004d2a <UART_SetConfig+0x61a>
 c004e50:	230c      	movs	r3, #12
 c004e52:	e76a      	b.n	c004d2a <UART_SetConfig+0x61a>
 c004e54:	2310      	movs	r3, #16
 c004e56:	e768      	b.n	c004d2a <UART_SetConfig+0x61a>
 c004e58:	2320      	movs	r3, #32
 c004e5a:	e766      	b.n	c004d2a <UART_SetConfig+0x61a>
 c004e5c:	2340      	movs	r3, #64	; 0x40
 c004e5e:	e764      	b.n	c004d2a <UART_SetConfig+0x61a>
 c004e60:	2380      	movs	r3, #128	; 0x80
 c004e62:	e762      	b.n	c004d2a <UART_SetConfig+0x61a>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004e64:	b1f0      	cbz	r0, c004ea4 <UART_SetConfig+0x794>
 c004e66:	2801      	cmp	r0, #1
 c004e68:	d01f      	beq.n	c004eaa <UART_SetConfig+0x79a>
 c004e6a:	2802      	cmp	r0, #2
 c004e6c:	d020      	beq.n	c004eb0 <UART_SetConfig+0x7a0>
 c004e6e:	2803      	cmp	r0, #3
 c004e70:	d021      	beq.n	c004eb6 <UART_SetConfig+0x7a6>
 c004e72:	2804      	cmp	r0, #4
 c004e74:	d022      	beq.n	c004ebc <UART_SetConfig+0x7ac>
 c004e76:	2805      	cmp	r0, #5
 c004e78:	d023      	beq.n	c004ec2 <UART_SetConfig+0x7b2>
 c004e7a:	2806      	cmp	r0, #6
 c004e7c:	d024      	beq.n	c004ec8 <UART_SetConfig+0x7b8>
 c004e7e:	2807      	cmp	r0, #7
 c004e80:	d025      	beq.n	c004ece <UART_SetConfig+0x7be>
 c004e82:	2808      	cmp	r0, #8
 c004e84:	d026      	beq.n	c004ed4 <UART_SetConfig+0x7c4>
 c004e86:	2809      	cmp	r0, #9
 c004e88:	d027      	beq.n	c004eda <UART_SetConfig+0x7ca>
 c004e8a:	280a      	cmp	r0, #10
 c004e8c:	d028      	beq.n	c004ee0 <UART_SetConfig+0x7d0>
 c004e8e:	280b      	cmp	r0, #11
 c004e90:	bf14      	ite	ne
 c004e92:	f44f 4300 	movne.w	r3, #32768	; 0x8000
 c004e96:	2380      	moveq	r3, #128	; 0x80
 c004e98:	6860      	ldr	r0, [r4, #4]
 c004e9a:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 c004e9e:	fbb3 f3f0 	udiv	r3, r3, r0
 c004ea2:	e7a4      	b.n	c004dee <UART_SetConfig+0x6de>
 c004ea4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 c004ea8:	e7f6      	b.n	c004e98 <UART_SetConfig+0x788>
 c004eaa:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 c004eae:	e7f3      	b.n	c004e98 <UART_SetConfig+0x788>
 c004eb0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 c004eb4:	e7f0      	b.n	c004e98 <UART_SetConfig+0x788>
 c004eb6:	f241 5355 	movw	r3, #5461	; 0x1555
 c004eba:	e7ed      	b.n	c004e98 <UART_SetConfig+0x788>
 c004ebc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 c004ec0:	e7ea      	b.n	c004e98 <UART_SetConfig+0x788>
 c004ec2:	f640 43cc 	movw	r3, #3276	; 0xccc
 c004ec6:	e7e7      	b.n	c004e98 <UART_SetConfig+0x788>
 c004ec8:	f640 23aa 	movw	r3, #2730	; 0xaaa
 c004ecc:	e7e4      	b.n	c004e98 <UART_SetConfig+0x788>
 c004ece:	f44f 6300 	mov.w	r3, #2048	; 0x800
 c004ed2:	e7e1      	b.n	c004e98 <UART_SetConfig+0x788>
 c004ed4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 c004ed8:	e7de      	b.n	c004e98 <UART_SetConfig+0x788>
 c004eda:	f44f 7300 	mov.w	r3, #512	; 0x200
 c004ede:	e7db      	b.n	c004e98 <UART_SetConfig+0x788>
 c004ee0:	f44f 7380 	mov.w	r3, #256	; 0x100
 c004ee4:	e7d8      	b.n	c004e98 <UART_SetConfig+0x788>
  if (UART_INSTANCE_LOWPOWER(huart))
 c004ee6:	4a88      	ldr	r2, [pc, #544]	; (c005108 <UART_SetConfig+0x9f8>)
 c004ee8:	4293      	cmp	r3, r2
 c004eea:	f43f acfb 	beq.w	c0048e4 <UART_SetConfig+0x1d4>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c004eee:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 c004ef2:	f47f af5b 	bne.w	c004dac <UART_SetConfig+0x69c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004ef6:	2800      	cmp	r0, #0
 c004ef8:	f43f ae9e 	beq.w	c004c38 <UART_SetConfig+0x528>
 c004efc:	2801      	cmp	r0, #1
 c004efe:	f43f ae9d 	beq.w	c004c3c <UART_SetConfig+0x52c>
 c004f02:	2802      	cmp	r0, #2
 c004f04:	f43f ae9c 	beq.w	c004c40 <UART_SetConfig+0x530>
 c004f08:	2803      	cmp	r0, #3
 c004f0a:	f43f ae9b 	beq.w	c004c44 <UART_SetConfig+0x534>
 c004f0e:	2804      	cmp	r0, #4
 c004f10:	f43f ae9a 	beq.w	c004c48 <UART_SetConfig+0x538>
 c004f14:	2805      	cmp	r0, #5
 c004f16:	f43f ae99 	beq.w	c004c4c <UART_SetConfig+0x53c>
 c004f1a:	2806      	cmp	r0, #6
 c004f1c:	f43f ae98 	beq.w	c004c50 <UART_SetConfig+0x540>
 c004f20:	2807      	cmp	r0, #7
 c004f22:	f43f ae97 	beq.w	c004c54 <UART_SetConfig+0x544>
 c004f26:	2808      	cmp	r0, #8
 c004f28:	f43f ae96 	beq.w	c004c58 <UART_SetConfig+0x548>
 c004f2c:	2809      	cmp	r0, #9
 c004f2e:	f43f ae95 	beq.w	c004c5c <UART_SetConfig+0x54c>
 c004f32:	280a      	cmp	r0, #10
 c004f34:	f43f ae94 	beq.w	c004c60 <UART_SetConfig+0x550>
 c004f38:	4b74      	ldr	r3, [pc, #464]	; (c00510c <UART_SetConfig+0x9fc>)
 c004f3a:	4a72      	ldr	r2, [pc, #456]	; (c005104 <UART_SetConfig+0x9f4>)
 c004f3c:	280b      	cmp	r0, #11
 c004f3e:	bf14      	ite	ne
 c004f40:	4618      	movne	r0, r3
 c004f42:	4610      	moveq	r0, r2
 c004f44:	6863      	ldr	r3, [r4, #4]
 c004f46:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 c004f4a:	fbb0 f3f3 	udiv	r3, r0, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 c004f4e:	2200      	movs	r2, #0
 c004f50:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 c004f52:	f64f 71ef 	movw	r1, #65519	; 0xffef
 c004f56:	f1a3 0010 	sub.w	r0, r3, #16
 c004f5a:	4288      	cmp	r0, r1
 c004f5c:	f63f ace7 	bhi.w	c00492e <UART_SetConfig+0x21e>
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 c004f60:	f023 010f 	bic.w	r1, r3, #15
      huart->Instance->BRR = brrtemp;
 c004f64:	6820      	ldr	r0, [r4, #0]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 c004f66:	f3c3 0342 	ubfx	r3, r3, #1, #3
      huart->Instance->BRR = brrtemp;
 c004f6a:	430b      	orrs	r3, r1
 c004f6c:	60c3      	str	r3, [r0, #12]
 c004f6e:	e4df      	b.n	c004930 <UART_SetConfig+0x220>
  if (UART_INSTANCE_LOWPOWER(huart))
 c004f70:	4a65      	ldr	r2, [pc, #404]	; (c005108 <UART_SetConfig+0x9f8>)
 c004f72:	4293      	cmp	r3, r2
 c004f74:	d132      	bne.n	c004fdc <UART_SetConfig+0x8cc>
        lpuart_ker_ck_pres = ((uint32_t)LSE_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 c004f76:	2108      	movs	r1, #8
 c004f78:	2800      	cmp	r0, #0
 c004f7a:	f43f ad5b 	beq.w	c004a34 <UART_SetConfig+0x324>
 c004f7e:	2801      	cmp	r0, #1
 c004f80:	f43f ad5b 	beq.w	c004a3a <UART_SetConfig+0x32a>
 c004f84:	2802      	cmp	r0, #2
 c004f86:	f43f ad5b 	beq.w	c004a40 <UART_SetConfig+0x330>
 c004f8a:	2803      	cmp	r0, #3
 c004f8c:	f43f ad5b 	beq.w	c004a46 <UART_SetConfig+0x336>
 c004f90:	2804      	cmp	r0, #4
 c004f92:	f43f ad5b 	beq.w	c004a4c <UART_SetConfig+0x33c>
 c004f96:	2805      	cmp	r0, #5
 c004f98:	f43f ad5b 	beq.w	c004a52 <UART_SetConfig+0x342>
 c004f9c:	2806      	cmp	r0, #6
 c004f9e:	f43f ad5b 	beq.w	c004a58 <UART_SetConfig+0x348>
 c004fa2:	2807      	cmp	r0, #7
 c004fa4:	f43f ad5b 	beq.w	c004a5e <UART_SetConfig+0x34e>
 c004fa8:	2808      	cmp	r0, #8
 c004faa:	f43f ad5b 	beq.w	c004a64 <UART_SetConfig+0x354>
 c004fae:	2809      	cmp	r0, #9
 c004fb0:	f43f ad5b 	beq.w	c004a6a <UART_SetConfig+0x35a>
 c004fb4:	280a      	cmp	r0, #10
 c004fb6:	f43f ad5b 	beq.w	c004a70 <UART_SetConfig+0x360>
 c004fba:	280b      	cmp	r0, #11
 c004fbc:	bf0c      	ite	eq
 c004fbe:	2080      	moveq	r0, #128	; 0x80
 c004fc0:	f44f 4000 	movne.w	r0, #32768	; 0x8000
 c004fc4:	e4ad      	b.n	c004922 <UART_SetConfig+0x212>
  if (UART_INSTANCE_LOWPOWER(huart))
 c004fc6:	4a50      	ldr	r2, [pc, #320]	; (c005108 <UART_SetConfig+0x9f8>)
 c004fc8:	4293      	cmp	r3, r2
 c004fca:	f43f acba 	beq.w	c004942 <UART_SetConfig+0x232>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c004fce:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 c004fd2:	f47f af2e 	bne.w	c004e32 <UART_SetConfig+0x722>
        pclk = HAL_RCC_GetSysClockFreq();
 c004fd6:	f7fe f929 	bl	c00322c <HAL_RCC_GetSysClockFreq>
 c004fda:	e036      	b.n	c00504a <UART_SetConfig+0x93a>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c004fdc:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 c004fe0:	f47f af40 	bne.w	c004e64 <UART_SetConfig+0x754>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004fe4:	2800      	cmp	r0, #0
 c004fe6:	f43f ae53 	beq.w	c004c90 <UART_SetConfig+0x580>
 c004fea:	2801      	cmp	r0, #1
 c004fec:	f43f ae53 	beq.w	c004c96 <UART_SetConfig+0x586>
 c004ff0:	2802      	cmp	r0, #2
 c004ff2:	f43f ae53 	beq.w	c004c9c <UART_SetConfig+0x58c>
 c004ff6:	2803      	cmp	r0, #3
 c004ff8:	f43f ae53 	beq.w	c004ca2 <UART_SetConfig+0x592>
 c004ffc:	2804      	cmp	r0, #4
 c004ffe:	f43f ae53 	beq.w	c004ca8 <UART_SetConfig+0x598>
 c005002:	2805      	cmp	r0, #5
 c005004:	f43f ae53 	beq.w	c004cae <UART_SetConfig+0x59e>
 c005008:	2806      	cmp	r0, #6
 c00500a:	f43f ae53 	beq.w	c004cb4 <UART_SetConfig+0x5a4>
 c00500e:	2807      	cmp	r0, #7
 c005010:	f43f ae53 	beq.w	c004cba <UART_SetConfig+0x5aa>
 c005014:	2808      	cmp	r0, #8
 c005016:	f43f ae53 	beq.w	c004cc0 <UART_SetConfig+0x5b0>
 c00501a:	2809      	cmp	r0, #9
 c00501c:	f43f ae53 	beq.w	c004cc6 <UART_SetConfig+0x5b6>
 c005020:	280a      	cmp	r0, #10
 c005022:	f43f ae53 	beq.w	c004ccc <UART_SetConfig+0x5bc>
 c005026:	280b      	cmp	r0, #11
 c005028:	bf14      	ite	ne
 c00502a:	f44f 3380 	movne.w	r3, #65536	; 0x10000
 c00502e:	f44f 7380 	moveq.w	r3, #256	; 0x100
 c005032:	6860      	ldr	r0, [r4, #4]
 c005034:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 c005038:	fbb3 f3f0 	udiv	r3, r3, r0
 c00503c:	e787      	b.n	c004f4e <UART_SetConfig+0x83e>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c00503e:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 c005042:	f47f ae49 	bne.w	c004cd8 <UART_SetConfig+0x5c8>
        pclk = HAL_RCC_GetPCLK1Freq();
 c005046:	f7fe fd3d 	bl	c003ac4 <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c00504a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 c00504c:	2900      	cmp	r1, #0
 c00504e:	f43f ae09 	beq.w	c004c64 <UART_SetConfig+0x554>
 c005052:	2901      	cmp	r1, #1
 c005054:	f43f ae08 	beq.w	c004c68 <UART_SetConfig+0x558>
 c005058:	2902      	cmp	r1, #2
 c00505a:	f43f ae07 	beq.w	c004c6c <UART_SetConfig+0x55c>
 c00505e:	2903      	cmp	r1, #3
 c005060:	f43f ae06 	beq.w	c004c70 <UART_SetConfig+0x560>
 c005064:	2904      	cmp	r1, #4
 c005066:	f43f ae05 	beq.w	c004c74 <UART_SetConfig+0x564>
 c00506a:	2905      	cmp	r1, #5
 c00506c:	f43f ae04 	beq.w	c004c78 <UART_SetConfig+0x568>
 c005070:	2906      	cmp	r1, #6
 c005072:	f43f ae03 	beq.w	c004c7c <UART_SetConfig+0x56c>
 c005076:	2907      	cmp	r1, #7
 c005078:	f43f ae02 	beq.w	c004c80 <UART_SetConfig+0x570>
 c00507c:	2908      	cmp	r1, #8
 c00507e:	f43f ae01 	beq.w	c004c84 <UART_SetConfig+0x574>
 c005082:	2909      	cmp	r1, #9
 c005084:	f43f ae00 	beq.w	c004c88 <UART_SetConfig+0x578>
 c005088:	290a      	cmp	r1, #10
 c00508a:	f43f adff 	beq.w	c004c8c <UART_SetConfig+0x57c>
 c00508e:	290b      	cmp	r1, #11
 c005090:	bf14      	ite	ne
 c005092:	2201      	movne	r2, #1
 c005094:	f44f 7280 	moveq.w	r2, #256	; 0x100
 c005098:	fbb0 f2f2 	udiv	r2, r0, r2
 c00509c:	6861      	ldr	r1, [r4, #4]
 c00509e:	084b      	lsrs	r3, r1, #1
 c0050a0:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 c0050a4:	fbb3 f3f1 	udiv	r3, r3, r1
 c0050a8:	e751      	b.n	c004f4e <UART_SetConfig+0x83e>
    switch (clocksource)
 c0050aa:	2b08      	cmp	r3, #8
 c0050ac:	f63f ac3f 	bhi.w	c00492e <UART_SetConfig+0x21e>
 c0050b0:	a201      	add	r2, pc, #4	; (adr r2, c0050b8 <UART_SetConfig+0x9a8>)
 c0050b2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 c0050b6:	bf00      	nop
 c0050b8:	0c004cd9 	.word	0x0c004cd9
 c0050bc:	0c004d3b 	.word	0x0c004d3b
 c0050c0:	0c004dad 	.word	0x0c004dad
 c0050c4:	0c00492f 	.word	0x0c00492f
 c0050c8:	0c004e33 	.word	0x0c004e33
 c0050cc:	0c00492f 	.word	0x0c00492f
 c0050d0:	0c00492f 	.word	0x0c00492f
 c0050d4:	0c00492f 	.word	0x0c00492f
 c0050d8:	0c004e65 	.word	0x0c004e65
 c0050dc:	00f42400 	.word	0x00f42400
 c0050e0:	007a1200 	.word	0x007a1200
 c0050e4:	003d0900 	.word	0x003d0900
 c0050e8:	0028b0aa 	.word	0x0028b0aa
 c0050ec:	001e8480 	.word	0x001e8480
 c0050f0:	00186a00 	.word	0x00186a00
 c0050f4:	00145855 	.word	0x00145855
 c0050f8:	000f4240 	.word	0x000f4240
 c0050fc:	0007a120 	.word	0x0007a120
 c005100:	0003d090 	.word	0x0003d090
 c005104:	0001e848 	.word	0x0001e848
 c005108:	50008000 	.word	0x50008000
 c00510c:	01e84800 	.word	0x01e84800

0c005110 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 c005110:	6a83      	ldr	r3, [r0, #40]	; 0x28
{
 c005112:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 c005114:	07da      	lsls	r2, r3, #31
 c005116:	d506      	bpl.n	c005126 <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 c005118:	6801      	ldr	r1, [r0, #0]
 c00511a:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 c00511c:	684a      	ldr	r2, [r1, #4]
 c00511e:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 c005122:	4322      	orrs	r2, r4
 c005124:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 c005126:	079c      	lsls	r4, r3, #30
 c005128:	d506      	bpl.n	c005138 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 c00512a:	6801      	ldr	r1, [r0, #0]
 c00512c:	6b04      	ldr	r4, [r0, #48]	; 0x30
 c00512e:	684a      	ldr	r2, [r1, #4]
 c005130:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 c005134:	4322      	orrs	r2, r4
 c005136:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 c005138:	0759      	lsls	r1, r3, #29
 c00513a:	d506      	bpl.n	c00514a <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 c00513c:	6801      	ldr	r1, [r0, #0]
 c00513e:	6b44      	ldr	r4, [r0, #52]	; 0x34
 c005140:	684a      	ldr	r2, [r1, #4]
 c005142:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 c005146:	4322      	orrs	r2, r4
 c005148:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 c00514a:	071a      	lsls	r2, r3, #28
 c00514c:	d506      	bpl.n	c00515c <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 c00514e:	6801      	ldr	r1, [r0, #0]
 c005150:	6b84      	ldr	r4, [r0, #56]	; 0x38
 c005152:	684a      	ldr	r2, [r1, #4]
 c005154:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 c005158:	4322      	orrs	r2, r4
 c00515a:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 c00515c:	06dc      	lsls	r4, r3, #27
 c00515e:	d506      	bpl.n	c00516e <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 c005160:	6801      	ldr	r1, [r0, #0]
 c005162:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 c005164:	688a      	ldr	r2, [r1, #8]
 c005166:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 c00516a:	4322      	orrs	r2, r4
 c00516c:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 c00516e:	0699      	lsls	r1, r3, #26
 c005170:	d506      	bpl.n	c005180 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 c005172:	6801      	ldr	r1, [r0, #0]
 c005174:	6c04      	ldr	r4, [r0, #64]	; 0x40
 c005176:	688a      	ldr	r2, [r1, #8]
 c005178:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 c00517c:	4322      	orrs	r2, r4
 c00517e:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 c005180:	065a      	lsls	r2, r3, #25
 c005182:	d510      	bpl.n	c0051a6 <UART_AdvFeatureConfig+0x96>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 c005184:	6801      	ldr	r1, [r0, #0]
 c005186:	6c44      	ldr	r4, [r0, #68]	; 0x44
 c005188:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 c00518a:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 c00518e:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 c005192:	ea42 0204 	orr.w	r2, r2, r4
 c005196:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 c005198:	d105      	bne.n	c0051a6 <UART_AdvFeatureConfig+0x96>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 c00519a:	684a      	ldr	r2, [r1, #4]
 c00519c:	6c84      	ldr	r4, [r0, #72]	; 0x48
 c00519e:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 c0051a2:	4322      	orrs	r2, r4
 c0051a4:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 c0051a6:	061b      	lsls	r3, r3, #24
 c0051a8:	d506      	bpl.n	c0051b8 <UART_AdvFeatureConfig+0xa8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 c0051aa:	6802      	ldr	r2, [r0, #0]
 c0051ac:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 c0051ae:	6853      	ldr	r3, [r2, #4]
 c0051b0:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 c0051b4:	430b      	orrs	r3, r1
 c0051b6:	6053      	str	r3, [r2, #4]
}
 c0051b8:	bd10      	pop	{r4, pc}

0c0051ba <UART_WaitOnFlagUntilTimeout>:
{
 c0051ba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c0051be:	4604      	mov	r4, r0
 c0051c0:	460f      	mov	r7, r1
 c0051c2:	4616      	mov	r6, r2
 c0051c4:	4698      	mov	r8, r3
 c0051c6:	9d06      	ldr	r5, [sp, #24]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 c0051c8:	6821      	ldr	r1, [r4, #0]
 c0051ca:	69ca      	ldr	r2, [r1, #28]
 c0051cc:	ea37 0302 	bics.w	r3, r7, r2
 c0051d0:	bf0c      	ite	eq
 c0051d2:	2201      	moveq	r2, #1
 c0051d4:	2200      	movne	r2, #0
 c0051d6:	42b2      	cmp	r2, r6
 c0051d8:	d001      	beq.n	c0051de <UART_WaitOnFlagUntilTimeout+0x24>
  return HAL_OK;
 c0051da:	2000      	movs	r0, #0
 c0051dc:	e01a      	b.n	c005214 <UART_WaitOnFlagUntilTimeout+0x5a>
    if (Timeout != HAL_MAX_DELAY)
 c0051de:	1c68      	adds	r0, r5, #1
 c0051e0:	d0f3      	beq.n	c0051ca <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 c0051e2:	f7fc f9ed 	bl	c0015c0 <HAL_GetTick>
 c0051e6:	eba0 0008 	sub.w	r0, r0, r8
 c0051ea:	42a8      	cmp	r0, r5
 c0051ec:	6820      	ldr	r0, [r4, #0]
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 c0051ee:	6803      	ldr	r3, [r0, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 c0051f0:	d800      	bhi.n	c0051f4 <UART_WaitOnFlagUntilTimeout+0x3a>
 c0051f2:	b98d      	cbnz	r5, c005218 <UART_WaitOnFlagUntilTimeout+0x5e>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 c0051f4:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 c0051f8:	6003      	str	r3, [r0, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c0051fa:	6883      	ldr	r3, [r0, #8]
 c0051fc:	f023 0301 	bic.w	r3, r3, #1
 c005200:	6083      	str	r3, [r0, #8]
        huart->gState = HAL_UART_STATE_READY;
 c005202:	2320      	movs	r3, #32
 c005204:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
        huart->RxState = HAL_UART_STATE_READY;
 c005208:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          __HAL_UNLOCK(huart);
 c00520c:	2300      	movs	r3, #0
          return HAL_TIMEOUT;
 c00520e:	2003      	movs	r0, #3
          __HAL_UNLOCK(huart);
 c005210:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
}
 c005214:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 c005218:	075a      	lsls	r2, r3, #29
 c00521a:	d5d5      	bpl.n	c0051c8 <UART_WaitOnFlagUntilTimeout+0xe>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 c00521c:	69c3      	ldr	r3, [r0, #28]
 c00521e:	051b      	lsls	r3, r3, #20
 c005220:	d5d2      	bpl.n	c0051c8 <UART_WaitOnFlagUntilTimeout+0xe>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 c005222:	f44f 6300 	mov.w	r3, #2048	; 0x800
 c005226:	6203      	str	r3, [r0, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 c005228:	6803      	ldr	r3, [r0, #0]
 c00522a:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 c00522e:	6003      	str	r3, [r0, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c005230:	6883      	ldr	r3, [r0, #8]
 c005232:	f023 0301 	bic.w	r3, r3, #1
 c005236:	6083      	str	r3, [r0, #8]
          huart->gState = HAL_UART_STATE_READY;
 c005238:	2320      	movs	r3, #32
 c00523a:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
          huart->RxState = HAL_UART_STATE_READY;
 c00523e:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 c005242:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 c005246:	e7e1      	b.n	c00520c <UART_WaitOnFlagUntilTimeout+0x52>

0c005248 <HAL_UART_Transmit>:
{
 c005248:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c00524c:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
 c00524e:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
{
 c005252:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
 c005254:	2b20      	cmp	r3, #32
{
 c005256:	460e      	mov	r6, r1
 c005258:	4691      	mov	r9, r2
  if (huart->gState == HAL_UART_STATE_READY)
 c00525a:	d14f      	bne.n	c0052fc <HAL_UART_Transmit+0xb4>
    if ((pData == NULL) || (Size == 0U))
 c00525c:	2900      	cmp	r1, #0
 c00525e:	d04b      	beq.n	c0052f8 <HAL_UART_Transmit+0xb0>
 c005260:	2a00      	cmp	r2, #0
 c005262:	d049      	beq.n	c0052f8 <HAL_UART_Transmit+0xb0>
    __HAL_LOCK(huart);
 c005264:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 c005268:	2b01      	cmp	r3, #1
 c00526a:	d047      	beq.n	c0052fc <HAL_UART_Transmit+0xb4>
 c00526c:	2301      	movs	r3, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 c00526e:	2500      	movs	r5, #0
    __HAL_LOCK(huart);
 c005270:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 c005274:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 c005276:	f8c0 5088 	str.w	r5, [r0, #136]	; 0x88
    huart->gState = HAL_UART_STATE_BUSY_TX;
 c00527a:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    tickstart = HAL_GetTick();
 c00527e:	f7fc f99f 	bl	c0015c0 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c005282:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 c005284:	4607      	mov	r7, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c005286:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->TxXferSize  = Size;
 c00528a:	f8a4 9054 	strh.w	r9, [r4, #84]	; 0x54
    huart->TxXferCount = Size;
 c00528e:	f8a4 9056 	strh.w	r9, [r4, #86]	; 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c005292:	d103      	bne.n	c00529c <HAL_UART_Transmit+0x54>
 c005294:	6923      	ldr	r3, [r4, #16]
 c005296:	b90b      	cbnz	r3, c00529c <HAL_UART_Transmit+0x54>
 c005298:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 c00529a:	461e      	mov	r6, r3
    __HAL_UNLOCK(huart);
 c00529c:	2300      	movs	r3, #0
 c00529e:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
    while (huart->TxXferCount > 0U)
 c0052a2:	f8b4 2056 	ldrh.w	r2, [r4, #86]	; 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 c0052a6:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
 c0052aa:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 c0052ac:	463b      	mov	r3, r7
    while (huart->TxXferCount > 0U)
 c0052ae:	b942      	cbnz	r2, c0052c2 <HAL_UART_Transmit+0x7a>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 c0052b0:	2140      	movs	r1, #64	; 0x40
 c0052b2:	4620      	mov	r0, r4
 c0052b4:	f7ff ff81 	bl	c0051ba <UART_WaitOnFlagUntilTimeout>
 c0052b8:	b948      	cbnz	r0, c0052ce <HAL_UART_Transmit+0x86>
    huart->gState = HAL_UART_STATE_READY;
 c0052ba:	2320      	movs	r3, #32
 c0052bc:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    return HAL_OK;
 c0052c0:	e006      	b.n	c0052d0 <HAL_UART_Transmit+0x88>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 c0052c2:	2200      	movs	r2, #0
 c0052c4:	2180      	movs	r1, #128	; 0x80
 c0052c6:	4620      	mov	r0, r4
 c0052c8:	f7ff ff77 	bl	c0051ba <UART_WaitOnFlagUntilTimeout>
 c0052cc:	b118      	cbz	r0, c0052d6 <HAL_UART_Transmit+0x8e>
        return HAL_TIMEOUT;
 c0052ce:	2003      	movs	r0, #3
}
 c0052d0:	b003      	add	sp, #12
 c0052d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 c0052d6:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
 c0052d8:	b95e      	cbnz	r6, c0052f2 <HAL_UART_Transmit+0xaa>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 c0052da:	f835 3b02 	ldrh.w	r3, [r5], #2
 c0052de:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 c0052e2:	6293      	str	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 c0052e4:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
 c0052e8:	3b01      	subs	r3, #1
 c0052ea:	b29b      	uxth	r3, r3
 c0052ec:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
 c0052f0:	e7d7      	b.n	c0052a2 <HAL_UART_Transmit+0x5a>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 c0052f2:	f816 3b01 	ldrb.w	r3, [r6], #1
 c0052f6:	e7f4      	b.n	c0052e2 <HAL_UART_Transmit+0x9a>
      return  HAL_ERROR;
 c0052f8:	2001      	movs	r0, #1
 c0052fa:	e7e9      	b.n	c0052d0 <HAL_UART_Transmit+0x88>
    return HAL_BUSY;
 c0052fc:	2002      	movs	r0, #2
 c0052fe:	e7e7      	b.n	c0052d0 <HAL_UART_Transmit+0x88>

0c005300 <UART_CheckIdleState>:
{
 c005300:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 c005302:	2600      	movs	r6, #0
{
 c005304:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 c005306:	f8c0 6088 	str.w	r6, [r0, #136]	; 0x88
  tickstart = HAL_GetTick();
 c00530a:	f7fc f959 	bl	c0015c0 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 c00530e:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 c005310:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 c005312:	681b      	ldr	r3, [r3, #0]
 c005314:	071a      	lsls	r2, r3, #28
 c005316:	d417      	bmi.n	c005348 <UART_CheckIdleState+0x48>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 c005318:	6823      	ldr	r3, [r4, #0]
 c00531a:	681b      	ldr	r3, [r3, #0]
 c00531c:	075b      	lsls	r3, r3, #29
 c00531e:	d50a      	bpl.n	c005336 <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 c005320:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 c005324:	2200      	movs	r2, #0
 c005326:	9300      	str	r3, [sp, #0]
 c005328:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 c00532c:	462b      	mov	r3, r5
 c00532e:	4620      	mov	r0, r4
 c005330:	f7ff ff43 	bl	c0051ba <UART_WaitOnFlagUntilTimeout>
 c005334:	b9a0      	cbnz	r0, c005360 <UART_CheckIdleState+0x60>
  huart->gState = HAL_UART_STATE_READY;
 c005336:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
 c005338:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 c00533a:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  __HAL_UNLOCK(huart);
 c00533e:	f884 007c 	strb.w	r0, [r4, #124]	; 0x7c
  huart->RxState = HAL_UART_STATE_READY;
 c005342:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  return HAL_OK;
 c005346:	e00c      	b.n	c005362 <UART_CheckIdleState+0x62>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 c005348:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 c00534c:	4632      	mov	r2, r6
 c00534e:	9300      	str	r3, [sp, #0]
 c005350:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 c005354:	4603      	mov	r3, r0
 c005356:	4620      	mov	r0, r4
 c005358:	f7ff ff2f 	bl	c0051ba <UART_WaitOnFlagUntilTimeout>
 c00535c:	2800      	cmp	r0, #0
 c00535e:	d0db      	beq.n	c005318 <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 c005360:	2003      	movs	r0, #3
}
 c005362:	b002      	add	sp, #8
 c005364:	bd70      	pop	{r4, r5, r6, pc}

0c005366 <HAL_UART_Init>:
{
 c005366:	b510      	push	{r4, lr}
  if (huart == NULL)
 c005368:	4604      	mov	r4, r0
 c00536a:	b350      	cbz	r0, c0053c2 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 c00536c:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 c005370:	b91b      	cbnz	r3, c00537a <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 c005372:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    HAL_UART_MspInit(huart);
 c005376:	f7ff f852 	bl	c00441e <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 c00537a:	2324      	movs	r3, #36	; 0x24
  __HAL_UART_DISABLE(huart);
 c00537c:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 c00537e:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  __HAL_UART_DISABLE(huart);
 c005382:	6813      	ldr	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 c005384:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 c005386:	f023 0301 	bic.w	r3, r3, #1
 c00538a:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 c00538c:	f7ff f9c0 	bl	c004710 <UART_SetConfig>
 c005390:	2801      	cmp	r0, #1
 c005392:	d016      	beq.n	c0053c2 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 c005394:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 c005396:	b113      	cbz	r3, c00539e <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 c005398:	4620      	mov	r0, r4
 c00539a:	f7ff feb9 	bl	c005110 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 c00539e:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 c0053a0:	4620      	mov	r0, r4
}
 c0053a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 c0053a6:	685a      	ldr	r2, [r3, #4]
 c0053a8:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 c0053ac:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 c0053ae:	689a      	ldr	r2, [r3, #8]
 c0053b0:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 c0053b4:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 c0053b6:	681a      	ldr	r2, [r3, #0]
 c0053b8:	f042 0201 	orr.w	r2, r2, #1
 c0053bc:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 c0053be:	f7ff bf9f 	b.w	c005300 <UART_CheckIdleState>
}
 c0053c2:	2001      	movs	r0, #1
 c0053c4:	bd10      	pop	{r4, pc}

0c0053c6 <mbedtls_asn1_get_len>:
 */
int mbedtls_asn1_get_len( unsigned char **p,
                  const unsigned char *end,
                  size_t *len )
{
    if( ( end - *p ) < 1 )
 c0053c6:	6803      	ldr	r3, [r0, #0]
{
 c0053c8:	b530      	push	{r4, r5, lr}
    if( ( end - *p ) < 1 )
 c0053ca:	1acd      	subs	r5, r1, r3
 c0053cc:	2d00      	cmp	r5, #0
 c0053ce:	dc02      	bgt.n	c0053d6 <mbedtls_asn1_get_len+0x10>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
 c0053d0:	f06f 005f 	mvn.w	r0, #95	; 0x5f

    if( *len > (size_t) ( end - *p ) )
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    return( 0 );
}
 c0053d4:	bd30      	pop	{r4, r5, pc}
    if( ( **p & 0x80 ) == 0 )
 c0053d6:	781c      	ldrb	r4, [r3, #0]
 c0053d8:	f014 0f80 	tst.w	r4, #128	; 0x80
 c0053dc:	d10a      	bne.n	c0053f4 <mbedtls_asn1_get_len+0x2e>
        *len = *(*p)++;
 c0053de:	1c5c      	adds	r4, r3, #1
 c0053e0:	6004      	str	r4, [r0, #0]
 c0053e2:	781b      	ldrb	r3, [r3, #0]
 c0053e4:	6013      	str	r3, [r2, #0]
    if( *len > (size_t) ( end - *p ) )
 c0053e6:	6803      	ldr	r3, [r0, #0]
 c0053e8:	1ac9      	subs	r1, r1, r3
 c0053ea:	6813      	ldr	r3, [r2, #0]
 c0053ec:	428b      	cmp	r3, r1
 c0053ee:	d8ef      	bhi.n	c0053d0 <mbedtls_asn1_get_len+0xa>
    return( 0 );
 c0053f0:	2000      	movs	r0, #0
 c0053f2:	e7ef      	b.n	c0053d4 <mbedtls_asn1_get_len+0xe>
        switch( **p & 0x7F )
 c0053f4:	f004 047f 	and.w	r4, r4, #127	; 0x7f
 c0053f8:	3c01      	subs	r4, #1
 c0053fa:	2c03      	cmp	r4, #3
 c0053fc:	d827      	bhi.n	c00544e <mbedtls_asn1_get_len+0x88>
 c0053fe:	e8df f004 	tbb	[pc, r4]
 c005402:	0902      	.short	0x0902
 c005404:	1e12      	.short	0x1e12
            if( ( end - *p ) < 2 )
 c005406:	2d01      	cmp	r5, #1
 c005408:	d0e2      	beq.n	c0053d0 <mbedtls_asn1_get_len+0xa>
            *len = (*p)[1];
 c00540a:	785c      	ldrb	r4, [r3, #1]
            (*p) += 2;
 c00540c:	3302      	adds	r3, #2
            *len = (*p)[1];
 c00540e:	6014      	str	r4, [r2, #0]
            (*p) += 5;
 c005410:	6003      	str	r3, [r0, #0]
            break;
 c005412:	e7e8      	b.n	c0053e6 <mbedtls_asn1_get_len+0x20>
            if( ( end - *p ) < 3 )
 c005414:	2d02      	cmp	r5, #2
 c005416:	dddb      	ble.n	c0053d0 <mbedtls_asn1_get_len+0xa>
            *len = ( (size_t)(*p)[1] << 8 ) | (*p)[2];
 c005418:	f8b3 4001 	ldrh.w	r4, [r3, #1]
            (*p) += 3;
 c00541c:	3303      	adds	r3, #3
            *len = ( (size_t)(*p)[1] << 8 ) | (*p)[2];
 c00541e:	ba64      	rev16	r4, r4
 c005420:	b2a4      	uxth	r4, r4
 c005422:	6014      	str	r4, [r2, #0]
 c005424:	e7f4      	b.n	c005410 <mbedtls_asn1_get_len+0x4a>
            if( ( end - *p ) < 4 )
 c005426:	2d03      	cmp	r5, #3
 c005428:	ddd2      	ble.n	c0053d0 <mbedtls_asn1_get_len+0xa>
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c00542a:	789c      	ldrb	r4, [r3, #2]
            *len = ( (size_t)(*p)[1] << 16 ) |
 c00542c:	785d      	ldrb	r5, [r3, #1]
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c00542e:	0224      	lsls	r4, r4, #8
            *len = ( (size_t)(*p)[1] << 16 ) |
 c005430:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c005434:	78dd      	ldrb	r5, [r3, #3]
            (*p) += 4;
 c005436:	3304      	adds	r3, #4
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c005438:	432c      	orrs	r4, r5
            *len = ( (size_t)(*p)[1] << 16 ) |
 c00543a:	6014      	str	r4, [r2, #0]
 c00543c:	e7e8      	b.n	c005410 <mbedtls_asn1_get_len+0x4a>
            if( ( end - *p ) < 5 )
 c00543e:	2d04      	cmp	r5, #4
 c005440:	ddc6      	ble.n	c0053d0 <mbedtls_asn1_get_len+0xa>
 c005442:	f8d3 4001 	ldr.w	r4, [r3, #1]
            (*p) += 5;
 c005446:	3305      	adds	r3, #5
 c005448:	ba24      	rev	r4, r4
            *len = ( (size_t)(*p)[1] << 24 ) | ( (size_t)(*p)[2] << 16 ) |
 c00544a:	6014      	str	r4, [r2, #0]
 c00544c:	e7e0      	b.n	c005410 <mbedtls_asn1_get_len+0x4a>
            return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
 c00544e:	f06f 0063 	mvn.w	r0, #99	; 0x63
 c005452:	e7bf      	b.n	c0053d4 <mbedtls_asn1_get_len+0xe>

0c005454 <mbedtls_asn1_get_tag>:

int mbedtls_asn1_get_tag( unsigned char **p,
                  const unsigned char *end,
                  size_t *len, int tag )
{
 c005454:	b470      	push	{r4, r5, r6}
    if( ( end - *p ) < 1 )
 c005456:	6804      	ldr	r4, [r0, #0]
 c005458:	1b0e      	subs	r6, r1, r4
 c00545a:	2e00      	cmp	r6, #0
 c00545c:	dd07      	ble.n	c00546e <mbedtls_asn1_get_tag+0x1a>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    if( **p != tag )
 c00545e:	7826      	ldrb	r6, [r4, #0]
 c005460:	429e      	cmp	r6, r3
 c005462:	d108      	bne.n	c005476 <mbedtls_asn1_get_tag+0x22>
        return( MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );

    (*p)++;
 c005464:	3401      	adds	r4, #1
 c005466:	6004      	str	r4, [r0, #0]

    return( mbedtls_asn1_get_len( p, end, len ) );
}
 c005468:	bc70      	pop	{r4, r5, r6}
    return( mbedtls_asn1_get_len( p, end, len ) );
 c00546a:	f7ff bfac 	b.w	c0053c6 <mbedtls_asn1_get_len>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
 c00546e:	f06f 005f 	mvn.w	r0, #95	; 0x5f
}
 c005472:	bc70      	pop	{r4, r5, r6}
 c005474:	4770      	bx	lr
        return( MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
 c005476:	f06f 0061 	mvn.w	r0, #97	; 0x61
 c00547a:	e7fa      	b.n	c005472 <mbedtls_asn1_get_tag+0x1e>

0c00547c <mbedtls_asn1_get_mpi>:

#if defined(MBEDTLS_BIGNUM_C)
int mbedtls_asn1_get_mpi( unsigned char **p,
                  const unsigned char *end,
                  mbedtls_mpi *X )
{
 c00547c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int ret;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c00547e:	2302      	movs	r3, #2
{
 c005480:	4615      	mov	r5, r2
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c005482:	aa01      	add	r2, sp, #4
{
 c005484:	4604      	mov	r4, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c005486:	f7ff ffe5 	bl	c005454 <mbedtls_asn1_get_tag>
 c00548a:	b940      	cbnz	r0, c00549e <mbedtls_asn1_get_mpi+0x22>
        return( ret );

    ret = mbedtls_mpi_read_binary( X, *p, len );
 c00548c:	9a01      	ldr	r2, [sp, #4]
 c00548e:	6821      	ldr	r1, [r4, #0]
 c005490:	4628      	mov	r0, r5
 c005492:	f000 fb5d 	bl	c005b50 <mbedtls_mpi_read_binary>

    *p += len;
 c005496:	6823      	ldr	r3, [r4, #0]
 c005498:	9a01      	ldr	r2, [sp, #4]
 c00549a:	4413      	add	r3, r2
 c00549c:	6023      	str	r3, [r4, #0]

    return( ret );
}
 c00549e:	b003      	add	sp, #12
 c0054a0:	bd30      	pop	{r4, r5, pc}

0c0054a2 <mpi_sub_hlp>:
static void mpi_sub_hlp( size_t n, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d )
{
    size_t i;
    mbedtls_mpi_uint c, z;

    for( i = c = 0; i < n; i++, s++, d++ )
 c0054a2:	2300      	movs	r3, #0
{
 c0054a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    for( i = c = 0; i < n; i++, s++, d++ )
 c0054a6:	461c      	mov	r4, r3
 c0054a8:	1f16      	subs	r6, r2, #4
 c0054aa:	4284      	cmp	r4, r0
 c0054ac:	d103      	bne.n	c0054b6 <mpi_sub_hlp+0x14>
 c0054ae:	eb02 0284 	add.w	r2, r2, r4, lsl #2
    {
        z = ( *d <  c );     *d -=  c;
        c = ( *d < *s ) + z; *d -= *s;
    }

    while( c != 0 )
 c0054b2:	b9bb      	cbnz	r3, c0054e4 <mpi_sub_hlp+0x42>
    {
        z = ( *d < c ); *d -= c;
        c = z; d++;
    }
}
 c0054b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
        z = ( *d <  c );     *d -=  c;
 c0054b6:	f8d6 c004 	ldr.w	ip, [r6, #4]
 c0054ba:	ebac 0503 	sub.w	r5, ip, r3
 c0054be:	f846 5f04 	str.w	r5, [r6, #4]!
        c = ( *d < *s ) + z; *d -= *s;
 c0054c2:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
    for( i = c = 0; i < n; i++, s++, d++ )
 c0054c6:	3401      	adds	r4, #1
        c = ( *d < *s ) + z; *d -= *s;
 c0054c8:	42bd      	cmp	r5, r7
 c0054ca:	bf2c      	ite	cs
 c0054cc:	f04f 0e00 	movcs.w	lr, #0
 c0054d0:	f04f 0e01 	movcc.w	lr, #1
 c0054d4:	1bed      	subs	r5, r5, r7
 c0054d6:	459c      	cmp	ip, r3
 c0054d8:	bf2c      	ite	cs
 c0054da:	4673      	movcs	r3, lr
 c0054dc:	f10e 0301 	addcc.w	r3, lr, #1
 c0054e0:	6035      	str	r5, [r6, #0]
 c0054e2:	e7e2      	b.n	c0054aa <mpi_sub_hlp+0x8>
        z = ( *d < c ); *d -= c;
 c0054e4:	6811      	ldr	r1, [r2, #0]
 c0054e6:	1ac8      	subs	r0, r1, r3
        c = z; d++;
 c0054e8:	4299      	cmp	r1, r3
        z = ( *d < c ); *d -= c;
 c0054ea:	f842 0b04 	str.w	r0, [r2], #4
        c = z; d++;
 c0054ee:	bf2c      	ite	cs
 c0054f0:	2300      	movcs	r3, #0
 c0054f2:	2301      	movcc	r3, #1
 c0054f4:	e7dd      	b.n	c0054b2 <mpi_sub_hlp+0x10>

0c0054f6 <mpi_mul_hlp>:
 * appears to need this to prevent bad ARM code generation at -O3.
 */
__attribute__ ((noinline))
#endif
void mpi_mul_hlp( size_t i, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d, mbedtls_mpi_uint b )
{
 c0054f6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
        MULADDC_INIT
        MULADDC_CORE
        MULADDC_STOP
    }
#else /* MULADDC_HUIT */
    for( ; i >= 16; i -= 16 )
 c0054fa:	4684      	mov	ip, r0
 c0054fc:	460d      	mov	r5, r1
    mbedtls_mpi_uint c = 0, t = 0;
 c0054fe:	f04f 0e00 	mov.w	lr, #0
 c005502:	f102 0440 	add.w	r4, r2, #64	; 0x40
    for( ; i >= 16; i -= 16 )
 c005506:	f1bc 0f0f 	cmp.w	ip, #15
 c00550a:	f854 8c40 	ldr.w	r8, [r4, #-64]
 c00550e:	f105 0540 	add.w	r5, r5, #64	; 0x40
 c005512:	f104 0440 	add.w	r4, r4, #64	; 0x40
 c005516:	f200 80ba 	bhi.w	c00568e <mpi_mul_hlp+0x198>
 c00551a:	f06f 040f 	mvn.w	r4, #15
 c00551e:	ea4f 1c10 	mov.w	ip, r0, lsr #4
 c005522:	fb04 000c 	mla	r0, r4, ip, r0
 c005526:	ea4f 1c8c 	mov.w	ip, ip, lsl #6
        MULADDC_CORE   MULADDC_CORE
        MULADDC_CORE   MULADDC_CORE
        MULADDC_STOP
    }

    for( ; i >= 8; i -= 8 )
 c00552a:	2807      	cmp	r0, #7
 c00552c:	eb01 050c 	add.w	r5, r1, ip
 c005530:	eb02 040c 	add.w	r4, r2, ip
 c005534:	f240 8093 	bls.w	c00565e <mpi_mul_hlp+0x168>
    {
        MULADDC_INIT
        MULADDC_CORE   MULADDC_CORE
 c005538:	f851 600c 	ldr.w	r6, [r1, ip]
    for( ; i >= 8; i -= 8 )
 c00553c:	3808      	subs	r0, #8
        MULADDC_CORE   MULADDC_CORE
 c00553e:	fba3 6706 	umull	r6, r7, r3, r6
 c005542:	eb1e 0e06 	adds.w	lr, lr, r6
 c005546:	bf2c      	ite	cs
 c005548:	f04f 0901 	movcs.w	r9, #1
 c00554c:	f04f 0900 	movcc.w	r9, #0
 c005550:	eb18 010e 	adds.w	r1, r8, lr
 c005554:	f842 100c 	str.w	r1, [r2, ip]
 c005558:	bf2c      	ite	cs
 c00555a:	2201      	movcs	r2, #1
 c00555c:	2200      	movcc	r2, #0
 c00555e:	686e      	ldr	r6, [r5, #4]
 c005560:	44b9      	add	r9, r7
 c005562:	fba3 6706 	umull	r6, r7, r3, r6
 c005566:	444a      	add	r2, r9
 c005568:	1992      	adds	r2, r2, r6
 c00556a:	bf2c      	ite	cs
 c00556c:	2101      	movcs	r1, #1
 c00556e:	2100      	movcc	r1, #0
 c005570:	6866      	ldr	r6, [r4, #4]
 c005572:	eb01 0c07 	add.w	ip, r1, r7
 c005576:	1992      	adds	r2, r2, r6
 c005578:	f04f 0100 	mov.w	r1, #0
 c00557c:	bf28      	it	cs
 c00557e:	2101      	movcs	r1, #1
 c005580:	6062      	str	r2, [r4, #4]
        MULADDC_CORE   MULADDC_CORE
 c005582:	68ae      	ldr	r6, [r5, #8]
        MULADDC_CORE   MULADDC_CORE
 c005584:	4461      	add	r1, ip
        MULADDC_CORE   MULADDC_CORE
 c005586:	fba3 6706 	umull	r6, r7, r3, r6
 c00558a:	1989      	adds	r1, r1, r6
 c00558c:	bf2c      	ite	cs
 c00558e:	2201      	movcs	r2, #1
 c005590:	2200      	movcc	r2, #0
 c005592:	68a6      	ldr	r6, [r4, #8]
 c005594:	eb02 0c07 	add.w	ip, r2, r7
 c005598:	1989      	adds	r1, r1, r6
 c00559a:	f04f 0200 	mov.w	r2, #0
 c00559e:	bf28      	it	cs
 c0055a0:	2201      	movcs	r2, #1
 c0055a2:	60a1      	str	r1, [r4, #8]
 c0055a4:	68ee      	ldr	r6, [r5, #12]
 c0055a6:	4462      	add	r2, ip
 c0055a8:	fba3 6706 	umull	r6, r7, r3, r6
 c0055ac:	1992      	adds	r2, r2, r6
 c0055ae:	bf2c      	ite	cs
 c0055b0:	2101      	movcs	r1, #1
 c0055b2:	2100      	movcc	r1, #0
 c0055b4:	68e6      	ldr	r6, [r4, #12]
 c0055b6:	eb01 0c07 	add.w	ip, r1, r7
 c0055ba:	1992      	adds	r2, r2, r6
 c0055bc:	f04f 0100 	mov.w	r1, #0
 c0055c0:	bf28      	it	cs
 c0055c2:	2101      	movcs	r1, #1
 c0055c4:	60e2      	str	r2, [r4, #12]

        MULADDC_CORE   MULADDC_CORE
 c0055c6:	692e      	ldr	r6, [r5, #16]
        MULADDC_CORE   MULADDC_CORE
 c0055c8:	4461      	add	r1, ip
        MULADDC_CORE   MULADDC_CORE
 c0055ca:	fba3 6706 	umull	r6, r7, r3, r6
 c0055ce:	1989      	adds	r1, r1, r6
 c0055d0:	bf2c      	ite	cs
 c0055d2:	2201      	movcs	r2, #1
 c0055d4:	2200      	movcc	r2, #0
 c0055d6:	6926      	ldr	r6, [r4, #16]
 c0055d8:	eb02 0c07 	add.w	ip, r2, r7
 c0055dc:	1989      	adds	r1, r1, r6
 c0055de:	f04f 0200 	mov.w	r2, #0
 c0055e2:	bf28      	it	cs
 c0055e4:	2201      	movcs	r2, #1
 c0055e6:	6121      	str	r1, [r4, #16]
 c0055e8:	696e      	ldr	r6, [r5, #20]
 c0055ea:	4462      	add	r2, ip
 c0055ec:	fba3 6706 	umull	r6, r7, r3, r6
 c0055f0:	1992      	adds	r2, r2, r6
 c0055f2:	bf2c      	ite	cs
 c0055f4:	2101      	movcs	r1, #1
 c0055f6:	2100      	movcc	r1, #0
 c0055f8:	6966      	ldr	r6, [r4, #20]
 c0055fa:	eb01 0c07 	add.w	ip, r1, r7
 c0055fe:	1992      	adds	r2, r2, r6
 c005600:	f04f 0100 	mov.w	r1, #0
 c005604:	bf28      	it	cs
 c005606:	2101      	movcs	r1, #1
 c005608:	6162      	str	r2, [r4, #20]
        MULADDC_CORE   MULADDC_CORE
 c00560a:	69ae      	ldr	r6, [r5, #24]
        MULADDC_CORE   MULADDC_CORE
 c00560c:	4461      	add	r1, ip
        MULADDC_CORE   MULADDC_CORE
 c00560e:	fba3 6706 	umull	r6, r7, r3, r6
 c005612:	1989      	adds	r1, r1, r6
 c005614:	bf2c      	ite	cs
 c005616:	2201      	movcs	r2, #1
 c005618:	2200      	movcc	r2, #0
 c00561a:	69a6      	ldr	r6, [r4, #24]
 c00561c:	eb02 0e07 	add.w	lr, r2, r7
 c005620:	1989      	adds	r1, r1, r6
 c005622:	f04f 0200 	mov.w	r2, #0
 c005626:	bf28      	it	cs
 c005628:	2201      	movcs	r2, #1
 c00562a:	61a1      	str	r1, [r4, #24]
 c00562c:	69ee      	ldr	r6, [r5, #28]
 c00562e:	4472      	add	r2, lr
 c005630:	fba3 6706 	umull	r6, r7, r3, r6
 c005634:	1992      	adds	r2, r2, r6
 c005636:	bf2c      	ite	cs
 c005638:	f04f 0e01 	movcs.w	lr, #1
 c00563c:	f04f 0e00 	movcc.w	lr, #0
 c005640:	f105 0c20 	add.w	ip, r5, #32
 c005644:	69e5      	ldr	r5, [r4, #28]
 c005646:	eb0e 0107 	add.w	r1, lr, r7
 c00564a:	1952      	adds	r2, r2, r5
 c00564c:	f04f 0e00 	mov.w	lr, #0
 c005650:	bf28      	it	cs
 c005652:	f04f 0e01 	movcs.w	lr, #1
 c005656:	4665      	mov	r5, ip
 c005658:	61e2      	str	r2, [r4, #28]
 c00565a:	448e      	add	lr, r1
 c00565c:	3420      	adds	r4, #32
 c00565e:	4621      	mov	r1, r4
 c005660:	0080      	lsls	r0, r0, #2
 c005662:	eb05 0c00 	add.w	ip, r5, r0
        MULADDC_STOP
    }

    for( ; i > 0; i-- )
 c005666:	4565      	cmp	r5, ip
 c005668:	f851 2b04 	ldr.w	r2, [r1], #4
 c00566c:	f040 819e 	bne.w	c0059ac <mpi_mul_hlp+0x4b6>
 c005670:	4404      	add	r4, r0
 c005672:	6823      	ldr	r3, [r4, #0]
 c005674:	2200      	movs	r2, #0
 c005676:	eb13 030e 	adds.w	r3, r3, lr
 c00567a:	bf28      	it	cs
 c00567c:	2201      	movcs	r2, #1
#endif /* MULADDC_HUIT */

    t++;

    do {
        *d += c; c = ( *d < c ); d++;
 c00567e:	f844 3b04 	str.w	r3, [r4], #4
 c005682:	f04f 0e01 	mov.w	lr, #1
    }
    while( c != 0 );
 c005686:	2a00      	cmp	r2, #0
 c005688:	d1f3      	bne.n	c005672 <mpi_mul_hlp+0x17c>
}
 c00568a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        MULADDC_CORE   MULADDC_CORE
 c00568e:	f855 6c40 	ldr.w	r6, [r5, #-64]
    for( ; i >= 16; i -= 16 )
 c005692:	f1ac 0c10 	sub.w	ip, ip, #16
        MULADDC_CORE   MULADDC_CORE
 c005696:	fba3 6706 	umull	r6, r7, r3, r6
 c00569a:	eb1e 0e06 	adds.w	lr, lr, r6
 c00569e:	bf2c      	ite	cs
 c0056a0:	f04f 0901 	movcs.w	r9, #1
 c0056a4:	f04f 0900 	movcc.w	r9, #0
 c0056a8:	eb1e 0608 	adds.w	r6, lr, r8
 c0056ac:	bf2c      	ite	cs
 c0056ae:	f04f 0801 	movcs.w	r8, #1
 c0056b2:	f04f 0800 	movcc.w	r8, #0
 c0056b6:	f844 6c80 	str.w	r6, [r4, #-128]
 c0056ba:	f855 6c3c 	ldr.w	r6, [r5, #-60]
 c0056be:	44b9      	add	r9, r7
 c0056c0:	fba3 6706 	umull	r6, r7, r3, r6
 c0056c4:	44c8      	add	r8, r9
 c0056c6:	eb18 0806 	adds.w	r8, r8, r6
 c0056ca:	bf2c      	ite	cs
 c0056cc:	f04f 0e01 	movcs.w	lr, #1
 c0056d0:	f04f 0e00 	movcc.w	lr, #0
 c0056d4:	f854 6c7c 	ldr.w	r6, [r4, #-124]
 c0056d8:	eb0e 0907 	add.w	r9, lr, r7
 c0056dc:	eb16 0608 	adds.w	r6, r6, r8
 c0056e0:	f04f 0e00 	mov.w	lr, #0
 c0056e4:	bf28      	it	cs
 c0056e6:	f04f 0e01 	movcs.w	lr, #1
 c0056ea:	f844 6c7c 	str.w	r6, [r4, #-124]
        MULADDC_CORE   MULADDC_CORE
 c0056ee:	f855 6c38 	ldr.w	r6, [r5, #-56]
        MULADDC_CORE   MULADDC_CORE
 c0056f2:	44ce      	add	lr, r9
        MULADDC_CORE   MULADDC_CORE
 c0056f4:	fba3 6706 	umull	r6, r7, r3, r6
 c0056f8:	eb1e 0e06 	adds.w	lr, lr, r6
 c0056fc:	bf2c      	ite	cs
 c0056fe:	f04f 0801 	movcs.w	r8, #1
 c005702:	f04f 0800 	movcc.w	r8, #0
 c005706:	eb08 0907 	add.w	r9, r8, r7
 c00570a:	f854 7c78 	ldr.w	r7, [r4, #-120]
 c00570e:	f04f 0800 	mov.w	r8, #0
 c005712:	eb17 070e 	adds.w	r7, r7, lr
 c005716:	bf28      	it	cs
 c005718:	f04f 0801 	movcs.w	r8, #1
 c00571c:	f844 7c78 	str.w	r7, [r4, #-120]
 c005720:	f855 6c34 	ldr.w	r6, [r5, #-52]
 c005724:	44c8      	add	r8, r9
 c005726:	fba3 6706 	umull	r6, r7, r3, r6
 c00572a:	eb18 0806 	adds.w	r8, r8, r6
 c00572e:	bf2c      	ite	cs
 c005730:	f04f 0e01 	movcs.w	lr, #1
 c005734:	f04f 0e00 	movcc.w	lr, #0
 c005738:	f854 6c74 	ldr.w	r6, [r4, #-116]
 c00573c:	eb0e 0907 	add.w	r9, lr, r7
 c005740:	eb16 0608 	adds.w	r6, r6, r8
 c005744:	f04f 0e00 	mov.w	lr, #0
 c005748:	bf28      	it	cs
 c00574a:	f04f 0e01 	movcs.w	lr, #1
 c00574e:	f844 6c74 	str.w	r6, [r4, #-116]
        MULADDC_CORE   MULADDC_CORE
 c005752:	f855 6c30 	ldr.w	r6, [r5, #-48]
        MULADDC_CORE   MULADDC_CORE
 c005756:	44ce      	add	lr, r9
        MULADDC_CORE   MULADDC_CORE
 c005758:	fba3 6706 	umull	r6, r7, r3, r6
 c00575c:	eb1e 0e06 	adds.w	lr, lr, r6
 c005760:	bf2c      	ite	cs
 c005762:	f04f 0801 	movcs.w	r8, #1
 c005766:	f04f 0800 	movcc.w	r8, #0
 c00576a:	eb08 0907 	add.w	r9, r8, r7
 c00576e:	f854 7c70 	ldr.w	r7, [r4, #-112]
 c005772:	f04f 0800 	mov.w	r8, #0
 c005776:	eb17 070e 	adds.w	r7, r7, lr
 c00577a:	bf28      	it	cs
 c00577c:	f04f 0801 	movcs.w	r8, #1
 c005780:	f844 7c70 	str.w	r7, [r4, #-112]
 c005784:	f855 6c2c 	ldr.w	r6, [r5, #-44]
 c005788:	44c8      	add	r8, r9
 c00578a:	fba3 6706 	umull	r6, r7, r3, r6
 c00578e:	eb18 0806 	adds.w	r8, r8, r6
 c005792:	bf2c      	ite	cs
 c005794:	f04f 0e01 	movcs.w	lr, #1
 c005798:	f04f 0e00 	movcc.w	lr, #0
 c00579c:	f854 6c6c 	ldr.w	r6, [r4, #-108]
 c0057a0:	eb0e 0907 	add.w	r9, lr, r7
 c0057a4:	eb16 0608 	adds.w	r6, r6, r8
 c0057a8:	f04f 0e00 	mov.w	lr, #0
 c0057ac:	bf28      	it	cs
 c0057ae:	f04f 0e01 	movcs.w	lr, #1
 c0057b2:	f844 6c6c 	str.w	r6, [r4, #-108]
        MULADDC_CORE   MULADDC_CORE
 c0057b6:	f855 6c28 	ldr.w	r6, [r5, #-40]
        MULADDC_CORE   MULADDC_CORE
 c0057ba:	44ce      	add	lr, r9
        MULADDC_CORE   MULADDC_CORE
 c0057bc:	fba3 6706 	umull	r6, r7, r3, r6
 c0057c0:	eb1e 0e06 	adds.w	lr, lr, r6
 c0057c4:	bf2c      	ite	cs
 c0057c6:	f04f 0801 	movcs.w	r8, #1
 c0057ca:	f04f 0800 	movcc.w	r8, #0
 c0057ce:	eb08 0907 	add.w	r9, r8, r7
 c0057d2:	f854 7c68 	ldr.w	r7, [r4, #-104]
 c0057d6:	f04f 0800 	mov.w	r8, #0
 c0057da:	eb17 070e 	adds.w	r7, r7, lr
 c0057de:	bf28      	it	cs
 c0057e0:	f04f 0801 	movcs.w	r8, #1
 c0057e4:	f844 7c68 	str.w	r7, [r4, #-104]
 c0057e8:	f855 6c24 	ldr.w	r6, [r5, #-36]
 c0057ec:	44c8      	add	r8, r9
 c0057ee:	fba3 6706 	umull	r6, r7, r3, r6
 c0057f2:	eb18 0806 	adds.w	r8, r8, r6
 c0057f6:	bf2c      	ite	cs
 c0057f8:	f04f 0e01 	movcs.w	lr, #1
 c0057fc:	f04f 0e00 	movcc.w	lr, #0
 c005800:	f854 6c64 	ldr.w	r6, [r4, #-100]
 c005804:	eb0e 0907 	add.w	r9, lr, r7
 c005808:	eb16 0608 	adds.w	r6, r6, r8
 c00580c:	f04f 0e00 	mov.w	lr, #0
 c005810:	bf28      	it	cs
 c005812:	f04f 0e01 	movcs.w	lr, #1
 c005816:	f844 6c64 	str.w	r6, [r4, #-100]
        MULADDC_CORE   MULADDC_CORE
 c00581a:	f855 6c20 	ldr.w	r6, [r5, #-32]
        MULADDC_CORE   MULADDC_CORE
 c00581e:	44ce      	add	lr, r9
        MULADDC_CORE   MULADDC_CORE
 c005820:	fba3 6706 	umull	r6, r7, r3, r6
 c005824:	eb1e 0e06 	adds.w	lr, lr, r6
 c005828:	bf2c      	ite	cs
 c00582a:	f04f 0801 	movcs.w	r8, #1
 c00582e:	f04f 0800 	movcc.w	r8, #0
 c005832:	eb08 0907 	add.w	r9, r8, r7
 c005836:	f854 7c60 	ldr.w	r7, [r4, #-96]
 c00583a:	f04f 0800 	mov.w	r8, #0
 c00583e:	eb17 070e 	adds.w	r7, r7, lr
 c005842:	bf28      	it	cs
 c005844:	f04f 0801 	movcs.w	r8, #1
 c005848:	f844 7c60 	str.w	r7, [r4, #-96]
 c00584c:	f855 6c1c 	ldr.w	r6, [r5, #-28]
 c005850:	44c8      	add	r8, r9
 c005852:	fba3 6706 	umull	r6, r7, r3, r6
 c005856:	eb18 0806 	adds.w	r8, r8, r6
 c00585a:	bf2c      	ite	cs
 c00585c:	f04f 0e01 	movcs.w	lr, #1
 c005860:	f04f 0e00 	movcc.w	lr, #0
 c005864:	f854 6c5c 	ldr.w	r6, [r4, #-92]
 c005868:	eb0e 0907 	add.w	r9, lr, r7
 c00586c:	eb16 0608 	adds.w	r6, r6, r8
 c005870:	f04f 0e00 	mov.w	lr, #0
 c005874:	bf28      	it	cs
 c005876:	f04f 0e01 	movcs.w	lr, #1
 c00587a:	f844 6c5c 	str.w	r6, [r4, #-92]
        MULADDC_CORE   MULADDC_CORE
 c00587e:	f855 6c18 	ldr.w	r6, [r5, #-24]
        MULADDC_CORE   MULADDC_CORE
 c005882:	44ce      	add	lr, r9
        MULADDC_CORE   MULADDC_CORE
 c005884:	fba3 6706 	umull	r6, r7, r3, r6
 c005888:	eb1e 0e06 	adds.w	lr, lr, r6
 c00588c:	bf2c      	ite	cs
 c00588e:	f04f 0801 	movcs.w	r8, #1
 c005892:	f04f 0800 	movcc.w	r8, #0
 c005896:	eb08 0907 	add.w	r9, r8, r7
 c00589a:	f854 7c58 	ldr.w	r7, [r4, #-88]
 c00589e:	f04f 0800 	mov.w	r8, #0
 c0058a2:	eb17 070e 	adds.w	r7, r7, lr
 c0058a6:	bf28      	it	cs
 c0058a8:	f04f 0801 	movcs.w	r8, #1
 c0058ac:	f844 7c58 	str.w	r7, [r4, #-88]
 c0058b0:	f855 6c14 	ldr.w	r6, [r5, #-20]
 c0058b4:	44c8      	add	r8, r9
 c0058b6:	fba3 6706 	umull	r6, r7, r3, r6
 c0058ba:	eb18 0806 	adds.w	r8, r8, r6
 c0058be:	bf2c      	ite	cs
 c0058c0:	f04f 0e01 	movcs.w	lr, #1
 c0058c4:	f04f 0e00 	movcc.w	lr, #0
 c0058c8:	f854 6c54 	ldr.w	r6, [r4, #-84]
 c0058cc:	eb0e 0907 	add.w	r9, lr, r7
 c0058d0:	eb16 0608 	adds.w	r6, r6, r8
 c0058d4:	f04f 0e00 	mov.w	lr, #0
 c0058d8:	bf28      	it	cs
 c0058da:	f04f 0e01 	movcs.w	lr, #1
 c0058de:	f844 6c54 	str.w	r6, [r4, #-84]
        MULADDC_CORE   MULADDC_CORE
 c0058e2:	f855 6c10 	ldr.w	r6, [r5, #-16]
        MULADDC_CORE   MULADDC_CORE
 c0058e6:	44ce      	add	lr, r9
        MULADDC_CORE   MULADDC_CORE
 c0058e8:	fba3 6706 	umull	r6, r7, r3, r6
 c0058ec:	eb1e 0e06 	adds.w	lr, lr, r6
 c0058f0:	bf2c      	ite	cs
 c0058f2:	f04f 0801 	movcs.w	r8, #1
 c0058f6:	f04f 0800 	movcc.w	r8, #0
 c0058fa:	eb08 0907 	add.w	r9, r8, r7
 c0058fe:	f854 7c50 	ldr.w	r7, [r4, #-80]
 c005902:	f04f 0800 	mov.w	r8, #0
 c005906:	eb17 070e 	adds.w	r7, r7, lr
 c00590a:	bf28      	it	cs
 c00590c:	f04f 0801 	movcs.w	r8, #1
 c005910:	f844 7c50 	str.w	r7, [r4, #-80]
 c005914:	f855 6c0c 	ldr.w	r6, [r5, #-12]
 c005918:	44c8      	add	r8, r9
 c00591a:	fba3 6706 	umull	r6, r7, r3, r6
 c00591e:	eb18 0806 	adds.w	r8, r8, r6
 c005922:	bf2c      	ite	cs
 c005924:	f04f 0e01 	movcs.w	lr, #1
 c005928:	f04f 0e00 	movcc.w	lr, #0
 c00592c:	f854 6c4c 	ldr.w	r6, [r4, #-76]
 c005930:	eb0e 0907 	add.w	r9, lr, r7
 c005934:	eb16 0608 	adds.w	r6, r6, r8
 c005938:	f04f 0e00 	mov.w	lr, #0
 c00593c:	bf28      	it	cs
 c00593e:	f04f 0e01 	movcs.w	lr, #1
 c005942:	f844 6c4c 	str.w	r6, [r4, #-76]
        MULADDC_CORE   MULADDC_CORE
 c005946:	f855 6c08 	ldr.w	r6, [r5, #-8]
        MULADDC_CORE   MULADDC_CORE
 c00594a:	44ce      	add	lr, r9
        MULADDC_CORE   MULADDC_CORE
 c00594c:	fba3 6706 	umull	r6, r7, r3, r6
 c005950:	eb1e 0e06 	adds.w	lr, lr, r6
 c005954:	bf2c      	ite	cs
 c005956:	f04f 0801 	movcs.w	r8, #1
 c00595a:	f04f 0800 	movcc.w	r8, #0
 c00595e:	eb08 0907 	add.w	r9, r8, r7
 c005962:	f854 7c48 	ldr.w	r7, [r4, #-72]
 c005966:	f04f 0800 	mov.w	r8, #0
 c00596a:	eb17 070e 	adds.w	r7, r7, lr
 c00596e:	bf28      	it	cs
 c005970:	f04f 0801 	movcs.w	r8, #1
 c005974:	f844 7c48 	str.w	r7, [r4, #-72]
 c005978:	f855 6c04 	ldr.w	r6, [r5, #-4]
 c00597c:	44c8      	add	r8, r9
 c00597e:	fba3 6706 	umull	r6, r7, r3, r6
 c005982:	eb18 0806 	adds.w	r8, r8, r6
 c005986:	bf2c      	ite	cs
 c005988:	f04f 0e01 	movcs.w	lr, #1
 c00598c:	f04f 0e00 	movcc.w	lr, #0
 c005990:	f854 6c44 	ldr.w	r6, [r4, #-68]
 c005994:	4477      	add	r7, lr
 c005996:	eb16 0608 	adds.w	r6, r6, r8
 c00599a:	f04f 0e00 	mov.w	lr, #0
 c00599e:	bf28      	it	cs
 c0059a0:	f04f 0e01 	movcs.w	lr, #1
 c0059a4:	f844 6c44 	str.w	r6, [r4, #-68]
 c0059a8:	44be      	add	lr, r7
 c0059aa:	e5ac      	b.n	c005506 <mpi_mul_hlp+0x10>
        MULADDC_CORE
 c0059ac:	f855 6b04 	ldr.w	r6, [r5], #4
 c0059b0:	fba3 7806 	umull	r7, r8, r3, r6
 c0059b4:	eb1e 0e07 	adds.w	lr, lr, r7
 c0059b8:	bf2c      	ite	cs
 c0059ba:	2601      	movcs	r6, #1
 c0059bc:	2600      	movcc	r6, #0
 c0059be:	eb1e 0202 	adds.w	r2, lr, r2
 c0059c2:	bf2c      	ite	cs
 c0059c4:	f04f 0e01 	movcs.w	lr, #1
 c0059c8:	f04f 0e00 	movcc.w	lr, #0
 c0059cc:	4446      	add	r6, r8
 c0059ce:	f841 2c04 	str.w	r2, [r1, #-4]
 c0059d2:	44b6      	add	lr, r6
 c0059d4:	e647      	b.n	c005666 <mpi_mul_hlp+0x170>

0c0059d6 <mbedtls_mpi_init>:
    if( X == NULL )
 c0059d6:	b120      	cbz	r0, c0059e2 <mbedtls_mpi_init+0xc>
    X->n = 0;
 c0059d8:	2300      	movs	r3, #0
 c0059da:	2201      	movs	r2, #1
 c0059dc:	e9c0 2300 	strd	r2, r3, [r0]
    X->p = NULL;
 c0059e0:	6083      	str	r3, [r0, #8]
}
 c0059e2:	4770      	bx	lr

0c0059e4 <mbedtls_mpi_free>:
{
 c0059e4:	b510      	push	{r4, lr}
    if( X == NULL )
 c0059e6:	4604      	mov	r4, r0
 c0059e8:	b168      	cbz	r0, c005a06 <mbedtls_mpi_free+0x22>
    if( X->p != NULL )
 c0059ea:	6880      	ldr	r0, [r0, #8]
 c0059ec:	b130      	cbz	r0, c0059fc <mbedtls_mpi_free+0x18>
    mbedtls_platform_zeroize( v, ciL * n );
 c0059ee:	6861      	ldr	r1, [r4, #4]
 c0059f0:	0089      	lsls	r1, r1, #2
 c0059f2:	f001 f999 	bl	c006d28 <mbedtls_platform_zeroize>
        mbedtls_free( X->p );
 c0059f6:	68a0      	ldr	r0, [r4, #8]
 c0059f8:	f001 f986 	bl	c006d08 <mbedtls_free>
    X->n = 0;
 c0059fc:	2300      	movs	r3, #0
 c0059fe:	2201      	movs	r2, #1
 c005a00:	e9c4 2300 	strd	r2, r3, [r4]
    X->p = NULL;
 c005a04:	60a3      	str	r3, [r4, #8]
}
 c005a06:	bd10      	pop	{r4, pc}

0c005a08 <mbedtls_mpi_grow>:
    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
 c005a08:	f242 7310 	movw	r3, #10000	; 0x2710
 c005a0c:	4299      	cmp	r1, r3
{
 c005a0e:	b570      	push	{r4, r5, r6, lr}
 c005a10:	4604      	mov	r4, r0
 c005a12:	460d      	mov	r5, r1
    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
 c005a14:	d902      	bls.n	c005a1c <mbedtls_mpi_grow+0x14>
        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
 c005a16:	f06f 000f 	mvn.w	r0, #15
}
 c005a1a:	bd70      	pop	{r4, r5, r6, pc}
    if( X->n < nblimbs )
 c005a1c:	6843      	ldr	r3, [r0, #4]
 c005a1e:	428b      	cmp	r3, r1
 c005a20:	d216      	bcs.n	c005a50 <mbedtls_mpi_grow+0x48>
        if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( nblimbs, ciL ) ) == NULL )
 c005a22:	2104      	movs	r1, #4
 c005a24:	4628      	mov	r0, r5
 c005a26:	f001 f969 	bl	c006cfc <mbedtls_calloc>
 c005a2a:	4606      	mov	r6, r0
 c005a2c:	2800      	cmp	r0, #0
 c005a2e:	d0f2      	beq.n	c005a16 <mbedtls_mpi_grow+0xe>
        if( X->p != NULL )
 c005a30:	68a1      	ldr	r1, [r4, #8]
 c005a32:	b159      	cbz	r1, c005a4c <mbedtls_mpi_grow+0x44>
            memcpy( p, X->p, X->n * ciL );
 c005a34:	6862      	ldr	r2, [r4, #4]
 c005a36:	0092      	lsls	r2, r2, #2
 c005a38:	f002 fe4c 	bl	c0086d4 <memcpy>
    mbedtls_platform_zeroize( v, ciL * n );
 c005a3c:	6861      	ldr	r1, [r4, #4]
 c005a3e:	68a0      	ldr	r0, [r4, #8]
 c005a40:	0089      	lsls	r1, r1, #2
 c005a42:	f001 f971 	bl	c006d28 <mbedtls_platform_zeroize>
            mbedtls_free( X->p );
 c005a46:	68a0      	ldr	r0, [r4, #8]
 c005a48:	f001 f95e 	bl	c006d08 <mbedtls_free>
        X->p = p;
 c005a4c:	e9c4 5601 	strd	r5, r6, [r4, #4]
    return( 0 );
 c005a50:	2000      	movs	r0, #0
 c005a52:	e7e2      	b.n	c005a1a <mbedtls_mpi_grow+0x12>

0c005a54 <mbedtls_mpi_copy>:
    if( X == Y )
 c005a54:	4288      	cmp	r0, r1
{
 c005a56:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c005a58:	4606      	mov	r6, r0
 c005a5a:	460f      	mov	r7, r1
    if( X == Y )
 c005a5c:	d003      	beq.n	c005a66 <mbedtls_mpi_copy+0x12>
    if( Y->p == NULL )
 c005a5e:	688d      	ldr	r5, [r1, #8]
 c005a60:	b91d      	cbnz	r5, c005a6a <mbedtls_mpi_copy+0x16>
        mbedtls_mpi_free( X );
 c005a62:	f7ff ffbf 	bl	c0059e4 <mbedtls_mpi_free>
        return( 0 );
 c005a66:	2000      	movs	r0, #0
 c005a68:	e011      	b.n	c005a8e <mbedtls_mpi_copy+0x3a>
    for( i = Y->n - 1; i > 0; i-- )
 c005a6a:	684c      	ldr	r4, [r1, #4]
 c005a6c:	3c01      	subs	r4, #1
 c005a6e:	b11c      	cbz	r4, c005a78 <mbedtls_mpi_copy+0x24>
        if( Y->p[i] != 0 )
 c005a70:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 c005a74:	2b00      	cmp	r3, #0
 c005a76:	d0f9      	beq.n	c005a6c <mbedtls_mpi_copy+0x18>
    if( X->n < i )
 c005a78:	6872      	ldr	r2, [r6, #4]
    i++;
 c005a7a:	3401      	adds	r4, #1
    X->s = Y->s;
 c005a7c:	683b      	ldr	r3, [r7, #0]
    if( X->n < i )
 c005a7e:	42a2      	cmp	r2, r4
    X->s = Y->s;
 c005a80:	6033      	str	r3, [r6, #0]
    if( X->n < i )
 c005a82:	d205      	bcs.n	c005a90 <mbedtls_mpi_copy+0x3c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i ) );
 c005a84:	4621      	mov	r1, r4
 c005a86:	4630      	mov	r0, r6
 c005a88:	f7ff ffbe 	bl	c005a08 <mbedtls_mpi_grow>
 c005a8c:	b140      	cbz	r0, c005aa0 <mbedtls_mpi_copy+0x4c>
}
 c005a8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        memset( X->p + i, 0, ( X->n - i ) * ciL );
 c005a90:	68b0      	ldr	r0, [r6, #8]
 c005a92:	1b12      	subs	r2, r2, r4
 c005a94:	0092      	lsls	r2, r2, #2
 c005a96:	2100      	movs	r1, #0
 c005a98:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 c005a9c:	f002 fe25 	bl	c0086ea <memset>
    memcpy( X->p, Y->p, i * ciL );
 c005aa0:	00a2      	lsls	r2, r4, #2
 c005aa2:	68b9      	ldr	r1, [r7, #8]
 c005aa4:	68b0      	ldr	r0, [r6, #8]
 c005aa6:	f002 fe15 	bl	c0086d4 <memcpy>
 c005aaa:	e7dc      	b.n	c005a66 <mbedtls_mpi_copy+0x12>

0c005aac <mbedtls_mpi_lset>:
{
 c005aac:	b570      	push	{r4, r5, r6, lr}
 c005aae:	460e      	mov	r6, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
 c005ab0:	2101      	movs	r1, #1
{
 c005ab2:	4604      	mov	r4, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
 c005ab4:	f7ff ffa8 	bl	c005a08 <mbedtls_mpi_grow>
 c005ab8:	4605      	mov	r5, r0
 c005aba:	b988      	cbnz	r0, c005ae0 <mbedtls_mpi_lset+0x34>
    memset( X->p, 0, X->n * ciL );
 c005abc:	6862      	ldr	r2, [r4, #4]
 c005abe:	4601      	mov	r1, r0
 c005ac0:	0092      	lsls	r2, r2, #2
 c005ac2:	68a0      	ldr	r0, [r4, #8]
 c005ac4:	f002 fe11 	bl	c0086ea <memset>
    X->p[0] = ( z < 0 ) ? -z : z;
 c005ac8:	68a3      	ldr	r3, [r4, #8]
 c005aca:	ea86 72e6 	eor.w	r2, r6, r6, asr #31
    X->s    = ( z < 0 ) ? -1 : 1;
 c005ace:	2e00      	cmp	r6, #0
    X->p[0] = ( z < 0 ) ? -z : z;
 c005ad0:	eba2 72e6 	sub.w	r2, r2, r6, asr #31
 c005ad4:	601a      	str	r2, [r3, #0]
    X->s    = ( z < 0 ) ? -1 : 1;
 c005ad6:	bfb4      	ite	lt
 c005ad8:	f04f 33ff 	movlt.w	r3, #4294967295
 c005adc:	2301      	movge	r3, #1
 c005ade:	6023      	str	r3, [r4, #0]
}
 c005ae0:	4628      	mov	r0, r5
 c005ae2:	bd70      	pop	{r4, r5, r6, pc}

0c005ae4 <mbedtls_mpi_get_bit>:
    if( X->n * biL <= pos )
 c005ae4:	6843      	ldr	r3, [r0, #4]
 c005ae6:	ebb1 1f43 	cmp.w	r1, r3, lsl #5
    return( ( X->p[pos / biL] >> ( pos % biL ) ) & 0x01 );
 c005aea:	bf3f      	itttt	cc
 c005aec:	6883      	ldrcc	r3, [r0, #8]
 c005aee:	094a      	lsrcc	r2, r1, #5
 c005af0:	f853 0022 	ldrcc.w	r0, [r3, r2, lsl #2]
 c005af4:	f001 011f 	andcc.w	r1, r1, #31
 c005af8:	bf3a      	itte	cc
 c005afa:	40c8      	lsrcc	r0, r1
 c005afc:	f000 0001 	andcc.w	r0, r0, #1
        return( 0 );
 c005b00:	2000      	movcs	r0, #0
}
 c005b02:	4770      	bx	lr

0c005b04 <mbedtls_mpi_bitlen>:
    if( X->n == 0 )
 c005b04:	6843      	ldr	r3, [r0, #4]
 c005b06:	b1db      	cbz	r3, c005b40 <mbedtls_mpi_bitlen+0x3c>
 c005b08:	6881      	ldr	r1, [r0, #8]
    for( i = X->n - 1; i > 0; i-- )
 c005b0a:	1e5a      	subs	r2, r3, #1
 c005b0c:	009b      	lsls	r3, r3, #2
 c005b0e:	b97a      	cbnz	r2, c005b30 <mbedtls_mpi_bitlen+0x2c>
    for( j = 0; j < biL; j++ )
 c005b10:	2000      	movs	r0, #0
    mbedtls_mpi_uint mask = (mbedtls_mpi_uint) 1 << (biL - 1);
 c005b12:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    j = biL - mbedtls_clz( X->p[i] );
 c005b16:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
        if( x & mask ) break;
 c005b1a:	4219      	tst	r1, r3
 c005b1c:	d104      	bne.n	c005b28 <mbedtls_mpi_bitlen+0x24>
    for( j = 0; j < biL; j++ )
 c005b1e:	3001      	adds	r0, #1
 c005b20:	2820      	cmp	r0, #32
        mask >>= 1;
 c005b22:	ea4f 0353 	mov.w	r3, r3, lsr #1
    for( j = 0; j < biL; j++ )
 c005b26:	d1f8      	bne.n	c005b1a <mbedtls_mpi_bitlen+0x16>
    return( ( i * biL ) + j );
 c005b28:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 c005b2c:	3020      	adds	r0, #32
 c005b2e:	4770      	bx	lr
        if( X->p[i] != 0 )
 c005b30:	18c8      	adds	r0, r1, r3
 c005b32:	f850 0c04 	ldr.w	r0, [r0, #-4]
 c005b36:	3b04      	subs	r3, #4
 c005b38:	2800      	cmp	r0, #0
 c005b3a:	d1e9      	bne.n	c005b10 <mbedtls_mpi_bitlen+0xc>
    for( i = X->n - 1; i > 0; i-- )
 c005b3c:	3a01      	subs	r2, #1
 c005b3e:	e7e6      	b.n	c005b0e <mbedtls_mpi_bitlen+0xa>
        return( 0 );
 c005b40:	4618      	mov	r0, r3
}
 c005b42:	4770      	bx	lr

0c005b44 <mbedtls_mpi_size>:
{
 c005b44:	b508      	push	{r3, lr}
    return( ( mbedtls_mpi_bitlen( X ) + 7 ) >> 3 );
 c005b46:	f7ff ffdd 	bl	c005b04 <mbedtls_mpi_bitlen>
 c005b4a:	3007      	adds	r0, #7
}
 c005b4c:	08c0      	lsrs	r0, r0, #3
 c005b4e:	bd08      	pop	{r3, pc}

0c005b50 <mbedtls_mpi_read_binary>:
{
 c005b50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c005b52:	460f      	mov	r7, r1
    size_t const limbs = CHARS_TO_LIMBS( buflen );
 c005b54:	f012 0103 	ands.w	r1, r2, #3
 c005b58:	bf18      	it	ne
 c005b5a:	2101      	movne	r1, #1
    if( X->n != limbs )
 c005b5c:	6843      	ldr	r3, [r0, #4]
    size_t const limbs = CHARS_TO_LIMBS( buflen );
 c005b5e:	eb01 0492 	add.w	r4, r1, r2, lsr #2
    if( X->n != limbs )
 c005b62:	42a3      	cmp	r3, r4
{
 c005b64:	4606      	mov	r6, r0
 c005b66:	4615      	mov	r5, r2
    if( X->n != limbs )
 c005b68:	d11a      	bne.n	c005ba0 <mbedtls_mpi_read_binary+0x50>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 c005b6a:	2100      	movs	r1, #0
 c005b6c:	4630      	mov	r0, r6
 c005b6e:	f7ff ff9d 	bl	c005aac <mbedtls_mpi_lset>
 c005b72:	b9f8      	cbnz	r0, c005bb4 <mbedtls_mpi_read_binary+0x64>
    for( i = buflen, j = 0; i > 0; i--, j++ )
 c005b74:	4603      	mov	r3, r0
 c005b76:	1979      	adds	r1, r7, r5
 c005b78:	429d      	cmp	r5, r3
 c005b7a:	d01b      	beq.n	c005bb4 <mbedtls_mpi_read_binary+0x64>
        X->p[j / ciL] |= ((mbedtls_mpi_uint) buf[i - 1]) << ((j % ciL) << 3);
 c005b7c:	f811 2d01 	ldrb.w	r2, [r1, #-1]!
 c005b80:	f8d6 c008 	ldr.w	ip, [r6, #8]
 c005b84:	00dc      	lsls	r4, r3, #3
 c005b86:	f023 0703 	bic.w	r7, r3, #3
 c005b8a:	f004 0418 	and.w	r4, r4, #24
 c005b8e:	fa02 f404 	lsl.w	r4, r2, r4
 c005b92:	f85c 2007 	ldr.w	r2, [ip, r7]
    for( i = buflen, j = 0; i > 0; i--, j++ )
 c005b96:	3301      	adds	r3, #1
        X->p[j / ciL] |= ((mbedtls_mpi_uint) buf[i - 1]) << ((j % ciL) << 3);
 c005b98:	4322      	orrs	r2, r4
 c005b9a:	f84c 2007 	str.w	r2, [ip, r7]
 c005b9e:	e7eb      	b.n	c005b78 <mbedtls_mpi_read_binary+0x28>
        mbedtls_mpi_free( X );
 c005ba0:	f7ff ff20 	bl	c0059e4 <mbedtls_mpi_free>
        mbedtls_mpi_init( X );
 c005ba4:	4630      	mov	r0, r6
 c005ba6:	f7ff ff16 	bl	c0059d6 <mbedtls_mpi_init>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, limbs ) );
 c005baa:	4621      	mov	r1, r4
 c005bac:	f7ff ff2c 	bl	c005a08 <mbedtls_mpi_grow>
 c005bb0:	2800      	cmp	r0, #0
 c005bb2:	d0da      	beq.n	c005b6a <mbedtls_mpi_read_binary+0x1a>
}
 c005bb4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0c005bb6 <mbedtls_mpi_write_binary>:
{
 c005bb6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c005bb8:	4605      	mov	r5, r0
    size_t stored_bytes = X->n * ciL;
 c005bba:	686c      	ldr	r4, [r5, #4]
{
 c005bbc:	4608      	mov	r0, r1
    size_t stored_bytes = X->n * ciL;
 c005bbe:	00a4      	lsls	r4, r4, #2
    if( stored_bytes < buflen )
 c005bc0:	4294      	cmp	r4, r2
 c005bc2:	d21c      	bcs.n	c005bfe <mbedtls_mpi_write_binary+0x48>
        p = buf + buflen - stored_bytes;
 c005bc4:	1b12      	subs	r2, r2, r4
 c005bc6:	188e      	adds	r6, r1, r2
        memset( buf, 0, buflen - stored_bytes );
 c005bc8:	2100      	movs	r1, #0
 c005bca:	f002 fd8e 	bl	c0086ea <memset>
        p = buf + buflen - stored_bytes;
 c005bce:	4630      	mov	r0, r6
 c005bd0:	4622      	mov	r2, r4
    for( i = 0; i < bytes_to_copy; i++ )
 c005bd2:	2300      	movs	r3, #0
 c005bd4:	4410      	add	r0, r2
 c005bd6:	429a      	cmp	r2, r3
 c005bd8:	d113      	bne.n	c005c02 <mbedtls_mpi_write_binary+0x4c>
    return( 0 );
 c005bda:	2000      	movs	r0, #0
}
 c005bdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if( GET_BYTE( X, i ) != 0 )
 c005bde:	68af      	ldr	r7, [r5, #8]
 c005be0:	f003 0103 	and.w	r1, r3, #3
 c005be4:	f023 0c03 	bic.w	ip, r3, #3
 c005be8:	00ce      	lsls	r6, r1, #3
 c005bea:	f857 100c 	ldr.w	r1, [r7, ip]
 c005bee:	40f1      	lsrs	r1, r6
 c005bf0:	f011 0fff 	tst.w	r1, #255	; 0xff
 c005bf4:	d111      	bne.n	c005c1a <mbedtls_mpi_write_binary+0x64>
        for( i = bytes_to_copy; i < stored_bytes; i++ )
 c005bf6:	3301      	adds	r3, #1
 c005bf8:	42a3      	cmp	r3, r4
 c005bfa:	d1f0      	bne.n	c005bde <mbedtls_mpi_write_binary+0x28>
 c005bfc:	e7e9      	b.n	c005bd2 <mbedtls_mpi_write_binary+0x1c>
 c005bfe:	4613      	mov	r3, r2
 c005c00:	e7fa      	b.n	c005bf8 <mbedtls_mpi_write_binary+0x42>
        p[bytes_to_copy - i - 1] = GET_BYTE( X, i );
 c005c02:	68af      	ldr	r7, [r5, #8]
 c005c04:	f003 0103 	and.w	r1, r3, #3
 c005c08:	f023 0603 	bic.w	r6, r3, #3
 c005c0c:	00cc      	lsls	r4, r1, #3
 c005c0e:	59b9      	ldr	r1, [r7, r6]
    for( i = 0; i < bytes_to_copy; i++ )
 c005c10:	3301      	adds	r3, #1
        p[bytes_to_copy - i - 1] = GET_BYTE( X, i );
 c005c12:	40e1      	lsrs	r1, r4
 c005c14:	f800 1d01 	strb.w	r1, [r0, #-1]!
 c005c18:	e7dd      	b.n	c005bd6 <mbedtls_mpi_write_binary+0x20>
                return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
 c005c1a:	f06f 0007 	mvn.w	r0, #7
 c005c1e:	e7dd      	b.n	c005bdc <mbedtls_mpi_write_binary+0x26>

0c005c20 <mbedtls_mpi_shift_l>:
{
 c005c20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c005c22:	4606      	mov	r6, r0
 c005c24:	460d      	mov	r5, r1
    v0 = count / (biL    );
 c005c26:	094c      	lsrs	r4, r1, #5
    t1 = count & (biL - 1);
 c005c28:	f001 071f 	and.w	r7, r1, #31
    i = mbedtls_mpi_bitlen( X ) + count;
 c005c2c:	f7ff ff6a 	bl	c005b04 <mbedtls_mpi_bitlen>
    if( X->n * biL < i )
 c005c30:	6873      	ldr	r3, [r6, #4]
    i = mbedtls_mpi_bitlen( X ) + count;
 c005c32:	4428      	add	r0, r5
    if( X->n * biL < i )
 c005c34:	ebb0 1f43 	cmp.w	r0, r3, lsl #5
 c005c38:	d803      	bhi.n	c005c42 <mbedtls_mpi_shift_l+0x22>
    if( v0 > 0 )
 c005c3a:	b974      	cbnz	r4, c005c5a <mbedtls_mpi_shift_l+0x3a>
    if( t1 > 0 )
 c005c3c:	bb2f      	cbnz	r7, c005c8a <mbedtls_mpi_shift_l+0x6a>
    ret = 0;
 c005c3e:	2000      	movs	r0, #0
 c005c40:	e00a      	b.n	c005c58 <mbedtls_mpi_shift_l+0x38>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, BITS_TO_LIMBS( i ) ) );
 c005c42:	f010 011f 	ands.w	r1, r0, #31
 c005c46:	bf18      	it	ne
 c005c48:	2101      	movne	r1, #1
 c005c4a:	eb01 1150 	add.w	r1, r1, r0, lsr #5
 c005c4e:	4630      	mov	r0, r6
 c005c50:	f7ff feda 	bl	c005a08 <mbedtls_mpi_grow>
 c005c54:	2800      	cmp	r0, #0
 c005c56:	d0f0      	beq.n	c005c3a <mbedtls_mpi_shift_l+0x1a>
}
 c005c58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        for( i = X->n; i > v0; i-- )
 c005c5a:	6873      	ldr	r3, [r6, #4]
 c005c5c:	00a0      	lsls	r0, r4, #2
 c005c5e:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
 c005c62:	3a01      	subs	r2, #1
 c005c64:	1b12      	subs	r2, r2, r4
 c005c66:	0092      	lsls	r2, r2, #2
 c005c68:	42a3      	cmp	r3, r4
 c005c6a:	d807      	bhi.n	c005c7c <mbedtls_mpi_shift_l+0x5c>
            X->p[i - 1] = 0;
 c005c6c:	2200      	movs	r2, #0
 c005c6e:	009b      	lsls	r3, r3, #2
 c005c70:	3b04      	subs	r3, #4
        for( ; i > 0; i-- )
 c005c72:	1d19      	adds	r1, r3, #4
 c005c74:	d0e2      	beq.n	c005c3c <mbedtls_mpi_shift_l+0x1c>
            X->p[i - 1] = 0;
 c005c76:	68b1      	ldr	r1, [r6, #8]
 c005c78:	50ca      	str	r2, [r1, r3]
 c005c7a:	e7f9      	b.n	c005c70 <mbedtls_mpi_shift_l+0x50>
            X->p[i - 1] = X->p[i - v0 - 1];
 c005c7c:	68b1      	ldr	r1, [r6, #8]
        for( i = X->n; i > v0; i-- )
 c005c7e:	3b01      	subs	r3, #1
            X->p[i - 1] = X->p[i - v0 - 1];
 c005c80:	588d      	ldr	r5, [r1, r2]
 c005c82:	4411      	add	r1, r2
 c005c84:	500d      	str	r5, [r1, r0]
 c005c86:	3a04      	subs	r2, #4
 c005c88:	e7ee      	b.n	c005c68 <mbedtls_mpi_shift_l+0x48>
    mbedtls_mpi_uint r0 = 0, r1;
 c005c8a:	2100      	movs	r1, #0
        for( i = v0; i < X->n; i++ )
 c005c8c:	f8d6 c004 	ldr.w	ip, [r6, #4]
 c005c90:	00a3      	lsls	r3, r4, #2
            r1 = X->p[i] >> (biL - t1);
 c005c92:	f1c7 0e20 	rsb	lr, r7, #32
        for( i = v0; i < X->n; i++ )
 c005c96:	45a4      	cmp	ip, r4
 c005c98:	d9d1      	bls.n	c005c3e <mbedtls_mpi_shift_l+0x1e>
            r1 = X->p[i] >> (biL - t1);
 c005c9a:	68b5      	ldr	r5, [r6, #8]
        for( i = v0; i < X->n; i++ )
 c005c9c:	3401      	adds	r4, #1
            r1 = X->p[i] >> (biL - t1);
 c005c9e:	58e8      	ldr	r0, [r5, r3]
            X->p[i] <<= t1;
 c005ca0:	fa00 f207 	lsl.w	r2, r0, r7
            X->p[i] |= r0;
 c005ca4:	430a      	orrs	r2, r1
 c005ca6:	50ea      	str	r2, [r5, r3]
            r1 = X->p[i] >> (biL - t1);
 c005ca8:	fa20 f10e 	lsr.w	r1, r0, lr
 c005cac:	3304      	adds	r3, #4
 c005cae:	e7f2      	b.n	c005c96 <mbedtls_mpi_shift_l+0x76>

0c005cb0 <mbedtls_mpi_shift_r>:
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 c005cb0:	6843      	ldr	r3, [r0, #4]
{
 c005cb2:	b4f0      	push	{r4, r5, r6, r7}
    v0 = count /  biL;
 c005cb4:	094d      	lsrs	r5, r1, #5
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 c005cb6:	42ab      	cmp	r3, r5
 c005cb8:	d303      	bcc.n	c005cc2 <mbedtls_mpi_shift_r+0x12>
    v1 = count & (biL - 1);
 c005cba:	f001 011f 	and.w	r1, r1, #31
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 c005cbe:	d104      	bne.n	c005cca <mbedtls_mpi_shift_r+0x1a>
 c005cc0:	b369      	cbz	r1, c005d1e <mbedtls_mpi_shift_r+0x6e>
}
 c005cc2:	bcf0      	pop	{r4, r5, r6, r7}
        return mbedtls_mpi_lset( X, 0 );
 c005cc4:	2100      	movs	r1, #0
 c005cc6:	f7ff bef1 	b.w	c005aac <mbedtls_mpi_lset>
    if( v0 > 0 )
 c005cca:	b9e5      	cbnz	r5, c005d06 <mbedtls_mpi_shift_r+0x56>
    if( v1 > 0 )
 c005ccc:	b129      	cbz	r1, c005cda <mbedtls_mpi_shift_r+0x2a>
    mbedtls_mpi_uint r0 = 0, r1;
 c005cce:	2500      	movs	r5, #0
 c005cd0:	009a      	lsls	r2, r3, #2
            r1 = X->p[i - 1] << (biL - v1);
 c005cd2:	f1c1 0c20 	rsb	ip, r1, #32
 c005cd6:	3a04      	subs	r2, #4
        for( i = X->n; i > 0; i-- )
 c005cd8:	b9bb      	cbnz	r3, c005d0a <mbedtls_mpi_shift_r+0x5a>
}
 c005cda:	bcf0      	pop	{r4, r5, r6, r7}
 c005cdc:	2000      	movs	r0, #0
 c005cde:	4770      	bx	lr
            X->p[i] = X->p[i + v0];
 c005ce0:	6884      	ldr	r4, [r0, #8]
 c005ce2:	1956      	adds	r6, r2, r5
 c005ce4:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 c005ce8:	f844 6022 	str.w	r6, [r4, r2, lsl #2]
        for( i = 0; i < X->n - v0; i++ )
 c005cec:	3201      	adds	r2, #1
 c005cee:	1b5c      	subs	r4, r3, r5
 c005cf0:	4294      	cmp	r4, r2
 c005cf2:	d8f5      	bhi.n	c005ce0 <mbedtls_mpi_shift_r+0x30>
            X->p[i] = 0;
 c005cf4:	2500      	movs	r5, #0
 c005cf6:	00a2      	lsls	r2, r4, #2
        for( ; i < X->n; i++ )
 c005cf8:	42a3      	cmp	r3, r4
 c005cfa:	d9e7      	bls.n	c005ccc <mbedtls_mpi_shift_r+0x1c>
            X->p[i] = 0;
 c005cfc:	6886      	ldr	r6, [r0, #8]
        for( ; i < X->n; i++ )
 c005cfe:	3401      	adds	r4, #1
            X->p[i] = 0;
 c005d00:	50b5      	str	r5, [r6, r2]
 c005d02:	3204      	adds	r2, #4
 c005d04:	e7f8      	b.n	c005cf8 <mbedtls_mpi_shift_r+0x48>
 c005d06:	2200      	movs	r2, #0
 c005d08:	e7f1      	b.n	c005cee <mbedtls_mpi_shift_r+0x3e>
            r1 = X->p[i - 1] << (biL - v1);
 c005d0a:	6887      	ldr	r7, [r0, #8]
        for( i = X->n; i > 0; i-- )
 c005d0c:	3b01      	subs	r3, #1
            r1 = X->p[i - 1] << (biL - v1);
 c005d0e:	58be      	ldr	r6, [r7, r2]
            X->p[i - 1] >>= v1;
 c005d10:	fa26 f401 	lsr.w	r4, r6, r1
            X->p[i - 1] |= r0;
 c005d14:	432c      	orrs	r4, r5
 c005d16:	50bc      	str	r4, [r7, r2]
            r1 = X->p[i - 1] << (biL - v1);
 c005d18:	fa06 f50c 	lsl.w	r5, r6, ip
 c005d1c:	e7db      	b.n	c005cd6 <mbedtls_mpi_shift_r+0x26>
    if( v0 > 0 )
 c005d1e:	2b00      	cmp	r3, #0
 c005d20:	d0db      	beq.n	c005cda <mbedtls_mpi_shift_r+0x2a>
 c005d22:	460a      	mov	r2, r1
 c005d24:	e7e3      	b.n	c005cee <mbedtls_mpi_shift_r+0x3e>

0c005d26 <mbedtls_mpi_cmp_abs>:
{
 c005d26:	b570      	push	{r4, r5, r6, lr}
    for( i = X->n; i > 0; i-- )
 c005d28:	6843      	ldr	r3, [r0, #4]
 c005d2a:	009a      	lsls	r2, r3, #2
 c005d2c:	b933      	cbnz	r3, c005d3c <mbedtls_mpi_cmp_abs+0x16>
    for( j = Y->n; j > 0; j-- )
 c005d2e:	684a      	ldr	r2, [r1, #4]
 c005d30:	0094      	lsls	r4, r2, #2
 c005d32:	b962      	cbnz	r2, c005d4e <mbedtls_mpi_cmp_abs+0x28>
    if( i == 0 && j == 0 )
 c005d34:	1c18      	adds	r0, r3, #0
 c005d36:	bf18      	it	ne
 c005d38:	2001      	movne	r0, #1
 c005d3a:	e016      	b.n	c005d6a <mbedtls_mpi_cmp_abs+0x44>
        if( X->p[i - 1] != 0 )
 c005d3c:	6884      	ldr	r4, [r0, #8]
 c005d3e:	4414      	add	r4, r2
 c005d40:	f854 4c04 	ldr.w	r4, [r4, #-4]
 c005d44:	3a04      	subs	r2, #4
 c005d46:	2c00      	cmp	r4, #0
 c005d48:	d1f1      	bne.n	c005d2e <mbedtls_mpi_cmp_abs+0x8>
    for( i = X->n; i > 0; i-- )
 c005d4a:	3b01      	subs	r3, #1
 c005d4c:	e7ee      	b.n	c005d2c <mbedtls_mpi_cmp_abs+0x6>
        if( Y->p[j - 1] != 0 )
 c005d4e:	688d      	ldr	r5, [r1, #8]
 c005d50:	192e      	adds	r6, r5, r4
 c005d52:	f856 6c04 	ldr.w	r6, [r6, #-4]
 c005d56:	3c04      	subs	r4, #4
 c005d58:	b90e      	cbnz	r6, c005d5e <mbedtls_mpi_cmp_abs+0x38>
    for( j = Y->n; j > 0; j-- )
 c005d5a:	3a01      	subs	r2, #1
 c005d5c:	e7e9      	b.n	c005d32 <mbedtls_mpi_cmp_abs+0xc>
    if( i > j ) return(  1 );
 c005d5e:	4293      	cmp	r3, r2
 c005d60:	d80d      	bhi.n	c005d7e <mbedtls_mpi_cmp_abs+0x58>
    if( j > i ) return( -1 );
 c005d62:	d30e      	bcc.n	c005d82 <mbedtls_mpi_cmp_abs+0x5c>
 c005d64:	009a      	lsls	r2, r3, #2
    for( ; i > 0; i-- )
 c005d66:	b90b      	cbnz	r3, c005d6c <mbedtls_mpi_cmp_abs+0x46>
    return( 0 );
 c005d68:	4618      	mov	r0, r3
}
 c005d6a:	bd70      	pop	{r4, r5, r6, pc}
        if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
 c005d6c:	6881      	ldr	r1, [r0, #8]
 c005d6e:	3a04      	subs	r2, #4
 c005d70:	588c      	ldr	r4, [r1, r2]
 c005d72:	58a9      	ldr	r1, [r5, r2]
 c005d74:	428c      	cmp	r4, r1
 c005d76:	d802      	bhi.n	c005d7e <mbedtls_mpi_cmp_abs+0x58>
        if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );
 c005d78:	d303      	bcc.n	c005d82 <mbedtls_mpi_cmp_abs+0x5c>
    for( ; i > 0; i-- )
 c005d7a:	3b01      	subs	r3, #1
 c005d7c:	e7f3      	b.n	c005d66 <mbedtls_mpi_cmp_abs+0x40>
    if( i > j ) return(  1 );
 c005d7e:	2001      	movs	r0, #1
 c005d80:	e7f3      	b.n	c005d6a <mbedtls_mpi_cmp_abs+0x44>
    if( j > i ) return( -1 );
 c005d82:	f04f 30ff 	mov.w	r0, #4294967295
 c005d86:	e7f0      	b.n	c005d6a <mbedtls_mpi_cmp_abs+0x44>

0c005d88 <mpi_montmul>:
/*
 * Montgomery multiplication: A = A * B * R^-1 mod N  (HAC 14.36)
 */
static int mpi_montmul( mbedtls_mpi *A, const mbedtls_mpi *B, const mbedtls_mpi *N, mbedtls_mpi_uint mm,
                         const mbedtls_mpi *T )
{
 c005d88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c005d8c:	4616      	mov	r6, r2
 c005d8e:	b085      	sub	sp, #20
 c005d90:	9303      	str	r3, [sp, #12]
    size_t i, n, m;
    mbedtls_mpi_uint u0, u1, *d;

    if( T->n < N->n + 1 || T->p == NULL )
 c005d92:	9b0e      	ldr	r3, [sp, #56]	; 0x38
{
 c005d94:	4681      	mov	r9, r0
    if( T->n < N->n + 1 || T->p == NULL )
 c005d96:	685a      	ldr	r2, [r3, #4]
 c005d98:	6873      	ldr	r3, [r6, #4]
{
 c005d9a:	468b      	mov	fp, r1
    if( T->n < N->n + 1 || T->p == NULL )
 c005d9c:	3301      	adds	r3, #1
 c005d9e:	429a      	cmp	r2, r3
 c005da0:	d353      	bcc.n	c005e4a <mpi_montmul+0xc2>
 c005da2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 c005da4:	6898      	ldr	r0, [r3, #8]
 c005da6:	2800      	cmp	r0, #0
 c005da8:	d04f      	beq.n	c005e4a <mpi_montmul+0xc2>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );

    memset( T->p, 0, T->n * ciL );
 c005daa:	0092      	lsls	r2, r2, #2
 c005dac:	2100      	movs	r1, #0
 c005dae:	f002 fc9c 	bl	c0086ea <memset>

    d = T->p;
 c005db2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    n = N->n;
 c005db4:	f8d6 a004 	ldr.w	sl, [r6, #4]
    d = T->p;
 c005db8:	689b      	ldr	r3, [r3, #8]
    m = ( B->n < n ) ? B->n : n;

    for( i = 0; i < n; i++ )
 c005dba:	2400      	movs	r4, #0
    d = T->p;
 c005dbc:	9300      	str	r3, [sp, #0]
    m = ( B->n < n ) ? B->n : n;
 c005dbe:	f8db 3004 	ldr.w	r3, [fp, #4]
        u1 = ( d[0] + u0 * B->p[0] ) * mm;

        mpi_mul_hlp( m, B->p, d, u0 );
        mpi_mul_hlp( n, N->p, d, u1 );

        *d++ = u0; d[n + 1] = 0;
 c005dc2:	f10a 0701 	add.w	r7, sl, #1
    m = ( B->n < n ) ? B->n : n;
 c005dc6:	4553      	cmp	r3, sl
 c005dc8:	bf28      	it	cs
 c005dca:	4653      	movcs	r3, sl
    d = T->p;
 c005dcc:	9d00      	ldr	r5, [sp, #0]
    m = ( B->n < n ) ? B->n : n;
 c005dce:	9301      	str	r3, [sp, #4]
        *d++ = u0; d[n + 1] = 0;
 c005dd0:	00bf      	lsls	r7, r7, #2
    for( i = 0; i < n; i++ )
 c005dd2:	4554      	cmp	r4, sl
 c005dd4:	f8d9 0008 	ldr.w	r0, [r9, #8]
 c005dd8:	d11b      	bne.n	c005e12 <mpi_montmul+0x8a>
    }

    memcpy( A->p, d, ( n + 1 ) * ciL );
 c005dda:	9b00      	ldr	r3, [sp, #0]
 c005ddc:	1f39      	subs	r1, r7, #4
 c005dde:	440b      	add	r3, r1
 c005de0:	463a      	mov	r2, r7
 c005de2:	4619      	mov	r1, r3
 c005de4:	f002 fc76 	bl	c0086d4 <memcpy>

    if( mbedtls_mpi_cmp_abs( A, N ) >= 0 )
 c005de8:	4631      	mov	r1, r6
 c005dea:	4648      	mov	r0, r9
 c005dec:	f7ff ff9b 	bl	c005d26 <mbedtls_mpi_cmp_abs>
 c005df0:	2800      	cmp	r0, #0
        mpi_sub_hlp( n, N->p, A->p );
    else
        /* prevent timing attacks */
        mpi_sub_hlp( n, A->p, T->p );
 c005df2:	bfb8      	it	lt
 c005df4:	9b0e      	ldrlt	r3, [sp, #56]	; 0x38
 c005df6:	4620      	mov	r0, r4
        mpi_sub_hlp( n, N->p, A->p );
 c005df8:	bfa7      	ittee	ge
 c005dfa:	f8d9 2008 	ldrge.w	r2, [r9, #8]
 c005dfe:	68b1      	ldrge	r1, [r6, #8]
        mpi_sub_hlp( n, A->p, T->p );
 c005e00:	689a      	ldrlt	r2, [r3, #8]
 c005e02:	f8d9 1008 	ldrlt.w	r1, [r9, #8]
 c005e06:	f7ff fb4c 	bl	c0054a2 <mpi_sub_hlp>

    return( 0 );
 c005e0a:	2000      	movs	r0, #0
}
 c005e0c:	b005      	add	sp, #20
 c005e0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 c005e12:	f8db 1008 	ldr.w	r1, [fp, #8]
        u0 = A->p[i];
 c005e16:	f850 8024 	ldr.w	r8, [r0, r4, lsl #2]
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 c005e1a:	682a      	ldr	r2, [r5, #0]
 c005e1c:	680b      	ldr	r3, [r1, #0]
        mpi_mul_hlp( m, B->p, d, u0 );
 c005e1e:	9801      	ldr	r0, [sp, #4]
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 c005e20:	fb03 2308 	mla	r3, r3, r8, r2
 c005e24:	9a03      	ldr	r2, [sp, #12]
    for( i = 0; i < n; i++ )
 c005e26:	3401      	adds	r4, #1
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 c005e28:	4353      	muls	r3, r2
        mpi_mul_hlp( m, B->p, d, u0 );
 c005e2a:	462a      	mov	r2, r5
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 c005e2c:	9302      	str	r3, [sp, #8]
        mpi_mul_hlp( m, B->p, d, u0 );
 c005e2e:	4643      	mov	r3, r8
 c005e30:	f7ff fb61 	bl	c0054f6 <mpi_mul_hlp>
        mpi_mul_hlp( n, N->p, d, u1 );
 c005e34:	9b02      	ldr	r3, [sp, #8]
 c005e36:	462a      	mov	r2, r5
 c005e38:	68b1      	ldr	r1, [r6, #8]
 c005e3a:	4650      	mov	r0, sl
 c005e3c:	f7ff fb5b 	bl	c0054f6 <mpi_mul_hlp>
        *d++ = u0; d[n + 1] = 0;
 c005e40:	2300      	movs	r3, #0
 c005e42:	f845 8b04 	str.w	r8, [r5], #4
 c005e46:	51eb      	str	r3, [r5, r7]
 c005e48:	e7c3      	b.n	c005dd2 <mpi_montmul+0x4a>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c005e4a:	f06f 0003 	mvn.w	r0, #3
 c005e4e:	e7dd      	b.n	c005e0c <mpi_montmul+0x84>

0c005e50 <mbedtls_mpi_cmp_mpi>:
{
 c005e50:	b570      	push	{r4, r5, r6, lr}
    for( i = X->n; i > 0; i-- )
 c005e52:	6843      	ldr	r3, [r0, #4]
 c005e54:	009a      	lsls	r2, r3, #2
 c005e56:	b923      	cbnz	r3, c005e62 <mbedtls_mpi_cmp_mpi+0x12>
    for( j = Y->n; j > 0; j-- )
 c005e58:	684a      	ldr	r2, [r1, #4]
 c005e5a:	0094      	lsls	r4, r2, #2
 c005e5c:	b952      	cbnz	r2, c005e74 <mbedtls_mpi_cmp_mpi+0x24>
    if( i == 0 && j == 0 )
 c005e5e:	b99b      	cbnz	r3, c005e88 <mbedtls_mpi_cmp_mpi+0x38>
 c005e60:	e024      	b.n	c005eac <mbedtls_mpi_cmp_mpi+0x5c>
        if( X->p[i - 1] != 0 )
 c005e62:	6884      	ldr	r4, [r0, #8]
 c005e64:	4414      	add	r4, r2
 c005e66:	f854 4c04 	ldr.w	r4, [r4, #-4]
 c005e6a:	3a04      	subs	r2, #4
 c005e6c:	2c00      	cmp	r4, #0
 c005e6e:	d1f3      	bne.n	c005e58 <mbedtls_mpi_cmp_mpi+0x8>
    for( i = X->n; i > 0; i-- )
 c005e70:	3b01      	subs	r3, #1
 c005e72:	e7f0      	b.n	c005e56 <mbedtls_mpi_cmp_mpi+0x6>
        if( Y->p[j - 1] != 0 )
 c005e74:	688d      	ldr	r5, [r1, #8]
 c005e76:	192e      	adds	r6, r5, r4
 c005e78:	f856 6c04 	ldr.w	r6, [r6, #-4]
 c005e7c:	3c04      	subs	r4, #4
 c005e7e:	b90e      	cbnz	r6, c005e84 <mbedtls_mpi_cmp_mpi+0x34>
    for( j = Y->n; j > 0; j-- )
 c005e80:	3a01      	subs	r2, #1
 c005e82:	e7eb      	b.n	c005e5c <mbedtls_mpi_cmp_mpi+0xc>
    if( i > j ) return(  X->s );
 c005e84:	4293      	cmp	r3, r2
 c005e86:	d902      	bls.n	c005e8e <mbedtls_mpi_cmp_mpi+0x3e>
 c005e88:	6802      	ldr	r2, [r0, #0]
}
 c005e8a:	4610      	mov	r0, r2
 c005e8c:	bd70      	pop	{r4, r5, r6, pc}
 c005e8e:	6809      	ldr	r1, [r1, #0]
    if( j > i ) return( -Y->s );
 c005e90:	d201      	bcs.n	c005e96 <mbedtls_mpi_cmp_mpi+0x46>
 c005e92:	424a      	negs	r2, r1
 c005e94:	e7f9      	b.n	c005e8a <mbedtls_mpi_cmp_mpi+0x3a>
    if( X->s > 0 && Y->s < 0 ) return(  1 );
 c005e96:	6802      	ldr	r2, [r0, #0]
 c005e98:	2a00      	cmp	r2, #0
 c005e9a:	dd01      	ble.n	c005ea0 <mbedtls_mpi_cmp_mpi+0x50>
 c005e9c:	2900      	cmp	r1, #0
 c005e9e:	db12      	blt.n	c005ec6 <mbedtls_mpi_cmp_mpi+0x76>
    if( Y->s > 0 && X->s < 0 ) return( -1 );
 c005ea0:	2900      	cmp	r1, #0
 c005ea2:	dd01      	ble.n	c005ea8 <mbedtls_mpi_cmp_mpi+0x58>
 c005ea4:	2a00      	cmp	r2, #0
 c005ea6:	db10      	blt.n	c005eca <mbedtls_mpi_cmp_mpi+0x7a>
 c005ea8:	0099      	lsls	r1, r3, #2
    for( ; i > 0; i-- )
 c005eaa:	b90b      	cbnz	r3, c005eb0 <mbedtls_mpi_cmp_mpi+0x60>
    return( 0 );
 c005eac:	461a      	mov	r2, r3
 c005eae:	e7ec      	b.n	c005e8a <mbedtls_mpi_cmp_mpi+0x3a>
        if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
 c005eb0:	6884      	ldr	r4, [r0, #8]
 c005eb2:	3904      	subs	r1, #4
 c005eb4:	5866      	ldr	r6, [r4, r1]
 c005eb6:	586c      	ldr	r4, [r5, r1]
 c005eb8:	42a6      	cmp	r6, r4
 c005eba:	d8e6      	bhi.n	c005e8a <mbedtls_mpi_cmp_mpi+0x3a>
        if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );
 c005ebc:	d201      	bcs.n	c005ec2 <mbedtls_mpi_cmp_mpi+0x72>
 c005ebe:	4252      	negs	r2, r2
 c005ec0:	e7e3      	b.n	c005e8a <mbedtls_mpi_cmp_mpi+0x3a>
    for( ; i > 0; i-- )
 c005ec2:	3b01      	subs	r3, #1
 c005ec4:	e7f1      	b.n	c005eaa <mbedtls_mpi_cmp_mpi+0x5a>
    if( X->s > 0 && Y->s < 0 ) return(  1 );
 c005ec6:	2201      	movs	r2, #1
 c005ec8:	e7df      	b.n	c005e8a <mbedtls_mpi_cmp_mpi+0x3a>
    if( Y->s > 0 && X->s < 0 ) return( -1 );
 c005eca:	f04f 32ff 	mov.w	r2, #4294967295
 c005ece:	e7dc      	b.n	c005e8a <mbedtls_mpi_cmp_mpi+0x3a>

0c005ed0 <mbedtls_mpi_cmp_int>:
{
 c005ed0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    *p  = ( z < 0 ) ? -z : z;
 c005ed2:	ea81 73e1 	eor.w	r3, r1, r1, asr #31
 c005ed6:	eba3 73e1 	sub.w	r3, r3, r1, asr #31
    Y.s = ( z < 0 ) ? -1 : 1;
 c005eda:	2900      	cmp	r1, #0
    *p  = ( z < 0 ) ? -z : z;
 c005edc:	9300      	str	r3, [sp, #0]
    Y.s = ( z < 0 ) ? -1 : 1;
 c005ede:	bfb4      	ite	lt
 c005ee0:	f04f 33ff 	movlt.w	r3, #4294967295
 c005ee4:	2301      	movge	r3, #1
 c005ee6:	9301      	str	r3, [sp, #4]
    Y.n = 1;
 c005ee8:	2301      	movs	r3, #1
    return( mbedtls_mpi_cmp_mpi( X, &Y ) );
 c005eea:	a901      	add	r1, sp, #4
    Y.n = 1;
 c005eec:	9302      	str	r3, [sp, #8]
    Y.p = p;
 c005eee:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_cmp_mpi( X, &Y ) );
 c005ef2:	f7ff ffad 	bl	c005e50 <mbedtls_mpi_cmp_mpi>
}
 c005ef6:	b005      	add	sp, #20
 c005ef8:	f85d fb04 	ldr.w	pc, [sp], #4

0c005efc <mbedtls_mpi_add_abs>:
    if( X == B )
 c005efc:	4290      	cmp	r0, r2
{
 c005efe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c005f02:	4606      	mov	r6, r0
 c005f04:	460c      	mov	r4, r1
 c005f06:	4615      	mov	r5, r2
    if( X == B )
 c005f08:	d002      	beq.n	c005f10 <mbedtls_mpi_add_abs+0x14>
    if( X != A )
 c005f0a:	4288      	cmp	r0, r1
 c005f0c:	d131      	bne.n	c005f72 <mbedtls_mpi_add_abs+0x76>
{
 c005f0e:	462c      	mov	r4, r5
    X->s = 1;
 c005f10:	2301      	movs	r3, #1
    for( j = B->n; j > 0; j-- )
 c005f12:	f8d4 8004 	ldr.w	r8, [r4, #4]
    X->s = 1;
 c005f16:	6033      	str	r3, [r6, #0]
 c005f18:	ea4f 0388 	mov.w	r3, r8, lsl #2
    for( j = B->n; j > 0; j-- )
 c005f1c:	f1b8 0f00 	cmp.w	r8, #0
 c005f20:	d12f      	bne.n	c005f82 <mbedtls_mpi_add_abs+0x86>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 c005f22:	4641      	mov	r1, r8
 c005f24:	4630      	mov	r0, r6
 c005f26:	f7ff fd6f 	bl	c005a08 <mbedtls_mpi_grow>
 c005f2a:	4607      	mov	r7, r0
 c005f2c:	bb30      	cbnz	r0, c005f7c <mbedtls_mpi_add_abs+0x80>
    o = B->p; p = X->p; c = 0;
 c005f2e:	68b3      	ldr	r3, [r6, #8]
 c005f30:	f8d4 e008 	ldr.w	lr, [r4, #8]
 c005f34:	4619      	mov	r1, r3
 c005f36:	4604      	mov	r4, r0
    for( i = 0; i < j; i++, o++, p++ )
 c005f38:	4605      	mov	r5, r0
 c005f3a:	45a8      	cmp	r8, r5
 c005f3c:	d12b      	bne.n	c005f96 <mbedtls_mpi_add_abs+0x9a>
 c005f3e:	eb03 0385 	add.w	r3, r3, r5, lsl #2
    while( c != 0 )
 c005f42:	b1dc      	cbz	r4, c005f7c <mbedtls_mpi_add_abs+0x80>
        if( i >= X->n )
 c005f44:	6872      	ldr	r2, [r6, #4]
 c005f46:	f105 0801 	add.w	r8, r5, #1
 c005f4a:	42aa      	cmp	r2, r5
 c005f4c:	d807      	bhi.n	c005f5e <mbedtls_mpi_add_abs+0x62>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
 c005f4e:	4641      	mov	r1, r8
 c005f50:	4630      	mov	r0, r6
 c005f52:	f7ff fd59 	bl	c005a08 <mbedtls_mpi_grow>
 c005f56:	bb80      	cbnz	r0, c005fba <mbedtls_mpi_add_abs+0xbe>
            p = X->p + i;
 c005f58:	68b3      	ldr	r3, [r6, #8]
 c005f5a:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 c005f5e:	681a      	ldr	r2, [r3, #0]
 c005f60:	2100      	movs	r1, #0
 c005f62:	1914      	adds	r4, r2, r4
 c005f64:	bf28      	it	cs
 c005f66:	2101      	movcs	r1, #1
        *p += c; c = ( *p < c ); i++; p++;
 c005f68:	f843 4b04 	str.w	r4, [r3], #4
 c005f6c:	4645      	mov	r5, r8
 c005f6e:	460c      	mov	r4, r1
 c005f70:	e7e7      	b.n	c005f42 <mbedtls_mpi_add_abs+0x46>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
 c005f72:	f7ff fd6f 	bl	c005a54 <mbedtls_mpi_copy>
 c005f76:	4607      	mov	r7, r0
 c005f78:	2800      	cmp	r0, #0
 c005f7a:	d0c8      	beq.n	c005f0e <mbedtls_mpi_add_abs+0x12>
}
 c005f7c:	4638      	mov	r0, r7
 c005f7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( B->p[j - 1] != 0 )
 c005f82:	68a2      	ldr	r2, [r4, #8]
 c005f84:	441a      	add	r2, r3
 c005f86:	f852 2c04 	ldr.w	r2, [r2, #-4]
 c005f8a:	3b04      	subs	r3, #4
 c005f8c:	2a00      	cmp	r2, #0
 c005f8e:	d1c8      	bne.n	c005f22 <mbedtls_mpi_add_abs+0x26>
    for( j = B->n; j > 0; j-- )
 c005f90:	f108 38ff 	add.w	r8, r8, #4294967295
 c005f94:	e7c2      	b.n	c005f1c <mbedtls_mpi_add_abs+0x20>
 c005f96:	680a      	ldr	r2, [r1, #0]
        tmp= *o;
 c005f98:	f85e 0025 	ldr.w	r0, [lr, r5, lsl #2]
 c005f9c:	1914      	adds	r4, r2, r4
 c005f9e:	f04f 0c00 	mov.w	ip, #0
 c005fa2:	bf28      	it	cs
 c005fa4:	f04f 0c01 	movcs.w	ip, #1
 c005fa8:	1824      	adds	r4, r4, r0
        *p += tmp; c += ( *p < tmp );
 c005faa:	f841 4b04 	str.w	r4, [r1], #4
 c005fae:	bf2c      	ite	cs
 c005fb0:	2401      	movcs	r4, #1
 c005fb2:	2400      	movcc	r4, #0
    for( i = 0; i < j; i++, o++, p++ )
 c005fb4:	3501      	adds	r5, #1
        *p += tmp; c += ( *p < tmp );
 c005fb6:	4464      	add	r4, ip
 c005fb8:	e7bf      	b.n	c005f3a <mbedtls_mpi_add_abs+0x3e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
 c005fba:	4607      	mov	r7, r0
    return( ret );
 c005fbc:	e7de      	b.n	c005f7c <mbedtls_mpi_add_abs+0x80>

0c005fbe <mbedtls_mpi_sub_abs>:
{
 c005fbe:	b5f0      	push	{r4, r5, r6, r7, lr}
 c005fc0:	460f      	mov	r7, r1
 c005fc2:	b085      	sub	sp, #20
 c005fc4:	4606      	mov	r6, r0
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c005fc6:	4611      	mov	r1, r2
 c005fc8:	4638      	mov	r0, r7
{
 c005fca:	4615      	mov	r5, r2
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c005fcc:	f7ff feab 	bl	c005d26 <mbedtls_mpi_cmp_abs>
 c005fd0:	2800      	cmp	r0, #0
 c005fd2:	db2f      	blt.n	c006034 <mbedtls_mpi_sub_abs+0x76>
    X->n = 0;
 c005fd4:	2300      	movs	r3, #0
 c005fd6:	2201      	movs	r2, #1
    if( X == B )
 c005fd8:	42b5      	cmp	r5, r6
    X->n = 0;
 c005fda:	e9cd 2301 	strd	r2, r3, [sp, #4]
    X->p = NULL;
 c005fde:	9303      	str	r3, [sp, #12]
    if( X == B )
 c005fe0:	d106      	bne.n	c005ff0 <mbedtls_mpi_sub_abs+0x32>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
 c005fe2:	4629      	mov	r1, r5
 c005fe4:	a801      	add	r0, sp, #4
 c005fe6:	f7ff fd35 	bl	c005a54 <mbedtls_mpi_copy>
 c005fea:	4604      	mov	r4, r0
 c005fec:	b9a0      	cbnz	r0, c006018 <mbedtls_mpi_sub_abs+0x5a>
        B = &TB;
 c005fee:	ad01      	add	r5, sp, #4
    if( X != A )
 c005ff0:	42b7      	cmp	r7, r6
 c005ff2:	d10a      	bne.n	c00600a <mbedtls_mpi_sub_abs+0x4c>
    X->s = 1;
 c005ff4:	2301      	movs	r3, #1
    for( n = B->n; n > 0; n-- )
 c005ff6:	6868      	ldr	r0, [r5, #4]
 c005ff8:	68a9      	ldr	r1, [r5, #8]
    X->s = 1;
 c005ffa:	6033      	str	r3, [r6, #0]
 c005ffc:	0083      	lsls	r3, r0, #2
    for( n = B->n; n > 0; n-- )
 c005ffe:	b988      	cbnz	r0, c006024 <mbedtls_mpi_sub_abs+0x66>
    mpi_sub_hlp( n, B->p, X->p );
 c006000:	68b2      	ldr	r2, [r6, #8]
 c006002:	f7ff fa4e 	bl	c0054a2 <mpi_sub_hlp>
    ret = 0;
 c006006:	2400      	movs	r4, #0
 c006008:	e006      	b.n	c006018 <mbedtls_mpi_sub_abs+0x5a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
 c00600a:	4639      	mov	r1, r7
 c00600c:	4630      	mov	r0, r6
 c00600e:	f7ff fd21 	bl	c005a54 <mbedtls_mpi_copy>
 c006012:	4604      	mov	r4, r0
 c006014:	2800      	cmp	r0, #0
 c006016:	d0ed      	beq.n	c005ff4 <mbedtls_mpi_sub_abs+0x36>
    mbedtls_mpi_free( &TB );
 c006018:	a801      	add	r0, sp, #4
 c00601a:	f7ff fce3 	bl	c0059e4 <mbedtls_mpi_free>
}
 c00601e:	4620      	mov	r0, r4
 c006020:	b005      	add	sp, #20
 c006022:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( B->p[n - 1] != 0 )
 c006024:	18ca      	adds	r2, r1, r3
 c006026:	f852 2c04 	ldr.w	r2, [r2, #-4]
 c00602a:	3b04      	subs	r3, #4
 c00602c:	2a00      	cmp	r2, #0
 c00602e:	d1e7      	bne.n	c006000 <mbedtls_mpi_sub_abs+0x42>
    for( n = B->n; n > 0; n-- )
 c006030:	3801      	subs	r0, #1
 c006032:	e7e4      	b.n	c005ffe <mbedtls_mpi_sub_abs+0x40>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 c006034:	f06f 0409 	mvn.w	r4, #9
 c006038:	e7f1      	b.n	c00601e <mbedtls_mpi_sub_abs+0x60>

0c00603a <mbedtls_mpi_add_mpi>:
{
 c00603a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int ret, s = A->s;
 c00603c:	680c      	ldr	r4, [r1, #0]
    if( A->s * B->s < 0 )
 c00603e:	6813      	ldr	r3, [r2, #0]
{
 c006040:	4605      	mov	r5, r0
    if( A->s * B->s < 0 )
 c006042:	4363      	muls	r3, r4
{
 c006044:	460f      	mov	r7, r1
 c006046:	4616      	mov	r6, r2
    if( A->s * B->s < 0 )
 c006048:	d516      	bpl.n	c006078 <mbedtls_mpi_add_mpi+0x3e>
        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
 c00604a:	4611      	mov	r1, r2
 c00604c:	4638      	mov	r0, r7
 c00604e:	f7ff fe6a 	bl	c005d26 <mbedtls_mpi_cmp_abs>
 c006052:	2800      	cmp	r0, #0
 c006054:	db06      	blt.n	c006064 <mbedtls_mpi_add_mpi+0x2a>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
 c006056:	4632      	mov	r2, r6
 c006058:	4639      	mov	r1, r7
 c00605a:	4628      	mov	r0, r5
 c00605c:	f7ff ffaf 	bl	c005fbe <mbedtls_mpi_sub_abs>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c006060:	b140      	cbz	r0, c006074 <mbedtls_mpi_add_mpi+0x3a>
}
 c006062:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 c006064:	463a      	mov	r2, r7
 c006066:	4631      	mov	r1, r6
 c006068:	4628      	mov	r0, r5
 c00606a:	f7ff ffa8 	bl	c005fbe <mbedtls_mpi_sub_abs>
 c00606e:	2800      	cmp	r0, #0
 c006070:	d1f7      	bne.n	c006062 <mbedtls_mpi_add_mpi+0x28>
            X->s = -s;
 c006072:	4264      	negs	r4, r4
        X->s = s;
 c006074:	602c      	str	r4, [r5, #0]
    return( ret );
 c006076:	e7f4      	b.n	c006062 <mbedtls_mpi_add_mpi+0x28>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c006078:	f7ff ff40 	bl	c005efc <mbedtls_mpi_add_abs>
 c00607c:	e7f0      	b.n	c006060 <mbedtls_mpi_add_mpi+0x26>

0c00607e <mbedtls_mpi_sub_mpi>:
{
 c00607e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int ret, s = A->s;
 c006080:	680c      	ldr	r4, [r1, #0]
    if( A->s * B->s > 0 )
 c006082:	6813      	ldr	r3, [r2, #0]
{
 c006084:	4605      	mov	r5, r0
    if( A->s * B->s > 0 )
 c006086:	4363      	muls	r3, r4
 c006088:	2b00      	cmp	r3, #0
{
 c00608a:	460f      	mov	r7, r1
 c00608c:	4616      	mov	r6, r2
    if( A->s * B->s > 0 )
 c00608e:	dd16      	ble.n	c0060be <mbedtls_mpi_sub_mpi+0x40>
        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
 c006090:	4611      	mov	r1, r2
 c006092:	4638      	mov	r0, r7
 c006094:	f7ff fe47 	bl	c005d26 <mbedtls_mpi_cmp_abs>
 c006098:	2800      	cmp	r0, #0
 c00609a:	db06      	blt.n	c0060aa <mbedtls_mpi_sub_mpi+0x2c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
 c00609c:	4632      	mov	r2, r6
 c00609e:	4639      	mov	r1, r7
 c0060a0:	4628      	mov	r0, r5
 c0060a2:	f7ff ff8c 	bl	c005fbe <mbedtls_mpi_sub_abs>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c0060a6:	b140      	cbz	r0, c0060ba <mbedtls_mpi_sub_mpi+0x3c>
}
 c0060a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 c0060aa:	463a      	mov	r2, r7
 c0060ac:	4631      	mov	r1, r6
 c0060ae:	4628      	mov	r0, r5
 c0060b0:	f7ff ff85 	bl	c005fbe <mbedtls_mpi_sub_abs>
 c0060b4:	2800      	cmp	r0, #0
 c0060b6:	d1f7      	bne.n	c0060a8 <mbedtls_mpi_sub_mpi+0x2a>
            X->s = -s;
 c0060b8:	4264      	negs	r4, r4
        X->s = s;
 c0060ba:	602c      	str	r4, [r5, #0]
    return( ret );
 c0060bc:	e7f4      	b.n	c0060a8 <mbedtls_mpi_sub_mpi+0x2a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c0060be:	f7ff ff1d 	bl	c005efc <mbedtls_mpi_add_abs>
 c0060c2:	e7f0      	b.n	c0060a6 <mbedtls_mpi_sub_mpi+0x28>

0c0060c4 <mbedtls_mpi_mul_mpi>:
{
 c0060c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    X->n = 0;
 c0060c8:	2300      	movs	r3, #0
{
 c0060ca:	4615      	mov	r5, r2
    X->n = 0;
 c0060cc:	2201      	movs	r2, #1
{
 c0060ce:	b086      	sub	sp, #24
    if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
 c0060d0:	4288      	cmp	r0, r1
{
 c0060d2:	4680      	mov	r8, r0
 c0060d4:	460e      	mov	r6, r1
    X->n = 0;
 c0060d6:	e9cd 2300 	strd	r2, r3, [sp]
    X->s = 1;
 c0060da:	e9cd 3202 	strd	r3, r2, [sp, #8]
    X->p = NULL;
 c0060de:	e9cd 3304 	strd	r3, r3, [sp, #16]
    if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
 c0060e2:	d105      	bne.n	c0060f0 <mbedtls_mpi_mul_mpi+0x2c>
 c0060e4:	4668      	mov	r0, sp
 c0060e6:	f7ff fcb5 	bl	c005a54 <mbedtls_mpi_copy>
 c0060ea:	4604      	mov	r4, r0
 c0060ec:	bb50      	cbnz	r0, c006144 <mbedtls_mpi_mul_mpi+0x80>
 c0060ee:	466e      	mov	r6, sp
    if( X == B ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) ); B = &TB; }
 c0060f0:	45a8      	cmp	r8, r5
 c0060f2:	d106      	bne.n	c006102 <mbedtls_mpi_mul_mpi+0x3e>
 c0060f4:	4641      	mov	r1, r8
 c0060f6:	a803      	add	r0, sp, #12
 c0060f8:	f7ff fcac 	bl	c005a54 <mbedtls_mpi_copy>
 c0060fc:	4604      	mov	r4, r0
 c0060fe:	bb08      	cbnz	r0, c006144 <mbedtls_mpi_mul_mpi+0x80>
 c006100:	ad03      	add	r5, sp, #12
    for( i = A->n; i > 0; i-- )
 c006102:	f8d6 9004 	ldr.w	r9, [r6, #4]
 c006106:	ea4f 0389 	mov.w	r3, r9, lsl #2
 c00610a:	f1b9 0f00 	cmp.w	r9, #0
 c00610e:	d123      	bne.n	c006158 <mbedtls_mpi_mul_mpi+0x94>
    for( j = B->n; j > 0; j-- )
 c006110:	686f      	ldr	r7, [r5, #4]
 c006112:	00bb      	lsls	r3, r7, #2
 c006114:	bb57      	cbnz	r7, c00616c <mbedtls_mpi_mul_mpi+0xa8>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + j ) );
 c006116:	eb09 0107 	add.w	r1, r9, r7
 c00611a:	4640      	mov	r0, r8
 c00611c:	f7ff fc74 	bl	c005a08 <mbedtls_mpi_grow>
 c006120:	4604      	mov	r4, r0
 c006122:	b978      	cbnz	r0, c006144 <mbedtls_mpi_mul_mpi+0x80>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 c006124:	4601      	mov	r1, r0
 c006126:	4640      	mov	r0, r8
 c006128:	f7ff fcc0 	bl	c005aac <mbedtls_mpi_lset>
 c00612c:	4604      	mov	r4, r0
 c00612e:	b948      	cbnz	r0, c006144 <mbedtls_mpi_mul_mpi+0x80>
 c006130:	ea4f 0a87 	mov.w	sl, r7, lsl #2
 c006134:	f1aa 0a04 	sub.w	sl, sl, #4
    for( ; j > 0; j-- )
 c006138:	bb0f      	cbnz	r7, c00617e <mbedtls_mpi_mul_mpi+0xba>
    X->s = A->s * B->s;
 c00613a:	6832      	ldr	r2, [r6, #0]
 c00613c:	682b      	ldr	r3, [r5, #0]
 c00613e:	4353      	muls	r3, r2
 c006140:	f8c8 3000 	str.w	r3, [r8]
    mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TA );
 c006144:	a803      	add	r0, sp, #12
 c006146:	f7ff fc4d 	bl	c0059e4 <mbedtls_mpi_free>
 c00614a:	4668      	mov	r0, sp
 c00614c:	f7ff fc4a 	bl	c0059e4 <mbedtls_mpi_free>
}
 c006150:	4620      	mov	r0, r4
 c006152:	b006      	add	sp, #24
 c006154:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if( A->p[i - 1] != 0 )
 c006158:	68b2      	ldr	r2, [r6, #8]
 c00615a:	441a      	add	r2, r3
 c00615c:	f852 2c04 	ldr.w	r2, [r2, #-4]
 c006160:	3b04      	subs	r3, #4
 c006162:	2a00      	cmp	r2, #0
 c006164:	d1d4      	bne.n	c006110 <mbedtls_mpi_mul_mpi+0x4c>
    for( i = A->n; i > 0; i-- )
 c006166:	f109 39ff 	add.w	r9, r9, #4294967295
 c00616a:	e7ce      	b.n	c00610a <mbedtls_mpi_mul_mpi+0x46>
        if( B->p[j - 1] != 0 )
 c00616c:	68aa      	ldr	r2, [r5, #8]
 c00616e:	441a      	add	r2, r3
 c006170:	f852 2c04 	ldr.w	r2, [r2, #-4]
 c006174:	3b04      	subs	r3, #4
 c006176:	2a00      	cmp	r2, #0
 c006178:	d1cd      	bne.n	c006116 <mbedtls_mpi_mul_mpi+0x52>
    for( j = B->n; j > 0; j-- )
 c00617a:	3f01      	subs	r7, #1
 c00617c:	e7ca      	b.n	c006114 <mbedtls_mpi_mul_mpi+0x50>
        mpi_mul_hlp( i, A->p, X->p + j - 1, B->p[j - 1] );
 c00617e:	68ab      	ldr	r3, [r5, #8]
 c006180:	f8d8 2008 	ldr.w	r2, [r8, #8]
 c006184:	f853 300a 	ldr.w	r3, [r3, sl]
 c006188:	4452      	add	r2, sl
 c00618a:	68b1      	ldr	r1, [r6, #8]
 c00618c:	4648      	mov	r0, r9
 c00618e:	f7ff f9b2 	bl	c0054f6 <mpi_mul_hlp>
    for( ; j > 0; j-- )
 c006192:	3f01      	subs	r7, #1
 c006194:	e7ce      	b.n	c006134 <mbedtls_mpi_mul_mpi+0x70>

0c006196 <mbedtls_mpi_mul_int>:
{
 c006196:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    _B.s = 1;
 c006198:	2301      	movs	r3, #1
    p[0] = b;
 c00619a:	9200      	str	r2, [sp, #0]
    return( mbedtls_mpi_mul_mpi( X, A, &_B ) );
 c00619c:	aa01      	add	r2, sp, #4
    _B.n = 1;
 c00619e:	e9cd 3301 	strd	r3, r3, [sp, #4]
    _B.p = p;
 c0061a2:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_mul_mpi( X, A, &_B ) );
 c0061a6:	f7ff ff8d 	bl	c0060c4 <mbedtls_mpi_mul_mpi>
}
 c0061aa:	b005      	add	sp, #20
 c0061ac:	f85d fb04 	ldr.w	pc, [sp], #4

0c0061b0 <mbedtls_mpi_div_mpi>:
{
 c0061b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0061b4:	b099      	sub	sp, #100	; 0x64
 c0061b6:	9001      	str	r0, [sp, #4]
 c0061b8:	460f      	mov	r7, r1
    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
 c0061ba:	4618      	mov	r0, r3
 c0061bc:	2100      	movs	r1, #0
{
 c0061be:	4690      	mov	r8, r2
 c0061c0:	9303      	str	r3, [sp, #12]
    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
 c0061c2:	f7ff fe85 	bl	c005ed0 <mbedtls_mpi_cmp_int>
 c0061c6:	2800      	cmp	r0, #0
 c0061c8:	f000 81a5 	beq.w	c006516 <mbedtls_mpi_div_mpi+0x366>
    X->n = 0;
 c0061cc:	2400      	movs	r4, #0
 c0061ce:	2501      	movs	r5, #1
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c0061d0:	9903      	ldr	r1, [sp, #12]
 c0061d2:	4640      	mov	r0, r8
    X->n = 0;
 c0061d4:	e9cd 5409 	strd	r5, r4, [sp, #36]	; 0x24
    X->s = 1;
 c0061d8:	e9cd 450b 	strd	r4, r5, [sp, #44]	; 0x2c
    X->p = NULL;
 c0061dc:	e9cd 440d 	strd	r4, r4, [sp, #52]	; 0x34
    X->n = 0;
 c0061e0:	e9cd 540f 	strd	r5, r4, [sp, #60]	; 0x3c
    X->s = 1;
 c0061e4:	e9cd 4511 	strd	r4, r5, [sp, #68]	; 0x44
    X->p = NULL;
 c0061e8:	e9cd 4413 	strd	r4, r4, [sp, #76]	; 0x4c
    X->n = 0;
 c0061ec:	e9cd 5415 	strd	r5, r4, [sp, #84]	; 0x54
    X->p = NULL;
 c0061f0:	9417      	str	r4, [sp, #92]	; 0x5c
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c0061f2:	f7ff fd98 	bl	c005d26 <mbedtls_mpi_cmp_abs>
 c0061f6:	42a0      	cmp	r0, r4
 c0061f8:	da26      	bge.n	c006248 <mbedtls_mpi_div_mpi+0x98>
        if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
 c0061fa:	9b01      	ldr	r3, [sp, #4]
 c0061fc:	b92b      	cbnz	r3, c00620a <mbedtls_mpi_div_mpi+0x5a>
        if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
 c0061fe:	b9df      	cbnz	r7, c006238 <mbedtls_mpi_div_mpi+0x88>
        return( 0 );
 c006200:	2400      	movs	r4, #0
}
 c006202:	4620      	mov	r0, r4
 c006204:	b019      	add	sp, #100	; 0x64
 c006206:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
 c00620a:	4621      	mov	r1, r4
 c00620c:	9801      	ldr	r0, [sp, #4]
 c00620e:	f7ff fc4d 	bl	c005aac <mbedtls_mpi_lset>
 c006212:	4604      	mov	r4, r0
 c006214:	2800      	cmp	r0, #0
 c006216:	d0f2      	beq.n	c0061fe <mbedtls_mpi_div_mpi+0x4e>
    mbedtls_mpi_free( &X ); mbedtls_mpi_free( &Y ); mbedtls_mpi_free( &Z );
 c006218:	a809      	add	r0, sp, #36	; 0x24
 c00621a:	f7ff fbe3 	bl	c0059e4 <mbedtls_mpi_free>
 c00621e:	a80c      	add	r0, sp, #48	; 0x30
 c006220:	f7ff fbe0 	bl	c0059e4 <mbedtls_mpi_free>
 c006224:	a80f      	add	r0, sp, #60	; 0x3c
 c006226:	f7ff fbdd 	bl	c0059e4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &T1 ); mbedtls_mpi_free( &T2 );
 c00622a:	a812      	add	r0, sp, #72	; 0x48
 c00622c:	f7ff fbda 	bl	c0059e4 <mbedtls_mpi_free>
 c006230:	a815      	add	r0, sp, #84	; 0x54
 c006232:	f7ff fbd7 	bl	c0059e4 <mbedtls_mpi_free>
    return( ret );
 c006236:	e7e4      	b.n	c006202 <mbedtls_mpi_div_mpi+0x52>
        if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
 c006238:	4641      	mov	r1, r8
 c00623a:	4638      	mov	r0, r7
 c00623c:	f7ff fc0a 	bl	c005a54 <mbedtls_mpi_copy>
 c006240:	4604      	mov	r4, r0
 c006242:	2800      	cmp	r0, #0
 c006244:	d1e8      	bne.n	c006218 <mbedtls_mpi_div_mpi+0x68>
 c006246:	e7db      	b.n	c006200 <mbedtls_mpi_div_mpi+0x50>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &X, A ) );
 c006248:	4641      	mov	r1, r8
 c00624a:	a809      	add	r0, sp, #36	; 0x24
 c00624c:	f7ff fc02 	bl	c005a54 <mbedtls_mpi_copy>
 c006250:	4604      	mov	r4, r0
 c006252:	2800      	cmp	r0, #0
 c006254:	d1e0      	bne.n	c006218 <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Y, B ) );
 c006256:	ae0c      	add	r6, sp, #48	; 0x30
 c006258:	9903      	ldr	r1, [sp, #12]
 c00625a:	4630      	mov	r0, r6
 c00625c:	f7ff fbfa 	bl	c005a54 <mbedtls_mpi_copy>
 c006260:	4604      	mov	r4, r0
 c006262:	2800      	cmp	r0, #0
 c006264:	d1d8      	bne.n	c006218 <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 c006266:	f8d8 1004 	ldr.w	r1, [r8, #4]
 c00626a:	a80f      	add	r0, sp, #60	; 0x3c
 c00626c:	3102      	adds	r1, #2
    X.s = Y.s = 1;
 c00626e:	950c      	str	r5, [sp, #48]	; 0x30
 c006270:	9509      	str	r5, [sp, #36]	; 0x24
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 c006272:	f7ff fbc9 	bl	c005a08 <mbedtls_mpi_grow>
 c006276:	4604      	mov	r4, r0
 c006278:	2800      	cmp	r0, #0
 c00627a:	d1cd      	bne.n	c006218 <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &Z,  0 ) );
 c00627c:	4601      	mov	r1, r0
 c00627e:	a80f      	add	r0, sp, #60	; 0x3c
 c006280:	f7ff fc14 	bl	c005aac <mbedtls_mpi_lset>
 c006284:	4604      	mov	r4, r0
 c006286:	2800      	cmp	r0, #0
 c006288:	d1c6      	bne.n	c006218 <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T1, 2 ) );
 c00628a:	2102      	movs	r1, #2
 c00628c:	a812      	add	r0, sp, #72	; 0x48
 c00628e:	f7ff fbbb 	bl	c005a08 <mbedtls_mpi_grow>
 c006292:	4604      	mov	r4, r0
 c006294:	2800      	cmp	r0, #0
 c006296:	d1bf      	bne.n	c006218 <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T2, 3 ) );
 c006298:	2103      	movs	r1, #3
 c00629a:	a815      	add	r0, sp, #84	; 0x54
 c00629c:	f7ff fbb4 	bl	c005a08 <mbedtls_mpi_grow>
 c0062a0:	4604      	mov	r4, r0
 c0062a2:	2800      	cmp	r0, #0
 c0062a4:	d1b8      	bne.n	c006218 <mbedtls_mpi_div_mpi+0x68>
    k = mbedtls_mpi_bitlen( &Y ) % biL;
 c0062a6:	4630      	mov	r0, r6
 c0062a8:	f7ff fc2c 	bl	c005b04 <mbedtls_mpi_bitlen>
 c0062ac:	f000 001f 	and.w	r0, r0, #31
    if( k < biL - 1 )
 c0062b0:	281f      	cmp	r0, #31
 c0062b2:	d076      	beq.n	c0063a2 <mbedtls_mpi_div_mpi+0x1f2>
        k = biL - 1 - k;
 c0062b4:	f1c0 031f 	rsb	r3, r0, #31
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &X, k ) );
 c0062b8:	4619      	mov	r1, r3
 c0062ba:	a809      	add	r0, sp, #36	; 0x24
        k = biL - 1 - k;
 c0062bc:	9302      	str	r3, [sp, #8]
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &X, k ) );
 c0062be:	f7ff fcaf 	bl	c005c20 <mbedtls_mpi_shift_l>
 c0062c2:	4604      	mov	r4, r0
 c0062c4:	2800      	cmp	r0, #0
 c0062c6:	d1a7      	bne.n	c006218 <mbedtls_mpi_div_mpi+0x68>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, k ) );
 c0062c8:	9902      	ldr	r1, [sp, #8]
 c0062ca:	4630      	mov	r0, r6
 c0062cc:	f7ff fca8 	bl	c005c20 <mbedtls_mpi_shift_l>
 c0062d0:	4604      	mov	r4, r0
 c0062d2:	2800      	cmp	r0, #0
 c0062d4:	d1a0      	bne.n	c006218 <mbedtls_mpi_div_mpi+0x68>
    n = X.n - 1;
 c0062d6:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    t = Y.n - 1;
 c0062d8:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    n = X.n - 1;
 c0062dc:	f105 39ff 	add.w	r9, r5, #4294967295
    t = Y.n - 1;
 c0062e0:	f10a 33ff 	add.w	r3, sl, #4294967295
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, biL * ( n - t ) ) );
 c0062e4:	eba9 0b03 	sub.w	fp, r9, r3
    t = Y.n - 1;
 c0062e8:	9300      	str	r3, [sp, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, biL * ( n - t ) ) );
 c0062ea:	ea4f 134b 	mov.w	r3, fp, lsl #5
 c0062ee:	4619      	mov	r1, r3
 c0062f0:	4630      	mov	r0, r6
 c0062f2:	9304      	str	r3, [sp, #16]
 c0062f4:	f7ff fc94 	bl	c005c20 <mbedtls_mpi_shift_l>
 c0062f8:	4604      	mov	r4, r0
 c0062fa:	2800      	cmp	r0, #0
 c0062fc:	d18c      	bne.n	c006218 <mbedtls_mpi_div_mpi+0x68>
        Z.p[n - t]++;
 c0062fe:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
    while( mbedtls_mpi_cmp_mpi( &X, &Y ) >= 0 )
 c006302:	4631      	mov	r1, r6
 c006304:	a809      	add	r0, sp, #36	; 0x24
 c006306:	f7ff fda3 	bl	c005e50 <mbedtls_mpi_cmp_mpi>
 c00630a:	2800      	cmp	r0, #0
 c00630c:	da4b      	bge.n	c0063a6 <mbedtls_mpi_div_mpi+0x1f6>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &Y, biL * ( n - t ) ) );
 c00630e:	9904      	ldr	r1, [sp, #16]
 c006310:	4630      	mov	r0, r6
 c006312:	f7ff fccd 	bl	c005cb0 <mbedtls_mpi_shift_r>
 c006316:	4604      	mov	r4, r0
 c006318:	2800      	cmp	r0, #0
 c00631a:	f47f af7d 	bne.w	c006218 <mbedtls_mpi_div_mpi+0x68>
        if( X.p[i] >= Y.p[t] )
 c00631e:	9b00      	ldr	r3, [sp, #0]
 c006320:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 c006324:	009b      	lsls	r3, r3, #2
 c006326:	9304      	str	r3, [sp, #16]
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c006328:	f10a 4380 	add.w	r3, sl, #1073741824	; 0x40000000
 c00632c:	3b02      	subs	r3, #2
 c00632e:	009b      	lsls	r3, r3, #2
 c006330:	9307      	str	r3, [sp, #28]
 c006332:	f06f 0303 	mvn.w	r3, #3
 c006336:	fb03 f30a 	mul.w	r3, r3, sl
 c00633a:	3d01      	subs	r5, #1
 c00633c:	9306      	str	r3, [sp, #24]
 c00633e:	ebca 63ca 	rsb	r3, sl, sl, lsl #27
 c006342:	00ad      	lsls	r5, r5, #2
 c006344:	9305      	str	r3, [sp, #20]
    for( i = n; i > t ; i-- )
 c006346:	9b00      	ldr	r3, [sp, #0]
 c006348:	4599      	cmp	r9, r3
 c00634a:	d83b      	bhi.n	c0063c4 <mbedtls_mpi_div_mpi+0x214>
    if( Q != NULL )
 c00634c:	9b01      	ldr	r3, [sp, #4]
 c00634e:	b15b      	cbz	r3, c006368 <mbedtls_mpi_div_mpi+0x1b8>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( Q, &Z ) );
 c006350:	a90f      	add	r1, sp, #60	; 0x3c
 c006352:	4618      	mov	r0, r3
 c006354:	f7ff fb7e 	bl	c005a54 <mbedtls_mpi_copy>
 c006358:	bb08      	cbnz	r0, c00639e <mbedtls_mpi_div_mpi+0x1ee>
        Q->s = A->s * B->s;
 c00635a:	9b03      	ldr	r3, [sp, #12]
 c00635c:	f8d8 2000 	ldr.w	r2, [r8]
 c006360:	681b      	ldr	r3, [r3, #0]
 c006362:	4353      	muls	r3, r2
 c006364:	9a01      	ldr	r2, [sp, #4]
 c006366:	6013      	str	r3, [r2, #0]
    if( R != NULL )
 c006368:	2f00      	cmp	r7, #0
 c00636a:	f43f af55 	beq.w	c006218 <mbedtls_mpi_div_mpi+0x68>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &X, k ) );
 c00636e:	9902      	ldr	r1, [sp, #8]
 c006370:	a809      	add	r0, sp, #36	; 0x24
 c006372:	f7ff fc9d 	bl	c005cb0 <mbedtls_mpi_shift_r>
 c006376:	b990      	cbnz	r0, c00639e <mbedtls_mpi_div_mpi+0x1ee>
        X.s = A->s;
 c006378:	f8d8 3000 	ldr.w	r3, [r8]
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
 c00637c:	a909      	add	r1, sp, #36	; 0x24
 c00637e:	4638      	mov	r0, r7
        X.s = A->s;
 c006380:	9309      	str	r3, [sp, #36]	; 0x24
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
 c006382:	f7ff fb67 	bl	c005a54 <mbedtls_mpi_copy>
 c006386:	4601      	mov	r1, r0
 c006388:	2800      	cmp	r0, #0
 c00638a:	f040 80c2 	bne.w	c006512 <mbedtls_mpi_div_mpi+0x362>
        if( mbedtls_mpi_cmp_int( R, 0 ) == 0 )
 c00638e:	4638      	mov	r0, r7
 c006390:	f7ff fd9e 	bl	c005ed0 <mbedtls_mpi_cmp_int>
 c006394:	2800      	cmp	r0, #0
 c006396:	f47f af3f 	bne.w	c006218 <mbedtls_mpi_div_mpi+0x68>
            R->s = 1;
 c00639a:	2301      	movs	r3, #1
 c00639c:	603b      	str	r3, [r7, #0]
cleanup:
 c00639e:	4604      	mov	r4, r0
 c0063a0:	e73a      	b.n	c006218 <mbedtls_mpi_div_mpi+0x68>
    else k = 0;
 c0063a2:	9402      	str	r4, [sp, #8]
 c0063a4:	e797      	b.n	c0062d6 <mbedtls_mpi_div_mpi+0x126>
        Z.p[n - t]++;
 c0063a6:	9911      	ldr	r1, [sp, #68]	; 0x44
 c0063a8:	f851 200b 	ldr.w	r2, [r1, fp]
 c0063ac:	3201      	adds	r2, #1
 c0063ae:	f841 200b 	str.w	r2, [r1, fp]
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &Y ) );
 c0063b2:	a909      	add	r1, sp, #36	; 0x24
 c0063b4:	4632      	mov	r2, r6
 c0063b6:	4608      	mov	r0, r1
 c0063b8:	f7ff fe61 	bl	c00607e <mbedtls_mpi_sub_mpi>
 c0063bc:	4604      	mov	r4, r0
 c0063be:	2800      	cmp	r0, #0
 c0063c0:	d09f      	beq.n	c006302 <mbedtls_mpi_div_mpi+0x152>
cleanup:
 c0063c2:	e729      	b.n	c006218 <mbedtls_mpi_div_mpi+0x68>
        if( X.p[i] >= Y.p[t] )
 c0063c4:	9804      	ldr	r0, [sp, #16]
 c0063c6:	990b      	ldr	r1, [sp, #44]	; 0x2c
 c0063c8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 c0063ca:	594b      	ldr	r3, [r1, r5]
 c0063cc:	5812      	ldr	r2, [r2, r0]
 c0063ce:	9806      	ldr	r0, [sp, #24]
 c0063d0:	4293      	cmp	r3, r2
 c0063d2:	eb00 0605 	add.w	r6, r0, r5
 c0063d6:	f1a5 0b04 	sub.w	fp, r5, #4
 c0063da:	f8dd a044 	ldr.w	sl, [sp, #68]	; 0x44
 c0063de:	d37e      	bcc.n	c0064de <mbedtls_mpi_div_mpi+0x32e>
            Z.p[i - t - 1] = ~0;
 c0063e0:	f04f 33ff 	mov.w	r3, #4294967295
 c0063e4:	f84a 3006 	str.w	r3, [sl, r6]
        Z.p[i - t - 1]++;
 c0063e8:	f85a 3006 	ldr.w	r3, [sl, r6]
 c0063ec:	3301      	adds	r3, #1
 c0063ee:	f84a 3006 	str.w	r3, [sl, r6]
 c0063f2:	f1a5 0a08 	sub.w	sl, r5, #8
            Z.p[i - t - 1]--;
 c0063f6:	9a11      	ldr	r2, [sp, #68]	; 0x44
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
 c0063f8:	2100      	movs	r1, #0
            Z.p[i - t - 1]--;
 c0063fa:	5993      	ldr	r3, [r2, r6]
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
 c0063fc:	a812      	add	r0, sp, #72	; 0x48
            Z.p[i - t - 1]--;
 c0063fe:	3b01      	subs	r3, #1
 c006400:	5193      	str	r3, [r2, r6]
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
 c006402:	f7ff fb53 	bl	c005aac <mbedtls_mpi_lset>
 c006406:	2800      	cmp	r0, #0
 c006408:	d1c9      	bne.n	c00639e <mbedtls_mpi_div_mpi+0x1ee>
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c00640a:	9b00      	ldr	r3, [sp, #0]
 c00640c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 c00640e:	2b00      	cmp	r3, #0
 c006410:	d07d      	beq.n	c00650e <mbedtls_mpi_div_mpi+0x35e>
 c006412:	9b07      	ldr	r3, [sp, #28]
 c006414:	58d1      	ldr	r1, [r2, r3]
 c006416:	9b14      	ldr	r3, [sp, #80]	; 0x50
 c006418:	6019      	str	r1, [r3, #0]
            T1.p[1] = Y.p[t];
 c00641a:	9904      	ldr	r1, [sp, #16]
 c00641c:	5852      	ldr	r2, [r2, r1]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
 c00641e:	a912      	add	r1, sp, #72	; 0x48
            T1.p[1] = Y.p[t];
 c006420:	605a      	str	r2, [r3, #4]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
 c006422:	9b11      	ldr	r3, [sp, #68]	; 0x44
 c006424:	4608      	mov	r0, r1
 c006426:	599a      	ldr	r2, [r3, r6]
 c006428:	f7ff feb5 	bl	c006196 <mbedtls_mpi_mul_int>
 c00642c:	4601      	mov	r1, r0
 c00642e:	2800      	cmp	r0, #0
 c006430:	d16f      	bne.n	c006512 <mbedtls_mpi_div_mpi+0x362>
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T2, 0 ) );
 c006432:	a815      	add	r0, sp, #84	; 0x54
 c006434:	f7ff fb3a 	bl	c005aac <mbedtls_mpi_lset>
 c006438:	2800      	cmp	r0, #0
 c00643a:	d1b0      	bne.n	c00639e <mbedtls_mpi_div_mpi+0x1ee>
 c00643c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
            T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
 c00643e:	f1b9 0f01 	cmp.w	r9, #1
 c006442:	bf18      	it	ne
 c006444:	f852 000a 	ldrne.w	r0, [r2, sl]
 c006448:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 c00644a:	6018      	str	r0, [r3, #0]
            T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
 c00644c:	f852 100b 	ldr.w	r1, [r2, fp]
        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
 c006450:	a812      	add	r0, sp, #72	; 0x48
            T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
 c006452:	6059      	str	r1, [r3, #4]
            T2.p[2] = X.p[i];
 c006454:	5952      	ldr	r2, [r2, r5]
        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
 c006456:	a915      	add	r1, sp, #84	; 0x54
            T2.p[2] = X.p[i];
 c006458:	609a      	str	r2, [r3, #8]
        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
 c00645a:	f7ff fcf9 	bl	c005e50 <mbedtls_mpi_cmp_mpi>
 c00645e:	2800      	cmp	r0, #0
 c006460:	dcc9      	bgt.n	c0063f6 <mbedtls_mpi_div_mpi+0x246>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &Y, Z.p[i - t - 1] ) );
 c006462:	9b11      	ldr	r3, [sp, #68]	; 0x44
 c006464:	a90c      	add	r1, sp, #48	; 0x30
 c006466:	599a      	ldr	r2, [r3, r6]
 c006468:	a812      	add	r0, sp, #72	; 0x48
 c00646a:	f7ff fe94 	bl	c006196 <mbedtls_mpi_mul_int>
 c00646e:	2800      	cmp	r0, #0
 c006470:	d195      	bne.n	c00639e <mbedtls_mpi_div_mpi+0x1ee>
 c006472:	9b05      	ldr	r3, [sp, #20]
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1,  biL * ( i - t - 1 ) ) );
 c006474:	a812      	add	r0, sp, #72	; 0x48
 c006476:	eb03 0a09 	add.w	sl, r3, r9
 c00647a:	ea4f 1a4a 	mov.w	sl, sl, lsl #5
 c00647e:	4651      	mov	r1, sl
 c006480:	f7ff fbce 	bl	c005c20 <mbedtls_mpi_shift_l>
 c006484:	2800      	cmp	r0, #0
 c006486:	d18a      	bne.n	c00639e <mbedtls_mpi_div_mpi+0x1ee>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &T1 ) );
 c006488:	a909      	add	r1, sp, #36	; 0x24
 c00648a:	4608      	mov	r0, r1
 c00648c:	aa12      	add	r2, sp, #72	; 0x48
 c00648e:	f7ff fdf6 	bl	c00607e <mbedtls_mpi_sub_mpi>
 c006492:	4601      	mov	r1, r0
 c006494:	2800      	cmp	r0, #0
 c006496:	d13c      	bne.n	c006512 <mbedtls_mpi_div_mpi+0x362>
        if( mbedtls_mpi_cmp_int( &X, 0 ) < 0 )
 c006498:	a809      	add	r0, sp, #36	; 0x24
 c00649a:	f7ff fd19 	bl	c005ed0 <mbedtls_mpi_cmp_int>
 c00649e:	2800      	cmp	r0, #0
 c0064a0:	da19      	bge.n	c0064d6 <mbedtls_mpi_div_mpi+0x326>
            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &T1, &Y ) );
 c0064a2:	a90c      	add	r1, sp, #48	; 0x30
 c0064a4:	a812      	add	r0, sp, #72	; 0x48
 c0064a6:	f7ff fad5 	bl	c005a54 <mbedtls_mpi_copy>
 c0064aa:	2800      	cmp	r0, #0
 c0064ac:	f47f af77 	bne.w	c00639e <mbedtls_mpi_div_mpi+0x1ee>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1, biL * ( i - t - 1 ) ) );
 c0064b0:	4651      	mov	r1, sl
 c0064b2:	a812      	add	r0, sp, #72	; 0x48
 c0064b4:	f7ff fbb4 	bl	c005c20 <mbedtls_mpi_shift_l>
 c0064b8:	2800      	cmp	r0, #0
 c0064ba:	f47f af70 	bne.w	c00639e <mbedtls_mpi_div_mpi+0x1ee>
            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &X, &X, &T1 ) );
 c0064be:	a909      	add	r1, sp, #36	; 0x24
 c0064c0:	aa12      	add	r2, sp, #72	; 0x48
 c0064c2:	4608      	mov	r0, r1
 c0064c4:	f7ff fdb9 	bl	c00603a <mbedtls_mpi_add_mpi>
 c0064c8:	2800      	cmp	r0, #0
 c0064ca:	f47f af68 	bne.w	c00639e <mbedtls_mpi_div_mpi+0x1ee>
            Z.p[i - t - 1]--;
 c0064ce:	9a11      	ldr	r2, [sp, #68]	; 0x44
 c0064d0:	5993      	ldr	r3, [r2, r6]
 c0064d2:	3b01      	subs	r3, #1
 c0064d4:	5193      	str	r3, [r2, r6]
    for( i = n; i > t ; i-- )
 c0064d6:	f109 39ff 	add.w	r9, r9, #4294967295
 c0064da:	3d04      	subs	r5, #4
 c0064dc:	e733      	b.n	c006346 <mbedtls_mpi_div_mpi+0x196>
            Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
 c0064de:	f851 c00b 	ldr.w	ip, [r1, fp]
    if( 0 == d || u1 >= d )
 c0064e2:	b18a      	cbz	r2, c006508 <mbedtls_mpi_div_mpi+0x358>
    dividend  = (mbedtls_t_udbl) u1 << biL;
 c0064e4:	4619      	mov	r1, r3
 c0064e6:	2300      	movs	r3, #0
 c0064e8:	4618      	mov	r0, r3
    quotient = dividend / d;
 c0064ea:	ea40 000c 	orr.w	r0, r0, ip
 c0064ee:	f003 fa6d 	bl	c0099cc <__aeabi_uldivmod>
    return (mbedtls_mpi_uint) quotient;
 c0064f2:	2300      	movs	r3, #0
 c0064f4:	f04f 32ff 	mov.w	r2, #4294967295
 c0064f8:	428b      	cmp	r3, r1
 c0064fa:	bf08      	it	eq
 c0064fc:	4282      	cmpeq	r2, r0
 c0064fe:	d200      	bcs.n	c006502 <mbedtls_mpi_div_mpi+0x352>
 c006500:	4610      	mov	r0, r2
            Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
 c006502:	f84a 0006 	str.w	r0, [sl, r6]
 c006506:	e76f      	b.n	c0063e8 <mbedtls_mpi_div_mpi+0x238>
        return ( ~0 );
 c006508:	f04f 30ff 	mov.w	r0, #4294967295
 c00650c:	e7f9      	b.n	c006502 <mbedtls_mpi_div_mpi+0x352>
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c00650e:	9900      	ldr	r1, [sp, #0]
 c006510:	e781      	b.n	c006416 <mbedtls_mpi_div_mpi+0x266>
cleanup:
 c006512:	460c      	mov	r4, r1
 c006514:	e680      	b.n	c006218 <mbedtls_mpi_div_mpi+0x68>
        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );
 c006516:	f06f 040b 	mvn.w	r4, #11
 c00651a:	e672      	b.n	c006202 <mbedtls_mpi_div_mpi+0x52>

0c00651c <mbedtls_mpi_mod_mpi>:
{
 c00651c:	b570      	push	{r4, r5, r6, lr}
 c00651e:	4604      	mov	r4, r0
 c006520:	460d      	mov	r5, r1
    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
 c006522:	4610      	mov	r0, r2
 c006524:	2100      	movs	r1, #0
{
 c006526:	4616      	mov	r6, r2
    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
 c006528:	f7ff fcd2 	bl	c005ed0 <mbedtls_mpi_cmp_int>
 c00652c:	2800      	cmp	r0, #0
 c00652e:	db24      	blt.n	c00657a <mbedtls_mpi_mod_mpi+0x5e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( NULL, R, A, B ) );
 c006530:	462a      	mov	r2, r5
 c006532:	4633      	mov	r3, r6
 c006534:	4621      	mov	r1, r4
 c006536:	2000      	movs	r0, #0
 c006538:	f7ff fe3a 	bl	c0061b0 <mbedtls_mpi_div_mpi>
 c00653c:	4605      	mov	r5, r0
 c00653e:	b138      	cbz	r0, c006550 <mbedtls_mpi_mod_mpi+0x34>
}
 c006540:	4628      	mov	r0, r5
 c006542:	bd70      	pop	{r4, r5, r6, pc}
      MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( R, R, B ) );
 c006544:	4632      	mov	r2, r6
 c006546:	4621      	mov	r1, r4
 c006548:	4620      	mov	r0, r4
 c00654a:	f7ff fd76 	bl	c00603a <mbedtls_mpi_add_mpi>
 c00654e:	b990      	cbnz	r0, c006576 <mbedtls_mpi_mod_mpi+0x5a>
    while( mbedtls_mpi_cmp_int( R, 0 ) < 0 )
 c006550:	2100      	movs	r1, #0
 c006552:	4620      	mov	r0, r4
 c006554:	f7ff fcbc 	bl	c005ed0 <mbedtls_mpi_cmp_int>
 c006558:	2800      	cmp	r0, #0
 c00655a:	dbf3      	blt.n	c006544 <mbedtls_mpi_mod_mpi+0x28>
    while( mbedtls_mpi_cmp_mpi( R, B ) >= 0 )
 c00655c:	4631      	mov	r1, r6
 c00655e:	4620      	mov	r0, r4
 c006560:	f7ff fc76 	bl	c005e50 <mbedtls_mpi_cmp_mpi>
 c006564:	2800      	cmp	r0, #0
 c006566:	dbeb      	blt.n	c006540 <mbedtls_mpi_mod_mpi+0x24>
      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( R, R, B ) );
 c006568:	4632      	mov	r2, r6
 c00656a:	4621      	mov	r1, r4
 c00656c:	4620      	mov	r0, r4
 c00656e:	f7ff fd86 	bl	c00607e <mbedtls_mpi_sub_mpi>
 c006572:	2800      	cmp	r0, #0
 c006574:	d0f2      	beq.n	c00655c <mbedtls_mpi_mod_mpi+0x40>
 c006576:	4605      	mov	r5, r0
 c006578:	e7e2      	b.n	c006540 <mbedtls_mpi_mod_mpi+0x24>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 c00657a:	f06f 0509 	mvn.w	r5, #9
 c00657e:	e7df      	b.n	c006540 <mbedtls_mpi_mod_mpi+0x24>

0c006580 <mbedtls_mpi_exp_mod>:

/*
 * Sliding-window exponentiation: X = A^E mod N  (HAC 14.85)
 */
int mbedtls_mpi_exp_mod( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *E, const mbedtls_mpi *N, mbedtls_mpi *_RR )
{
 c006580:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c006584:	4606      	mov	r6, r0
 c006586:	f2ad 6d54 	subw	sp, sp, #1620	; 0x654
 c00658a:	460f      	mov	r7, r1
    size_t bufsize, nbits;
    mbedtls_mpi_uint ei, mm, state;
    mbedtls_mpi RR, T, W[ 2 << MBEDTLS_MPI_WINDOW_SIZE ], Apos;
    int neg;

    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 || ( N->p[0] & 1 ) == 0 )
 c00658c:	4618      	mov	r0, r3
 c00658e:	2100      	movs	r1, #0
{
 c006590:	9203      	str	r2, [sp, #12]
 c006592:	461d      	mov	r5, r3
    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 || ( N->p[0] & 1 ) == 0 )
 c006594:	f7ff fc9c 	bl	c005ed0 <mbedtls_mpi_cmp_int>
 c006598:	2800      	cmp	r0, #0
 c00659a:	f340 8225 	ble.w	c0069e8 <mbedtls_mpi_exp_mod+0x468>
 c00659e:	68ab      	ldr	r3, [r5, #8]
 c0065a0:	f8d3 8000 	ldr.w	r8, [r3]
 c0065a4:	f018 0f01 	tst.w	r8, #1
 c0065a8:	f000 821e 	beq.w	c0069e8 <mbedtls_mpi_exp_mod+0x468>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );

    if( mbedtls_mpi_cmp_int( E, 0 ) < 0 )
 c0065ac:	2100      	movs	r1, #0
 c0065ae:	9803      	ldr	r0, [sp, #12]
 c0065b0:	f7ff fc8e 	bl	c005ed0 <mbedtls_mpi_cmp_int>
 c0065b4:	2800      	cmp	r0, #0
 c0065b6:	f2c0 8217 	blt.w	c0069e8 <mbedtls_mpi_exp_mod+0x468>
    x += ( ( m0 + 2 ) & 4 ) << 1;
 c0065ba:	2103      	movs	r1, #3
 c0065bc:	f108 0402 	add.w	r4, r8, #2
 c0065c0:	0064      	lsls	r4, r4, #1
 c0065c2:	f004 0408 	and.w	r4, r4, #8
 c0065c6:	4444      	add	r4, r8
        x *= ( 2 - ( m0 * x ) );
 c0065c8:	fb04 f308 	mul.w	r3, r4, r8
    for( i = biL; i >= 8; i /= 2 )
 c0065cc:	3901      	subs	r1, #1
        x *= ( 2 - ( m0 * x ) );
 c0065ce:	f1c3 0302 	rsb	r3, r3, #2
 c0065d2:	fb03 f404 	mul.w	r4, r3, r4
    for( i = biL; i >= 8; i /= 2 )
 c0065d6:	d1f7      	bne.n	c0065c8 <mbedtls_mpi_exp_mod+0x48>
    X->s = 1;
 c0065d8:	2301      	movs	r3, #1
     * Init temps and window size
     */
    mpi_montg_init( &mm, N );
    mbedtls_mpi_init( &RR ); mbedtls_mpi_init( &T );
    mbedtls_mpi_init( &Apos );
    memset( W, 0, sizeof( W ) );
 c0065da:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 c0065de:	a814      	add	r0, sp, #80	; 0x50
    X->n = 0;
 c0065e0:	e9cd 3108 	strd	r3, r1, [sp, #32]
    X->s = 1;
 c0065e4:	e9cd 130a 	strd	r1, r3, [sp, #40]	; 0x28
    X->p = NULL;
 c0065e8:	e9cd 110c 	strd	r1, r1, [sp, #48]	; 0x30
    X->n = 0;
 c0065ec:	e9cd 310e 	strd	r3, r1, [sp, #56]	; 0x38
    X->p = NULL;
 c0065f0:	9110      	str	r1, [sp, #64]	; 0x40
    memset( W, 0, sizeof( W ) );
 c0065f2:	f002 f87a 	bl	c0086ea <memset>

    i = mbedtls_mpi_bitlen( E );
 c0065f6:	9803      	ldr	r0, [sp, #12]
 c0065f8:	f7ff fa84 	bl	c005b04 <mbedtls_mpi_bitlen>

    wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
 c0065fc:	f5b0 7f28 	cmp.w	r0, #672	; 0x2a0
 c006600:	f080 80e2 	bcs.w	c0067c8 <mbedtls_mpi_exp_mod+0x248>
 c006604:	28ef      	cmp	r0, #239	; 0xef
 c006606:	f200 80e2 	bhi.w	c0067ce <mbedtls_mpi_exp_mod+0x24e>
 c00660a:	284f      	cmp	r0, #79	; 0x4f
 c00660c:	f200 80e2 	bhi.w	c0067d4 <mbedtls_mpi_exp_mod+0x254>
 c006610:	2818      	cmp	r0, #24
 c006612:	bf34      	ite	cc
 c006614:	f04f 0b01 	movcc.w	fp, #1
 c006618:	f04f 0b03 	movcs.w	fp, #3
            ( i >  79 ) ? 4 : ( i >  23 ) ? 3 : 1;

    if( wsize > MBEDTLS_MPI_WINDOW_SIZE )
        wsize = MBEDTLS_MPI_WINDOW_SIZE;

    j = N->n + 1;
 c00661c:	686b      	ldr	r3, [r5, #4]
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 c00661e:	4630      	mov	r0, r6
    j = N->n + 1;
 c006620:	f103 0801 	add.w	r8, r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 c006624:	4641      	mov	r1, r8
 c006626:	f7ff f9ef 	bl	c005a08 <mbedtls_mpi_grow>
 c00662a:	4603      	mov	r3, r0
 c00662c:	2800      	cmp	r0, #0
 c00662e:	f040 8163 	bne.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[1],  j ) );
 c006632:	4641      	mov	r1, r8
 c006634:	a817      	add	r0, sp, #92	; 0x5c
 c006636:	f7ff f9e7 	bl	c005a08 <mbedtls_mpi_grow>
 c00663a:	4603      	mov	r3, r0
 c00663c:	2800      	cmp	r0, #0
 c00663e:	f040 815b 	bne.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T, j * 2 ) );
 c006642:	ea4f 0148 	mov.w	r1, r8, lsl #1
 c006646:	a80b      	add	r0, sp, #44	; 0x2c
 c006648:	f7ff f9de 	bl	c005a08 <mbedtls_mpi_grow>
 c00664c:	4603      	mov	r3, r0
 c00664e:	2800      	cmp	r0, #0
 c006650:	f040 8152 	bne.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>

    /*
     * Compensate for negative A (and correct at the end)
     */
    neg = ( A->s == -1 );
 c006654:	683b      	ldr	r3, [r7, #0]
 c006656:	9304      	str	r3, [sp, #16]
    if( neg )
 c006658:	3301      	adds	r3, #1
 c00665a:	d10a      	bne.n	c006672 <mbedtls_mpi_exp_mod+0xf2>
    {
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Apos, A ) );
 c00665c:	4639      	mov	r1, r7
 c00665e:	a80e      	add	r0, sp, #56	; 0x38
 c006660:	f7ff f9f8 	bl	c005a54 <mbedtls_mpi_copy>
 c006664:	4603      	mov	r3, r0
 c006666:	2800      	cmp	r0, #0
 c006668:	f040 8146 	bne.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>
        Apos.s = 1;
 c00666c:	2301      	movs	r3, #1
        A = &Apos;
 c00666e:	af0e      	add	r7, sp, #56	; 0x38
        Apos.s = 1;
 c006670:	930e      	str	r3, [sp, #56]	; 0x38
    }

    /*
     * If 1st call, pre-compute R^2 mod N
     */
    if( _RR == NULL || _RR->p == NULL )
 c006672:	f8dd 3678 	ldr.w	r3, [sp, #1656]	; 0x678
 c006676:	b11b      	cbz	r3, c006680 <mbedtls_mpi_exp_mod+0x100>
 c006678:	689b      	ldr	r3, [r3, #8]
 c00667a:	2b00      	cmp	r3, #0
 c00667c:	f040 80ad 	bne.w	c0067da <mbedtls_mpi_exp_mod+0x25a>
    {
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &RR, 1 ) );
 c006680:	2101      	movs	r1, #1
 c006682:	a808      	add	r0, sp, #32
 c006684:	f7ff fa12 	bl	c005aac <mbedtls_mpi_lset>
 c006688:	4603      	mov	r3, r0
 c00668a:	2800      	cmp	r0, #0
 c00668c:	f040 8134 	bne.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &RR, N->n * 2 * biL ) );
 c006690:	6869      	ldr	r1, [r5, #4]
 c006692:	a808      	add	r0, sp, #32
 c006694:	0189      	lsls	r1, r1, #6
 c006696:	f7ff fac3 	bl	c005c20 <mbedtls_mpi_shift_l>
 c00669a:	4603      	mov	r3, r0
 c00669c:	2800      	cmp	r0, #0
 c00669e:	f040 812b 	bne.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &RR, &RR, N ) );
 c0066a2:	a908      	add	r1, sp, #32
 c0066a4:	462a      	mov	r2, r5
 c0066a6:	4608      	mov	r0, r1
 c0066a8:	f7ff ff38 	bl	c00651c <mbedtls_mpi_mod_mpi>
 c0066ac:	4603      	mov	r3, r0
 c0066ae:	2800      	cmp	r0, #0
 c0066b0:	f040 8122 	bne.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>

        if( _RR != NULL )
 c0066b4:	f8dd 3678 	ldr.w	r3, [sp, #1656]	; 0x678
 c0066b8:	b13b      	cbz	r3, c0066ca <mbedtls_mpi_exp_mod+0x14a>
            memcpy( _RR, &RR, sizeof( mbedtls_mpi ) );
 c0066ba:	f8dd 2678 	ldr.w	r2, [sp, #1656]	; 0x678
 c0066be:	ab08      	add	r3, sp, #32
 c0066c0:	cb03      	ldmia	r3!, {r0, r1}
 c0066c2:	6010      	str	r0, [r2, #0]
 c0066c4:	6818      	ldr	r0, [r3, #0]
 c0066c6:	6051      	str	r1, [r2, #4]
 c0066c8:	6090      	str	r0, [r2, #8]
        memcpy( &RR, _RR, sizeof( mbedtls_mpi ) );

    /*
     * W[1] = A * R^2 * R^-1 mod N = A * R mod N
     */
    if( mbedtls_mpi_cmp_mpi( A, N ) >= 0 )
 c0066ca:	4629      	mov	r1, r5
 c0066cc:	4638      	mov	r0, r7
 c0066ce:	f7ff fbbf 	bl	c005e50 <mbedtls_mpi_cmp_mpi>
 c0066d2:	2800      	cmp	r0, #0
 c0066d4:	f2c0 808a 	blt.w	c0067ec <mbedtls_mpi_exp_mod+0x26c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &W[1], A, N ) );
 c0066d8:	462a      	mov	r2, r5
 c0066da:	4639      	mov	r1, r7
 c0066dc:	a817      	add	r0, sp, #92	; 0x5c
 c0066de:	f7ff ff1d 	bl	c00651c <mbedtls_mpi_mod_mpi>
 c0066e2:	4603      	mov	r3, r0
 c0066e4:	2800      	cmp	r0, #0
 c0066e6:	f040 8107 	bne.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>
    *mm = ~x + 1;
 c0066ea:	4264      	negs	r4, r4
    else
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[1], A ) );

    MBEDTLS_MPI_CHK( mpi_montmul( &W[1], &RR, N, mm, &T ) );
 c0066ec:	f10d 092c 	add.w	r9, sp, #44	; 0x2c
 c0066f0:	4623      	mov	r3, r4
 c0066f2:	f8cd 9000 	str.w	r9, [sp]
 c0066f6:	462a      	mov	r2, r5
 c0066f8:	a908      	add	r1, sp, #32
 c0066fa:	a817      	add	r0, sp, #92	; 0x5c
 c0066fc:	f7ff fb44 	bl	c005d88 <mpi_montmul>
 c006700:	4603      	mov	r3, r0
 c006702:	2800      	cmp	r0, #0
 c006704:	f040 80f8 	bne.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>

    /*
     * X = R^2 * R^-1 mod N = R mod N
     */
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &RR ) );
 c006708:	a908      	add	r1, sp, #32
 c00670a:	4630      	mov	r0, r6
 c00670c:	f7ff f9a2 	bl	c005a54 <mbedtls_mpi_copy>
 c006710:	4603      	mov	r3, r0
 c006712:	2800      	cmp	r0, #0
 c006714:	f040 80f0 	bne.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>
    mbedtls_mpi_uint z = 1;
 c006718:	2701      	movs	r7, #1
 c00671a:	ab07      	add	r3, sp, #28
    U.p = &z;
 c00671c:	9313      	str	r3, [sp, #76]	; 0x4c
    return( mpi_montmul( A, &U, N, mm, T ) );
 c00671e:	f8cd 9000 	str.w	r9, [sp]
 c006722:	4623      	mov	r3, r4
 c006724:	462a      	mov	r2, r5
 c006726:	a911      	add	r1, sp, #68	; 0x44
 c006728:	4630      	mov	r0, r6
    mbedtls_mpi_uint z = 1;
 c00672a:	9707      	str	r7, [sp, #28]
    U.n = U.s = (int) z;
 c00672c:	e9cd 7711 	strd	r7, r7, [sp, #68]	; 0x44
    return( mpi_montmul( A, &U, N, mm, T ) );
 c006730:	f7ff fb2a 	bl	c005d88 <mpi_montmul>
    MBEDTLS_MPI_CHK( mpi_montred( X, N, mm, &T ) );
 c006734:	4603      	mov	r3, r0
 c006736:	2800      	cmp	r0, #0
 c006738:	f040 80de 	bne.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>

    if( wsize > 1 )
 c00673c:	45bb      	cmp	fp, r7
 c00673e:	d15a      	bne.n	c0067f6 <mbedtls_mpi_exp_mod+0x276>

    nblimbs = E->n;
    bufsize = 0;
    nbits   = 0;
    wbits   = 0;
    state   = 0;
 c006740:	f04f 0900 	mov.w	r9, #0
    nbits   = 0;
 c006744:	46c8      	mov	r8, r9
    bufsize = 0;
 c006746:	46ca      	mov	sl, r9
    wbits   = 0;
 c006748:	464f      	mov	r7, r9
    nblimbs = E->n;
 c00674a:	9b03      	ldr	r3, [sp, #12]
 c00674c:	685b      	ldr	r3, [r3, #4]
 c00674e:	9302      	str	r3, [sp, #8]

    while( 1 )
    {
        if( bufsize == 0 )
 c006750:	f1ba 0f00 	cmp.w	sl, #0
 c006754:	f040 80b1 	bne.w	c0068ba <mbedtls_mpi_exp_mod+0x33a>
        {
            if( nblimbs == 0 )
 c006758:	9b02      	ldr	r3, [sp, #8]
 c00675a:	2b00      	cmp	r3, #0
 c00675c:	f040 80a8 	bne.w	c0068b0 <mbedtls_mpi_exp_mod+0x330>
    {
        MBEDTLS_MPI_CHK( mpi_montmul( X, X, N, mm, &T ) );

        wbits <<= 1;

        if( ( wbits & ( one << wsize ) ) != 0 )
 c006760:	f04f 0a01 	mov.w	sl, #1
 c006764:	f10d 092c 	add.w	r9, sp, #44	; 0x2c
 c006768:	fa0a fa0b 	lsl.w	sl, sl, fp
    for( i = 0; i < nbits; i++ )
 c00676c:	9b02      	ldr	r3, [sp, #8]
 c00676e:	4543      	cmp	r3, r8
 c006770:	f040 8113 	bne.w	c00699a <mbedtls_mpi_exp_mod+0x41a>
    mbedtls_mpi_uint z = 1;
 c006774:	2301      	movs	r3, #1
 c006776:	aa07      	add	r2, sp, #28
 c006778:	9307      	str	r3, [sp, #28]
    U.n = U.s = (int) z;
 c00677a:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
    U.p = &z;
 c00677e:	9213      	str	r2, [sp, #76]	; 0x4c
    return( mpi_montmul( A, &U, N, mm, T ) );
 c006780:	4623      	mov	r3, r4
 c006782:	f8cd 9000 	str.w	r9, [sp]
 c006786:	462a      	mov	r2, r5
 c006788:	a911      	add	r1, sp, #68	; 0x44
 c00678a:	4630      	mov	r0, r6
 c00678c:	f7ff fafc 	bl	c005d88 <mpi_montmul>
    }

    /*
     * X = A^E * R * R^-1 mod N = A^E mod N
     */
    MBEDTLS_MPI_CHK( mpi_montred( X, N, mm, &T ) );
 c006790:	4603      	mov	r3, r0
 c006792:	2800      	cmp	r0, #0
 c006794:	f040 80b0 	bne.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>

    if( neg && E->n != 0 && ( E->p[0] & 1 ) != 0 )
 c006798:	9a04      	ldr	r2, [sp, #16]
 c00679a:	3201      	adds	r2, #1
 c00679c:	f040 80ac 	bne.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>
 c0067a0:	9a03      	ldr	r2, [sp, #12]
 c0067a2:	6852      	ldr	r2, [r2, #4]
 c0067a4:	2a00      	cmp	r2, #0
 c0067a6:	f000 80a7 	beq.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>
 c0067aa:	9a03      	ldr	r2, [sp, #12]
 c0067ac:	6892      	ldr	r2, [r2, #8]
 c0067ae:	6812      	ldr	r2, [r2, #0]
 c0067b0:	07d2      	lsls	r2, r2, #31
 c0067b2:	f140 80a1 	bpl.w	c0068f8 <mbedtls_mpi_exp_mod+0x378>
    {
        X->s = -1;
 c0067b6:	9b04      	ldr	r3, [sp, #16]
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( X, N, X ) );
 c0067b8:	4632      	mov	r2, r6
        X->s = -1;
 c0067ba:	6033      	str	r3, [r6, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( X, N, X ) );
 c0067bc:	4629      	mov	r1, r5
 c0067be:	4630      	mov	r0, r6
 c0067c0:	f7ff fc3b 	bl	c00603a <mbedtls_mpi_add_mpi>
 c0067c4:	4603      	mov	r3, r0
    }

cleanup:
 c0067c6:	e097      	b.n	c0068f8 <mbedtls_mpi_exp_mod+0x378>
    wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
 c0067c8:	f04f 0b06 	mov.w	fp, #6
 c0067cc:	e726      	b.n	c00661c <mbedtls_mpi_exp_mod+0x9c>
 c0067ce:	f04f 0b05 	mov.w	fp, #5
 c0067d2:	e723      	b.n	c00661c <mbedtls_mpi_exp_mod+0x9c>
 c0067d4:	f04f 0b04 	mov.w	fp, #4
 c0067d8:	e720      	b.n	c00661c <mbedtls_mpi_exp_mod+0x9c>
        memcpy( &RR, _RR, sizeof( mbedtls_mpi ) );
 c0067da:	f8dd 2678 	ldr.w	r2, [sp, #1656]	; 0x678
 c0067de:	ab08      	add	r3, sp, #32
 c0067e0:	6810      	ldr	r0, [r2, #0]
 c0067e2:	6851      	ldr	r1, [r2, #4]
 c0067e4:	c303      	stmia	r3!, {r0, r1}
 c0067e6:	6890      	ldr	r0, [r2, #8]
 c0067e8:	6018      	str	r0, [r3, #0]
 c0067ea:	e76e      	b.n	c0066ca <mbedtls_mpi_exp_mod+0x14a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[1], A ) );
 c0067ec:	4639      	mov	r1, r7
 c0067ee:	a817      	add	r0, sp, #92	; 0x5c
 c0067f0:	f7ff f930 	bl	c005a54 <mbedtls_mpi_copy>
 c0067f4:	e775      	b.n	c0066e2 <mbedtls_mpi_exp_mod+0x162>
 c0067f6:	f10b 33ff 	add.w	r3, fp, #4294967295
 c0067fa:	9302      	str	r3, [sp, #8]
 c0067fc:	fa07 f303 	lsl.w	r3, r7, r3
 c006800:	270c      	movs	r7, #12
 c006802:	9305      	str	r3, [sp, #20]
 c006804:	9b02      	ldr	r3, [sp, #8]
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[j], N->n + 1 ) );
 c006806:	6869      	ldr	r1, [r5, #4]
 c006808:	409f      	lsls	r7, r3
 c00680a:	ab14      	add	r3, sp, #80	; 0x50
 c00680c:	eb03 0807 	add.w	r8, r3, r7
 c006810:	3101      	adds	r1, #1
 c006812:	4640      	mov	r0, r8
 c006814:	f7ff f8f8 	bl	c005a08 <mbedtls_mpi_grow>
 c006818:	4603      	mov	r3, r0
 c00681a:	2800      	cmp	r0, #0
 c00681c:	d16c      	bne.n	c0068f8 <mbedtls_mpi_exp_mod+0x378>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[j], &W[1]    ) );
 c00681e:	a917      	add	r1, sp, #92	; 0x5c
 c006820:	4640      	mov	r0, r8
 c006822:	f7ff f917 	bl	c005a54 <mbedtls_mpi_copy>
 c006826:	4603      	mov	r3, r0
 c006828:	2800      	cmp	r0, #0
 c00682a:	d165      	bne.n	c0068f8 <mbedtls_mpi_exp_mod+0x378>
        for( i = 0; i < wsize - 1; i++ )
 c00682c:	4682      	mov	sl, r0
            MBEDTLS_MPI_CHK( mpi_montmul( &W[j], &W[j], N, mm, &T ) );
 c00682e:	4623      	mov	r3, r4
 c006830:	f8cd 9000 	str.w	r9, [sp]
 c006834:	462a      	mov	r2, r5
 c006836:	4641      	mov	r1, r8
 c006838:	4640      	mov	r0, r8
 c00683a:	f7ff faa5 	bl	c005d88 <mpi_montmul>
 c00683e:	4603      	mov	r3, r0
 c006840:	2800      	cmp	r0, #0
 c006842:	d159      	bne.n	c0068f8 <mbedtls_mpi_exp_mod+0x378>
        for( i = 0; i < wsize - 1; i++ )
 c006844:	9b02      	ldr	r3, [sp, #8]
 c006846:	f10a 0a01 	add.w	sl, sl, #1
 c00684a:	4553      	cmp	r3, sl
 c00684c:	d8ef      	bhi.n	c00682e <mbedtls_mpi_exp_mod+0x2ae>
        for( i = j + 1; i < ( one << wsize ); i++ )
 c00684e:	f04f 0901 	mov.w	r9, #1
 c006852:	9b05      	ldr	r3, [sp, #20]
 c006854:	fa09 f90b 	lsl.w	r9, r9, fp
 c006858:	f103 0801 	add.w	r8, r3, #1
 c00685c:	f50d 63ca 	add.w	r3, sp, #1616	; 0x650
 c006860:	441f      	add	r7, r3
 c006862:	f2a7 57f4 	subw	r7, r7, #1524	; 0x5f4
            MBEDTLS_MPI_CHK( mpi_montmul( &W[i], &W[1], N, mm, &T ) );
 c006866:	f10d 0a2c 	add.w	sl, sp, #44	; 0x2c
        for( i = j + 1; i < ( one << wsize ); i++ )
 c00686a:	45c1      	cmp	r9, r8
 c00686c:	f67f af68 	bls.w	c006740 <mbedtls_mpi_exp_mod+0x1c0>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[i], N->n + 1 ) );
 c006870:	6869      	ldr	r1, [r5, #4]
 c006872:	4638      	mov	r0, r7
 c006874:	3101      	adds	r1, #1
 c006876:	f7ff f8c7 	bl	c005a08 <mbedtls_mpi_grow>
 c00687a:	4603      	mov	r3, r0
 c00687c:	2800      	cmp	r0, #0
 c00687e:	d13b      	bne.n	c0068f8 <mbedtls_mpi_exp_mod+0x378>
            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[i], &W[i - 1] ) );
 c006880:	f1a7 010c 	sub.w	r1, r7, #12
 c006884:	4638      	mov	r0, r7
 c006886:	f7ff f8e5 	bl	c005a54 <mbedtls_mpi_copy>
 c00688a:	4603      	mov	r3, r0
 c00688c:	bba0      	cbnz	r0, c0068f8 <mbedtls_mpi_exp_mod+0x378>
            MBEDTLS_MPI_CHK( mpi_montmul( &W[i], &W[1], N, mm, &T ) );
 c00688e:	4623      	mov	r3, r4
 c006890:	4638      	mov	r0, r7
 c006892:	f8cd a000 	str.w	sl, [sp]
 c006896:	462a      	mov	r2, r5
 c006898:	a917      	add	r1, sp, #92	; 0x5c
 c00689a:	f7ff fa75 	bl	c005d88 <mpi_montmul>
 c00689e:	370c      	adds	r7, #12
 c0068a0:	4603      	mov	r3, r0
 c0068a2:	bb48      	cbnz	r0, c0068f8 <mbedtls_mpi_exp_mod+0x378>
        for( i = j + 1; i < ( one << wsize ); i++ )
 c0068a4:	f108 0801 	add.w	r8, r8, #1
 c0068a8:	e7df      	b.n	c00686a <mbedtls_mpi_exp_mod+0x2ea>
        state = 2;
 c0068aa:	f04f 0902 	mov.w	r9, #2
 c0068ae:	e74f      	b.n	c006750 <mbedtls_mpi_exp_mod+0x1d0>
            bufsize = sizeof( mbedtls_mpi_uint ) << 3;
 c0068b0:	f04f 0a20 	mov.w	sl, #32
            nblimbs--;
 c0068b4:	9b02      	ldr	r3, [sp, #8]
 c0068b6:	3b01      	subs	r3, #1
 c0068b8:	9302      	str	r3, [sp, #8]
        ei = (E->p[nblimbs] >> bufsize) & 1;
 c0068ba:	9b03      	ldr	r3, [sp, #12]
 c0068bc:	9a02      	ldr	r2, [sp, #8]
 c0068be:	689b      	ldr	r3, [r3, #8]
        bufsize--;
 c0068c0:	f10a 3aff 	add.w	sl, sl, #4294967295
        ei = (E->p[nblimbs] >> bufsize) & 1;
 c0068c4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c0068c8:	fa23 f30a 	lsr.w	r3, r3, sl
        if( ei == 0 && state == 0 )
 c0068cc:	f013 0301 	ands.w	r3, r3, #1
 c0068d0:	d136      	bne.n	c006940 <mbedtls_mpi_exp_mod+0x3c0>
 c0068d2:	f1b9 0f00 	cmp.w	r9, #0
 c0068d6:	f43f af3b 	beq.w	c006750 <mbedtls_mpi_exp_mod+0x1d0>
        if( ei == 0 && state == 1 )
 c0068da:	f1b9 0f01 	cmp.w	r9, #1
 c0068de:	d12f      	bne.n	c006940 <mbedtls_mpi_exp_mod+0x3c0>
            MBEDTLS_MPI_CHK( mpi_montmul( X, X, N, mm, &T ) );
 c0068e0:	ab0b      	add	r3, sp, #44	; 0x2c
 c0068e2:	9300      	str	r3, [sp, #0]
 c0068e4:	462a      	mov	r2, r5
 c0068e6:	4623      	mov	r3, r4
 c0068e8:	4631      	mov	r1, r6
 c0068ea:	4630      	mov	r0, r6
 c0068ec:	f7ff fa4c 	bl	c005d88 <mpi_montmul>
 c0068f0:	4603      	mov	r3, r0
 c0068f2:	2800      	cmp	r0, #0
 c0068f4:	f43f af2c 	beq.w	c006750 <mbedtls_mpi_exp_mod+0x1d0>

    for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
 c0068f8:	2201      	movs	r2, #1
        mbedtls_mpi_free( &W[i] );
 c0068fa:	260c      	movs	r6, #12
    for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
 c0068fc:	f10b 34ff 	add.w	r4, fp, #4294967295
 c006900:	fa02 f404 	lsl.w	r4, r2, r4
 c006904:	fa02 f50b 	lsl.w	r5, r2, fp
 c006908:	42a5      	cmp	r5, r4
 c00690a:	9302      	str	r3, [sp, #8]
 c00690c:	d864      	bhi.n	c0069d8 <mbedtls_mpi_exp_mod+0x458>

    mbedtls_mpi_free( &W[1] ); mbedtls_mpi_free( &T ); mbedtls_mpi_free( &Apos );
 c00690e:	a817      	add	r0, sp, #92	; 0x5c
 c006910:	f7ff f868 	bl	c0059e4 <mbedtls_mpi_free>
 c006914:	a80b      	add	r0, sp, #44	; 0x2c
 c006916:	f7ff f865 	bl	c0059e4 <mbedtls_mpi_free>
 c00691a:	a80e      	add	r0, sp, #56	; 0x38
 c00691c:	f7ff f862 	bl	c0059e4 <mbedtls_mpi_free>

    if( _RR == NULL || _RR->p == NULL )
 c006920:	f8dd 2678 	ldr.w	r2, [sp, #1656]	; 0x678
 c006924:	9b02      	ldr	r3, [sp, #8]
 c006926:	b10a      	cbz	r2, c00692c <mbedtls_mpi_exp_mod+0x3ac>
 c006928:	6892      	ldr	r2, [r2, #8]
 c00692a:	b922      	cbnz	r2, c006936 <mbedtls_mpi_exp_mod+0x3b6>
        mbedtls_mpi_free( &RR );
 c00692c:	a808      	add	r0, sp, #32
 c00692e:	9302      	str	r3, [sp, #8]
 c006930:	f7ff f858 	bl	c0059e4 <mbedtls_mpi_free>
 c006934:	9b02      	ldr	r3, [sp, #8]

    return( ret );
}
 c006936:	4618      	mov	r0, r3
 c006938:	f20d 6d54 	addw	sp, sp, #1620	; 0x654
 c00693c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        nbits++;
 c006940:	f108 0801 	add.w	r8, r8, #1
        wbits |= ( ei << ( wsize - nbits ) );
 c006944:	ebab 0208 	sub.w	r2, fp, r8
 c006948:	4093      	lsls	r3, r2
        if( nbits == wsize )
 c00694a:	45c3      	cmp	fp, r8
        wbits |= ( ei << ( wsize - nbits ) );
 c00694c:	ea47 0703 	orr.w	r7, r7, r3
        if( nbits == wsize )
 c006950:	d1ab      	bne.n	c0068aa <mbedtls_mpi_exp_mod+0x32a>
            for( i = 0; i < wsize; i++ )
 c006952:	f04f 0800 	mov.w	r8, #0
                MBEDTLS_MPI_CHK( mpi_montmul( X, X, N, mm, &T ) );
 c006956:	ab0b      	add	r3, sp, #44	; 0x2c
 c006958:	9300      	str	r3, [sp, #0]
 c00695a:	462a      	mov	r2, r5
 c00695c:	4623      	mov	r3, r4
 c00695e:	4631      	mov	r1, r6
 c006960:	4630      	mov	r0, r6
 c006962:	f7ff fa11 	bl	c005d88 <mpi_montmul>
 c006966:	4603      	mov	r3, r0
 c006968:	2800      	cmp	r0, #0
 c00696a:	d1c5      	bne.n	c0068f8 <mbedtls_mpi_exp_mod+0x378>
            for( i = 0; i < wsize; i++ )
 c00696c:	f108 0801 	add.w	r8, r8, #1
 c006970:	45c3      	cmp	fp, r8
 c006972:	d8f0      	bhi.n	c006956 <mbedtls_mpi_exp_mod+0x3d6>
            MBEDTLS_MPI_CHK( mpi_montmul( X, &W[wbits], N, mm, &T ) );
 c006974:	210c      	movs	r1, #12
 c006976:	ab0b      	add	r3, sp, #44	; 0x2c
 c006978:	a814      	add	r0, sp, #80	; 0x50
 c00697a:	9300      	str	r3, [sp, #0]
 c00697c:	fb01 0107 	mla	r1, r1, r7, r0
 c006980:	4623      	mov	r3, r4
 c006982:	462a      	mov	r2, r5
 c006984:	4630      	mov	r0, r6
 c006986:	f7ff f9ff 	bl	c005d88 <mpi_montmul>
 c00698a:	4603      	mov	r3, r0
 c00698c:	2800      	cmp	r0, #0
 c00698e:	d1b3      	bne.n	c0068f8 <mbedtls_mpi_exp_mod+0x378>
            state--;
 c006990:	f04f 0901 	mov.w	r9, #1
            nbits = 0;
 c006994:	4607      	mov	r7, r0
            wbits = 0;
 c006996:	4680      	mov	r8, r0
 c006998:	e6da      	b.n	c006750 <mbedtls_mpi_exp_mod+0x1d0>
        MBEDTLS_MPI_CHK( mpi_montmul( X, X, N, mm, &T ) );
 c00699a:	4623      	mov	r3, r4
 c00699c:	f8cd 9000 	str.w	r9, [sp]
 c0069a0:	462a      	mov	r2, r5
 c0069a2:	4631      	mov	r1, r6
 c0069a4:	4630      	mov	r0, r6
 c0069a6:	f7ff f9ef 	bl	c005d88 <mpi_montmul>
 c0069aa:	4603      	mov	r3, r0
 c0069ac:	2800      	cmp	r0, #0
 c0069ae:	d1a3      	bne.n	c0068f8 <mbedtls_mpi_exp_mod+0x378>
        wbits <<= 1;
 c0069b0:	007f      	lsls	r7, r7, #1
        if( ( wbits & ( one << wsize ) ) != 0 )
 c0069b2:	ea1a 0f07 	tst.w	sl, r7
 c0069b6:	d103      	bne.n	c0069c0 <mbedtls_mpi_exp_mod+0x440>
    for( i = 0; i < nbits; i++ )
 c0069b8:	9b02      	ldr	r3, [sp, #8]
 c0069ba:	3301      	adds	r3, #1
 c0069bc:	9302      	str	r3, [sp, #8]
 c0069be:	e6d5      	b.n	c00676c <mbedtls_mpi_exp_mod+0x1ec>
            MBEDTLS_MPI_CHK( mpi_montmul( X, &W[1], N, mm, &T ) );
 c0069c0:	4623      	mov	r3, r4
 c0069c2:	f8cd 9000 	str.w	r9, [sp]
 c0069c6:	462a      	mov	r2, r5
 c0069c8:	a917      	add	r1, sp, #92	; 0x5c
 c0069ca:	4630      	mov	r0, r6
 c0069cc:	f7ff f9dc 	bl	c005d88 <mpi_montmul>
 c0069d0:	4603      	mov	r3, r0
 c0069d2:	2800      	cmp	r0, #0
 c0069d4:	d0f0      	beq.n	c0069b8 <mbedtls_mpi_exp_mod+0x438>
 c0069d6:	e78f      	b.n	c0068f8 <mbedtls_mpi_exp_mod+0x378>
        mbedtls_mpi_free( &W[i] );
 c0069d8:	ab14      	add	r3, sp, #80	; 0x50
 c0069da:	fb06 3004 	mla	r0, r6, r4, r3
 c0069de:	f7ff f801 	bl	c0059e4 <mbedtls_mpi_free>
    for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
 c0069e2:	3401      	adds	r4, #1
 c0069e4:	9b02      	ldr	r3, [sp, #8]
 c0069e6:	e78f      	b.n	c006908 <mbedtls_mpi_exp_mod+0x388>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c0069e8:	f06f 0303 	mvn.w	r3, #3
 c0069ec:	e7a3      	b.n	c006936 <mbedtls_mpi_exp_mod+0x3b6>
	...

0c0069f0 <verify_header>:
}
#endif /* MBEDTLS_MEMORY_DEBUG */

static int verify_header( memory_header *hdr )
{
    if( hdr->magic1 != MAGIC1 )
 c0069f0:	6802      	ldr	r2, [r0, #0]
 c0069f2:	4b0e      	ldr	r3, [pc, #56]	; (c006a2c <verify_header+0x3c>)
 c0069f4:	429a      	cmp	r2, r3
 c0069f6:	d115      	bne.n	c006a24 <verify_header+0x34>
        mbedtls_fprintf( stderr, "FATAL: MAGIC1 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->magic2 != MAGIC2 )
 c0069f8:	69c2      	ldr	r2, [r0, #28]
 c0069fa:	f1a3 2310 	sub.w	r3, r3, #268439552	; 0x10001000
 c0069fe:	f1a3 13ef 	sub.w	r3, r3, #15663343	; 0xef00ef
 c006a02:	429a      	cmp	r2, r3
 c006a04:	d10e      	bne.n	c006a24 <verify_header+0x34>
        mbedtls_fprintf( stderr, "FATAL: MAGIC2 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->alloc > 1 )
 c006a06:	6883      	ldr	r3, [r0, #8]
 c006a08:	2b01      	cmp	r3, #1
 c006a0a:	d80b      	bhi.n	c006a24 <verify_header+0x34>
        mbedtls_fprintf( stderr, "FATAL: alloc has illegal value\n" );
#endif
        return( 1 );
    }

    if( hdr->prev != NULL && hdr->prev == hdr->next )
 c006a0c:	68c3      	ldr	r3, [r0, #12]
 c006a0e:	b113      	cbz	r3, c006a16 <verify_header+0x26>
 c006a10:	6902      	ldr	r2, [r0, #16]
 c006a12:	4293      	cmp	r3, r2
 c006a14:	d006      	beq.n	c006a24 <verify_header+0x34>
        mbedtls_fprintf( stderr, "FATAL: prev == next\n" );
#endif
        return( 1 );
    }

    if( hdr->prev_free != NULL && hdr->prev_free == hdr->next_free )
 c006a16:	6943      	ldr	r3, [r0, #20]
 c006a18:	b133      	cbz	r3, c006a28 <verify_header+0x38>
 c006a1a:	6980      	ldr	r0, [r0, #24]
 c006a1c:	1ac3      	subs	r3, r0, r3
 c006a1e:	4258      	negs	r0, r3
 c006a20:	4158      	adcs	r0, r3
 c006a22:	4770      	bx	lr
        return( 1 );
 c006a24:	2001      	movs	r0, #1
 c006a26:	4770      	bx	lr
        mbedtls_fprintf( stderr, "FATAL: prev_free == next_free\n" );
#endif
        return( 1 );
    }

    return( 0 );
 c006a28:	4618      	mov	r0, r3
}
 c006a2a:	4770      	bx	lr
 c006a2c:	ff00aa55 	.word	0xff00aa55

0c006a30 <verify_chain>:

static int verify_chain( void )
{
 c006a30:	b538      	push	{r3, r4, r5, lr}
    memory_header *prv = heap.first, *cur;
 c006a32:	4b0d      	ldr	r3, [pc, #52]	; (c006a68 <verify_chain+0x38>)
 c006a34:	689d      	ldr	r5, [r3, #8]

    if( prv == NULL || verify_header( prv ) != 0 )
 c006a36:	b1a5      	cbz	r5, c006a62 <verify_chain+0x32>
 c006a38:	4628      	mov	r0, r5
 c006a3a:	f7ff ffd9 	bl	c0069f0 <verify_header>
 c006a3e:	4601      	mov	r1, r0
 c006a40:	b978      	cbnz	r0, c006a62 <verify_chain+0x32>
                                  "failed\n" );
#endif
        return( 1 );
    }

    if( heap.first->prev != NULL )
 c006a42:	68eb      	ldr	r3, [r5, #12]
 c006a44:	b96b      	cbnz	r3, c006a62 <verify_chain+0x32>
                                  "first->prev != NULL\n" );
#endif
        return( 1 );
    }

    cur = heap.first->next;
 c006a46:	692c      	ldr	r4, [r5, #16]

    while( cur != NULL )
 c006a48:	b90c      	cbnz	r4, c006a4e <verify_chain+0x1e>
        prv = cur;
        cur = cur->next;
    }

    return( 0 );
}
 c006a4a:	4608      	mov	r0, r1
 c006a4c:	bd38      	pop	{r3, r4, r5, pc}
        if( verify_header( cur ) != 0 )
 c006a4e:	4620      	mov	r0, r4
 c006a50:	f7ff ffce 	bl	c0069f0 <verify_header>
 c006a54:	b928      	cbnz	r0, c006a62 <verify_chain+0x32>
        if( cur->prev != prv )
 c006a56:	68e3      	ldr	r3, [r4, #12]
 c006a58:	42ab      	cmp	r3, r5
 c006a5a:	d102      	bne.n	c006a62 <verify_chain+0x32>
        cur = cur->next;
 c006a5c:	4625      	mov	r5, r4
 c006a5e:	6924      	ldr	r4, [r4, #16]
 c006a60:	e7f2      	b.n	c006a48 <verify_chain+0x18>
        return( 1 );
 c006a62:	2101      	movs	r1, #1
 c006a64:	e7f1      	b.n	c006a4a <verify_chain+0x1a>
 c006a66:	bf00      	nop
 c006a68:	3003028c 	.word	0x3003028c

0c006a6c <buffer_alloc_calloc>:

static void *buffer_alloc_calloc( size_t n, size_t size )
{
 c006a6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if defined(MBEDTLS_MEMORY_BACKTRACE)
    void *trace_buffer[MAX_BT];
    size_t trace_cnt;
#endif

    if( heap.buf == NULL || heap.first == NULL )
 c006a70:	4e41      	ldr	r6, [pc, #260]	; (c006b78 <buffer_alloc_calloc+0x10c>)
 c006a72:	6834      	ldr	r4, [r6, #0]
 c006a74:	b1dc      	cbz	r4, c006aae <buffer_alloc_calloc+0x42>
 c006a76:	68b4      	ldr	r4, [r6, #8]
 c006a78:	b1cc      	cbz	r4, c006aae <buffer_alloc_calloc+0x42>
        return( NULL );

    original_len = len = n * size;
 c006a7a:	fb01 f700 	mul.w	r7, r1, r0

    if( n == 0 || size == 0 || len / n != size )
 c006a7e:	2800      	cmp	r0, #0
 c006a80:	d04c      	beq.n	c006b1c <buffer_alloc_calloc+0xb0>
 c006a82:	2900      	cmp	r1, #0
 c006a84:	d04a      	beq.n	c006b1c <buffer_alloc_calloc+0xb0>
 c006a86:	fbb7 f4f0 	udiv	r4, r7, r0
 c006a8a:	428c      	cmp	r4, r1
 c006a8c:	d146      	bne.n	c006b1c <buffer_alloc_calloc+0xb0>
        return( NULL );
    else if( len > (size_t)-MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c006a8e:	1d38      	adds	r0, r7, #4
 c006a90:	d844      	bhi.n	c006b1c <buffer_alloc_calloc+0xb0>
        return( NULL );

    if( len % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c006a92:	07b9      	lsls	r1, r7, #30
 c006a94:	d00e      	beq.n	c006ab4 <buffer_alloc_calloc+0x48>
    {
        len -= len % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
 c006a96:	f027 0803 	bic.w	r8, r7, #3
        len += MBEDTLS_MEMORY_ALIGN_MULTIPLE;
 c006a9a:	f108 0804 	add.w	r8, r8, #4
    memory_header *new, *cur = heap.first_free;
 c006a9e:	68f4      	ldr	r4, [r6, #12]
 c006aa0:	e003      	b.n	c006aaa <buffer_alloc_calloc+0x3e>

    // Find block that fits
    //
    while( cur != NULL )
    {
        if( cur->size >= len )
 c006aa2:	6863      	ldr	r3, [r4, #4]
 c006aa4:	4543      	cmp	r3, r8
 c006aa6:	d23b      	bcs.n	c006b20 <buffer_alloc_calloc+0xb4>
            break;

        cur = cur->next_free;
 c006aa8:	69a4      	ldr	r4, [r4, #24]
    while( cur != NULL )
 c006aaa:	2c00      	cmp	r4, #0
 c006aac:	d1f9      	bne.n	c006aa2 <buffer_alloc_calloc+0x36>

    ret = (unsigned char *) cur + sizeof( memory_header );
    memset( ret, 0, original_len );

    return( ret );
}
 c006aae:	4620      	mov	r0, r4
 c006ab0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c006ab4:	46b8      	mov	r8, r7
 c006ab6:	e7f2      	b.n	c006a9e <buffer_alloc_calloc+0x32>
            heap.first_free = cur->next_free;
 c006ab8:	60f0      	str	r0, [r6, #12]
 c006aba:	e045      	b.n	c006b48 <buffer_alloc_calloc+0xdc>
    p = ( (unsigned char *) cur ) + sizeof(memory_header) + len;
 c006abc:	f108 0c20 	add.w	ip, r8, #32
 c006ac0:	eb04 030c 	add.w	r3, r4, ip
    new->size = cur->size - len - sizeof(memory_header);
 c006ac4:	3920      	subs	r1, #32
 c006ac6:	6059      	str	r1, [r3, #4]
    new->alloc = 0;
 c006ac8:	2100      	movs	r1, #0
    new->magic1 = MAGIC1;
 c006aca:	f8df e0b4 	ldr.w	lr, [pc, #180]	; c006b80 <buffer_alloc_calloc+0x114>
    new->prev = cur;
 c006ace:	e9c3 1402 	strd	r1, r4, [r3, #8]
    new->next = cur->next;
 c006ad2:	6921      	ldr	r1, [r4, #16]
 c006ad4:	6119      	str	r1, [r3, #16]
    new->magic1 = MAGIC1;
 c006ad6:	f844 e00c 	str.w	lr, [r4, ip]
    new->magic2 = MAGIC2;
 c006ada:	f8df c0a8 	ldr.w	ip, [pc, #168]	; c006b84 <buffer_alloc_calloc+0x118>
 c006ade:	f8c3 c01c 	str.w	ip, [r3, #28]
    if( new->next != NULL )
 c006ae2:	b101      	cbz	r1, c006ae6 <buffer_alloc_calloc+0x7a>
        new->next->prev = new;
 c006ae4:	60cb      	str	r3, [r1, #12]
    new->next_free = cur->next_free;
 c006ae6:	e9c3 2005 	strd	r2, r0, [r3, #20]
    if( new->prev_free != NULL )
 c006aea:	b1aa      	cbz	r2, c006b18 <buffer_alloc_calloc+0xac>
        new->prev_free->next_free = new;
 c006aec:	6193      	str	r3, [r2, #24]
    if( new->next_free != NULL )
 c006aee:	699a      	ldr	r2, [r3, #24]
 c006af0:	b102      	cbz	r2, c006af4 <buffer_alloc_calloc+0x88>
        new->next_free->prev_free = new;
 c006af2:	6153      	str	r3, [r2, #20]
    cur->next = new;
 c006af4:	6123      	str	r3, [r4, #16]
    cur->prev_free = NULL;
 c006af6:	2300      	movs	r3, #0
    cur->alloc = 1;
 c006af8:	f04f 0901 	mov.w	r9, #1
    cur->next_free = NULL;
 c006afc:	e9c4 3305 	strd	r3, r3, [r4, #20]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
 c006b00:	6933      	ldr	r3, [r6, #16]
    cur->size = len;
 c006b02:	e9c4 8901 	strd	r8, r9, [r4, #4]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
 c006b06:	07db      	lsls	r3, r3, #31
 c006b08:	d52e      	bpl.n	c006b68 <buffer_alloc_calloc+0xfc>
 c006b0a:	f7ff ff91 	bl	c006a30 <verify_chain>
 c006b0e:	b358      	cbz	r0, c006b68 <buffer_alloc_calloc+0xfc>
        mbedtls_exit( 1 );
 c006b10:	4b1a      	ldr	r3, [pc, #104]	; (c006b7c <buffer_alloc_calloc+0x110>)
 c006b12:	4648      	mov	r0, r9
 c006b14:	681b      	ldr	r3, [r3, #0]
 c006b16:	e026      	b.n	c006b66 <buffer_alloc_calloc+0xfa>
        heap.first_free = new;
 c006b18:	60f3      	str	r3, [r6, #12]
 c006b1a:	e7e8      	b.n	c006aee <buffer_alloc_calloc+0x82>
        return( NULL );
 c006b1c:	2400      	movs	r4, #0
 c006b1e:	e7c6      	b.n	c006aae <buffer_alloc_calloc+0x42>
    if( cur->alloc != 0 )
 c006b20:	68a3      	ldr	r3, [r4, #8]
 c006b22:	b11b      	cbz	r3, c006b2c <buffer_alloc_calloc+0xc0>
        mbedtls_exit( 1 );
 c006b24:	4b15      	ldr	r3, [pc, #84]	; (c006b7c <buffer_alloc_calloc+0x110>)
 c006b26:	2001      	movs	r0, #1
 c006b28:	681b      	ldr	r3, [r3, #0]
 c006b2a:	4798      	blx	r3
 c006b2c:	e9d4 2005 	ldrd	r2, r0, [r4, #20]
    if( cur->size - len < sizeof(memory_header) +
 c006b30:	6861      	ldr	r1, [r4, #4]
 c006b32:	f104 0520 	add.w	r5, r4, #32
 c006b36:	eba1 0108 	sub.w	r1, r1, r8
 c006b3a:	2923      	cmp	r1, #35	; 0x23
 c006b3c:	d8be      	bhi.n	c006abc <buffer_alloc_calloc+0x50>
        cur->alloc = 1;
 c006b3e:	2301      	movs	r3, #1
 c006b40:	60a3      	str	r3, [r4, #8]
        if( cur->prev_free != NULL )
 c006b42:	2a00      	cmp	r2, #0
 c006b44:	d0b8      	beq.n	c006ab8 <buffer_alloc_calloc+0x4c>
            cur->prev_free->next_free = cur->next_free;
 c006b46:	6190      	str	r0, [r2, #24]
        if( cur->next_free != NULL )
 c006b48:	69a3      	ldr	r3, [r4, #24]
 c006b4a:	b103      	cbz	r3, c006b4e <buffer_alloc_calloc+0xe2>
            cur->next_free->prev_free = cur->prev_free;
 c006b4c:	615a      	str	r2, [r3, #20]
        cur->prev_free = NULL;
 c006b4e:	2300      	movs	r3, #0
        cur->next_free = NULL;
 c006b50:	e9c4 3305 	strd	r3, r3, [r4, #20]
        if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
 c006b54:	6933      	ldr	r3, [r6, #16]
 c006b56:	07da      	lsls	r2, r3, #31
 c006b58:	d506      	bpl.n	c006b68 <buffer_alloc_calloc+0xfc>
 c006b5a:	f7ff ff69 	bl	c006a30 <verify_chain>
 c006b5e:	b118      	cbz	r0, c006b68 <buffer_alloc_calloc+0xfc>
            mbedtls_exit( 1 );
 c006b60:	2001      	movs	r0, #1
 c006b62:	4b06      	ldr	r3, [pc, #24]	; (c006b7c <buffer_alloc_calloc+0x110>)
 c006b64:	681b      	ldr	r3, [r3, #0]
        mbedtls_exit( 1 );
 c006b66:	4798      	blx	r3
    memset( ret, 0, original_len );
 c006b68:	463a      	mov	r2, r7
 c006b6a:	2100      	movs	r1, #0
 c006b6c:	4628      	mov	r0, r5
    ret = (unsigned char *) cur + sizeof( memory_header );
 c006b6e:	462c      	mov	r4, r5
    memset( ret, 0, original_len );
 c006b70:	f001 fdbb 	bl	c0086ea <memset>
    return( ret );
 c006b74:	e79b      	b.n	c006aae <buffer_alloc_calloc+0x42>
 c006b76:	bf00      	nop
 c006b78:	3003028c 	.word	0x3003028c
 c006b7c:	30030030 	.word	0x30030030
 c006b80:	ff00aa55 	.word	0xff00aa55
 c006b84:	ee119966 	.word	0xee119966

0c006b88 <buffer_alloc_free>:

static void buffer_alloc_free( void *ptr )
{
 c006b88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    memory_header *hdr, *old = NULL;
    unsigned char *p = (unsigned char *) ptr;

    if( ptr == NULL || heap.buf == NULL || heap.first == NULL )
 c006b8c:	4607      	mov	r7, r0
 c006b8e:	2800      	cmp	r0, #0
 c006b90:	d07c      	beq.n	c006c8c <buffer_alloc_free+0x104>
 c006b92:	4d3f      	ldr	r5, [pc, #252]	; (c006c90 <buffer_alloc_free+0x108>)
 c006b94:	682b      	ldr	r3, [r5, #0]
 c006b96:	2b00      	cmp	r3, #0
 c006b98:	d078      	beq.n	c006c8c <buffer_alloc_free+0x104>
 c006b9a:	68aa      	ldr	r2, [r5, #8]
 c006b9c:	2a00      	cmp	r2, #0
 c006b9e:	d075      	beq.n	c006c8c <buffer_alloc_free+0x104>
        return;

    if( p < heap.buf || p >= heap.buf + heap.len )
 c006ba0:	4283      	cmp	r3, r0
 c006ba2:	d803      	bhi.n	c006bac <buffer_alloc_free+0x24>
 c006ba4:	686a      	ldr	r2, [r5, #4]
 c006ba6:	4413      	add	r3, r2
 c006ba8:	4298      	cmp	r0, r3
 c006baa:	d303      	bcc.n	c006bb4 <buffer_alloc_free+0x2c>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        mbedtls_fprintf( stderr, "FATAL: mbedtls_free() outside of managed "
                                  "space\n" );
#endif
        mbedtls_exit( 1 );
 c006bac:	4b39      	ldr	r3, [pc, #228]	; (c006c94 <buffer_alloc_free+0x10c>)
 c006bae:	2001      	movs	r0, #1
 c006bb0:	681b      	ldr	r3, [r3, #0]
 c006bb2:	4798      	blx	r3
    }

    p -= sizeof(memory_header);
 c006bb4:	f1a7 0420 	sub.w	r4, r7, #32
    hdr = (memory_header *) p;

    if( verify_header( hdr ) != 0 )
 c006bb8:	4620      	mov	r0, r4
 c006bba:	f7ff ff19 	bl	c0069f0 <verify_header>
 c006bbe:	b118      	cbz	r0, c006bc8 <buffer_alloc_free+0x40>
        mbedtls_exit( 1 );
 c006bc0:	4b34      	ldr	r3, [pc, #208]	; (c006c94 <buffer_alloc_free+0x10c>)
 c006bc2:	2001      	movs	r0, #1
 c006bc4:	681b      	ldr	r3, [r3, #0]
 c006bc6:	4798      	blx	r3

    if( hdr->alloc != 1 )
 c006bc8:	f857 3c18 	ldr.w	r3, [r7, #-24]
 c006bcc:	2b01      	cmp	r3, #1
 c006bce:	d003      	beq.n	c006bd8 <buffer_alloc_free+0x50>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        mbedtls_fprintf( stderr, "FATAL: mbedtls_free() on unallocated "
                                  "data\n" );
#endif
        mbedtls_exit( 1 );
 c006bd0:	4b30      	ldr	r3, [pc, #192]	; (c006c94 <buffer_alloc_free+0x10c>)
 c006bd2:	2001      	movs	r0, #1
 c006bd4:	681b      	ldr	r3, [r3, #0]
 c006bd6:	4798      	blx	r3
    }

    hdr->alloc = 0;
 c006bd8:	2300      	movs	r3, #0
    hdr->trace_count = 0;
#endif

    // Regroup with block before
    //
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
 c006bda:	f857 6c14 	ldr.w	r6, [r7, #-20]
    hdr->alloc = 0;
 c006bde:	f847 3c18 	str.w	r3, [r7, #-24]
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
 c006be2:	b1ae      	cbz	r6, c006c10 <buffer_alloc_free+0x88>
 c006be4:	68b2      	ldr	r2, [r6, #8]
 c006be6:	b992      	cbnz	r2, c006c0e <buffer_alloc_free+0x86>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->prev->size += sizeof(memory_header) + hdr->size;
 c006be8:	f857 3c1c 	ldr.w	r3, [r7, #-28]
 c006bec:	f103 0220 	add.w	r2, r3, #32
 c006bf0:	6873      	ldr	r3, [r6, #4]
 c006bf2:	4413      	add	r3, r2
 c006bf4:	6073      	str	r3, [r6, #4]
        hdr->prev->next = hdr->next;
 c006bf6:	f857 3c10 	ldr.w	r3, [r7, #-16]
 c006bfa:	6133      	str	r3, [r6, #16]
        old = hdr;
        hdr = hdr->prev;

        if( hdr->next != NULL )
 c006bfc:	b103      	cbz	r3, c006c00 <buffer_alloc_free+0x78>
            hdr->next->prev = hdr;
 c006bfe:	60de      	str	r6, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
 c006c00:	4620      	mov	r0, r4
 c006c02:	2220      	movs	r2, #32
 c006c04:	2100      	movs	r1, #0
 c006c06:	f001 fd70 	bl	c0086ea <memset>
 c006c0a:	4634      	mov	r4, r6
 c006c0c:	4603      	mov	r3, r0
    memory_header *hdr, *old = NULL;
 c006c0e:	461e      	mov	r6, r3
    }

    // Regroup with block after
    //
    if( hdr->next != NULL && hdr->next->alloc == 0 )
 c006c10:	6920      	ldr	r0, [r4, #16]
 c006c12:	2800      	cmp	r0, #0
 c006c14:	d032      	beq.n	c006c7c <buffer_alloc_free+0xf4>
 c006c16:	6883      	ldr	r3, [r0, #8]
 c006c18:	2b00      	cmp	r3, #0
 c006c1a:	d12f      	bne.n	c006c7c <buffer_alloc_free+0xf4>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->size += sizeof(memory_header) + hdr->next->size;
 c006c1c:	6863      	ldr	r3, [r4, #4]
 c006c1e:	6842      	ldr	r2, [r0, #4]
 c006c20:	3320      	adds	r3, #32
 c006c22:	4413      	add	r3, r2
 c006c24:	6063      	str	r3, [r4, #4]
        old = hdr->next;
        hdr->next = hdr->next->next;
 c006c26:	6903      	ldr	r3, [r0, #16]
 c006c28:	e9d4 2105 	ldrd	r2, r1, [r4, #20]
 c006c2c:	6123      	str	r3, [r4, #16]

        if( hdr->prev_free != NULL || hdr->next_free != NULL )
 c006c2e:	b9da      	cbnz	r2, c006c68 <buffer_alloc_free+0xe0>
 c006c30:	bb01      	cbnz	r1, c006c74 <buffer_alloc_free+0xec>

            if( hdr->next_free != NULL )
                hdr->next_free->prev_free = hdr->prev_free;
        }

        hdr->prev_free = old->prev_free;
 c006c32:	6942      	ldr	r2, [r0, #20]
        hdr->next_free = old->next_free;
 c006c34:	6981      	ldr	r1, [r0, #24]
        hdr->prev_free = old->prev_free;
 c006c36:	6162      	str	r2, [r4, #20]
        hdr->next_free = old->next_free;
 c006c38:	61a1      	str	r1, [r4, #24]

        if( hdr->prev_free != NULL )
 c006c3a:	b1ea      	cbz	r2, c006c78 <buffer_alloc_free+0xf0>
            hdr->prev_free->next_free = hdr;
 c006c3c:	6194      	str	r4, [r2, #24]
        else
            heap.first_free = hdr;

        if( hdr->next_free != NULL )
 c006c3e:	69a2      	ldr	r2, [r4, #24]
 c006c40:	b102      	cbz	r2, c006c44 <buffer_alloc_free+0xbc>
            hdr->next_free->prev_free = hdr;
 c006c42:	6154      	str	r4, [r2, #20]

        if( hdr->next != NULL )
 c006c44:	b103      	cbz	r3, c006c48 <buffer_alloc_free+0xc0>
            hdr->next->prev = hdr;
 c006c46:	60dc      	str	r4, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
 c006c48:	2220      	movs	r2, #32
 c006c4a:	2100      	movs	r1, #0
 c006c4c:	f001 fd4d 	bl	c0086ea <memset>
        if( heap.first_free != NULL )
            heap.first_free->prev_free = hdr;
        heap.first_free = hdr;
    }

    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_FREE ) && verify_chain() != 0 )
 c006c50:	692b      	ldr	r3, [r5, #16]
 c006c52:	079b      	lsls	r3, r3, #30
 c006c54:	d51a      	bpl.n	c006c8c <buffer_alloc_free+0x104>
 c006c56:	f7ff feeb 	bl	c006a30 <verify_chain>
 c006c5a:	b1b8      	cbz	r0, c006c8c <buffer_alloc_free+0x104>
        mbedtls_exit( 1 );
}
 c006c5c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        mbedtls_exit( 1 );
 c006c60:	4b0c      	ldr	r3, [pc, #48]	; (c006c94 <buffer_alloc_free+0x10c>)
 c006c62:	2001      	movs	r0, #1
 c006c64:	681b      	ldr	r3, [r3, #0]
 c006c66:	4718      	bx	r3
                hdr->prev_free->next_free = hdr->next_free;
 c006c68:	6191      	str	r1, [r2, #24]
            if( hdr->next_free != NULL )
 c006c6a:	69a1      	ldr	r1, [r4, #24]
 c006c6c:	2900      	cmp	r1, #0
 c006c6e:	d0e0      	beq.n	c006c32 <buffer_alloc_free+0xaa>
                hdr->next_free->prev_free = hdr->prev_free;
 c006c70:	614a      	str	r2, [r1, #20]
 c006c72:	e7de      	b.n	c006c32 <buffer_alloc_free+0xaa>
                heap.first_free = hdr->next_free;
 c006c74:	60e9      	str	r1, [r5, #12]
 c006c76:	e7f8      	b.n	c006c6a <buffer_alloc_free+0xe2>
            heap.first_free = hdr;
 c006c78:	60ec      	str	r4, [r5, #12]
 c006c7a:	e7e0      	b.n	c006c3e <buffer_alloc_free+0xb6>
    if( old == NULL )
 c006c7c:	2e00      	cmp	r6, #0
 c006c7e:	d1e7      	bne.n	c006c50 <buffer_alloc_free+0xc8>
        hdr->next_free = heap.first_free;
 c006c80:	68eb      	ldr	r3, [r5, #12]
 c006c82:	61a3      	str	r3, [r4, #24]
        if( heap.first_free != NULL )
 c006c84:	b103      	cbz	r3, c006c88 <buffer_alloc_free+0x100>
            heap.first_free->prev_free = hdr;
 c006c86:	615c      	str	r4, [r3, #20]
        heap.first_free = hdr;
 c006c88:	60ec      	str	r4, [r5, #12]
 c006c8a:	e7e1      	b.n	c006c50 <buffer_alloc_free+0xc8>
}
 c006c8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c006c90:	3003028c 	.word	0x3003028c
 c006c94:	30030030 	.word	0x30030030

0c006c98 <mbedtls_memory_buffer_alloc_init>:
    (void) mbedtls_mutex_unlock( &heap.mutex );
}
#endif /* MBEDTLS_THREADING_C */

void mbedtls_memory_buffer_alloc_init( unsigned char *buf, size_t len )
{
 c006c98:	b538      	push	{r3, r4, r5, lr}
 c006c9a:	460d      	mov	r5, r1
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
 c006c9c:	2214      	movs	r2, #20
 c006c9e:	2100      	movs	r1, #0
{
 c006ca0:	4604      	mov	r4, r0
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
 c006ca2:	4812      	ldr	r0, [pc, #72]	; (c006cec <mbedtls_memory_buffer_alloc_init+0x54>)
 c006ca4:	f001 fd21 	bl	c0086ea <memset>
#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_init( &heap.mutex );
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc_mutexed,
                              buffer_alloc_free_mutexed );
#else
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc, buffer_alloc_free );
 c006ca8:	4911      	ldr	r1, [pc, #68]	; (c006cf0 <mbedtls_memory_buffer_alloc_init+0x58>)
 c006caa:	4812      	ldr	r0, [pc, #72]	; (c006cf4 <mbedtls_memory_buffer_alloc_init+0x5c>)
 c006cac:	f000 f832 	bl	c006d14 <mbedtls_platform_set_calloc_free>
#endif

    if( len < sizeof( memory_header ) + MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c006cb0:	2d23      	cmp	r5, #35	; 0x23
 c006cb2:	d91a      	bls.n	c006cea <mbedtls_memory_buffer_alloc_init+0x52>
        return;
    else if( (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c006cb4:	f014 0303 	ands.w	r3, r4, #3
 c006cb8:	bf1f      	itttt	ne
 c006cba:	3d04      	subne	r5, #4
    {
        /* Adjust len first since buf is used in the computation */
        len -= MBEDTLS_MEMORY_ALIGN_MULTIPLE
 c006cbc:	18ed      	addne	r5, r5, r3
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
 c006cbe:	f1c3 0304 	rsbne	r3, r3, #4
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
 c006cc2:	18e4      	addne	r4, r4, r3
    }

    memset( buf, 0, len );
 c006cc4:	462a      	mov	r2, r5
 c006cc6:	2100      	movs	r1, #0
 c006cc8:	4620      	mov	r0, r4
 c006cca:	f001 fd0e 	bl	c0086ea <memset>

    heap.buf = buf;
 c006cce:	4b07      	ldr	r3, [pc, #28]	; (c006cec <mbedtls_memory_buffer_alloc_init+0x54>)
    heap.len = len;

    heap.first = (memory_header *)buf;
    heap.first->size = len - sizeof( memory_header );
    heap.first->magic1 = MAGIC1;
 c006cd0:	4a09      	ldr	r2, [pc, #36]	; (c006cf8 <mbedtls_memory_buffer_alloc_init+0x60>)
    heap.len = len;
 c006cd2:	e9c3 4500 	strd	r4, r5, [r3]
    heap.first = (memory_header *)buf;
 c006cd6:	609c      	str	r4, [r3, #8]
    heap.first->magic1 = MAGIC1;
 c006cd8:	6022      	str	r2, [r4, #0]
    heap.first->magic2 = MAGIC2;
 c006cda:	f1a2 2210 	sub.w	r2, r2, #268439552	; 0x10001000
    heap.first->size = len - sizeof( memory_header );
 c006cde:	3d20      	subs	r5, #32
    heap.first->magic2 = MAGIC2;
 c006ce0:	f1a2 12ef 	sub.w	r2, r2, #15663343	; 0xef00ef
    heap.first->size = len - sizeof( memory_header );
 c006ce4:	6065      	str	r5, [r4, #4]
    heap.first->magic2 = MAGIC2;
 c006ce6:	61e2      	str	r2, [r4, #28]
    heap.first_free = heap.first;
 c006ce8:	60dc      	str	r4, [r3, #12]
}
 c006cea:	bd38      	pop	{r3, r4, r5, pc}
 c006cec:	3003028c 	.word	0x3003028c
 c006cf0:	0c006b89 	.word	0x0c006b89
 c006cf4:	0c006a6d 	.word	0x0c006a6d
 c006cf8:	ff00aa55 	.word	0xff00aa55

0c006cfc <mbedtls_calloc>:
static void * (*mbedtls_calloc_func)( size_t, size_t ) = MBEDTLS_PLATFORM_STD_CALLOC;
static void (*mbedtls_free_func)( void * ) = MBEDTLS_PLATFORM_STD_FREE;

void * mbedtls_calloc( size_t nmemb, size_t size )
{
    return (*mbedtls_calloc_func)( nmemb, size );
 c006cfc:	4b01      	ldr	r3, [pc, #4]	; (c006d04 <mbedtls_calloc+0x8>)
 c006cfe:	681b      	ldr	r3, [r3, #0]
 c006d00:	4718      	bx	r3
 c006d02:	bf00      	nop
 c006d04:	3003002c 	.word	0x3003002c

0c006d08 <mbedtls_free>:
}

void mbedtls_free( void * ptr )
{
    (*mbedtls_free_func)( ptr );
 c006d08:	4b01      	ldr	r3, [pc, #4]	; (c006d10 <mbedtls_free+0x8>)
 c006d0a:	681b      	ldr	r3, [r3, #0]
 c006d0c:	4718      	bx	r3
 c006d0e:	bf00      	nop
 c006d10:	30030034 	.word	0x30030034

0c006d14 <mbedtls_platform_set_calloc_free>:
}

int mbedtls_platform_set_calloc_free( void * (*calloc_func)( size_t, size_t ),
                              void (*free_func)( void * ) )
{
    mbedtls_calloc_func = calloc_func;
 c006d14:	4b02      	ldr	r3, [pc, #8]	; (c006d20 <mbedtls_platform_set_calloc_free+0xc>)
 c006d16:	6018      	str	r0, [r3, #0]
    mbedtls_free_func = free_func;
 c006d18:	4b02      	ldr	r3, [pc, #8]	; (c006d24 <mbedtls_platform_set_calloc_free+0x10>)
    return( 0 );
}
 c006d1a:	2000      	movs	r0, #0
    mbedtls_free_func = free_func;
 c006d1c:	6019      	str	r1, [r3, #0]
}
 c006d1e:	4770      	bx	lr
 c006d20:	3003002c 	.word	0x3003002c
 c006d24:	30030034 	.word	0x30030034

0c006d28 <mbedtls_platform_zeroize>:
 */
static void * (* const volatile memset_func)( void *, int, size_t ) = memset;

void mbedtls_platform_zeroize( void *buf, size_t len )
{
    memset_func( buf, 0, len );
 c006d28:	4b02      	ldr	r3, [pc, #8]	; (c006d34 <mbedtls_platform_zeroize+0xc>)
 c006d2a:	460a      	mov	r2, r1
 c006d2c:	681b      	ldr	r3, [r3, #0]
 c006d2e:	2100      	movs	r1, #0
 c006d30:	4718      	bx	r3
 c006d32:	bf00      	nop
 c006d34:	30030038 	.word	0x30030038

0c006d38 <rsa_check_context.isra.0>:
/*
 * Checks whether the context fields are set in such a way
 * that the RSA primitives will be able to execute without error.
 * It does *not* make guarantees for consistency of the parameters.
 */
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 c006d38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    /* blinding_needed is only used for NO_CRT to decide whether
     * P,Q need to be present or not. */
    ((void) blinding_needed);
#endif

    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c006d3a:	f100 0508 	add.w	r5, r0, #8
 c006d3e:	6847      	ldr	r7, [r0, #4]
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 c006d40:	4604      	mov	r4, r0
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c006d42:	4628      	mov	r0, r5
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 c006d44:	460e      	mov	r6, r1
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c006d46:	f7fe fefd 	bl	c005b44 <mbedtls_mpi_size>
 c006d4a:	4287      	cmp	r7, r0
 c006d4c:	d001      	beq.n	c006d52 <rsa_check_context.isra.0+0x1a>
        ctx->len > MBEDTLS_MPI_MAX_SIZE )
    {
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c006d4e:	4827      	ldr	r0, [pc, #156]	; (c006dec <rsa_check_context.isra.0+0xb4>)
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
    }
#endif

    return( 0 );
}
 c006d50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c006d52:	6863      	ldr	r3, [r4, #4]
 c006d54:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
 c006d58:	d8f9      	bhi.n	c006d4e <rsa_check_context.isra.0+0x16>
    if( mbedtls_mpi_cmp_int( &ctx->N, 0 ) <= 0 ||
 c006d5a:	2100      	movs	r1, #0
 c006d5c:	4628      	mov	r0, r5
 c006d5e:	f7ff f8b7 	bl	c005ed0 <mbedtls_mpi_cmp_int>
 c006d62:	2800      	cmp	r0, #0
 c006d64:	ddf3      	ble.n	c006d4e <rsa_check_context.isra.0+0x16>
        mbedtls_mpi_get_bit( &ctx->N, 0 ) == 0  )
 c006d66:	2100      	movs	r1, #0
 c006d68:	4628      	mov	r0, r5
 c006d6a:	f7fe febb 	bl	c005ae4 <mbedtls_mpi_get_bit>
    if( mbedtls_mpi_cmp_int( &ctx->N, 0 ) <= 0 ||
 c006d6e:	2800      	cmp	r0, #0
 c006d70:	d0ed      	beq.n	c006d4e <rsa_check_context.isra.0+0x16>
    if( is_priv &&
 c006d72:	b9f6      	cbnz	r6, c006db2 <rsa_check_context.isra.0+0x7a>
    if( mbedtls_mpi_cmp_int( &ctx->E, 0 ) <= 0 )
 c006d74:	2100      	movs	r1, #0
 c006d76:	f104 0014 	add.w	r0, r4, #20
 c006d7a:	f7ff f8a9 	bl	c005ed0 <mbedtls_mpi_cmp_int>
 c006d7e:	2800      	cmp	r0, #0
 c006d80:	dde5      	ble.n	c006d4e <rsa_check_context.isra.0+0x16>
    if( is_priv &&
 c006d82:	b1a6      	cbz	r6, c006dae <rsa_check_context.isra.0+0x76>
        ( mbedtls_mpi_cmp_int( &ctx->DP, 0 ) <= 0 ||
 c006d84:	2100      	movs	r1, #0
 c006d86:	f104 0044 	add.w	r0, r4, #68	; 0x44
 c006d8a:	f7ff f8a1 	bl	c005ed0 <mbedtls_mpi_cmp_int>
    if( is_priv &&
 c006d8e:	2800      	cmp	r0, #0
 c006d90:	dddd      	ble.n	c006d4e <rsa_check_context.isra.0+0x16>
          mbedtls_mpi_cmp_int( &ctx->DQ, 0 ) <= 0  ) )
 c006d92:	2100      	movs	r1, #0
 c006d94:	f104 0050 	add.w	r0, r4, #80	; 0x50
 c006d98:	f7ff f89a 	bl	c005ed0 <mbedtls_mpi_cmp_int>
        ( mbedtls_mpi_cmp_int( &ctx->DP, 0 ) <= 0 ||
 c006d9c:	2800      	cmp	r0, #0
 c006d9e:	ddd6      	ble.n	c006d4e <rsa_check_context.isra.0+0x16>
        mbedtls_mpi_cmp_int( &ctx->QP, 0 ) <= 0 )
 c006da0:	2100      	movs	r1, #0
 c006da2:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 c006da6:	f7ff f893 	bl	c005ed0 <mbedtls_mpi_cmp_int>
    if( is_priv &&
 c006daa:	2800      	cmp	r0, #0
 c006dac:	ddcf      	ble.n	c006d4e <rsa_check_context.isra.0+0x16>
    return( 0 );
 c006dae:	2000      	movs	r0, #0
 c006db0:	e7ce      	b.n	c006d50 <rsa_check_context.isra.0+0x18>
        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
 c006db2:	f104 052c 	add.w	r5, r4, #44	; 0x2c
 c006db6:	2100      	movs	r1, #0
 c006db8:	4628      	mov	r0, r5
 c006dba:	f7ff f889 	bl	c005ed0 <mbedtls_mpi_cmp_int>
    if( is_priv &&
 c006dbe:	2800      	cmp	r0, #0
 c006dc0:	ddc5      	ble.n	c006d4e <rsa_check_context.isra.0+0x16>
          mbedtls_mpi_get_bit( &ctx->P, 0 ) == 0 ||
 c006dc2:	2100      	movs	r1, #0
 c006dc4:	4628      	mov	r0, r5
 c006dc6:	f7fe fe8d 	bl	c005ae4 <mbedtls_mpi_get_bit>
        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
 c006dca:	2800      	cmp	r0, #0
 c006dcc:	d0bf      	beq.n	c006d4e <rsa_check_context.isra.0+0x16>
          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ||
 c006dce:	f104 0538 	add.w	r5, r4, #56	; 0x38
 c006dd2:	2100      	movs	r1, #0
 c006dd4:	4628      	mov	r0, r5
 c006dd6:	f7ff f87b 	bl	c005ed0 <mbedtls_mpi_cmp_int>
          mbedtls_mpi_get_bit( &ctx->P, 0 ) == 0 ||
 c006dda:	2800      	cmp	r0, #0
 c006ddc:	ddb7      	ble.n	c006d4e <rsa_check_context.isra.0+0x16>
          mbedtls_mpi_get_bit( &ctx->Q, 0 ) == 0  ) )
 c006dde:	2100      	movs	r1, #0
 c006de0:	4628      	mov	r0, r5
 c006de2:	f7fe fe7f 	bl	c005ae4 <mbedtls_mpi_get_bit>
          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ||
 c006de6:	2800      	cmp	r0, #0
 c006de8:	d1c4      	bne.n	c006d74 <rsa_check_context.isra.0+0x3c>
 c006dea:	e7b0      	b.n	c006d4e <rsa_check_context.isra.0+0x16>
 c006dec:	ffffbf80 	.word	0xffffbf80

0c006df0 <mbedtls_rsa_import>:
{
 c006df0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c006df4:	4604      	mov	r4, r0
 c006df6:	e9dd 7608 	ldrd	r7, r6, [sp, #32]
 c006dfa:	4691      	mov	r9, r2
 c006dfc:	4698      	mov	r8, r3
    if( ( N != NULL && ( ret = mbedtls_mpi_copy( &ctx->N, N ) ) != 0 ) ||
 c006dfe:	460d      	mov	r5, r1
 c006e00:	b979      	cbnz	r1, c006e22 <mbedtls_rsa_import+0x32>
 c006e02:	f1b9 0f00 	cmp.w	r9, #0
 c006e06:	d115      	bne.n	c006e34 <mbedtls_rsa_import+0x44>
        ( P != NULL && ( ret = mbedtls_mpi_copy( &ctx->P, P ) ) != 0 ) ||
 c006e08:	f1b8 0f00 	cmp.w	r8, #0
 c006e0c:	d11a      	bne.n	c006e44 <mbedtls_rsa_import+0x54>
        ( Q != NULL && ( ret = mbedtls_mpi_copy( &ctx->Q, Q ) ) != 0 ) ||
 c006e0e:	bb0f      	cbnz	r7, c006e54 <mbedtls_rsa_import+0x64>
        ( D != NULL && ( ret = mbedtls_mpi_copy( &ctx->D, D ) ) != 0 ) ||
 c006e10:	bb46      	cbnz	r6, c006e64 <mbedtls_rsa_import+0x74>
    if( N != NULL )
 c006e12:	b37d      	cbz	r5, c006e74 <mbedtls_rsa_import+0x84>
        ctx->len = mbedtls_mpi_size( &ctx->N );
 c006e14:	f104 0008 	add.w	r0, r4, #8
 c006e18:	f7fe fe94 	bl	c005b44 <mbedtls_mpi_size>
 c006e1c:	6060      	str	r0, [r4, #4]
    return( 0 );
 c006e1e:	2000      	movs	r0, #0
 c006e20:	e006      	b.n	c006e30 <mbedtls_rsa_import+0x40>
    if( ( N != NULL && ( ret = mbedtls_mpi_copy( &ctx->N, N ) ) != 0 ) ||
 c006e22:	3008      	adds	r0, #8
 c006e24:	f7fe fe16 	bl	c005a54 <mbedtls_mpi_copy>
 c006e28:	2800      	cmp	r0, #0
 c006e2a:	d0ea      	beq.n	c006e02 <mbedtls_rsa_import+0x12>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
 c006e2c:	f5a0 4081 	sub.w	r0, r0, #16512	; 0x4080
}
 c006e30:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        ( P != NULL && ( ret = mbedtls_mpi_copy( &ctx->P, P ) ) != 0 ) ||
 c006e34:	4649      	mov	r1, r9
 c006e36:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 c006e3a:	f7fe fe0b 	bl	c005a54 <mbedtls_mpi_copy>
 c006e3e:	2800      	cmp	r0, #0
 c006e40:	d0e2      	beq.n	c006e08 <mbedtls_rsa_import+0x18>
 c006e42:	e7f3      	b.n	c006e2c <mbedtls_rsa_import+0x3c>
        ( Q != NULL && ( ret = mbedtls_mpi_copy( &ctx->Q, Q ) ) != 0 ) ||
 c006e44:	4641      	mov	r1, r8
 c006e46:	f104 0038 	add.w	r0, r4, #56	; 0x38
 c006e4a:	f7fe fe03 	bl	c005a54 <mbedtls_mpi_copy>
 c006e4e:	2800      	cmp	r0, #0
 c006e50:	d0dd      	beq.n	c006e0e <mbedtls_rsa_import+0x1e>
 c006e52:	e7eb      	b.n	c006e2c <mbedtls_rsa_import+0x3c>
        ( D != NULL && ( ret = mbedtls_mpi_copy( &ctx->D, D ) ) != 0 ) ||
 c006e54:	4639      	mov	r1, r7
 c006e56:	f104 0020 	add.w	r0, r4, #32
 c006e5a:	f7fe fdfb 	bl	c005a54 <mbedtls_mpi_copy>
 c006e5e:	2800      	cmp	r0, #0
 c006e60:	d0d6      	beq.n	c006e10 <mbedtls_rsa_import+0x20>
 c006e62:	e7e3      	b.n	c006e2c <mbedtls_rsa_import+0x3c>
        ( E != NULL && ( ret = mbedtls_mpi_copy( &ctx->E, E ) ) != 0 ) )
 c006e64:	4631      	mov	r1, r6
 c006e66:	f104 0014 	add.w	r0, r4, #20
 c006e6a:	f7fe fdf3 	bl	c005a54 <mbedtls_mpi_copy>
 c006e6e:	2800      	cmp	r0, #0
 c006e70:	d0cf      	beq.n	c006e12 <mbedtls_rsa_import+0x22>
 c006e72:	e7db      	b.n	c006e2c <mbedtls_rsa_import+0x3c>
    return( 0 );
 c006e74:	4628      	mov	r0, r5
 c006e76:	e7db      	b.n	c006e30 <mbedtls_rsa_import+0x40>

0c006e78 <mbedtls_rsa_init>:
 * Initialize an RSA context
 */
void mbedtls_rsa_init( mbedtls_rsa_context *ctx,
               int padding,
               int hash_id )
{
 c006e78:	b538      	push	{r3, r4, r5, lr}
 c006e7a:	460d      	mov	r5, r1
 c006e7c:	4614      	mov	r4, r2
    memset( ctx, 0, sizeof( mbedtls_rsa_context ) );
 c006e7e:	2100      	movs	r1, #0
 c006e80:	22a4      	movs	r2, #164	; 0xa4
 c006e82:	f001 fc32 	bl	c0086ea <memset>
 * Set padding for an existing RSA context
 */
void mbedtls_rsa_set_padding( mbedtls_rsa_context *ctx, int padding, int hash_id )
{
    ctx->padding = padding;
    ctx->hash_id = hash_id;
 c006e86:	e9c0 5429 	strd	r5, r4, [r0, #164]	; 0xa4
}
 c006e8a:	bd38      	pop	{r3, r4, r5, pc}

0c006e8c <mbedtls_rsa_check_pubkey>:

/*
 * Check a public RSA key
 */
int mbedtls_rsa_check_pubkey( const mbedtls_rsa_context *ctx )
{
 c006e8c:	b570      	push	{r4, r5, r6, lr}
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) != 0 )
 c006e8e:	2100      	movs	r1, #0
{
 c006e90:	4604      	mov	r4, r0
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) != 0 )
 c006e92:	f7ff ff51 	bl	c006d38 <rsa_check_context.isra.0>
 c006e96:	4605      	mov	r5, r0
 c006e98:	b9b8      	cbnz	r0, c006eca <mbedtls_rsa_check_pubkey+0x3e>
        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );

    if( mbedtls_mpi_bitlen( &ctx->N ) < 128 )
 c006e9a:	f104 0608 	add.w	r6, r4, #8
 c006e9e:	4630      	mov	r0, r6
 c006ea0:	f7fe fe30 	bl	c005b04 <mbedtls_mpi_bitlen>
 c006ea4:	287f      	cmp	r0, #127	; 0x7f
 c006ea6:	d910      	bls.n	c006eca <mbedtls_rsa_check_pubkey+0x3e>
    {
        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
    }

    if( mbedtls_mpi_get_bit( &ctx->E, 0 ) == 0 ||
 c006ea8:	3414      	adds	r4, #20
 c006eaa:	4629      	mov	r1, r5
 c006eac:	4620      	mov	r0, r4
 c006eae:	f7fe fe19 	bl	c005ae4 <mbedtls_mpi_get_bit>
 c006eb2:	b150      	cbz	r0, c006eca <mbedtls_rsa_check_pubkey+0x3e>
        mbedtls_mpi_bitlen( &ctx->E )     < 2  ||
 c006eb4:	4620      	mov	r0, r4
 c006eb6:	f7fe fe25 	bl	c005b04 <mbedtls_mpi_bitlen>
    if( mbedtls_mpi_get_bit( &ctx->E, 0 ) == 0 ||
 c006eba:	2801      	cmp	r0, #1
 c006ebc:	d905      	bls.n	c006eca <mbedtls_rsa_check_pubkey+0x3e>
        mbedtls_mpi_cmp_mpi( &ctx->E, &ctx->N ) >= 0 )
 c006ebe:	4631      	mov	r1, r6
 c006ec0:	4620      	mov	r0, r4
 c006ec2:	f7fe ffc5 	bl	c005e50 <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_bitlen( &ctx->E )     < 2  ||
 c006ec6:	2800      	cmp	r0, #0
 c006ec8:	db00      	blt.n	c006ecc <mbedtls_rsa_check_pubkey+0x40>
    {
        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 c006eca:	4d01      	ldr	r5, [pc, #4]	; (c006ed0 <mbedtls_rsa_check_pubkey+0x44>)
    }

    return( 0 );
}
 c006ecc:	4628      	mov	r0, r5
 c006ece:	bd70      	pop	{r4, r5, r6, pc}
 c006ed0:	ffffbe00 	.word	0xffffbe00

0c006ed4 <mbedtls_rsa_public>:
 * Do an RSA public key operation
 */
int mbedtls_rsa_public( mbedtls_rsa_context *ctx,
                const unsigned char *input,
                unsigned char *output )
{
 c006ed4:	b5f0      	push	{r4, r5, r6, r7, lr}
 c006ed6:	460c      	mov	r4, r1
 c006ed8:	b087      	sub	sp, #28
    int ret;
    size_t olen;
    mbedtls_mpi T;

    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) )
 c006eda:	2100      	movs	r1, #0
{
 c006edc:	4605      	mov	r5, r0
 c006ede:	4616      	mov	r6, r2
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) )
 c006ee0:	f7ff ff2a 	bl	c006d38 <rsa_check_context.isra.0>
 c006ee4:	bb80      	cbnz	r0, c006f48 <mbedtls_rsa_public+0x74>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );

    mbedtls_mpi_init( &T );
 c006ee6:	a803      	add	r0, sp, #12
 c006ee8:	f7fe fd75 	bl	c0059d6 <mbedtls_mpi_init>
#if defined(MBEDTLS_THREADING_C)
    if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
        return( ret );
#endif

    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
 c006eec:	4621      	mov	r1, r4
 c006eee:	686a      	ldr	r2, [r5, #4]
 c006ef0:	a803      	add	r0, sp, #12
 c006ef2:	f7fe fe2d 	bl	c005b50 <mbedtls_mpi_read_binary>
 c006ef6:	4604      	mov	r4, r0
 c006ef8:	b9d0      	cbnz	r0, c006f30 <mbedtls_rsa_public+0x5c>

    if( mbedtls_mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
 c006efa:	f105 0408 	add.w	r4, r5, #8
 c006efe:	4621      	mov	r1, r4
 c006f00:	a803      	add	r0, sp, #12
 c006f02:	f7fe ffa5 	bl	c005e50 <mbedtls_mpi_cmp_mpi>
 c006f06:	2800      	cmp	r0, #0
 c006f08:	da1b      	bge.n	c006f42 <mbedtls_rsa_public+0x6e>
        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
        goto cleanup;
    }

    olen = ctx->len;
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &T, &T, &ctx->E, &ctx->N, &ctx->RN ) );
 c006f0a:	f105 0368 	add.w	r3, r5, #104	; 0x68
 c006f0e:	a903      	add	r1, sp, #12
 c006f10:	9300      	str	r3, [sp, #0]
 c006f12:	f105 0214 	add.w	r2, r5, #20
 c006f16:	4623      	mov	r3, r4
 c006f18:	4608      	mov	r0, r1
    olen = ctx->len;
 c006f1a:	686f      	ldr	r7, [r5, #4]
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &T, &T, &ctx->E, &ctx->N, &ctx->RN ) );
 c006f1c:	f7ff fb30 	bl	c006580 <mbedtls_mpi_exp_mod>
 c006f20:	4604      	mov	r4, r0
 c006f22:	b928      	cbnz	r0, c006f30 <mbedtls_rsa_public+0x5c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &T, output, olen ) );
 c006f24:	463a      	mov	r2, r7
 c006f26:	4631      	mov	r1, r6
 c006f28:	a803      	add	r0, sp, #12
 c006f2a:	f7fe fe44 	bl	c005bb6 <mbedtls_mpi_write_binary>
 c006f2e:	4604      	mov	r4, r0
#if defined(MBEDTLS_THREADING_C)
    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
#endif

    mbedtls_mpi_free( &T );
 c006f30:	a803      	add	r0, sp, #12
 c006f32:	f7fe fd57 	bl	c0059e4 <mbedtls_mpi_free>

    if( ret != 0 )
 c006f36:	b10c      	cbz	r4, c006f3c <mbedtls_rsa_public+0x68>
        return( MBEDTLS_ERR_RSA_PUBLIC_FAILED + ret );
 c006f38:	f5a4 4485 	sub.w	r4, r4, #17024	; 0x4280

    return( 0 );
}
 c006f3c:	4620      	mov	r0, r4
 c006f3e:	b007      	add	sp, #28
 c006f40:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
 c006f42:	f06f 0403 	mvn.w	r4, #3
 c006f46:	e7f3      	b.n	c006f30 <mbedtls_rsa_public+0x5c>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c006f48:	4c00      	ldr	r4, [pc, #0]	; (c006f4c <mbedtls_rsa_public+0x78>)
 c006f4a:	e7f7      	b.n	c006f3c <mbedtls_rsa_public+0x68>
 c006f4c:	ffffbf80 	.word	0xffffbf80

0c006f50 <mbedtls_rsa_free>:

/*
 * Free the components of an RSA key
 */
void mbedtls_rsa_free( mbedtls_rsa_context *ctx )
{
 c006f50:	b510      	push	{r4, lr}
 c006f52:	4604      	mov	r4, r0
    mbedtls_mpi_free( &ctx->Vi ); mbedtls_mpi_free( &ctx->Vf );
 c006f54:	308c      	adds	r0, #140	; 0x8c
 c006f56:	f7fe fd45 	bl	c0059e4 <mbedtls_mpi_free>
 c006f5a:	f104 0098 	add.w	r0, r4, #152	; 0x98
 c006f5e:	f7fe fd41 	bl	c0059e4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->RN ); mbedtls_mpi_free( &ctx->D  );
 c006f62:	f104 0068 	add.w	r0, r4, #104	; 0x68
 c006f66:	f7fe fd3d 	bl	c0059e4 <mbedtls_mpi_free>
 c006f6a:	f104 0020 	add.w	r0, r4, #32
 c006f6e:	f7fe fd39 	bl	c0059e4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->Q  ); mbedtls_mpi_free( &ctx->P  );
 c006f72:	f104 0038 	add.w	r0, r4, #56	; 0x38
 c006f76:	f7fe fd35 	bl	c0059e4 <mbedtls_mpi_free>
 c006f7a:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 c006f7e:	f7fe fd31 	bl	c0059e4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->E  ); mbedtls_mpi_free( &ctx->N  );
 c006f82:	f104 0014 	add.w	r0, r4, #20
 c006f86:	f7fe fd2d 	bl	c0059e4 <mbedtls_mpi_free>
 c006f8a:	f104 0008 	add.w	r0, r4, #8
 c006f8e:	f7fe fd29 	bl	c0059e4 <mbedtls_mpi_free>

#if !defined(MBEDTLS_RSA_NO_CRT)
    mbedtls_mpi_free( &ctx->RQ ); mbedtls_mpi_free( &ctx->RP );
 c006f92:	f104 0080 	add.w	r0, r4, #128	; 0x80
 c006f96:	f7fe fd25 	bl	c0059e4 <mbedtls_mpi_free>
 c006f9a:	f104 0074 	add.w	r0, r4, #116	; 0x74
 c006f9e:	f7fe fd21 	bl	c0059e4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->QP ); mbedtls_mpi_free( &ctx->DQ );
 c006fa2:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 c006fa6:	f7fe fd1d 	bl	c0059e4 <mbedtls_mpi_free>
 c006faa:	f104 0050 	add.w	r0, r4, #80	; 0x50
 c006fae:	f7fe fd19 	bl	c0059e4 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->DP );
 c006fb2:	f104 0044 	add.w	r0, r4, #68	; 0x44
#endif /* MBEDTLS_RSA_NO_CRT */

#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_free( &ctx->mutex );
#endif
}
 c006fb6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_mpi_free( &ctx->DP );
 c006fba:	f7fe bd13 	b.w	c0059e4 <mbedtls_mpi_free>
	...

0c006fc0 <bl2_main>:
    jumper(vt);
}


int bl2_main(void)
{
 c006fc0:	b530      	push	{r4, r5, lr}
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 c006fc2:	4b2c      	ldr	r3, [pc, #176]	; (c007074 <bl2_main+0xb4>)
 c006fc4:	b085      	sub	sp, #20
 c006fc6:	f383 880a 	msr	MSPLIM, r3

#if defined(__ARM_ARCH_8M_MAIN__) || defined(__ARM_ARCH_8M_BASE__)
    __set_MSPLIM(msp_stack_bottom);
#endif
#ifdef TFM_DEV_MODE
    stdio_init();
 c006fca:	f001 fb27 	bl	c00861c <stdio_init>
    /* Initialise the mbedtls static memory allocator so that mbedtls allocates
     * memory from the provided static buffer instead of from the heap.
     */
    mbedtls_memory_buffer_alloc_init(mbedtls_mem_buf, BL2_MBEDTLS_MEM_BUF_LEN);

    rc = FLASH_DEV_NAME.Initialize(NULL);
 c006fce:	4c2a      	ldr	r4, [pc, #168]	; (c007078 <bl2_main+0xb8>)
    BOOT_LOG_INF("Starting bootloader");
 c006fd0:	482a      	ldr	r0, [pc, #168]	; (c00707c <bl2_main+0xbc>)
 c006fd2:	f001 fcbd 	bl	c008950 <puts>
    mbedtls_memory_buffer_alloc_init(mbedtls_mem_buf, BL2_MBEDTLS_MEM_BUF_LEN);
 c006fd6:	482a      	ldr	r0, [pc, #168]	; (c007080 <bl2_main+0xc0>)
 c006fd8:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 c006fdc:	f7ff fe5c 	bl	c006c98 <mbedtls_memory_buffer_alloc_init>
    rc = FLASH_DEV_NAME.Initialize(NULL);
 c006fe0:	68a3      	ldr	r3, [r4, #8]
 c006fe2:	2000      	movs	r0, #0
 c006fe4:	4798      	blx	r3
    if(rc != ARM_DRIVER_OK) {
 c006fe6:	b120      	cbz	r0, c006ff2 <bl2_main+0x32>
        BOOT_LOG_ERR("Error while initializing Flash Interface");
 c006fe8:	4826      	ldr	r0, [pc, #152]	; (c007084 <bl2_main+0xc4>)
 c006fea:	f001 fcb1 	bl	c008950 <puts>
        Error_Handler();
 c006fee:	f7fa fb13 	bl	c001618 <Error_Handler>
    }

    rc = boot_nv_security_counter_init();
 c006ff2:	f001 facd 	bl	c008590 <boot_nv_security_counter_init>
    if (rc != 0) {
 c006ff6:	b120      	cbz	r0, c007002 <bl2_main+0x42>
        BOOT_LOG_ERR("Error while initializing the security counter");
 c006ff8:	4823      	ldr	r0, [pc, #140]	; (c007088 <bl2_main+0xc8>)
 c006ffa:	f001 fca9 	bl	c008950 <puts>
        Error_Handler();
 c006ffe:	f7fa fb0b 	bl	c001618 <Error_Handler>
    }

    rc = boot_go(&rsp);
 c007002:	a801      	add	r0, sp, #4
 c007004:	f000 ffd8 	bl	c007fb8 <boot_go>
    if (rc != 0) {
 c007008:	b120      	cbz	r0, c007014 <bl2_main+0x54>
        BOOT_LOG_ERR("Unable to find bootable image");
 c00700a:	4820      	ldr	r0, [pc, #128]	; (c00708c <bl2_main+0xcc>)
 c00700c:	f001 fca0 	bl	c008950 <puts>
        Error_Handler();
 c007010:	f7fa fb02 	bl	c001618 <Error_Handler>
    }

    BOOT_LOG_INF("Bootloader chainload address offset: 0x%x",
 c007014:	9903      	ldr	r1, [sp, #12]
 c007016:	481e      	ldr	r0, [pc, #120]	; (c007090 <bl2_main+0xd0>)
 c007018:	f001 fc26 	bl	c008868 <iprintf>
            rsp.br_image_off);
    flash_area_warn_on_open();
 c00701c:	f000 fb00 	bl	c007620 <flash_area_warn_on_open>
    BOOT_LOG_INF("Jumping to the first image slot");
 c007020:	481c      	ldr	r0, [pc, #112]	; (c007094 <bl2_main+0xd4>)
 c007022:	f001 fc95 	bl	c008950 <puts>
    rc = flash_device_base(rsp->br_flash_dev_id, &flash_base);
 c007026:	4669      	mov	r1, sp
 c007028:	f89d 0008 	ldrb.w	r0, [sp, #8]
 c00702c:	f000 fab2 	bl	c007594 <flash_device_base>
    if (rsp->br_hdr->ih_flags & IMAGE_F_RAM_LOAD) {
 c007030:	9a01      	ldr	r2, [sp, #4]
 c007032:	4d19      	ldr	r5, [pc, #100]	; (c007098 <bl2_main+0xd8>)
 c007034:	6913      	ldr	r3, [r2, #16]
 c007036:	8911      	ldrh	r1, [r2, #8]
 c007038:	f013 0f20 	tst.w	r3, #32
        vt = (struct arm_vector_table *)(flash_base +
 c00703c:	bf05      	ittet	eq
 c00703e:	9b03      	ldreq	r3, [sp, #12]
 c007040:	9a00      	ldreq	r2, [sp, #0]
        vt = (struct arm_vector_table *)(rsp->br_hdr->ih_load_addr +
 c007042:	6853      	ldrne	r3, [r2, #4]
        vt = (struct arm_vector_table *)(flash_base +
 c007044:	189b      	addeq	r3, r3, r2
                                         rsp->br_image_off +
 c007046:	440b      	add	r3, r1
        vt = (struct arm_vector_table *)(flash_base +
 c007048:	602b      	str	r3, [r5, #0]
    rc = FLASH_DEV_NAME.Uninitialize();
 c00704a:	68e3      	ldr	r3, [r4, #12]
 c00704c:	4798      	blx	r3
    if(rc != ARM_DRIVER_OK) {
 c00704e:	b110      	cbz	r0, c007056 <bl2_main+0x96>
        BOOT_LOG_ERR("Error while uninitializing Flash Interface");
 c007050:	4812      	ldr	r0, [pc, #72]	; (c00709c <bl2_main+0xdc>)
 c007052:	f001 fc7d 	bl	c008950 <puts>
    stdio_uninit();
 c007056:	f001 faef 	bl	c008638 <stdio_uninit>
    TFM_BL2_CopySharedData();
 c00705a:	f7fa fe8d 	bl	c001d78 <TFM_BL2_CopySharedData>
    jumper(vt);
 c00705e:	6828      	ldr	r0, [r5, #0]
 c007060:	f7f9 ffee 	bl	c001040 <jumper>
    do_boot(&rsp);

    BOOT_LOG_ERR("Never should get here");
 c007064:	480e      	ldr	r0, [pc, #56]	; (c0070a0 <bl2_main+0xe0>)
 c007066:	f001 fc73 	bl	c008950 <puts>
    Error_Handler();
 c00706a:	f7fa fad5 	bl	c001618 <Error_Handler>
    return 0;
}
 c00706e:	2000      	movs	r0, #0
 c007070:	b005      	add	sp, #20
 c007072:	bd30      	pop	{r4, r5, pc}
 c007074:	30034998 	.word	0x30034998
 c007078:	0c00a054 	.word	0x0c00a054
 c00707c:	0c00a59e 	.word	0x0c00a59e
 c007080:	300302a0 	.word	0x300302a0
 c007084:	0c00a5b9 	.word	0x0c00a5b9
 c007088:	0c00a5e9 	.word	0x0c00a5e9
 c00708c:	0c00a61e 	.word	0x0c00a61e
 c007090:	0c00a643 	.word	0x0c00a643
 c007094:	0c00a675 	.word	0x0c00a675
 c007098:	300322a0 	.word	0x300322a0
 c00709c:	0c00a69c 	.word	0x0c00a69c
 c0070a0:	0c00a6ce 	.word	0x0c00a6ce

0c0070a4 <boot_add_data_to_shared_area>:
enum shared_memory_err_t
boot_add_data_to_shared_area(uint8_t        major_type,
                             uint16_t       minor_type,
                             size_t         size,
                             const uint8_t *data)
{
 c0070a4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 c0070a8:	461f      	mov	r7, r3
    struct shared_data_tlv_entry tlv_entry = {0};
 c0070aa:	2300      	movs	r3, #0
    boot_data = (struct tfm_boot_data *)BOOT_TFM_SHARED_DATA_BASE;

    /* Check whether first time to call this function. If does then initialise
     * shared data area.
     */
    if (shared_memory_init_done == SHARED_MEMORY_UNINITIALZED) {
 c0070ac:	f8df 80c4 	ldr.w	r8, [pc, #196]	; c007174 <boot_add_data_to_shared_area+0xd0>
{
 c0070b0:	460c      	mov	r4, r1
    if (shared_memory_init_done == SHARED_MEMORY_UNINITIALZED) {
 c0070b2:	f8d8 1000 	ldr.w	r1, [r8]
{
 c0070b6:	4605      	mov	r5, r0
 c0070b8:	4616      	mov	r6, r2
    struct shared_data_tlv_entry tlv_entry = {0};
 c0070ba:	9301      	str	r3, [sp, #4]
    if (shared_memory_init_done == SHARED_MEMORY_UNINITIALZED) {
 c0070bc:	b951      	cbnz	r1, c0070d4 <boot_add_data_to_shared_area+0x30>
        memset((void *)BOOT_TFM_SHARED_DATA_BASE, 0, BOOT_TFM_SHARED_DATA_SIZE);
 c0070be:	4b2a      	ldr	r3, [pc, #168]	; (c007168 <boot_add_data_to_shared_area+0xc4>)
 c0070c0:	f44f 6280 	mov.w	r2, #1024	; 0x400
 c0070c4:	4618      	mov	r0, r3
 c0070c6:	f001 fb10 	bl	c0086ea <memset>
        boot_data->header.tlv_magic   = SHARED_DATA_TLV_INFO_MAGIC;
        boot_data->header.tlv_tot_len = SHARED_DATA_HEADER_SIZE;
        shared_memory_init_done = SHARED_MEMORY_INITIALZED;
 c0070ca:	2301      	movs	r3, #1
        boot_data->header.tlv_magic   = SHARED_DATA_TLV_INFO_MAGIC;
 c0070cc:	4a27      	ldr	r2, [pc, #156]	; (c00716c <boot_add_data_to_shared_area+0xc8>)
 c0070ce:	6002      	str	r2, [r0, #0]
        shared_memory_init_done = SHARED_MEMORY_INITIALZED;
 c0070d0:	f8c8 3000 	str.w	r3, [r8]
    }

    /* Check whether TLV entry is already added.
     * Get the boundaries of TLV section
     */
    tlv_end = BOOT_TFM_SHARED_DATA_BASE + boot_data->header.tlv_tot_len;
 c0070d4:	4b24      	ldr	r3, [pc, #144]	; (c007168 <boot_add_data_to_shared_area+0xc4>)
    offset  = BOOT_TFM_SHARED_DATA_BASE + SHARED_DATA_HEADER_SIZE;
 c0070d6:	4a26      	ldr	r2, [pc, #152]	; (c007170 <boot_add_data_to_shared_area+0xcc>)
    tlv_end = BOOT_TFM_SHARED_DATA_BASE + boot_data->header.tlv_tot_len;
 c0070d8:	885b      	ldrh	r3, [r3, #2]
     * returns with error: SHARED_MEMORY_OVERWRITE
     */
    for (; offset < tlv_end; offset += tlv_entry.tlv_len) {
        /* Create local copy to avoid unaligned access */
        memcpy(&tlv_entry, (const void *)offset, SHARED_DATA_ENTRY_HEADER_SIZE);
        if (GET_MAJOR(tlv_entry.tlv_type) == major_type &&
 c0070da:	fa1f fc85 	uxth.w	ip, r5
    tlv_end = BOOT_TFM_SHARED_DATA_BASE + boot_data->header.tlv_tot_len;
 c0070de:	f103 5340 	add.w	r3, r3, #805306368	; 0x30000000
 c0070e2:	f503 337f 	add.w	r3, r3, #261120	; 0x3fc00
    for (; offset < tlv_end; offset += tlv_entry.tlv_len) {
 c0070e6:	429a      	cmp	r2, r3
 c0070e8:	d32c      	bcc.n	c007144 <boot_add_data_to_shared_area+0xa0>
            return SHARED_MEMORY_OVERWRITE;
        }
    }

    /* Add TLV entry */
    tlv_entry.tlv_type = SET_TLV_TYPE(major_type, minor_type);
 c0070ea:	f3c4 040b 	ubfx	r4, r4, #0, #12
 c0070ee:	ea44 3405 	orr.w	r4, r4, r5, lsl #12
 c0070f2:	f8ad 4004 	strh.w	r4, [sp, #4]
    tlv_entry.tlv_len  = SHARED_DATA_ENTRY_SIZE(size);
 c0070f6:	1d34      	adds	r4, r6, #4
 c0070f8:	b2a4      	uxth	r4, r4

    /* Verify integer overflow */
    if (boot_add_uint16_overflow_check(boot_data->header.tlv_tot_len,
 c0070fa:	f8df 806c 	ldr.w	r8, [pc, #108]	; c007168 <boot_add_data_to_shared_area+0xc4>
    tlv_entry.tlv_len  = SHARED_DATA_ENTRY_SIZE(size);
 c0070fe:	f8ad 4006 	strh.w	r4, [sp, #6]
    if (boot_add_uint16_overflow_check(boot_data->header.tlv_tot_len,
 c007102:	4621      	mov	r1, r4
 c007104:	f8b8 0002 	ldrh.w	r0, [r8, #2]
 c007108:	f000 fa0f 	bl	c00752a <boot_add_uint16_overflow_check>
 c00710c:	4605      	mov	r5, r0
 c00710e:	bb38      	cbnz	r0, c007160 <boot_add_data_to_shared_area+0xbc>
                                       tlv_entry.tlv_len)) {
        return SHARED_MEMORY_GEN_ERROR;
    }

    /* Verify overflow of shared area */
    if ((boot_data->header.tlv_tot_len + tlv_entry.tlv_len) >
 c007110:	f8b8 0002 	ldrh.w	r0, [r8, #2]
 c007114:	1903      	adds	r3, r0, r4
 c007116:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 c00711a:	dc23      	bgt.n	c007164 <boot_add_data_to_shared_area+0xc0>
         BOOT_TFM_SHARED_DATA_SIZE){
        return SHARED_MEMORY_OVERFLOW;
    }

    next_tlv = (uint8_t *)boot_data + boot_data->header.tlv_tot_len;
    memcpy(next_tlv, &tlv_entry, SHARED_DATA_ENTRY_HEADER_SIZE);
 c00711c:	9b01      	ldr	r3, [sp, #4]
 c00711e:	f100 5040 	add.w	r0, r0, #805306368	; 0x30000000
 c007122:	f500 307f 	add.w	r0, r0, #261120	; 0x3fc00
 c007126:	f840 3b04 	str.w	r3, [r0], #4

    next_tlv += SHARED_DATA_ENTRY_HEADER_SIZE;
    memcpy(next_tlv, data, size);
 c00712a:	4632      	mov	r2, r6
 c00712c:	4639      	mov	r1, r7
 c00712e:	f001 fad1 	bl	c0086d4 <memcpy>

    boot_data->header.tlv_tot_len += tlv_entry.tlv_len;

    return SHARED_MEMORY_OK;
 c007132:	4628      	mov	r0, r5
    boot_data->header.tlv_tot_len += tlv_entry.tlv_len;
 c007134:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 c007138:	441c      	add	r4, r3
 c00713a:	f8a8 4002 	strh.w	r4, [r8, #2]
}
 c00713e:	b002      	add	sp, #8
 c007140:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        memcpy(&tlv_entry, (const void *)offset, SHARED_DATA_ENTRY_HEADER_SIZE);
 c007144:	6810      	ldr	r0, [r2, #0]
 c007146:	b281      	uxth	r1, r0
        if (GET_MAJOR(tlv_entry.tlv_type) == major_type &&
 c007148:	ebbc 3f11 	cmp.w	ip, r1, lsr #12
 c00714c:	d103      	bne.n	c007156 <boot_add_data_to_shared_area+0xb2>
 c00714e:	f3c1 010b 	ubfx	r1, r1, #0, #12
 c007152:	42a1      	cmp	r1, r4
 c007154:	d002      	beq.n	c00715c <boot_add_data_to_shared_area+0xb8>
    for (; offset < tlv_end; offset += tlv_entry.tlv_len) {
 c007156:	eb02 4210 	add.w	r2, r2, r0, lsr #16
 c00715a:	e7c4      	b.n	c0070e6 <boot_add_data_to_shared_area+0x42>
            return SHARED_MEMORY_OVERWRITE;
 c00715c:	2002      	movs	r0, #2
 c00715e:	e7ee      	b.n	c00713e <boot_add_data_to_shared_area+0x9a>
        return SHARED_MEMORY_GEN_ERROR;
 c007160:	2003      	movs	r0, #3
 c007162:	e7ec      	b.n	c00713e <boot_add_data_to_shared_area+0x9a>
        return SHARED_MEMORY_OVERFLOW;
 c007164:	2001      	movs	r0, #1
 c007166:	e7ea      	b.n	c00713e <boot_add_data_to_shared_area+0x9a>
 c007168:	3003fc00 	.word	0x3003fc00
 c00716c:	00042016 	.word	0x00042016
 c007170:	3003fc04 	.word	0x3003fc04
 c007174:	300322a4 	.word	0x300322a4

0c007178 <boot_save_boot_status>:
/* See in boot_record.h */
enum boot_status_err_t
boot_save_boot_status(uint8_t sw_module,
                      const struct image_header *hdr,
                      const struct flash_area *fap)
{
 c007178:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    switch (sw_module) {
 c00717c:	2805      	cmp	r0, #5
{
 c00717e:	b08e      	sub	sp, #56	; 0x38
 c007180:	460d      	mov	r5, r1
 c007182:	4616      	mov	r6, r2
    switch (sw_module) {
 c007184:	d03d      	beq.n	c007202 <boot_save_boot_status+0x8a>
 c007186:	2806      	cmp	r0, #6
 c007188:	d038      	beq.n	c0071fc <boot_save_boot_status+0x84>
 c00718a:	2804      	cmp	r0, #4
 c00718c:	d132      	bne.n	c0071f4 <boot_save_boot_status+0x7c>
        sw_type = sw_comp_s;
 c00718e:	f8df 8124 	ldr.w	r8, [pc, #292]	; c0072b4 <boot_save_boot_status+0x13c>
    ias_minor = SET_IAS_MINOR(sw_module, SW_TYPE);
 c007192:	0184      	lsls	r4, r0, #6
    res = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c007194:	4640      	mov	r0, r8
 c007196:	f001 fc27 	bl	c0089e8 <strlen>
    ias_minor = SET_IAS_MINOR(sw_module, SW_TYPE);
 c00719a:	b227      	sxth	r7, r4
    res = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c00719c:	4602      	mov	r2, r0
 c00719e:	4643      	mov	r3, r8
 c0071a0:	f047 0103 	orr.w	r1, r7, #3
 c0071a4:	2001      	movs	r0, #1
 c0071a6:	f7ff ff7d 	bl	c0070a4 <boot_add_data_to_shared_area>
    if (res) {
 c0071aa:	bb18      	cbnz	r0, c0071f4 <boot_save_boot_status+0x7c>
    cnt = snprintf(sw_version, sizeof(sw_version), "%u.%u.%u",
 c0071ac:	8aea      	ldrh	r2, [r5, #22]
 c0071ae:	7d2b      	ldrb	r3, [r5, #20]
 c0071b0:	9201      	str	r2, [sp, #4]
 c0071b2:	7d6a      	ldrb	r2, [r5, #21]
 c0071b4:	210e      	movs	r1, #14
 c0071b6:	9200      	str	r2, [sp, #0]
 c0071b8:	a806      	add	r0, sp, #24
 c0071ba:	4a3c      	ldr	r2, [pc, #240]	; (c0072ac <boot_save_boot_status+0x134>)
 c0071bc:	f001 fbe0 	bl	c008980 <sniprintf>
    res = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c0071c0:	ab06      	add	r3, sp, #24
 c0071c2:	4602      	mov	r2, r0
 c0071c4:	4621      	mov	r1, r4
 c0071c6:	2001      	movs	r0, #1
 c0071c8:	f7ff ff6c 	bl	c0070a4 <boot_add_data_to_shared_area>
    if (res) {
 c0071cc:	b990      	cbnz	r0, c0071f4 <boot_save_boot_status+0x7c>
    char measure_type[] = "SHA256";
 c0071ce:	4b38      	ldr	r3, [pc, #224]	; (c0072b0 <boot_save_boot_status+0x138>)
    offset = hdr->ih_img_size + hdr->ih_hdr_size;
 c0071d0:	892c      	ldrh	r4, [r5, #8]
    char measure_type[] = "SHA256";
 c0071d2:	6818      	ldr	r0, [r3, #0]
 c0071d4:	889a      	ldrh	r2, [r3, #4]
 c0071d6:	799b      	ldrb	r3, [r3, #6]
 c0071d8:	9004      	str	r0, [sp, #16]
 c0071da:	f88d 3016 	strb.w	r3, [sp, #22]
    offset = hdr->ih_img_size + hdr->ih_hdr_size;
 c0071de:	68eb      	ldr	r3, [r5, #12]
    char measure_type[] = "SHA256";
 c0071e0:	f8ad 2014 	strh.w	r2, [sp, #20]
    offset = hdr->ih_img_size + hdr->ih_hdr_size;
 c0071e4:	441c      	add	r4, r3
    res = LOAD_IMAGE_DATA(fap, offset, &tlv_header, sizeof(tlv_header));
 c0071e6:	aa02      	add	r2, sp, #8
 c0071e8:	2304      	movs	r3, #4
 c0071ea:	4621      	mov	r1, r4
 c0071ec:	4630      	mov	r0, r6
 c0071ee:	f000 fa33 	bl	c007658 <flash_area_read>
    if (res) {
 c0071f2:	b148      	cbz	r0, c007208 <boot_save_boot_status+0x90>
        return BOOT_STATUS_ERROR;
 c0071f4:	2001      	movs	r0, #1
    if (res) {
        return res;
    }

    return BOOT_STATUS_OK;
}
 c0071f6:	b00e      	add	sp, #56	; 0x38
 c0071f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        sw_type = sw_comp_ns_s;
 c0071fc:	f8df 80b8 	ldr.w	r8, [pc, #184]	; c0072b8 <boot_save_boot_status+0x140>
 c007200:	e7c7      	b.n	c007192 <boot_save_boot_status+0x1a>
        sw_type = sw_comp_ns;
 c007202:	f8df 80b8 	ldr.w	r8, [pc, #184]	; c0072bc <boot_save_boot_status+0x144>
 c007206:	e7c4      	b.n	c007192 <boot_save_boot_status+0x1a>
    if (tlv_header.it_magic != IMAGE_TLV_INFO_MAGIC) {
 c007208:	f646 1307 	movw	r3, #26887	; 0x6907
 c00720c:	f8bd 2008 	ldrh.w	r2, [sp, #8]
 c007210:	429a      	cmp	r2, r3
 c007212:	d1ef      	bne.n	c0071f4 <boot_save_boot_status+0x7c>
    tlv_end = offset + tlv_header.it_tlv_tot;
 c007214:	f8bd 800a 	ldrh.w	r8, [sp, #10]
            res2 = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c007218:	f047 0a01 	orr.w	sl, r7, #1
    tlv_end = offset + tlv_header.it_tlv_tot;
 c00721c:	44a0      	add	r8, r4
    offset += sizeof(tlv_header);
 c00721e:	3404      	adds	r4, #4
    for (; offset < tlv_end; offset += sizeof(tlv_entry) + tlv_entry.it_len) {
 c007220:	45a0      	cmp	r8, r4
 c007222:	d801      	bhi.n	c007228 <boot_save_boot_status+0xb0>
    return BOOT_STATUS_OK;
 c007224:	2000      	movs	r0, #0
 c007226:	e7e6      	b.n	c0071f6 <boot_save_boot_status+0x7e>
        res = LOAD_IMAGE_DATA(fap, offset, &tlv_entry, sizeof(tlv_entry));
 c007228:	2304      	movs	r3, #4
 c00722a:	aa03      	add	r2, sp, #12
 c00722c:	4621      	mov	r1, r4
 c00722e:	4630      	mov	r0, r6
 c007230:	f000 fa12 	bl	c007658 <flash_area_read>
        if (res) {
 c007234:	2800      	cmp	r0, #0
 c007236:	d1dd      	bne.n	c0071f4 <boot_save_boot_status+0x7c>
        if (tlv_entry.it_type == IMAGE_TLV_SHA256) {
 c007238:	f89d 900c 	ldrb.w	r9, [sp, #12]
 c00723c:	f8bd 500e 	ldrh.w	r5, [sp, #14]
 c007240:	f1b9 0f10 	cmp.w	r9, #16
 c007244:	d121      	bne.n	c00728a <boot_save_boot_status+0x112>
            if (tlv_entry.it_len != sizeof(buf)) { /* SHA256 - 32 bytes */
 c007246:	2d20      	cmp	r5, #32
 c007248:	d1d4      	bne.n	c0071f4 <boot_save_boot_status+0x7c>
            res = LOAD_IMAGE_DATA(fap, offset + sizeof(tlv_entry),
 c00724a:	462b      	mov	r3, r5
 c00724c:	aa06      	add	r2, sp, #24
 c00724e:	1d21      	adds	r1, r4, #4
 c007250:	4630      	mov	r0, r6
 c007252:	f000 fa01 	bl	c007658 <flash_area_read>
            if (res) {
 c007256:	2800      	cmp	r0, #0
 c007258:	d1cc      	bne.n	c0071f4 <boot_save_boot_status+0x7c>
            res2 = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c00725a:	ab06      	add	r3, sp, #24
 c00725c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 c007260:	f047 0108 	orr.w	r1, r7, #8
 c007264:	2001      	movs	r0, #1
 c007266:	f7ff ff1d 	bl	c0070a4 <boot_add_data_to_shared_area>
            if (res2) {
 c00726a:	2800      	cmp	r0, #0
 c00726c:	d1c2      	bne.n	c0071f4 <boot_save_boot_status+0x7c>
            res2 = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c00726e:	2206      	movs	r2, #6
 c007270:	ab04      	add	r3, sp, #16
 c007272:	f047 0109 	orr.w	r1, r7, #9
 c007276:	2001      	movs	r0, #1
 c007278:	f7ff ff14 	bl	c0070a4 <boot_add_data_to_shared_area>
            if (res2) {
 c00727c:	2800      	cmp	r0, #0
 c00727e:	d1b9      	bne.n	c0071f4 <boot_save_boot_status+0x7c>
    for (; offset < tlv_end; offset += sizeof(tlv_entry) + tlv_entry.it_len) {
 c007280:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 c007284:	3304      	adds	r3, #4
 c007286:	441c      	add	r4, r3
 c007288:	e7ca      	b.n	c007220 <boot_save_boot_status+0xa8>
        } else if (tlv_entry.it_type == IMAGE_TLV_KEYHASH) {
 c00728a:	f1b9 0f01 	cmp.w	r9, #1
 c00728e:	d1f7      	bne.n	c007280 <boot_save_boot_status+0x108>
            if (tlv_entry.it_len != sizeof(buf)) { /* SHA256 - 32 bytes */
 c007290:	2d20      	cmp	r5, #32
 c007292:	d1af      	bne.n	c0071f4 <boot_save_boot_status+0x7c>
            res = LOAD_IMAGE_DATA(fap, offset + sizeof(tlv_entry),
 c007294:	462b      	mov	r3, r5
 c007296:	aa06      	add	r2, sp, #24
 c007298:	1d21      	adds	r1, r4, #4
 c00729a:	4630      	mov	r0, r6
 c00729c:	f000 f9dc 	bl	c007658 <flash_area_read>
            if (res) {
 c0072a0:	2800      	cmp	r0, #0
 c0072a2:	d1a7      	bne.n	c0071f4 <boot_save_boot_status+0x7c>
            res2 = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c0072a4:	ab06      	add	r3, sp, #24
 c0072a6:	462a      	mov	r2, r5
 c0072a8:	4651      	mov	r1, sl
 c0072aa:	e7e4      	b.n	c007276 <boot_save_boot_status+0xfe>
 c0072ac:	0c00a6eb 	.word	0x0c00a6eb
 c0072b0:	0c00a6f4 	.word	0x0c00a6f4
 c0072b4:	0c00a709 	.word	0x0c00a709
 c0072b8:	0c00a700 	.word	0x0c00a700
 c0072bc:	0c00a6fb 	.word	0x0c00a6fb

0c0072c0 <boot_secure_memequal>:
 *              so should not be considered a drop-in replacement.
 *
 * @return      0 if memory regions are equal.
 */
uint32_t boot_secure_memequal(const void *s1, const void *s2, size_t n)
{
 c0072c0:	b570      	push	{r4, r5, r6, lr}
 c0072c2:	4605      	mov	r5, r0
    size_t i;
    uint8_t *s1_p = (uint8_t*) s1;
    uint8_t *s2_p = (uint8_t*) s2;
    uint32_t ret = 0;
 c0072c4:	2000      	movs	r0, #0

    for (i = 0; i < n; i++) {
 c0072c6:	4603      	mov	r3, r0
 c0072c8:	4293      	cmp	r3, r2
 c0072ca:	d100      	bne.n	c0072ce <boot_secure_memequal+0xe>
        ret |= (s1_p[i] ^ s2_p[i]);
    }

    return ret;
}
 c0072cc:	bd70      	pop	{r4, r5, r6, pc}
        ret |= (s1_p[i] ^ s2_p[i]);
 c0072ce:	5cec      	ldrb	r4, [r5, r3]
 c0072d0:	5cce      	ldrb	r6, [r1, r3]
    for (i = 0; i < n; i++) {
 c0072d2:	3301      	adds	r3, #1
        ret |= (s1_p[i] ^ s2_p[i]);
 c0072d4:	4074      	eors	r4, r6
 c0072d6:	4320      	orrs	r0, r4
 c0072d8:	e7f6      	b.n	c0072c8 <boot_secure_memequal+0x8>

0c0072da <boot_magic_compatible_check>:
 *                              0 otherwise.
 */
int
boot_magic_compatible_check(uint8_t tbl_val, uint8_t val)
{
    switch (tbl_val) {
 c0072da:	2804      	cmp	r0, #4
 c0072dc:	d00a      	beq.n	c0072f4 <boot_magic_compatible_check+0x1a>
 c0072de:	2805      	cmp	r0, #5
 c0072e0:	d104      	bne.n	c0072ec <boot_magic_compatible_check+0x12>
    case BOOT_MAGIC_ANY:
        return 1;

    case BOOT_MAGIC_NOTGOOD:
        return val != BOOT_MAGIC_GOOD;
 c0072e2:	f111 30ff 	adds.w	r0, r1, #4294967295
 c0072e6:	bf18      	it	ne
 c0072e8:	2001      	movne	r0, #1
 c0072ea:	4770      	bx	lr

    default:
        return tbl_val == val;
 c0072ec:	1a43      	subs	r3, r0, r1
 c0072ee:	4258      	negs	r0, r3
 c0072f0:	4158      	adcs	r0, r3
 c0072f2:	4770      	bx	lr
        return 1;
 c0072f4:	2001      	movs	r0, #1
    }
}
 c0072f6:	4770      	bx	lr

0c0072f8 <boot_read_swap_state>:
}

int
boot_read_swap_state(const struct flash_area *fap,
                     struct boot_swap_state *state)
{
 c0072f8:	b530      	push	{r4, r5, lr}
 c0072fa:	460c      	mov	r4, r1
    return fap->fa_size - BOOT_MAGIC_SZ;
 c0072fc:	6881      	ldr	r1, [r0, #8]
{
 c0072fe:	b087      	sub	sp, #28
    uint32_t off;
    uint8_t swap_info;
    int rc;

    off = boot_magic_off(fap);
    rc = flash_area_read_is_empty(fap, off, magic, BOOT_MAGIC_SZ);
 c007300:	2310      	movs	r3, #16
 c007302:	aa02      	add	r2, sp, #8
 c007304:	3910      	subs	r1, #16
{
 c007306:	4605      	mov	r5, r0
    rc = flash_area_read_is_empty(fap, off, magic, BOOT_MAGIC_SZ);
 c007308:	f000 f9b4 	bl	c007674 <flash_area_read_is_empty>
    if (rc < 0) {
 c00730c:	2800      	cmp	r0, #0
 c00730e:	db0d      	blt.n	c00732c <boot_read_swap_state+0x34>
        return BOOT_EFLASH;
    }
    if (rc == 1) {
 c007310:	2801      	cmp	r0, #1
 c007312:	d10d      	bne.n	c007330 <boot_read_swap_state+0x38>
        state->magic = BOOT_MAGIC_UNSET;
 c007314:	2303      	movs	r3, #3
    } else {
        state->magic = boot_magic_decode(magic);
 c007316:	7023      	strb	r3, [r4, #0]
    return fap->fa_size - BOOT_MAGIC_SZ - BOOT_MAX_ALIGN * 3;
 c007318:	68a9      	ldr	r1, [r5, #8]
    }

    off = boot_swap_info_off(fap);
    rc = flash_area_read_is_empty(fap, off, &swap_info, sizeof swap_info);
 c00731a:	2301      	movs	r3, #1
 c00731c:	f10d 0207 	add.w	r2, sp, #7
 c007320:	3928      	subs	r1, #40	; 0x28
 c007322:	4628      	mov	r0, r5
 c007324:	f000 f9a6 	bl	c007674 <flash_area_read_is_empty>
    if (rc < 0) {
 c007328:	2800      	cmp	r0, #0
 c00732a:	da0b      	bge.n	c007344 <boot_read_swap_state+0x4c>
        return BOOT_EFLASH;
 c00732c:	2001      	movs	r0, #1
 c00732e:	e034      	b.n	c00739a <boot_read_swap_state+0xa2>
    if (boot_secure_memequal(magic, boot_img_magic, BOOT_MAGIC_SZ) == 0) {
 c007330:	2210      	movs	r2, #16
 c007332:	4921      	ldr	r1, [pc, #132]	; (c0073b8 <boot_read_swap_state+0xc0>)
 c007334:	a802      	add	r0, sp, #8
 c007336:	f7ff ffc3 	bl	c0072c0 <boot_secure_memequal>
    return BOOT_MAGIC_BAD;
 c00733a:	2800      	cmp	r0, #0
 c00733c:	bf0c      	ite	eq
 c00733e:	2301      	moveq	r3, #1
 c007340:	2302      	movne	r3, #2
 c007342:	e7e8      	b.n	c007316 <boot_read_swap_state+0x1e>
        return BOOT_EFLASH;
    }

    /* Extract the swap type and image number */
    state->swap_type = BOOT_GET_SWAP_TYPE(swap_info);
 c007344:	f89d 3007 	ldrb.w	r3, [sp, #7]
    state->image_num = BOOT_GET_IMAGE_NUM(swap_info);

    if (rc == 1 || state->swap_type > BOOT_SWAP_TYPE_REVERT) {
 c007348:	2801      	cmp	r0, #1
    state->swap_type = BOOT_GET_SWAP_TYPE(swap_info);
 c00734a:	f003 020f 	and.w	r2, r3, #15
    state->image_num = BOOT_GET_IMAGE_NUM(swap_info);
 c00734e:	ea4f 1313 	mov.w	r3, r3, lsr #4
    state->swap_type = BOOT_GET_SWAP_TYPE(swap_info);
 c007352:	7062      	strb	r2, [r4, #1]
    state->image_num = BOOT_GET_IMAGE_NUM(swap_info);
 c007354:	7123      	strb	r3, [r4, #4]
    if (rc == 1 || state->swap_type > BOOT_SWAP_TYPE_REVERT) {
 c007356:	d001      	beq.n	c00735c <boot_read_swap_state+0x64>
 c007358:	2a04      	cmp	r2, #4
 c00735a:	d903      	bls.n	c007364 <boot_read_swap_state+0x6c>
        state->swap_type = BOOT_SWAP_TYPE_NONE;
 c00735c:	2301      	movs	r3, #1
 c00735e:	7063      	strb	r3, [r4, #1]
        state->image_num = 0;
 c007360:	2300      	movs	r3, #0
 c007362:	7123      	strb	r3, [r4, #4]
    return fap->fa_size - BOOT_MAGIC_SZ - BOOT_MAX_ALIGN * 2;
 c007364:	68a9      	ldr	r1, [r5, #8]
    }

    off = boot_copy_done_off(fap);
    rc = flash_area_read_is_empty(fap, off, &state->copy_done,
 c007366:	2301      	movs	r3, #1
 c007368:	1ca2      	adds	r2, r4, #2
 c00736a:	3920      	subs	r1, #32
 c00736c:	4628      	mov	r0, r5
 c00736e:	f000 f981 	bl	c007674 <flash_area_read_is_empty>
            sizeof state->copy_done);
    if (rc < 0) {
 c007372:	2800      	cmp	r0, #0
 c007374:	dbda      	blt.n	c00732c <boot_read_swap_state+0x34>
        return BOOT_EFLASH;
    }
    if (rc == 1) {
 c007376:	2801      	cmp	r0, #1
 c007378:	d111      	bne.n	c00739e <boot_read_swap_state+0xa6>
        state->copy_done = BOOT_FLAG_UNSET;
 c00737a:	2303      	movs	r3, #3
    } else {
        state->copy_done = boot_flag_decode(state->copy_done);
 c00737c:	70a3      	strb	r3, [r4, #2]
    return fap->fa_size - BOOT_MAGIC_SZ - BOOT_MAX_ALIGN;
 c00737e:	68a9      	ldr	r1, [r5, #8]
    }

    off = boot_image_ok_off(fap);
    rc = flash_area_read_is_empty(fap, off, &state->image_ok,
 c007380:	2301      	movs	r3, #1
 c007382:	1ce2      	adds	r2, r4, #3
 c007384:	3918      	subs	r1, #24
 c007386:	4628      	mov	r0, r5
 c007388:	f000 f974 	bl	c007674 <flash_area_read_is_empty>
                                  sizeof state->image_ok);
    if (rc < 0) {
 c00738c:	2800      	cmp	r0, #0
 c00738e:	dbcd      	blt.n	c00732c <boot_read_swap_state+0x34>
        return BOOT_EFLASH;
    }
    if (rc == 1) {
 c007390:	2801      	cmp	r0, #1
 c007392:	d10a      	bne.n	c0073aa <boot_read_swap_state+0xb2>
        state->image_ok = BOOT_FLAG_UNSET;
 c007394:	2303      	movs	r3, #3
    } else {
        state->image_ok = boot_flag_decode(state->image_ok);
    }

    return 0;
 c007396:	2000      	movs	r0, #0
        state->image_ok = boot_flag_decode(state->image_ok);
 c007398:	70e3      	strb	r3, [r4, #3]
}
 c00739a:	b007      	add	sp, #28
 c00739c:	bd30      	pop	{r4, r5, pc}
    if (flag != BOOT_FLAG_SET) {
 c00739e:	78a3      	ldrb	r3, [r4, #2]
    return BOOT_FLAG_SET;
 c0073a0:	2b01      	cmp	r3, #1
 c0073a2:	bf14      	ite	ne
 c0073a4:	2302      	movne	r3, #2
 c0073a6:	2301      	moveq	r3, #1
 c0073a8:	e7e8      	b.n	c00737c <boot_read_swap_state+0x84>
    if (flag != BOOT_FLAG_SET) {
 c0073aa:	78e3      	ldrb	r3, [r4, #3]
    return BOOT_FLAG_SET;
 c0073ac:	2b01      	cmp	r3, #1
 c0073ae:	bf14      	ite	ne
 c0073b0:	2302      	movne	r3, #2
 c0073b2:	2301      	moveq	r3, #1
 c0073b4:	e7ef      	b.n	c007396 <boot_read_swap_state+0x9e>
 c0073b6:	bf00      	nop
 c0073b8:	0c00a710 	.word	0x0c00a710

0c0073bc <boot_read_swap_state_by_id>:
boot_read_swap_state_by_id(int flash_area_id, struct boot_swap_state *state)
{
    const struct flash_area *fap;
    int rc;

    if (flash_area_id == FLASH_AREA_IMAGE_SCRATCH ||
 c0073bc:	2805      	cmp	r0, #5
{
 c0073be:	b513      	push	{r0, r1, r4, lr}
 c0073c0:	460c      	mov	r4, r1
    if (flash_area_id == FLASH_AREA_IMAGE_SCRATCH ||
 c0073c2:	d009      	beq.n	c0073d8 <boot_read_swap_state_by_id+0x1c>
        flash_area_id == FLASH_AREA_IMAGE_PRIMARY ||
 c0073c4:	4b11      	ldr	r3, [pc, #68]	; (c00740c <boot_read_swap_state_by_id+0x50>)
 c0073c6:	781b      	ldrb	r3, [r3, #0]
 c0073c8:	b1e3      	cbz	r3, c007404 <boot_read_swap_state_by_id+0x48>
 c0073ca:	2b01      	cmp	r3, #1
 c0073cc:	d116      	bne.n	c0073fc <boot_read_swap_state_by_id+0x40>
    if (flash_area_id == FLASH_AREA_IMAGE_SCRATCH ||
 c0073ce:	2802      	cmp	r0, #2
 c0073d0:	d002      	beq.n	c0073d8 <boot_read_swap_state_by_id+0x1c>
        flash_area_id == FLASH_AREA_IMAGE_SECONDARY) {
 c0073d2:	2304      	movs	r3, #4
        flash_area_id == FLASH_AREA_IMAGE_PRIMARY ||
 c0073d4:	4283      	cmp	r3, r0
 c0073d6:	d113      	bne.n	c007400 <boot_read_swap_state_by_id+0x44>
        rc = flash_area_open(flash_area_id, &fap);
 c0073d8:	a901      	add	r1, sp, #4
 c0073da:	b2c0      	uxtb	r0, r0
 c0073dc:	f000 f8ec 	bl	c0075b8 <flash_area_open>
        if (rc != 0) {
 c0073e0:	b950      	cbnz	r0, c0073f8 <boot_read_swap_state_by_id+0x3c>
        }
    } else {
        return BOOT_EBADARGS;
    }

    rc = boot_read_swap_state(fap, state);
 c0073e2:	4621      	mov	r1, r4
 c0073e4:	9801      	ldr	r0, [sp, #4]
 c0073e6:	f7ff ff87 	bl	c0072f8 <boot_read_swap_state>
 c0073ea:	4604      	mov	r4, r0
    flash_area_close(fap);
 c0073ec:	9801      	ldr	r0, [sp, #4]
 c0073ee:	f000 f8fd 	bl	c0075ec <flash_area_close>
    return rc;
}
 c0073f2:	4620      	mov	r0, r4
 c0073f4:	b002      	add	sp, #8
 c0073f6:	bd10      	pop	{r4, pc}
            return BOOT_EFLASH;
 c0073f8:	2401      	movs	r4, #1
 c0073fa:	e7fa      	b.n	c0073f2 <boot_read_swap_state_by_id+0x36>
    if (flash_area_id == FLASH_AREA_IMAGE_SCRATCH ||
 c0073fc:	28ff      	cmp	r0, #255	; 0xff
 c0073fe:	e7ea      	b.n	c0073d6 <boot_read_swap_state_by_id+0x1a>
        return BOOT_EBADARGS;
 c007400:	2407      	movs	r4, #7
 c007402:	e7f6      	b.n	c0073f2 <boot_read_swap_state_by_id+0x36>
    if (flash_area_id == FLASH_AREA_IMAGE_SCRATCH ||
 c007404:	2801      	cmp	r0, #1
 c007406:	d0e7      	beq.n	c0073d8 <boot_read_swap_state_by_id+0x1c>
        flash_area_id == FLASH_AREA_IMAGE_SECONDARY) {
 c007408:	2303      	movs	r3, #3
 c00740a:	e7e3      	b.n	c0073d4 <boot_read_swap_state_by_id+0x18>
 c00740c:	3003277c 	.word	0x3003277c

0c007410 <boot_swap_type>:
    return 0;
}

int
boot_swap_type(void)
{
 c007410:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    struct boot_swap_state primary_slot;
    struct boot_swap_state secondary_slot;
    int rc;
    size_t i;

    rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_PRIMARY, &primary_slot);
 c007414:	4c2f      	ldr	r4, [pc, #188]	; (c0074d4 <boot_swap_type+0xc4>)
 c007416:	7822      	ldrb	r2, [r4, #0]
 c007418:	b15a      	cbz	r2, c007432 <boot_swap_type+0x22>
 c00741a:	2a01      	cmp	r2, #1
 c00741c:	bf0c      	ite	eq
 c00741e:	2002      	moveq	r0, #2
 c007420:	20ff      	movne	r0, #255	; 0xff
 c007422:	4669      	mov	r1, sp
 c007424:	f7ff ffca 	bl	c0073bc <boot_read_swap_state_by_id>
    if (rc) {
 c007428:	b128      	cbz	r0, c007436 <boot_swap_type+0x26>
        return BOOT_SWAP_TYPE_PANIC;
 c00742a:	20ff      	movs	r0, #255	; 0xff
        }
    }

    BOOT_LOG_INF("Swap type: none");
    return BOOT_SWAP_TYPE_NONE;
}
 c00742c:	b004      	add	sp, #16
 c00742e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_PRIMARY, &primary_slot);
 c007432:	2001      	movs	r0, #1
 c007434:	e7f5      	b.n	c007422 <boot_swap_type+0x12>
    rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_SECONDARY,
 c007436:	7823      	ldrb	r3, [r4, #0]
 c007438:	2b00      	cmp	r3, #0
 c00743a:	d035      	beq.n	c0074a8 <boot_swap_type+0x98>
 c00743c:	2b01      	cmp	r3, #1
 c00743e:	bf0c      	ite	eq
 c007440:	2004      	moveq	r0, #4
 c007442:	20ff      	movne	r0, #255	; 0xff
 c007444:	a902      	add	r1, sp, #8
 c007446:	f7ff ffb9 	bl	c0073bc <boot_read_swap_state_by_id>
    if (rc) {
 c00744a:	2800      	cmp	r0, #0
 c00744c:	d1ed      	bne.n	c00742a <boot_swap_type+0x1a>
                table->copy_done_primary_slot == primary_slot.copy_done)) {
 c00744e:	4602      	mov	r2, r0
        if (boot_magic_compatible_check(table->magic_primary_slot,
 c007450:	f89d 6000 	ldrb.w	r6, [sp]
            boot_magic_compatible_check(table->magic_secondary_slot,
 c007454:	f89d 7008 	ldrb.w	r7, [sp, #8]
                table->image_ok_primary_slot == primary_slot.image_ok) &&
 c007458:	f89d 8003 	ldrb.w	r8, [sp, #3]
                table->image_ok_secondary_slot == secondary_slot.image_ok) &&
 c00745c:	f89d 900b 	ldrb.w	r9, [sp, #11]
                table->copy_done_primary_slot == primary_slot.copy_done)) {
 c007460:	f89d a002 	ldrb.w	sl, [sp, #2]
 c007464:	4d1c      	ldr	r5, [pc, #112]	; (c0074d8 <boot_swap_type+0xc8>)
        if (boot_magic_compatible_check(table->magic_primary_slot,
 c007466:	4631      	mov	r1, r6
 c007468:	5ca8      	ldrb	r0, [r5, r2]
 c00746a:	18ac      	adds	r4, r5, r2
 c00746c:	f7ff ff35 	bl	c0072da <boot_magic_compatible_check>
 c007470:	b1f0      	cbz	r0, c0074b0 <boot_swap_type+0xa0>
            boot_magic_compatible_check(table->magic_secondary_slot,
 c007472:	4639      	mov	r1, r7
 c007474:	7860      	ldrb	r0, [r4, #1]
 c007476:	f7ff ff30 	bl	c0072da <boot_magic_compatible_check>
                                        primary_slot.magic) &&
 c00747a:	b1c8      	cbz	r0, c0074b0 <boot_swap_type+0xa0>
            (table->image_ok_primary_slot == BOOT_FLAG_ANY   ||
 c00747c:	78a3      	ldrb	r3, [r4, #2]
                                        secondary_slot.magic) &&
 c00747e:	2b04      	cmp	r3, #4
 c007480:	d001      	beq.n	c007486 <boot_swap_type+0x76>
            (table->image_ok_primary_slot == BOOT_FLAG_ANY   ||
 c007482:	4543      	cmp	r3, r8
 c007484:	d114      	bne.n	c0074b0 <boot_swap_type+0xa0>
            (table->image_ok_secondary_slot == BOOT_FLAG_ANY ||
 c007486:	78e3      	ldrb	r3, [r4, #3]
                table->image_ok_primary_slot == primary_slot.image_ok) &&
 c007488:	2b04      	cmp	r3, #4
 c00748a:	d001      	beq.n	c007490 <boot_swap_type+0x80>
            (table->image_ok_secondary_slot == BOOT_FLAG_ANY ||
 c00748c:	454b      	cmp	r3, r9
 c00748e:	d10f      	bne.n	c0074b0 <boot_swap_type+0xa0>
            (table->copy_done_primary_slot == BOOT_FLAG_ANY  ||
 c007490:	7923      	ldrb	r3, [r4, #4]
                table->image_ok_secondary_slot == secondary_slot.image_ok) &&
 c007492:	2b04      	cmp	r3, #4
 c007494:	d10a      	bne.n	c0074ac <boot_swap_type+0x9c>
            BOOT_LOG_INF("Swap type: %s",
 c007496:	7963      	ldrb	r3, [r4, #5]
 c007498:	2b02      	cmp	r3, #2
 c00749a:	d111      	bne.n	c0074c0 <boot_swap_type+0xb0>
 c00749c:	490f      	ldr	r1, [pc, #60]	; (c0074dc <boot_swap_type+0xcc>)
 c00749e:	4810      	ldr	r0, [pc, #64]	; (c0074e0 <boot_swap_type+0xd0>)
 c0074a0:	f001 f9e2 	bl	c008868 <iprintf>
            return table->swap_type;
 c0074a4:	7960      	ldrb	r0, [r4, #5]
 c0074a6:	e7c1      	b.n	c00742c <boot_swap_type+0x1c>
    rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_SECONDARY,
 c0074a8:	2003      	movs	r0, #3
 c0074aa:	e7cb      	b.n	c007444 <boot_swap_type+0x34>
            (table->copy_done_primary_slot == BOOT_FLAG_ANY  ||
 c0074ac:	4553      	cmp	r3, sl
 c0074ae:	d0f2      	beq.n	c007496 <boot_swap_type+0x86>
 c0074b0:	3206      	adds	r2, #6
    for (i = 0; i < BOOT_SWAP_TABLES_COUNT; i++) {
 c0074b2:	2a12      	cmp	r2, #18
 c0074b4:	d1d7      	bne.n	c007466 <boot_swap_type+0x56>
    BOOT_LOG_INF("Swap type: none");
 c0074b6:	480b      	ldr	r0, [pc, #44]	; (c0074e4 <boot_swap_type+0xd4>)
 c0074b8:	f001 fa4a 	bl	c008950 <puts>
    return BOOT_SWAP_TYPE_NONE;
 c0074bc:	2001      	movs	r0, #1
 c0074be:	e7b5      	b.n	c00742c <boot_swap_type+0x1c>
            BOOT_LOG_INF("Swap type: %s",
 c0074c0:	2b03      	cmp	r3, #3
 c0074c2:	d005      	beq.n	c0074d0 <boot_swap_type+0xc0>
 c0074c4:	4908      	ldr	r1, [pc, #32]	; (c0074e8 <boot_swap_type+0xd8>)
 c0074c6:	4a09      	ldr	r2, [pc, #36]	; (c0074ec <boot_swap_type+0xdc>)
 c0074c8:	2b04      	cmp	r3, #4
 c0074ca:	bf18      	it	ne
 c0074cc:	4611      	movne	r1, r2
 c0074ce:	e7e6      	b.n	c00749e <boot_swap_type+0x8e>
 c0074d0:	4907      	ldr	r1, [pc, #28]	; (c0074f0 <boot_swap_type+0xe0>)
 c0074d2:	e7e4      	b.n	c00749e <boot_swap_type+0x8e>
 c0074d4:	3003277c 	.word	0x3003277c
 c0074d8:	0c00a720 	.word	0x0c00a720
 c0074dc:	0c00a737 	.word	0x0c00a737
 c0074e0:	0c00a755 	.word	0x0c00a755
 c0074e4:	0c00a76b 	.word	0x0c00a76b
 c0074e8:	0c00a74e 	.word	0x0c00a74e
 c0074ec:	0c00a73c 	.word	0x0c00a73c
 c0074f0:	0c00a732 	.word	0x0c00a732

0c0074f4 <boot_is_version_sufficient>:
 */
int
boot_is_version_sufficient(struct image_version *req,
                           struct image_version *ver)
{
    if (ver->iv_major > req->iv_major) {
 c0074f4:	780a      	ldrb	r2, [r1, #0]
 c0074f6:	7803      	ldrb	r3, [r0, #0]
 c0074f8:	429a      	cmp	r2, r3
 c0074fa:	d80c      	bhi.n	c007516 <boot_is_version_sufficient+0x22>
        return 0;
    }
    if (ver->iv_major < req->iv_major) {
 c0074fc:	d30d      	bcc.n	c00751a <boot_is_version_sufficient+0x26>
        return BOOT_EBADVERSION;
    }
    /* The major version numbers are equal. */
    if (ver->iv_minor > req->iv_minor) {
 c0074fe:	784a      	ldrb	r2, [r1, #1]
 c007500:	7843      	ldrb	r3, [r0, #1]
 c007502:	429a      	cmp	r2, r3
 c007504:	d807      	bhi.n	c007516 <boot_is_version_sufficient+0x22>
        return 0;
    }
    if (ver->iv_minor < req->iv_minor) {
 c007506:	d308      	bcc.n	c00751a <boot_is_version_sufficient+0x26>
        return BOOT_EBADVERSION;
    }
    /* The minor version numbers are equal. */
    if (ver->iv_revision < req->iv_revision) {
 c007508:	884b      	ldrh	r3, [r1, #2]
 c00750a:	8840      	ldrh	r0, [r0, #2]
        return BOOT_EBADVERSION;
 c00750c:	4283      	cmp	r3, r0
 c00750e:	bf34      	ite	cc
 c007510:	2009      	movcc	r0, #9
 c007512:	2000      	movcs	r0, #0
 c007514:	4770      	bx	lr
        return BOOT_EBADVERSION;
    }

    return 0;
 c007516:	2000      	movs	r0, #0
 c007518:	4770      	bx	lr
        return BOOT_EBADVERSION;
 c00751a:	2009      	movs	r0, #9
}
 c00751c:	4770      	bx	lr

0c00751e <boot_add_uint32_overflow_check>:
 * @return    True in case of overflow, false otherwise
 */
bool
boot_add_uint32_overflow_check(uint32_t a, uint32_t b)
{
    return (a > UINT32_MAX - b);
 c00751e:	43c9      	mvns	r1, r1
}
 c007520:	4281      	cmp	r1, r0
 c007522:	bf2c      	ite	cs
 c007524:	2000      	movcs	r0, #0
 c007526:	2001      	movcc	r0, #1
 c007528:	4770      	bx	lr

0c00752a <boot_add_uint16_overflow_check>:
 * @return    True in case of overflow, false otherwise
 */
bool
boot_add_uint16_overflow_check(uint16_t a, uint16_t b)
{
    return (a > UINT16_MAX - b);
 c00752a:	f5c1 417f 	rsb	r1, r1, #65280	; 0xff00
 c00752e:	31ff      	adds	r1, #255	; 0xff
}
 c007530:	4288      	cmp	r0, r1
 c007532:	bfd4      	ite	le
 c007534:	2000      	movle	r0, #0
 c007536:	2001      	movgt	r0, #1
 c007538:	4770      	bx	lr
	...

0c00753c <validate_idx>:
    BOOT_LOG_ERR("invalid flash area ID");
    return -1;
}

static int validate_idx(int idx, uint32_t *off, uint32_t *len)
{
 c00753c:	b508      	push	{r3, lr}
    /*
     * This simple layout has uniform slots, so just fill in the
     * right one.
     */

    switch (idx) {
 c00753e:	1e43      	subs	r3, r0, #1
 c007540:	2b04      	cmp	r3, #4
 c007542:	d81e      	bhi.n	c007582 <validate_idx+0x46>
 c007544:	e8df f003 	tbb	[pc, r3]
 c007548:	140b0e03 	.word	0x140b0e03
 c00754c:	17          	.byte	0x17
 c00754d:	00          	.byte	0x00
    case FLASH_AREA_0_ID:
        *off = FLASH_AREA_0_OFFSET;
 c00754e:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
        *len = FLASH_AREA_0_SIZE;
        break;
    case FLASH_AREA_2_ID:
        *off = FLASH_AREA_2_OFFSET;
 c007552:	600b      	str	r3, [r1, #0]
        *len = FLASH_AREA_2_SIZE;
 c007554:	f44f 3310 	mov.w	r3, #147456	; 0x24000
        return -1;
    }

    BOOT_LOG_DBG("area %d: offset=0x%x, length=0x%x, sector size=0x%x",
                 idx, *off, *len, FLASH_AREA_IMAGE_SECTOR_SIZE);
    return 0;
 c007558:	2000      	movs	r0, #0
        *len = FLASH_AREA_SCRATCH_SIZE;
 c00755a:	6013      	str	r3, [r2, #0]
}
 c00755c:	bd08      	pop	{r3, pc}
        *off = FLASH_AREA_2_OFFSET;
 c00755e:	f44f 2394 	mov.w	r3, #303104	; 0x4a000
 c007562:	e7f6      	b.n	c007552 <validate_idx+0x16>
        *off = FLASH_AREA_1_OFFSET;
 c007564:	f44f 3360 	mov.w	r3, #229376	; 0x38000
        *off = FLASH_AREA_3_OFFSET;
 c007568:	600b      	str	r3, [r1, #0]
        *len = FLASH_AREA_3_SIZE;
 c00756a:	f44f 3390 	mov.w	r3, #73728	; 0x12000
 c00756e:	e7f3      	b.n	c007558 <validate_idx+0x1c>
        *off = FLASH_AREA_3_OFFSET;
 c007570:	f44f 23dc 	mov.w	r3, #450560	; 0x6e000
 c007574:	e7f8      	b.n	c007568 <validate_idx+0x2c>
        *off = FLASH_AREA_SCRATCH_OFFSET;
 c007576:	f44f 4350 	mov.w	r3, #53248	; 0xd000
 c00757a:	600b      	str	r3, [r1, #0]
        *len = FLASH_AREA_SCRATCH_SIZE;
 c00757c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 c007580:	e7ea      	b.n	c007558 <validate_idx+0x1c>
        BOOT_LOG_ERR("unknown flash area %d", idx);
 c007582:	4601      	mov	r1, r0
 c007584:	4802      	ldr	r0, [pc, #8]	; (c007590 <validate_idx+0x54>)
 c007586:	f001 f96f 	bl	c008868 <iprintf>
        return -1;
 c00758a:	f04f 30ff 	mov.w	r0, #4294967295
 c00758e:	e7e5      	b.n	c00755c <validate_idx+0x20>
 c007590:	0c00a874 	.word	0x0c00a874

0c007594 <flash_device_base>:
    if (fd_id != FLASH_DEVICE_ID) {
 c007594:	2864      	cmp	r0, #100	; 0x64
{
 c007596:	b508      	push	{r3, lr}
    if (fd_id != FLASH_DEVICE_ID) {
 c007598:	d007      	beq.n	c0075aa <flash_device_base+0x16>
        BOOT_LOG_ERR("invalid flash ID %d; expected %d",
 c00759a:	4601      	mov	r1, r0
 c00759c:	2264      	movs	r2, #100	; 0x64
 c00759e:	4805      	ldr	r0, [pc, #20]	; (c0075b4 <flash_device_base+0x20>)
 c0075a0:	f001 f962 	bl	c008868 <iprintf>
        return -1;
 c0075a4:	f04f 30ff 	mov.w	r0, #4294967295
}
 c0075a8:	bd08      	pop	{r3, pc}
    *ret = FLASH_DEVICE_BASE;
 c0075aa:	f04f 6340 	mov.w	r3, #201326592	; 0xc000000
    return 0;
 c0075ae:	2000      	movs	r0, #0
    *ret = FLASH_DEVICE_BASE;
 c0075b0:	600b      	str	r3, [r1, #0]
    return 0;
 c0075b2:	e7f9      	b.n	c0075a8 <flash_device_base+0x14>
 c0075b4:	0c00a84b 	.word	0x0c00a84b

0c0075b8 <flash_area_open>:
{
 c0075b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    for (i = 0; i < ARRAY_SIZE(part_map); i++) {
 c0075ba:	2400      	movs	r4, #0
 c0075bc:	2614      	movs	r6, #20
        if (id == part_map[i].area.fa_id) {
 c0075be:	4b0a      	ldr	r3, [pc, #40]	; (c0075e8 <flash_area_open+0x30>)
 c0075c0:	fb06 f204 	mul.w	r2, r6, r4
 c0075c4:	189d      	adds	r5, r3, r2
 c0075c6:	792f      	ldrb	r7, [r5, #4]
 c0075c8:	4287      	cmp	r7, r0
 c0075ca:	d005      	beq.n	c0075d8 <flash_area_open+0x20>
    for (i = 0; i < ARRAY_SIZE(part_map); i++) {
 c0075cc:	3401      	adds	r4, #1
 c0075ce:	2c05      	cmp	r4, #5
 c0075d0:	d1f6      	bne.n	c0075c0 <flash_area_open+0x8>
        return -1;
 c0075d2:	f04f 30ff 	mov.w	r0, #4294967295
}
 c0075d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    *area = &part_map[i].area;
 c0075d8:	3204      	adds	r2, #4
 c0075da:	4413      	add	r3, r2
 c0075dc:	600b      	str	r3, [r1, #0]
    part_map[i].ref_count++;
 c0075de:	692b      	ldr	r3, [r5, #16]
    return 0;
 c0075e0:	2000      	movs	r0, #0
    part_map[i].ref_count++;
 c0075e2:	3301      	adds	r3, #1
 c0075e4:	612b      	str	r3, [r5, #16]
    return 0;
 c0075e6:	e7f6      	b.n	c0075d6 <flash_area_open+0x1e>
 c0075e8:	3003003c 	.word	0x3003003c

0c0075ec <flash_area_close>:
    if (!area) {
 c0075ec:	4601      	mov	r1, r0
 c0075ee:	b180      	cbz	r0, c007612 <flash_area_close+0x26>
    if (entry->magic != FLASH_MAP_ENTRY_MAGIC) {
 c0075f0:	f850 2c04 	ldr.w	r2, [r0, #-4]
 c0075f4:	4b07      	ldr	r3, [pc, #28]	; (c007614 <flash_area_close+0x28>)
 c0075f6:	429a      	cmp	r2, r3
 c0075f8:	d003      	beq.n	c007602 <flash_area_close+0x16>
        BOOT_LOG_ERR("invalid area %p (id %u)", area, area->fa_id);
 c0075fa:	7802      	ldrb	r2, [r0, #0]
 c0075fc:	4806      	ldr	r0, [pc, #24]	; (c007618 <flash_area_close+0x2c>)
 c0075fe:	f001 b933 	b.w	c008868 <iprintf>
    if (entry->ref_count == 0) {
 c007602:	68c3      	ldr	r3, [r0, #12]
 c007604:	b91b      	cbnz	r3, c00760e <flash_area_close+0x22>
        BOOT_LOG_ERR("area %u use count underflow", area->fa_id);
 c007606:	7801      	ldrb	r1, [r0, #0]
 c007608:	4804      	ldr	r0, [pc, #16]	; (c00761c <flash_area_close+0x30>)
 c00760a:	f001 b92d 	b.w	c008868 <iprintf>
    entry->ref_count--;
 c00760e:	3b01      	subs	r3, #1
 c007610:	60c3      	str	r3, [r0, #12]
}
 c007612:	4770      	bx	lr
 c007614:	d00dbeef 	.word	0xd00dbeef
 c007618:	0c00a782 	.word	0x0c00a782
 c00761c:	0c00a7a2 	.word	0x0c00a7a2

0c007620 <flash_area_warn_on_open>:
{
 c007620:	b570      	push	{r4, r5, r6, lr}
 c007622:	2400      	movs	r4, #0
 c007624:	4d06      	ldr	r5, [pc, #24]	; (c007640 <flash_area_warn_on_open+0x20>)
            BOOT_LOG_WRN("area %u has %u users",
 c007626:	4e07      	ldr	r6, [pc, #28]	; (c007644 <flash_area_warn_on_open+0x24>)
 c007628:	192b      	adds	r3, r5, r4
        if (entry->ref_count) {
 c00762a:	691a      	ldr	r2, [r3, #16]
 c00762c:	b11a      	cbz	r2, c007636 <flash_area_warn_on_open+0x16>
            BOOT_LOG_WRN("area %u has %u users",
 c00762e:	7919      	ldrb	r1, [r3, #4]
 c007630:	4630      	mov	r0, r6
 c007632:	f001 f919 	bl	c008868 <iprintf>
 c007636:	3414      	adds	r4, #20
    for (i = 0; i < ARRAY_SIZE(part_map); i++) {
 c007638:	2c64      	cmp	r4, #100	; 0x64
 c00763a:	d1f5      	bne.n	c007628 <flash_area_warn_on_open+0x8>
}
 c00763c:	bd70      	pop	{r4, r5, r6, pc}
 c00763e:	bf00      	nop
 c007640:	3003003c 	.word	0x3003003c
 c007644:	0c00a82e 	.word	0x0c00a82e

0c007648 <flash_area_erased_val>:
{
 c007648:	b508      	push	{r3, lr}
    return FLASH_DEV_NAME.GetInfo()->erased_value;
 c00764a:	4b02      	ldr	r3, [pc, #8]	; (c007654 <flash_area_erased_val+0xc>)
 c00764c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 c00764e:	4798      	blx	r3
}
 c007650:	7d00      	ldrb	r0, [r0, #20]
 c007652:	bd08      	pop	{r3, pc}
 c007654:	0c00a054 	.word	0x0c00a054

0c007658 <flash_area_read>:
{
 c007658:	b430      	push	{r4, r5}
 c00765a:	4615      	mov	r5, r2
    return FLASH_DEV_NAME.ReadData(area->fa_off + off, dst, len);
 c00765c:	4a04      	ldr	r2, [pc, #16]	; (c007670 <flash_area_read+0x18>)
 c00765e:	6840      	ldr	r0, [r0, #4]
 c007660:	6954      	ldr	r4, [r2, #20]
 c007662:	4408      	add	r0, r1
 c007664:	461a      	mov	r2, r3
 c007666:	4629      	mov	r1, r5
 c007668:	4623      	mov	r3, r4
}
 c00766a:	bc30      	pop	{r4, r5}
    return FLASH_DEV_NAME.ReadData(area->fa_off + off, dst, len);
 c00766c:	4718      	bx	r3
 c00766e:	bf00      	nop
 c007670:	0c00a054 	.word	0x0c00a054

0c007674 <flash_area_read_is_empty>:
{
 c007674:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c007678:	4614      	mov	r4, r2
 c00767a:	461e      	mov	r6, r3
 c00767c:	4607      	mov	r7, r0
    rc = FLASH_DEV_NAME.ReadData(area->fa_off + off, dst, len);
 c00767e:	4b0d      	ldr	r3, [pc, #52]	; (c0076b4 <flash_area_read_is_empty+0x40>)
 c007680:	6840      	ldr	r0, [r0, #4]
 c007682:	4632      	mov	r2, r6
 c007684:	4408      	add	r0, r1
 c007686:	695b      	ldr	r3, [r3, #20]
 c007688:	4621      	mov	r1, r4
 c00768a:	4798      	blx	r3
    if(rc != 0) {
 c00768c:	4605      	mov	r5, r0
 c00768e:	b970      	cbnz	r0, c0076ae <flash_area_read_is_empty+0x3a>
 c007690:	4426      	add	r6, r4
    for (i = 0; i < len; i++) {
 c007692:	42b4      	cmp	r4, r6
 c007694:	d101      	bne.n	c00769a <flash_area_read_is_empty+0x26>
    return 1;
 c007696:	2501      	movs	r5, #1
 c007698:	e006      	b.n	c0076a8 <flash_area_read_is_empty+0x34>
        if (u8dst[i] != flash_area_erased_val(area)) {
 c00769a:	4638      	mov	r0, r7
 c00769c:	f814 8b01 	ldrb.w	r8, [r4], #1
 c0076a0:	f7ff ffd2 	bl	c007648 <flash_area_erased_val>
 c0076a4:	4580      	cmp	r8, r0
 c0076a6:	d0f4      	beq.n	c007692 <flash_area_read_is_empty+0x1e>
}
 c0076a8:	4628      	mov	r0, r5
 c0076aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return -1;
 c0076ae:	f04f 35ff 	mov.w	r5, #4294967295
 c0076b2:	e7f9      	b.n	c0076a8 <flash_area_read_is_empty+0x34>
 c0076b4:	0c00a054 	.word	0x0c00a054

0c0076b8 <flash_area_write>:
{
 c0076b8:	b430      	push	{r4, r5}
 c0076ba:	4615      	mov	r5, r2
    return FLASH_DEV_NAME.ProgramData(area->fa_off + off, src, len);
 c0076bc:	4a04      	ldr	r2, [pc, #16]	; (c0076d0 <flash_area_write+0x18>)
 c0076be:	6840      	ldr	r0, [r0, #4]
 c0076c0:	6994      	ldr	r4, [r2, #24]
 c0076c2:	4408      	add	r0, r1
 c0076c4:	461a      	mov	r2, r3
 c0076c6:	4629      	mov	r1, r5
 c0076c8:	4623      	mov	r3, r4
}
 c0076ca:	bc30      	pop	{r4, r5}
    return FLASH_DEV_NAME.ProgramData(area->fa_off + off, src, len);
 c0076cc:	4718      	bx	r3
 c0076ce:	bf00      	nop
 c0076d0:	0c00a054 	.word	0x0c00a054

0c0076d4 <flash_area_erase>:
{
 c0076d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    flash_info = FLASH_DEV_NAME.GetInfo();
 c0076d8:	4d0c      	ldr	r5, [pc, #48]	; (c00770c <flash_area_erase+0x38>)
{
 c0076da:	4680      	mov	r8, r0
    flash_info = FLASH_DEV_NAME.GetInfo();
 c0076dc:	6aab      	ldr	r3, [r5, #40]	; 0x28
{
 c0076de:	460e      	mov	r6, r1
 c0076e0:	4617      	mov	r7, r2
    flash_info = FLASH_DEV_NAME.GetInfo();
 c0076e2:	4798      	blx	r3
    if (flash_info->sector_info == NULL) {
 c0076e4:	6804      	ldr	r4, [r0, #0]
    flash_info = FLASH_DEV_NAME.GetInfo();
 c0076e6:	4681      	mov	r9, r0
    if (flash_info->sector_info == NULL) {
 c0076e8:	b16c      	cbz	r4, c007706 <flash_area_erase+0x32>
    int32_t rc = 0;
 c0076ea:	2000      	movs	r0, #0
}
 c0076ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            rc = FLASH_DEV_NAME.EraseSector(area->fa_off + off);
 c0076f0:	f8d8 0004 	ldr.w	r0, [r8, #4]
 c0076f4:	69eb      	ldr	r3, [r5, #28]
 c0076f6:	4430      	add	r0, r6
 c0076f8:	4798      	blx	r3
            if (rc != 0) {
 c0076fa:	2800      	cmp	r0, #0
 c0076fc:	d1f6      	bne.n	c0076ec <flash_area_erase+0x18>
            deleted_len += flash_info->sector_size;
 c0076fe:	f8d9 3008 	ldr.w	r3, [r9, #8]
 c007702:	441c      	add	r4, r3
            off         += flash_info->sector_size;
 c007704:	441e      	add	r6, r3
        while (deleted_len < len) {
 c007706:	42bc      	cmp	r4, r7
 c007708:	d3f2      	bcc.n	c0076f0 <flash_area_erase+0x1c>
 c00770a:	e7ee      	b.n	c0076ea <flash_area_erase+0x16>
 c00770c:	0c00a054 	.word	0x0c00a054

0c007710 <flash_area_align>:
{
 c007710:	b508      	push	{r3, lr}
    flash_info = FLASH_DEV_NAME.GetInfo();
 c007712:	4b02      	ldr	r3, [pc, #8]	; (c00771c <flash_area_align+0xc>)
 c007714:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 c007716:	4798      	blx	r3
}
 c007718:	6900      	ldr	r0, [r0, #16]
 c00771a:	bd08      	pop	{r3, pc}
 c00771c:	0c00a054 	.word	0x0c00a054

0c007720 <flash_area_id_from_image_slot>:
    const int area_id_tab[] = {FLASH_AREA_IMAGE_PRIMARY,
 c007720:	4b10      	ldr	r3, [pc, #64]	; (c007764 <flash_area_id_from_image_slot+0x44>)
{
 c007722:	b084      	sub	sp, #16
    const int area_id_tab[] = {FLASH_AREA_IMAGE_PRIMARY,
 c007724:	781b      	ldrb	r3, [r3, #0]
 c007726:	b1c3      	cbz	r3, c00775a <flash_area_id_from_image_slot+0x3a>
 c007728:	2b01      	cmp	r3, #1
 c00772a:	bf0c      	ite	eq
 c00772c:	2202      	moveq	r2, #2
 c00772e:	22ff      	movne	r2, #255	; 0xff
 c007730:	9201      	str	r2, [sp, #4]
                               FLASH_AREA_IMAGE_SECONDARY,
 c007732:	b1a3      	cbz	r3, c00775e <flash_area_id_from_image_slot+0x3e>
 c007734:	2b01      	cmp	r3, #1
 c007736:	bf0c      	ite	eq
 c007738:	2304      	moveq	r3, #4
 c00773a:	23ff      	movne	r3, #255	; 0xff
    const int area_id_tab[] = {FLASH_AREA_IMAGE_PRIMARY,
 c00773c:	9302      	str	r3, [sp, #8]
 c00773e:	2305      	movs	r3, #5
    if (slot >= 0 && slot < ARRAY_SIZE(area_id_tab)) {
 c007740:	2802      	cmp	r0, #2
    return -1; /* flash_area_open will fail on that */
 c007742:	bf88      	it	hi
 c007744:	f04f 30ff 	movhi.w	r0, #4294967295
    const int area_id_tab[] = {FLASH_AREA_IMAGE_PRIMARY,
 c007748:	9303      	str	r3, [sp, #12]
        return area_id_tab[slot];
 c00774a:	bf9e      	ittt	ls
 c00774c:	ab04      	addls	r3, sp, #16
 c00774e:	eb03 0080 	addls.w	r0, r3, r0, lsl #2
 c007752:	f850 0c0c 	ldrls.w	r0, [r0, #-12]
}
 c007756:	b004      	add	sp, #16
 c007758:	4770      	bx	lr
    const int area_id_tab[] = {FLASH_AREA_IMAGE_PRIMARY,
 c00775a:	2201      	movs	r2, #1
 c00775c:	e7e8      	b.n	c007730 <flash_area_id_from_image_slot+0x10>
                               FLASH_AREA_IMAGE_SECONDARY,
 c00775e:	2303      	movs	r3, #3
 c007760:	e7ec      	b.n	c00773c <flash_area_id_from_image_slot+0x1c>
 c007762:	bf00      	nop
 c007764:	3003277c 	.word	0x3003277c

0c007768 <flash_area_get_sectors>:
 * `ret` with all of the sectors in the area.  `*cnt` will be set to
 * the storage at `ret` and should be set to the final number of
 * sectors in this area.
 */
int flash_area_get_sectors(int idx, uint32_t *cnt, struct flash_sector *ret)
{
 c007768:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c00776a:	460c      	mov	r4, r1
 c00776c:	4617      	mov	r7, r2
    uint32_t off;
    uint32_t len;
    uint32_t max_cnt = *cnt;
 c00776e:	680e      	ldr	r6, [r1, #0]
    uint32_t rem_len;

    if (validate_idx(idx, &off, &len)) {
 c007770:	aa01      	add	r2, sp, #4
 c007772:	4669      	mov	r1, sp
{
 c007774:	4605      	mov	r5, r0
    if (validate_idx(idx, &off, &len)) {
 c007776:	f7ff fee1 	bl	c00753c <validate_idx>
 c00777a:	b9d0      	cbnz	r0, c0077b2 <flash_area_get_sectors+0x4a>
        return -1;
    }

    if (*cnt < 1) {
 c00777c:	6823      	ldr	r3, [r4, #0]
 c00777e:	b1c3      	cbz	r3, c0077b2 <flash_area_get_sectors+0x4a>
        return -1;
    }

    rem_len = len;
 c007780:	9a01      	ldr	r2, [sp, #4]
                         idx, len, FLASH_AREA_IMAGE_SECTOR_SIZE);
            return -1;
        }

        ret[*cnt].fs_off = FLASH_AREA_IMAGE_SECTOR_SIZE * (*cnt);
        ret[*cnt].fs_size = FLASH_AREA_IMAGE_SECTOR_SIZE;
 c007782:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
    rem_len = len;
 c007786:	4611      	mov	r1, r2
    *cnt = 0;
 c007788:	6020      	str	r0, [r4, #0]
 c00778a:	6823      	ldr	r3, [r4, #0]
    while (rem_len > 0 && *cnt < max_cnt) {
 c00778c:	b109      	cbz	r1, c007792 <flash_area_get_sectors+0x2a>
 c00778e:	429e      	cmp	r6, r3
 c007790:	d806      	bhi.n	c0077a0 <flash_area_get_sectors+0x38>
        *cnt = *cnt + 1;
        rem_len -= FLASH_AREA_IMAGE_SECTOR_SIZE;
    }

    if (*cnt > max_cnt) {
 c007792:	429e      	cmp	r6, r3
 c007794:	d20f      	bcs.n	c0077b6 <flash_area_get_sectors+0x4e>
        BOOT_LOG_ERR("flash area %d sector count overflow", idx);
 c007796:	4629      	mov	r1, r5
 c007798:	480f      	ldr	r0, [pc, #60]	; (c0077d8 <flash_area_get_sectors+0x70>)
 c00779a:	f001 f865 	bl	c008868 <iprintf>
 c00779e:	e008      	b.n	c0077b2 <flash_area_get_sectors+0x4a>
        if (rem_len < FLASH_AREA_IMAGE_SECTOR_SIZE) {
 c0077a0:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 c0077a4:	d209      	bcs.n	c0077ba <flash_area_get_sectors+0x52>
            BOOT_LOG_ERR("area %d size 0x%x not divisible by sector size 0x%x",
 c0077a6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 c0077aa:	4629      	mov	r1, r5
 c0077ac:	480b      	ldr	r0, [pc, #44]	; (c0077dc <flash_area_get_sectors+0x74>)
 c0077ae:	f001 f85b 	bl	c008868 <iprintf>
        return -1;
 c0077b2:	f04f 30ff 	mov.w	r0, #4294967295
        return -1;
    }

    return 0;
}
 c0077b6:	b003      	add	sp, #12
 c0077b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ret[*cnt].fs_off = FLASH_AREA_IMAGE_SECTOR_SIZE * (*cnt);
 c0077ba:	ea4f 3e03 	mov.w	lr, r3, lsl #12
 c0077be:	f847 e033 	str.w	lr, [r7, r3, lsl #3]
        ret[*cnt].fs_size = FLASH_AREA_IMAGE_SECTOR_SIZE;
 c0077c2:	6823      	ldr	r3, [r4, #0]
        rem_len -= FLASH_AREA_IMAGE_SECTOR_SIZE;
 c0077c4:	f5a1 5180 	sub.w	r1, r1, #4096	; 0x1000
        ret[*cnt].fs_size = FLASH_AREA_IMAGE_SECTOR_SIZE;
 c0077c8:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
 c0077cc:	f8c3 c004 	str.w	ip, [r3, #4]
        *cnt = *cnt + 1;
 c0077d0:	6823      	ldr	r3, [r4, #0]
 c0077d2:	3301      	adds	r3, #1
 c0077d4:	6023      	str	r3, [r4, #0]
 c0077d6:	e7d8      	b.n	c00778a <flash_area_get_sectors+0x22>
 c0077d8:	0c00a802 	.word	0x0c00a802
 c0077dc:	0c00a7c6 	.word	0x0c00a7c6

0c0077e0 <bootutil_verify_sig>:
}

int
bootutil_verify_sig(uint8_t *hash, uint32_t hlen, uint8_t *sig, size_t slen,
  uint8_t key_id)
{
 c0077e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0077e4:	4616      	mov	r6, r2
    mbedtls_rsa_context ctx;
    int rc;
    uint8_t *cp;
    uint8_t *end;

    mbedtls_rsa_init(&ctx, 0, 0);
 c0077e6:	2200      	movs	r2, #0
{
 c0077e8:	f2ad 5d34 	subw	sp, sp, #1332	; 0x534
 c0077ec:	4680      	mov	r8, r0
 c0077ee:	460f      	mov	r7, r1
    mbedtls_rsa_init(&ctx, 0, 0);
 c0077f0:	a80d      	add	r0, sp, #52	; 0x34
 c0077f2:	4611      	mov	r1, r2
{
 c0077f4:	f89d 9558 	ldrb.w	r9, [sp, #1368]	; 0x558
 c0077f8:	461d      	mov	r5, r3
    mbedtls_rsa_init(&ctx, 0, 0);
 c0077fa:	f7ff fb3d 	bl	c006e78 <mbedtls_rsa_init>

    cp = (uint8_t *)bootutil_keys[key_id].key;
 c0077fe:	4b74      	ldr	r3, [pc, #464]	; (c0079d0 <bootutil_verify_sig+0x1f0>)
    rc = mbedtls_asn1_get_tag(p, end, &len,
 c007800:	aaec      	add	r2, sp, #944	; 0x3b0
    cp = (uint8_t *)bootutil_keys[key_id].key;
 c007802:	f853 4039 	ldr.w	r4, [r3, r9, lsl #3]
    end = cp + *bootutil_keys[key_id].len;
 c007806:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
 c00780a:	685b      	ldr	r3, [r3, #4]
    cp = (uint8_t *)bootutil_keys[key_id].key;
 c00780c:	9403      	str	r4, [sp, #12]
    end = cp + *bootutil_keys[key_id].len;
 c00780e:	681b      	ldr	r3, [r3, #0]
    rc = mbedtls_asn1_get_tag(p, end, &len,
 c007810:	a803      	add	r0, sp, #12
    end = cp + *bootutil_keys[key_id].len;
 c007812:	441c      	add	r4, r3
    rc = mbedtls_asn1_get_tag(p, end, &len,
 c007814:	4621      	mov	r1, r4
 c007816:	2330      	movs	r3, #48	; 0x30
 c007818:	f7fd fe1c 	bl	c005454 <mbedtls_asn1_get_tag>
    if (rc != 0) {
 c00781c:	b110      	cbz	r0, c007824 <bootutil_verify_sig+0x44>
        return -1;
 c00781e:	f04f 34ff 	mov.w	r4, #4294967295
 c007822:	e0c1      	b.n	c0079a8 <bootutil_verify_sig+0x1c8>
    if (*p + len != end) {
 c007824:	9b03      	ldr	r3, [sp, #12]
 c007826:	9aec      	ldr	r2, [sp, #944]	; 0x3b0
 c007828:	4413      	add	r3, r2
 c00782a:	429c      	cmp	r4, r3
 c00782c:	f040 80cd 	bne.w	c0079ca <bootutil_verify_sig+0x1ea>
    rc  = mbedtls_asn1_get_mpi(p, end, &ctx->N);
 c007830:	aa0f      	add	r2, sp, #60	; 0x3c
 c007832:	4621      	mov	r1, r4
 c007834:	a803      	add	r0, sp, #12
 c007836:	f7fd fe21 	bl	c00547c <mbedtls_asn1_get_mpi>
    rc2 = mbedtls_asn1_get_mpi(p, end, &ctx->E);
 c00783a:	f10d 0a48 	add.w	sl, sp, #72	; 0x48
    rc  = mbedtls_asn1_get_mpi(p, end, &ctx->N);
 c00783e:	4683      	mov	fp, r0
    rc2 = mbedtls_asn1_get_mpi(p, end, &ctx->E);
 c007840:	4652      	mov	r2, sl
 c007842:	4621      	mov	r1, r4
 c007844:	a803      	add	r0, sp, #12
 c007846:	f7fd fe19 	bl	c00547c <mbedtls_asn1_get_mpi>
 c00784a:	4681      	mov	r9, r0
    if ((rc != 0) || (rc2 != 0)) {
 c00784c:	f1bb 0f00 	cmp.w	fp, #0
 c007850:	f040 80b8 	bne.w	c0079c4 <bootutil_verify_sig+0x1e4>
 c007854:	2800      	cmp	r0, #0
 c007856:	f040 80b5 	bne.w	c0079c4 <bootutil_verify_sig+0x1e4>
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c00785a:	a80f      	add	r0, sp, #60	; 0x3c
 c00785c:	f7fe f972 	bl	c005b44 <mbedtls_mpi_size>
    if (*p != end) {
 c007860:	9b03      	ldr	r3, [sp, #12]
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c007862:	900e      	str	r0, [sp, #56]	; 0x38
    if (*p != end) {
 c007864:	429c      	cmp	r4, r3
 c007866:	f040 80aa 	bne.w	c0079be <bootutil_verify_sig+0x1de>
    rc = mbedtls_rsa_import(ctx, &ctx->N, NULL, NULL, NULL, &ctx->E);
 c00786a:	e9cd 9a00 	strd	r9, sl, [sp]
 c00786e:	464b      	mov	r3, r9
 c007870:	464a      	mov	r2, r9
 c007872:	a90f      	add	r1, sp, #60	; 0x3c
 c007874:	a80d      	add	r0, sp, #52	; 0x34
 c007876:	f7ff fabb 	bl	c006df0 <mbedtls_rsa_import>
    if (rc != 0) {
 c00787a:	2800      	cmp	r0, #0
 c00787c:	f040 809c 	bne.w	c0079b8 <bootutil_verify_sig+0x1d8>
    rc = mbedtls_rsa_check_pubkey(ctx);
 c007880:	a80d      	add	r0, sp, #52	; 0x34
 c007882:	f7ff fb03 	bl	c006e8c <mbedtls_rsa_check_pubkey>
    if (rc != 0) {
 c007886:	4604      	mov	r4, r0
 c007888:	2800      	cmp	r0, #0
 c00788a:	f040 808b 	bne.w	c0079a4 <bootutil_verify_sig+0x1c4>
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c00788e:	a80f      	add	r0, sp, #60	; 0x3c
 c007890:	f7fe f958 	bl	c005b44 <mbedtls_mpi_size>

    rc = bootutil_parse_rsakey(&ctx, &cp, end);
    if (rc || slen != ctx.len) {
 c007894:	4285      	cmp	r5, r0
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c007896:	900e      	str	r0, [sp, #56]	; 0x38
    if (rc || slen != ctx.len) {
 c007898:	f040 8086 	bne.w	c0079a8 <bootutil_verify_sig+0x1c8>
    if (ctx->len != PSS_EMLEN || PSS_EMLEN > MBEDTLS_MPI_MAX_SIZE) {
 c00789c:	f5b5 7fc0 	cmp.w	r5, #384	; 0x180
 c0078a0:	d1bd      	bne.n	c00781e <bootutil_verify_sig+0x3e>
    if (hlen != PSS_HLEN) {
 c0078a2:	2f20      	cmp	r7, #32
 c0078a4:	d1bb      	bne.n	c00781e <bootutil_verify_sig+0x3e>
    if (mbedtls_rsa_public(ctx, sig, em)) {
 c0078a6:	f50d 796c 	add.w	r9, sp, #944	; 0x3b0
 c0078aa:	464a      	mov	r2, r9
 c0078ac:	4631      	mov	r1, r6
 c0078ae:	a80d      	add	r0, sp, #52	; 0x34
 c0078b0:	f7ff fb10 	bl	c006ed4 <mbedtls_rsa_public>
 c0078b4:	4605      	mov	r5, r0
 c0078b6:	2800      	cmp	r0, #0
 c0078b8:	d1b1      	bne.n	c00781e <bootutil_verify_sig+0x3e>
    if (em[PSS_EMLEN - 1] != 0xbc) {
 c0078ba:	f899 317f 	ldrb.w	r3, [r9, #383]	; 0x17f
 c0078be:	2bbc      	cmp	r3, #188	; 0xbc
 c0078c0:	d1ad      	bne.n	c00781e <bootutil_verify_sig+0x3e>
    uint8_t counter[4] = { 0, 0, 0, 0 };
 c0078c2:	af38      	add	r7, sp, #224	; 0xe0
    int count = PSS_MASK_LEN;
 c0078c4:	f240 165f 	movw	r6, #351	; 0x15f
 c0078c8:	463c      	mov	r4, r7
    uint8_t counter[4] = { 0, 0, 0, 0 };
 c0078ca:	9004      	str	r0, [sp, #16]
    mbedtls_sha256_init(ctx);
 c0078cc:	a890      	add	r0, sp, #576	; 0x240
 c0078ce:	f7fa f8f5 	bl	c001abc <mbedtls_sha256_init>
    mbedtls_sha256_starts(ctx, 0);
 c0078d2:	2100      	movs	r1, #0
 c0078d4:	a890      	add	r0, sp, #576	; 0x240
 c0078d6:	f7fa f9a0 	bl	c001c1a <mbedtls_sha256_starts>
    mbedtls_sha256_update(ctx, data, data_len);
 c0078da:	2220      	movs	r2, #32
 c0078dc:	f20d 510f 	addw	r1, sp, #1295	; 0x50f
 c0078e0:	a890      	add	r0, sp, #576	; 0x240
 c0078e2:	f7fa f99c 	bl	c001c1e <mbedtls_sha256_update>
 c0078e6:	2204      	movs	r2, #4
 c0078e8:	a904      	add	r1, sp, #16
 c0078ea:	a890      	add	r0, sp, #576	; 0x240
 c0078ec:	f7fa f997 	bl	c001c1e <mbedtls_sha256_update>
    mbedtls_sha256_finish(ctx, output);
 c0078f0:	a905      	add	r1, sp, #20
 c0078f2:	a890      	add	r0, sp, #576	; 0x240
 c0078f4:	f7fa f995 	bl	c001c22 <mbedtls_sha256_finish>
        if (bytes > count)
 c0078f8:	2e1f      	cmp	r6, #31
 c0078fa:	bfd4      	ite	le
 c0078fc:	46b2      	movle	sl, r6
 c0078fe:	f04f 0a20 	movgt.w	sl, #32
        counter[3]++;
 c007902:	f89d 3013 	ldrb.w	r3, [sp, #19]
        memcpy(mask, htmp, bytes);
 c007906:	4638      	mov	r0, r7
        counter[3]++;
 c007908:	3301      	adds	r3, #1
        memcpy(mask, htmp, bytes);
 c00790a:	4652      	mov	r2, sl
 c00790c:	a905      	add	r1, sp, #20
        count -= bytes;
 c00790e:	eba6 060a 	sub.w	r6, r6, sl
        counter[3]++;
 c007912:	f88d 3013 	strb.w	r3, [sp, #19]
        memcpy(mask, htmp, bytes);
 c007916:	f000 fedd 	bl	c0086d4 <memcpy>
    while (count > 0) {
 c00791a:	2e00      	cmp	r6, #0
        mask += bytes;
 c00791c:	4457      	add	r7, sl
    while (count > 0) {
 c00791e:	dcd5      	bgt.n	c0078cc <bootutil_verify_sig+0xec>
    for (i = 0; i < PSS_MASK_LEN; i++) {
 c007920:	2300      	movs	r3, #0
 c007922:	f240 115f 	movw	r1, #351	; 0x15f
        db_mask[i] ^= em[i];
 c007926:	5ce2      	ldrb	r2, [r4, r3]
 c007928:	f819 0003 	ldrb.w	r0, [r9, r3]
 c00792c:	4042      	eors	r2, r0
 c00792e:	54e2      	strb	r2, [r4, r3]
    for (i = 0; i < PSS_MASK_LEN; i++) {
 c007930:	3301      	adds	r3, #1
 c007932:	428b      	cmp	r3, r1
 c007934:	d1f7      	bne.n	c007926 <bootutil_verify_sig+0x146>
    db_mask[0] &= 0x7F;
 c007936:	7823      	ldrb	r3, [r4, #0]
 c007938:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 c00793c:	7023      	strb	r3, [r4, #0]
        if (db_mask[i] != 0) {
 c00793e:	5d66      	ldrb	r6, [r4, r5]
 c007940:	2e00      	cmp	r6, #0
 c007942:	f47f af6c 	bne.w	c00781e <bootutil_verify_sig+0x3e>
    for (i = 0; i < PSS_MASK_ZERO_COUNT; i++) {
 c007946:	3501      	adds	r5, #1
 c007948:	f5b5 7f9f 	cmp.w	r5, #318	; 0x13e
 c00794c:	d1f7      	bne.n	c00793e <bootutil_verify_sig+0x15e>
    if (db_mask[PSS_MASK_ONE_POS] != 1) {
 c00794e:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 c007952:	2b01      	cmp	r3, #1
 c007954:	f47f af63 	bne.w	c00781e <bootutil_verify_sig+0x3e>
    mbedtls_sha256_init(ctx);
 c007958:	a890      	add	r0, sp, #576	; 0x240
 c00795a:	f7fa f8af 	bl	c001abc <mbedtls_sha256_init>
    mbedtls_sha256_starts(ctx, 0);
 c00795e:	4631      	mov	r1, r6
 c007960:	a890      	add	r0, sp, #576	; 0x240
 c007962:	f7fa f95a 	bl	c001c1a <mbedtls_sha256_starts>
    mbedtls_sha256_update(ctx, data, data_len);
 c007966:	2208      	movs	r2, #8
 c007968:	491a      	ldr	r1, [pc, #104]	; (c0079d4 <bootutil_verify_sig+0x1f4>)
 c00796a:	a890      	add	r0, sp, #576	; 0x240
 c00796c:	f7fa f957 	bl	c001c1e <mbedtls_sha256_update>
 c007970:	2220      	movs	r2, #32
 c007972:	4641      	mov	r1, r8
 c007974:	a890      	add	r0, sp, #576	; 0x240
 c007976:	f7fa f952 	bl	c001c1e <mbedtls_sha256_update>
 c00797a:	2220      	movs	r2, #32
 c00797c:	f20d 211f 	addw	r1, sp, #543	; 0x21f
 c007980:	a890      	add	r0, sp, #576	; 0x240
 c007982:	f7fa f94c 	bl	c001c1e <mbedtls_sha256_update>
    mbedtls_sha256_finish(ctx, output);
 c007986:	a905      	add	r1, sp, #20
 c007988:	a890      	add	r0, sp, #576	; 0x240
 c00798a:	f7fa f94a 	bl	c001c22 <mbedtls_sha256_finish>
    if (boot_secure_memequal(h2, &em[PSS_HASH_OFFSET], PSS_HLEN) != 0) {
 c00798e:	2220      	movs	r2, #32
 c007990:	f20d 510f 	addw	r1, sp, #1295	; 0x50f
 c007994:	a805      	add	r0, sp, #20
 c007996:	f7ff fc93 	bl	c0072c0 <boot_secure_memequal>
 c00799a:	3000      	adds	r0, #0
 c00799c:	bf18      	it	ne
 c00799e:	2001      	movne	r0, #1
 c0079a0:	4244      	negs	r4, r0
 c0079a2:	e001      	b.n	c0079a8 <bootutil_verify_sig+0x1c8>
        return -6;
 c0079a4:	f06f 0405 	mvn.w	r4, #5
        mbedtls_rsa_free(&ctx);
        return rc;
    }
    rc = bootutil_cmp_rsasig(&ctx, hash, hlen, sig);
    mbedtls_rsa_free(&ctx);
 c0079a8:	a80d      	add	r0, sp, #52	; 0x34
 c0079aa:	f7ff fad1 	bl	c006f50 <mbedtls_rsa_free>

    return rc;
}
 c0079ae:	4620      	mov	r0, r4
 c0079b0:	f20d 5d34 	addw	sp, sp, #1332	; 0x534
 c0079b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return -5;
 c0079b8:	f06f 0404 	mvn.w	r4, #4
 c0079bc:	e7f4      	b.n	c0079a8 <bootutil_verify_sig+0x1c8>
        return -4;
 c0079be:	f06f 0403 	mvn.w	r4, #3
 c0079c2:	e7f1      	b.n	c0079a8 <bootutil_verify_sig+0x1c8>
        return -3;
 c0079c4:	f06f 0402 	mvn.w	r4, #2
 c0079c8:	e7ee      	b.n	c0079a8 <bootutil_verify_sig+0x1c8>
        return -2;
 c0079ca:	f06f 0401 	mvn.w	r4, #1
 c0079ce:	e7eb      	b.n	c0079a8 <bootutil_verify_sig+0x1c8>
 c0079d0:	0c00a8a0 	.word	0x0c00a8a0
 c0079d4:	0c00a892 	.word	0x0c00a892

0c0079d8 <bootutil_get_img_security_cnt>:
 */
int32_t
bootutil_get_img_security_cnt(struct image_header *hdr,
                              const struct flash_area *fap,
                              uint32_t *img_security_cnt)
{
 c0079d8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c0079da:	460d      	mov	r5, r1
 c0079dc:	4617      	mov	r7, r2
    uint32_t off;
    uint32_t end;
    uint32_t found = 0;
    int32_t rc;

    if ((hdr == NULL) ||
 c0079de:	4606      	mov	r6, r0
 c0079e0:	2800      	cmp	r0, #0
 c0079e2:	d044      	beq.n	c007a6e <bootutil_get_img_security_cnt+0x96>
 c0079e4:	2900      	cmp	r1, #0
 c0079e6:	d042      	beq.n	c007a6e <bootutil_get_img_security_cnt+0x96>
        (fap == NULL) ||
 c0079e8:	2a00      	cmp	r2, #0
 c0079ea:	d040      	beq.n	c007a6e <bootutil_get_img_security_cnt+0x96>
        /* Invalid parameter. */
        return BOOT_EBADARGS;
    }

    /* The TLVs come after the image. */
    off = hdr->ih_hdr_size + hdr->ih_img_size;
 c0079ec:	68c3      	ldr	r3, [r0, #12]
 c0079ee:	8904      	ldrh	r4, [r0, #8]

    /* The TLV area always starts with an image_tlv_info structure. */
    rc = LOAD_IMAGE_DATA(fap, off, &info, sizeof(info));
 c0079f0:	466a      	mov	r2, sp
    off = hdr->ih_hdr_size + hdr->ih_img_size;
 c0079f2:	441c      	add	r4, r3
    rc = LOAD_IMAGE_DATA(fap, off, &info, sizeof(info));
 c0079f4:	4621      	mov	r1, r4
 c0079f6:	2304      	movs	r3, #4
 c0079f8:	4628      	mov	r0, r5
 c0079fa:	f7ff fe2d 	bl	c007658 <flash_area_read>
    if (rc != 0) {
 c0079fe:	b110      	cbz	r0, c007a06 <bootutil_get_img_security_cnt+0x2e>
        return BOOT_EFLASH;
 c007a00:	2001      	movs	r0, #1
    if (found) {
        return 0;
    }

    return -1;
}
 c007a02:	b003      	add	sp, #12
 c007a04:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (info.it_magic != IMAGE_TLV_INFO_MAGIC) {
 c007a06:	f646 1307 	movw	r3, #26887	; 0x6907
 c007a0a:	f8bd 2000 	ldrh.w	r2, [sp]
 c007a0e:	429a      	cmp	r2, r3
 c007a10:	d12f      	bne.n	c007a72 <bootutil_get_img_security_cnt+0x9a>
    if (hdr->ih_protect_tlv_size != 0) {
 c007a12:	8976      	ldrh	r6, [r6, #10]
 c007a14:	b916      	cbnz	r6, c007a1c <bootutil_get_img_security_cnt+0x44>
    return -1;
 c007a16:	f04f 30ff 	mov.w	r0, #4294967295
 c007a1a:	e7f2      	b.n	c007a02 <bootutil_get_img_security_cnt+0x2a>
        end = off + (uint32_t)hdr->ih_protect_tlv_size;
 c007a1c:	4426      	add	r6, r4
        off += sizeof(info);
 c007a1e:	3404      	adds	r4, #4
        while (off < end) {
 c007a20:	42b4      	cmp	r4, r6
 c007a22:	d2f8      	bcs.n	c007a16 <bootutil_get_img_security_cnt+0x3e>
            rc = LOAD_IMAGE_DATA(fap, off, &tlv, sizeof(tlv));
 c007a24:	2304      	movs	r3, #4
 c007a26:	4621      	mov	r1, r4
 c007a28:	eb0d 0203 	add.w	r2, sp, r3
 c007a2c:	4628      	mov	r0, r5
 c007a2e:	f7ff fe13 	bl	c007658 <flash_area_read>
            if (rc != 0) {
 c007a32:	2800      	cmp	r0, #0
 c007a34:	d1e4      	bne.n	c007a00 <bootutil_get_img_security_cnt+0x28>
            if (tlv.it_type == IMAGE_TLV_SEC_CNT) {
 c007a36:	f89d 2004 	ldrb.w	r2, [sp, #4]
 c007a3a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 c007a3e:	2a50      	cmp	r2, #80	; 0x50
 c007a40:	d10a      	bne.n	c007a58 <bootutil_get_img_security_cnt+0x80>
                if (tlv.it_len != sizeof(*img_security_cnt)) {
 c007a42:	2b04      	cmp	r3, #4
 c007a44:	d1e7      	bne.n	c007a16 <bootutil_get_img_security_cnt+0x3e>
                rc = LOAD_IMAGE_DATA(fap, off + sizeof(tlv),
 c007a46:	463a      	mov	r2, r7
 c007a48:	1d21      	adds	r1, r4, #4
 c007a4a:	4628      	mov	r0, r5
 c007a4c:	f7ff fe04 	bl	c007658 <flash_area_read>
                if (rc != 0) {
 c007a50:	3000      	adds	r0, #0
 c007a52:	bf18      	it	ne
 c007a54:	2001      	movne	r0, #1
 c007a56:	e7d4      	b.n	c007a02 <bootutil_get_img_security_cnt+0x2a>
            if (boot_add_uint32_overflow_check(off, (sizeof(tlv) + tlv.it_len)))
 c007a58:	1d19      	adds	r1, r3, #4
 c007a5a:	4620      	mov	r0, r4
 c007a5c:	f7ff fd5f 	bl	c00751e <boot_add_uint32_overflow_check>
 c007a60:	2800      	cmp	r0, #0
 c007a62:	d1d8      	bne.n	c007a16 <bootutil_get_img_security_cnt+0x3e>
                off += sizeof(tlv) + tlv.it_len;
 c007a64:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 c007a68:	3304      	adds	r3, #4
 c007a6a:	441c      	add	r4, r3
 c007a6c:	e7d8      	b.n	c007a20 <bootutil_get_img_security_cnt+0x48>
        return BOOT_EBADARGS;
 c007a6e:	2007      	movs	r0, #7
 c007a70:	e7c7      	b.n	c007a02 <bootutil_get_img_security_cnt+0x2a>
        return BOOT_EBADMAGIC;
 c007a72:	2008      	movs	r0, #8
 c007a74:	e7c5      	b.n	c007a02 <bootutil_get_img_security_cnt+0x2a>
	...

0c007a78 <bootutil_img_validate>:
 */
int
bootutil_img_validate(struct image_header *hdr, const struct flash_area *fap,
                      uint8_t *tmp_buf, uint32_t tmp_buf_sz,
                      uint8_t *seed, int seed_len, uint8_t *out_hash)
{
 c007a78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c007a7c:	4692      	mov	sl, r2
    uint8_t key_buf[SIG_BUF_SIZE + 24];
#endif
#endif
    struct image_tlv tlv;
    uint8_t buf[SIG_BUF_SIZE];
    uint8_t hash[32] = {0};
 c007a7e:	2220      	movs	r2, #32
{
 c007a80:	f5ad 7d55 	sub.w	sp, sp, #852	; 0x354
 c007a84:	4606      	mov	r6, r0
 c007a86:	4688      	mov	r8, r1
    uint8_t hash[32] = {0};
 c007a88:	eb0d 0002 	add.w	r0, sp, r2
 c007a8c:	2100      	movs	r1, #0
{
 c007a8e:	469b      	mov	fp, r3
 c007a90:	9dde      	ldr	r5, [sp, #888]	; 0x378
 c007a92:	9fdf      	ldr	r7, [sp, #892]	; 0x37c
 c007a94:	9ce0      	ldr	r4, [sp, #896]	; 0x380
    uint8_t hash[32] = {0};
 c007a96:	f000 fe28 	bl	c0086ea <memset>
    mbedtls_sha256_init(ctx);
 c007a9a:	a874      	add	r0, sp, #464	; 0x1d0
 c007a9c:	f7fa f80e 	bl	c001abc <mbedtls_sha256_init>
    mbedtls_sha256_starts(ctx, 0);
 c007aa0:	2100      	movs	r1, #0
 c007aa2:	a874      	add	r0, sp, #464	; 0x1d0
 c007aa4:	f7fa f8b9 	bl	c001c1a <mbedtls_sha256_starts>
    if (seed && (seed_len > 0)) {
 c007aa8:	b135      	cbz	r5, c007ab8 <bootutil_img_validate+0x40>
 c007aaa:	2f00      	cmp	r7, #0
 c007aac:	dd04      	ble.n	c007ab8 <bootutil_img_validate+0x40>
    mbedtls_sha256_update(ctx, data, data_len);
 c007aae:	463a      	mov	r2, r7
 c007ab0:	4629      	mov	r1, r5
 c007ab2:	a874      	add	r0, sp, #464	; 0x1d0
 c007ab4:	f7fa f8b3 	bl	c001c1e <mbedtls_sha256_update>
    size = hdr->ih_img_size + hdr->ih_hdr_size;
 c007ab8:	68f3      	ldr	r3, [r6, #12]
 c007aba:	8935      	ldrh	r5, [r6, #8]
 c007abc:	441d      	add	r5, r3
    if (hdr->ih_protect_tlv_size != 0) {
 c007abe:	8973      	ldrh	r3, [r6, #10]
 c007ac0:	b103      	cbz	r3, c007ac4 <bootutil_img_validate+0x4c>
        size += hdr->ih_protect_tlv_size;
 c007ac2:	441d      	add	r5, r3
    for (off = 0; off < size; off += blk_sz) {
 c007ac4:	2700      	movs	r7, #0
 c007ac6:	42bd      	cmp	r5, r7
 c007ac8:	d822      	bhi.n	c007b10 <bootutil_img_validate+0x98>
    mbedtls_sha256_finish(ctx, output);
 c007aca:	a908      	add	r1, sp, #32
 c007acc:	a874      	add	r0, sp, #464	; 0x1d0
 c007ace:	f7fa f8a8 	bl	c001c22 <mbedtls_sha256_finish>
                           seed, seed_len);
    if (rc) {
        return rc;
    }

    if (out_hash) {
 c007ad2:	bb8c      	cbnz	r4, c007b38 <bootutil_img_validate+0xc0>
        memcpy(out_hash, hash, 32);
    }

    /* The TLVs come after the image. */
    off = hdr->ih_img_size + hdr->ih_hdr_size;
 c007ad4:	68f3      	ldr	r3, [r6, #12]
 c007ad6:	8935      	ldrh	r5, [r6, #8]

    rc = LOAD_IMAGE_DATA(fap, off, &info, sizeof(info));
 c007ad8:	aa04      	add	r2, sp, #16
    off = hdr->ih_img_size + hdr->ih_hdr_size;
 c007ada:	441d      	add	r5, r3
    rc = LOAD_IMAGE_DATA(fap, off, &info, sizeof(info));
 c007adc:	4629      	mov	r1, r5
 c007ade:	2304      	movs	r3, #4
 c007ae0:	4640      	mov	r0, r8
 c007ae2:	f7ff fdb9 	bl	c007658 <flash_area_read>
    if (rc) {
 c007ae6:	b978      	cbnz	r0, c007b08 <bootutil_img_validate+0x90>
        return rc;
    }
    if (info.it_magic != IMAGE_TLV_INFO_MAGIC) {
 c007ae8:	f646 1307 	movw	r3, #26887	; 0x6907
 c007aec:	f8bd 2010 	ldrh.w	r2, [sp, #16]
 c007af0:	429a      	cmp	r2, r3
 c007af2:	f040 80f0 	bne.w	c007cd6 <bootutil_img_validate+0x25e>
        return BOOT_EBADMAGIC;
    }
    if (boot_add_uint32_overflow_check(off, (info.it_tlv_tot + sizeof(info)))) {
 c007af6:	f8bd 1012 	ldrh.w	r1, [sp, #18]
 c007afa:	4628      	mov	r0, r5
 c007afc:	3104      	adds	r1, #4
 c007afe:	f7ff fd0e 	bl	c00751e <boot_add_uint32_overflow_check>
 c007b02:	b330      	cbz	r0, c007b52 <bootutil_img_validate+0xda>
        return -1;
 c007b04:	f04f 30ff 	mov.w	r0, #4294967295
        return -1;
    }
#endif

    return 0;
}
 c007b08:	f50d 7d55 	add.w	sp, sp, #852	; 0x354
 c007b0c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        blk_sz = size - off;
 c007b10:	eba5 0907 	sub.w	r9, r5, r7
 c007b14:	45d9      	cmp	r9, fp
 c007b16:	bf28      	it	cs
 c007b18:	46d9      	movcs	r9, fp
        if(flash_area_read(fap, off, tmp_buf, blk_sz)) {
 c007b1a:	4652      	mov	r2, sl
 c007b1c:	464b      	mov	r3, r9
 c007b1e:	4639      	mov	r1, r7
 c007b20:	4640      	mov	r0, r8
 c007b22:	f7ff fd99 	bl	c007658 <flash_area_read>
 c007b26:	2800      	cmp	r0, #0
 c007b28:	d1ec      	bne.n	c007b04 <bootutil_img_validate+0x8c>
    mbedtls_sha256_update(ctx, data, data_len);
 c007b2a:	464a      	mov	r2, r9
 c007b2c:	4651      	mov	r1, sl
 c007b2e:	a874      	add	r0, sp, #464	; 0x1d0
 c007b30:	f7fa f875 	bl	c001c1e <mbedtls_sha256_update>
    for (off = 0; off < size; off += blk_sz) {
 c007b34:	444f      	add	r7, r9
 c007b36:	e7c6      	b.n	c007ac6 <bootutil_img_validate+0x4e>
        memcpy(out_hash, hash, 32);
 c007b38:	4623      	mov	r3, r4
 c007b3a:	ad08      	add	r5, sp, #32
 c007b3c:	ac10      	add	r4, sp, #64	; 0x40
 c007b3e:	462a      	mov	r2, r5
 c007b40:	ca03      	ldmia	r2!, {r0, r1}
 c007b42:	42a2      	cmp	r2, r4
 c007b44:	6018      	str	r0, [r3, #0]
 c007b46:	6059      	str	r1, [r3, #4]
 c007b48:	4615      	mov	r5, r2
 c007b4a:	f103 0308 	add.w	r3, r3, #8
 c007b4e:	d1f6      	bne.n	c007b3e <bootutil_img_validate+0xc6>
 c007b50:	e7c0      	b.n	c007ad4 <bootutil_img_validate+0x5c>
    int valid_signature = 0;
 c007b52:	4606      	mov	r6, r0
    int sha256_valid = 0;
 c007b54:	4682      	mov	sl, r0
    int32_t security_counter_valid = 0;
 c007b56:	4681      	mov	r9, r0
    int key_id = -1;
 c007b58:	f04f 34ff 	mov.w	r4, #4294967295
    end = off + info.it_tlv_tot;
 c007b5c:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    bootutil_sha256_update(&sha256_ctx, key->key, *key->len);
 c007b60:	f8df b180 	ldr.w	fp, [pc, #384]	; c007ce4 <bootutil_img_validate+0x26c>
    end = off + info.it_tlv_tot;
 c007b64:	442b      	add	r3, r5
 c007b66:	9303      	str	r3, [sp, #12]
    off += sizeof(info);
 c007b68:	3504      	adds	r5, #4
    while (off < end) {
 c007b6a:	9b03      	ldr	r3, [sp, #12]
 c007b6c:	429d      	cmp	r5, r3
 c007b6e:	d30a      	bcc.n	c007b86 <bootutil_img_validate+0x10e>
    if (!sha256_valid || !security_counter_valid) {
 c007b70:	f1ba 0f00 	cmp.w	sl, #0
 c007b74:	d0c6      	beq.n	c007b04 <bootutil_img_validate+0x8c>
 c007b76:	f1b9 0f00 	cmp.w	r9, #0
 c007b7a:	d0c3      	beq.n	c007b04 <bootutil_img_validate+0x8c>
    if (!valid_signature) {
 c007b7c:	fab6 f086 	clz	r0, r6
 c007b80:	0940      	lsrs	r0, r0, #5
 c007b82:	4240      	negs	r0, r0
 c007b84:	e7c0      	b.n	c007b08 <bootutil_img_validate+0x90>
        rc = LOAD_IMAGE_DATA(fap, off, &tlv, sizeof(tlv));
 c007b86:	2304      	movs	r3, #4
 c007b88:	aa05      	add	r2, sp, #20
 c007b8a:	4629      	mov	r1, r5
 c007b8c:	4640      	mov	r0, r8
 c007b8e:	f7ff fd63 	bl	c007658 <flash_area_read>
        if (rc) {
 c007b92:	2800      	cmp	r0, #0
 c007b94:	d1b8      	bne.n	c007b08 <bootutil_img_validate+0x90>
        if (tlv.it_type == IMAGE_TLV_SHA256) {
 c007b96:	f89d 3014 	ldrb.w	r3, [sp, #20]
 c007b9a:	f8bd 7016 	ldrh.w	r7, [sp, #22]
 c007b9e:	2b10      	cmp	r3, #16
 c007ba0:	d11f      	bne.n	c007be2 <bootutil_img_validate+0x16a>
            if (tlv.it_len != sizeof(hash)) {
 c007ba2:	2f20      	cmp	r7, #32
 c007ba4:	d1ae      	bne.n	c007b04 <bootutil_img_validate+0x8c>
            rc = LOAD_IMAGE_DATA(fap, off + sizeof(tlv), buf, sizeof(hash));
 c007ba6:	463b      	mov	r3, r7
 c007ba8:	aa74      	add	r2, sp, #464	; 0x1d0
 c007baa:	1d29      	adds	r1, r5, #4
 c007bac:	4640      	mov	r0, r8
 c007bae:	f7ff fd53 	bl	c007658 <flash_area_read>
            if (rc) {
 c007bb2:	2800      	cmp	r0, #0
 c007bb4:	d1a8      	bne.n	c007b08 <bootutil_img_validate+0x90>
            if (boot_secure_memequal(hash, buf, sizeof(hash))) {
 c007bb6:	463a      	mov	r2, r7
 c007bb8:	a974      	add	r1, sp, #464	; 0x1d0
 c007bba:	a808      	add	r0, sp, #32
 c007bbc:	f7ff fb80 	bl	c0072c0 <boot_secure_memequal>
 c007bc0:	2800      	cmp	r0, #0
 c007bc2:	d19f      	bne.n	c007b04 <bootutil_img_validate+0x8c>
            sha256_valid = 1;
 c007bc4:	f04f 0a01 	mov.w	sl, #1
        if (boot_add_uint32_overflow_check(off, (sizeof(tlv) + tlv.it_len))) {
 c007bc8:	f8bd 1016 	ldrh.w	r1, [sp, #22]
 c007bcc:	4628      	mov	r0, r5
 c007bce:	3104      	adds	r1, #4
 c007bd0:	f7ff fca5 	bl	c00751e <boot_add_uint32_overflow_check>
 c007bd4:	2800      	cmp	r0, #0
 c007bd6:	d1cb      	bne.n	c007b70 <bootutil_img_validate+0xf8>
            off += sizeof(tlv) + tlv.it_len;
 c007bd8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 c007bdc:	3304      	adds	r3, #4
 c007bde:	441d      	add	r5, r3
 c007be0:	e7c3      	b.n	c007b6a <bootutil_img_validate+0xf2>
        } else if (tlv.it_type == IMAGE_TLV_KEYHASH) {
 c007be2:	2b01      	cmp	r3, #1
 c007be4:	d12e      	bne.n	c007c44 <bootutil_img_validate+0x1cc>
            if (tlv.it_len > 32) {
 c007be6:	2f20      	cmp	r7, #32
 c007be8:	d88c      	bhi.n	c007b04 <bootutil_img_validate+0x8c>
            rc = LOAD_IMAGE_DATA(fap, off + sizeof(tlv), buf, tlv.it_len);
 c007bea:	463b      	mov	r3, r7
 c007bec:	aa74      	add	r2, sp, #464	; 0x1d0
 c007bee:	1d29      	adds	r1, r5, #4
 c007bf0:	4640      	mov	r0, r8
 c007bf2:	f7ff fd31 	bl	c007658 <flash_area_read>
            if (rc) {
 c007bf6:	2800      	cmp	r0, #0
 c007bf8:	d186      	bne.n	c007b08 <bootutil_img_validate+0x90>
    uint32_t key_id = current_image > 2 ? current_image -2 : current_image;
 c007bfa:	4b38      	ldr	r3, [pc, #224]	; (c007cdc <bootutil_img_validate+0x264>)
    mbedtls_sha256_init(ctx);
 c007bfc:	a818      	add	r0, sp, #96	; 0x60
 c007bfe:	781c      	ldrb	r4, [r3, #0]
            key_id = bootutil_find_key(buf, tlv.it_len);
 c007c00:	f89d 7016 	ldrb.w	r7, [sp, #22]
    uint32_t key_id = current_image > 2 ? current_image -2 : current_image;
 c007c04:	2c02      	cmp	r4, #2
 c007c06:	bf88      	it	hi
 c007c08:	3c02      	subhi	r4, #2
 c007c0a:	f7f9 ff57 	bl	c001abc <mbedtls_sha256_init>
    mbedtls_sha256_starts(ctx, 0);
 c007c0e:	2100      	movs	r1, #0
 c007c10:	a818      	add	r0, sp, #96	; 0x60
 c007c12:	f7fa f802 	bl	c001c1a <mbedtls_sha256_starts>
    bootutil_sha256_update(&sha256_ctx, key->key, *key->len);
 c007c16:	eb0b 03c4 	add.w	r3, fp, r4, lsl #3
 c007c1a:	685b      	ldr	r3, [r3, #4]
    mbedtls_sha256_update(ctx, data, data_len);
 c007c1c:	f85b 1034 	ldr.w	r1, [fp, r4, lsl #3]
 c007c20:	681a      	ldr	r2, [r3, #0]
 c007c22:	a818      	add	r0, sp, #96	; 0x60
 c007c24:	f7f9 fffb 	bl	c001c1e <mbedtls_sha256_update>
    mbedtls_sha256_finish(ctx, output);
 c007c28:	a910      	add	r1, sp, #64	; 0x40
 c007c2a:	a818      	add	r0, sp, #96	; 0x60
 c007c2c:	f7f9 fff9 	bl	c001c22 <mbedtls_sha256_finish>
    if (!boot_secure_memequal(hash, keyhash, keyhash_len)) {
 c007c30:	463a      	mov	r2, r7
 c007c32:	a974      	add	r1, sp, #464	; 0x1d0
 c007c34:	a810      	add	r0, sp, #64	; 0x40
 c007c36:	f7ff fb43 	bl	c0072c0 <boot_secure_memequal>
        return (int)key_id;
 c007c3a:	2800      	cmp	r0, #0
 c007c3c:	bf18      	it	ne
 c007c3e:	f04f 34ff 	movne.w	r4, #4294967295
 c007c42:	e7c1      	b.n	c007bc8 <bootutil_img_validate+0x150>
        } else if (tlv.it_type == EXPECTED_SIG_TLV) {
 c007c44:	2b23      	cmp	r3, #35	; 0x23
 c007c46:	d122      	bne.n	c007c8e <bootutil_img_validate+0x216>
            if (key_id >= 0 && key_id < bootutil_key_cnt) {
 c007c48:	1c63      	adds	r3, r4, #1
 c007c4a:	d0bd      	beq.n	c007bc8 <bootutil_img_validate+0x150>
 c007c4c:	4b24      	ldr	r3, [pc, #144]	; (c007ce0 <bootutil_img_validate+0x268>)
 c007c4e:	681b      	ldr	r3, [r3, #0]
 c007c50:	42a3      	cmp	r3, r4
 c007c52:	dd3d      	ble.n	c007cd0 <bootutil_img_validate+0x258>
                if (!EXPECTED_SIG_LEN(tlv.it_len) || tlv.it_len > sizeof(buf)) {
 c007c54:	f5b7 7fc0 	cmp.w	r7, #384	; 0x180
 c007c58:	f47f af54 	bne.w	c007b04 <bootutil_img_validate+0x8c>
                rc = LOAD_IMAGE_DATA(fap, off + sizeof(tlv), buf, tlv.it_len);
 c007c5c:	463b      	mov	r3, r7
 c007c5e:	aa74      	add	r2, sp, #464	; 0x1d0
 c007c60:	1d29      	adds	r1, r5, #4
 c007c62:	4640      	mov	r0, r8
 c007c64:	f7ff fcf8 	bl	c007658 <flash_area_read>
                if (rc) {
 c007c68:	2800      	cmp	r0, #0
 c007c6a:	f47f af4b 	bne.w	c007b04 <bootutil_img_validate+0x8c>
                rc = bootutil_verify_sig(hash, sizeof(hash), buf, tlv.it_len,
 c007c6e:	2120      	movs	r1, #32
 c007c70:	b2e4      	uxtb	r4, r4
 c007c72:	9400      	str	r4, [sp, #0]
 c007c74:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 c007c78:	aa74      	add	r2, sp, #464	; 0x1d0
 c007c7a:	eb0d 0001 	add.w	r0, sp, r1
 c007c7e:	f7ff fdaf 	bl	c0077e0 <bootutil_verify_sig>
            key_id = -1;
 c007c82:	2800      	cmp	r0, #0
 c007c84:	f04f 34ff 	mov.w	r4, #4294967295
 c007c88:	bf08      	it	eq
 c007c8a:	2601      	moveq	r6, #1
 c007c8c:	e79c      	b.n	c007bc8 <bootutil_img_validate+0x150>
        } else if (tlv.it_type == IMAGE_TLV_SEC_CNT) {
 c007c8e:	2b50      	cmp	r3, #80	; 0x50
 c007c90:	d19a      	bne.n	c007bc8 <bootutil_img_validate+0x150>
            if (tlv.it_len != sizeof(img_security_cnt)) {
 c007c92:	2f04      	cmp	r7, #4
 c007c94:	f47f af36 	bne.w	c007b04 <bootutil_img_validate+0x8c>
            rc = LOAD_IMAGE_DATA(fap, off + sizeof(tlv),
 c007c98:	463b      	mov	r3, r7
 c007c9a:	aa07      	add	r2, sp, #28
 c007c9c:	1d29      	adds	r1, r5, #4
 c007c9e:	4640      	mov	r0, r8
 c007ca0:	f7ff fcda 	bl	c007658 <flash_area_read>
            if (rc) {
 c007ca4:	2800      	cmp	r0, #0
 c007ca6:	f47f af2f 	bne.w	c007b08 <bootutil_img_validate+0x90>
            rc = boot_nv_security_counter_get((current_image > 2 ? current_image -2 : current_image), &security_cnt);
 c007caa:	4b0c      	ldr	r3, [pc, #48]	; (c007cdc <bootutil_img_validate+0x264>)
 c007cac:	a906      	add	r1, sp, #24
 c007cae:	7818      	ldrb	r0, [r3, #0]
 c007cb0:	2802      	cmp	r0, #2
 c007cb2:	bf88      	it	hi
 c007cb4:	3802      	subhi	r0, #2
 c007cb6:	f000 fc73 	bl	c0085a0 <boot_nv_security_counter_get>
            if (rc) {
 c007cba:	2800      	cmp	r0, #0
 c007cbc:	f47f af24 	bne.w	c007b08 <bootutil_img_validate+0x90>
            if (img_security_cnt < security_cnt) {
 c007cc0:	e9dd 3206 	ldrd	r3, r2, [sp, #24]
 c007cc4:	429a      	cmp	r2, r3
 c007cc6:	f4ff af1d 	bcc.w	c007b04 <bootutil_img_validate+0x8c>
            security_counter_valid = 1;
 c007cca:	f04f 0901 	mov.w	r9, #1
 c007cce:	e77b      	b.n	c007bc8 <bootutil_img_validate+0x150>
            key_id = -1;
 c007cd0:	f04f 34ff 	mov.w	r4, #4294967295
 c007cd4:	e778      	b.n	c007bc8 <bootutil_img_validate+0x150>
        return BOOT_EBADMAGIC;
 c007cd6:	2008      	movs	r0, #8
 c007cd8:	e716      	b.n	c007b08 <bootutil_img_validate+0x90>
 c007cda:	bf00      	nop
 c007cdc:	3003277c 	.word	0x3003277c
 c007ce0:	0c00a89c 	.word	0x0c00a89c
 c007ce4:	0c00a8a0 	.word	0x0c00a8a0

0c007ce8 <boot_review_image_swap_types>:
 * @param aborted_swap          The current image upgrade is a
 *                              partial/aborted swap.
 */
static void
boot_review_image_swap_types(bool aborted_swap)
{
 c007ce8:	b530      	push	{r4, r5, lr}
     *      REVERT swap types to NONE (these images had been successfully
     *      updated before the system rebooted between two separate image
     *      upgrades).
     */

    if (current_image == 0) {
 c007cea:	4b0e      	ldr	r3, [pc, #56]	; (c007d24 <boot_review_image_swap_types+0x3c>)
 c007cec:	781b      	ldrb	r3, [r3, #0]
 c007cee:	b1b3      	cbz	r3, c007d1e <boot_review_image_swap_types+0x36>
        /* Nothing to do */
        return;
    }

    if (!aborted_swap) {
 c007cf0:	b9b0      	cbnz	r0, c007d20 <boot_review_image_swap_types+0x38>
        if ((BOOT_SWAP_TYPE(&boot_data) == BOOT_SWAP_TYPE_NONE) ||
 c007cf2:	4a0d      	ldr	r2, [pc, #52]	; (c007d28 <boot_review_image_swap_types+0x40>)
 c007cf4:	441a      	add	r2, r3
 c007cf6:	f892 20cc 	ldrb.w	r2, [r2, #204]	; 0xcc
 c007cfa:	2a01      	cmp	r2, #1
 c007cfc:	d00f      	beq.n	c007d1e <boot_review_image_swap_types+0x36>
 c007cfe:	2a04      	cmp	r2, #4
 c007d00:	d00d      	beq.n	c007d1e <boot_review_image_swap_types+0x36>
 c007d02:	4909      	ldr	r1, [pc, #36]	; (c007d28 <boot_review_image_swap_types+0x40>)
        }
    }

    for (uint8_t i = 0; i < current_image; i++) {
        if (boot_data.swap_type[i] == BOOT_SWAP_TYPE_REVERT) {
            boot_data.swap_type[i] = BOOT_SWAP_TYPE_NONE;
 c007d04:	2401      	movs	r4, #1
 c007d06:	e007      	b.n	c007d18 <boot_review_image_swap_types+0x30>
 c007d08:	180a      	adds	r2, r1, r0
        if (boot_data.swap_type[i] == BOOT_SWAP_TYPE_REVERT) {
 c007d0a:	f892 50cc 	ldrb.w	r5, [r2, #204]	; 0xcc
 c007d0e:	3001      	adds	r0, #1
 c007d10:	2d04      	cmp	r5, #4
            boot_data.swap_type[i] = BOOT_SWAP_TYPE_NONE;
 c007d12:	bf08      	it	eq
 c007d14:	f882 40cc 	strbeq.w	r4, [r2, #204]	; 0xcc
    for (uint8_t i = 0; i < current_image; i++) {
 c007d18:	b2c2      	uxtb	r2, r0
 c007d1a:	4293      	cmp	r3, r2
 c007d1c:	d8f4      	bhi.n	c007d08 <boot_review_image_swap_types+0x20>
        }
    }
}
 c007d1e:	bd30      	pop	{r4, r5, pc}
 c007d20:	2000      	movs	r0, #0
 c007d22:	e7ee      	b.n	c007d02 <boot_review_image_swap_types+0x1a>
 c007d24:	3003277c 	.word	0x3003277c
 c007d28:	300322a8 	.word	0x300322a8

0c007d2c <boot_update_security_counter.constprop.7>:
boot_update_security_counter(int slot, struct image_header *hdr)
 c007d2c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c007d2e:	4605      	mov	r5, r0
    const struct flash_area *fap = NULL;
 c007d30:	2000      	movs	r0, #0
 c007d32:	ac02      	add	r4, sp, #8
 c007d34:	f844 0d08 	str.w	r0, [r4, #-8]!
    rc = flash_area_open(flash_area_id_from_image_slot(slot), &fap);
 c007d38:	f7ff fcf2 	bl	c007720 <flash_area_id_from_image_slot>
 c007d3c:	4621      	mov	r1, r4
 c007d3e:	b2c0      	uxtb	r0, r0
 c007d40:	f7ff fc3a 	bl	c0075b8 <flash_area_open>
    if (rc != 0) {
 c007d44:	b990      	cbnz	r0, c007d6c <boot_update_security_counter.constprop.7+0x40>
    rc = bootutil_get_img_security_cnt(hdr, fap, &img_security_cnt);
 c007d46:	aa01      	add	r2, sp, #4
 c007d48:	9900      	ldr	r1, [sp, #0]
 c007d4a:	4628      	mov	r0, r5
 c007d4c:	f7ff fe44 	bl	c0079d8 <bootutil_get_img_security_cnt>
    if (rc != 0) {
 c007d50:	4604      	mov	r4, r0
 c007d52:	b928      	cbnz	r0, c007d60 <boot_update_security_counter.constprop.7+0x34>
    rc = boot_nv_security_counter_update(current_image, img_security_cnt);
 c007d54:	4b06      	ldr	r3, [pc, #24]	; (c007d70 <boot_update_security_counter.constprop.7+0x44>)
 c007d56:	9901      	ldr	r1, [sp, #4]
 c007d58:	7818      	ldrb	r0, [r3, #0]
 c007d5a:	f000 fc35 	bl	c0085c8 <boot_nv_security_counter_update>
 c007d5e:	4604      	mov	r4, r0
    flash_area_close(fap);
 c007d60:	9800      	ldr	r0, [sp, #0]
 c007d62:	f7ff fc43 	bl	c0075ec <flash_area_close>
}
 c007d66:	4620      	mov	r0, r4
 c007d68:	b003      	add	sp, #12
 c007d6a:	bd30      	pop	{r4, r5, pc}
        rc = BOOT_EFLASH;
 c007d6c:	2401      	movs	r4, #1
 c007d6e:	e7f7      	b.n	c007d60 <boot_update_security_counter.constprop.7+0x34>
 c007d70:	3003277c 	.word	0x3003277c

0c007d74 <boot_read_image_headers.constprop.8>:
boot_read_image_headers(bool require_all)
 c007d74:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int image_header_ok = 0;
 c007d78:	2600      	movs	r6, #0
    for (i = 0; i < BOOT_NUM_SLOTS; i++) {
 c007d7a:	4634      	mov	r4, r6
#define BOOT_SWAP_TYPE(state) ((state)->swap_type[current_image])

static inline struct image_header*
boot_img_hdr(struct boot_loader_state *state, size_t slot)
{
    return &BOOT_IMG(state, slot).hdr;
 c007d7c:	4b30      	ldr	r3, [pc, #192]	; (c007e40 <boot_read_image_headers.constprop.8+0xcc>)
    const struct flash_area *fap = NULL;
 c007d7e:	af02      	add	r7, sp, #8
 c007d80:	781d      	ldrb	r5, [r3, #0]
 c007d82:	2300      	movs	r3, #0
    area_id = flash_area_id_from_image_slot(slot);
 c007d84:	4620      	mov	r0, r4
    const struct flash_area *fap = NULL;
 c007d86:	f847 3d04 	str.w	r3, [r7, #-4]!
    area_id = flash_area_id_from_image_slot(slot);
 c007d8a:	f7ff fcc9 	bl	c007720 <flash_area_id_from_image_slot>
    rc = flash_area_open(area_id, &fap);
 c007d8e:	4639      	mov	r1, r7
 c007d90:	b2c0      	uxtb	r0, r0
 c007d92:	f7ff fc11 	bl	c0075b8 <flash_area_open>
    if (rc != 0) {
 c007d96:	4601      	mov	r1, r0
 c007d98:	b190      	cbz	r0, c007dc0 <boot_read_image_headers.constprop.8+0x4c>
        rc = BOOT_EFLASH;
 c007d9a:	f04f 0a01 	mov.w	sl, #1
    flash_area_close(fap);
 c007d9e:	9801      	ldr	r0, [sp, #4]
 c007da0:	f7ff fc24 	bl	c0075ec <flash_area_close>
        if (rc == 0)
 c007da4:	f1ba 0f00 	cmp.w	sl, #0
 c007da8:	d100      	bne.n	c007dac <boot_read_image_headers.constprop.8+0x38>
          image_header_ok += 1;
 c007daa:	3601      	adds	r6, #1
    for (i = 0; i < BOOT_NUM_SLOTS; i++) {
 c007dac:	b134      	cbz	r4, c007dbc <boot_read_image_headers.constprop.8+0x48>
}
 c007dae:	2e00      	cmp	r6, #0
 c007db0:	bfcc      	ite	gt
 c007db2:	2000      	movgt	r0, #0
 c007db4:	2001      	movle	r0, #1
 c007db6:	b003      	add	sp, #12
 c007db8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for (i = 0; i < BOOT_NUM_SLOTS; i++) {
 c007dbc:	2401      	movs	r4, #1
 c007dbe:	e7dd      	b.n	c007d7c <boot_read_image_headers.constprop.8+0x8>
 c007dc0:	f04f 0830 	mov.w	r8, #48	; 0x30
 c007dc4:	f04f 0b60 	mov.w	fp, #96	; 0x60
 c007dc8:	fb08 f804 	mul.w	r8, r8, r4
 c007dcc:	fb1b 8205 	smlabb	r2, fp, r5, r8
 c007dd0:	f8df 9074 	ldr.w	r9, [pc, #116]	; c007e48 <boot_read_image_headers.constprop.8+0xd4>
    rc = flash_area_read(fap, 0, out_hdr, sizeof(*out_hdr));
 c007dd4:	2320      	movs	r3, #32
 c007dd6:	444a      	add	r2, r9
 c007dd8:	9801      	ldr	r0, [sp, #4]
 c007dda:	f7ff fc3d 	bl	c007658 <flash_area_read>
 c007dde:	464f      	mov	r7, r9
    if (rc != 0) {
 c007de0:	4682      	mov	sl, r0
 c007de2:	2800      	cmp	r0, #0
 c007de4:	d1d9      	bne.n	c007d9a <boot_read_image_headers.constprop.8+0x26>
    if (hdr->ih_magic != IMAGE_MAGIC) {
 c007de6:	fb0b 8505 	mla	r5, fp, r5, r8
 c007dea:	4b16      	ldr	r3, [pc, #88]	; (c007e44 <boot_read_image_headers.constprop.8+0xd0>)
 c007dec:	f859 2005 	ldr.w	r2, [r9, r5]
 c007df0:	eb09 0b05 	add.w	fp, r9, r5
 c007df4:	429a      	cmp	r2, r3
 c007df6:	d00f      	beq.n	c007e18 <boot_read_image_headers.constprop.8+0xa4>
        return BOOT_EBADIMAGE;
 c007df8:	f04f 0a03 	mov.w	sl, #3
    BOOT_IMG_HDR_IS_VALID(&boot_data, slot) = (rc == 0);
 c007dfc:	2260      	movs	r2, #96	; 0x60
 c007dfe:	4b10      	ldr	r3, [pc, #64]	; (c007e40 <boot_read_image_headers.constprop.8+0xcc>)
 c007e00:	7819      	ldrb	r1, [r3, #0]
 c007e02:	4351      	muls	r1, r2
 c007e04:	2230      	movs	r2, #48	; 0x30
 c007e06:	fb02 1204 	mla	r2, r2, r4, r1
 c007e0a:	4417      	add	r7, r2
 c007e0c:	faba f28a 	clz	r2, sl
 c007e10:	0952      	lsrs	r2, r2, #5
 c007e12:	f887 202c 	strb.w	r2, [r7, #44]	; 0x2c
 c007e16:	e7c2      	b.n	c007d9e <boot_read_image_headers.constprop.8+0x2a>
    if (boot_add_uint32_overflow_check(hdr->ih_hdr_size, hdr->ih_img_size)) {
 c007e18:	f8db 100c 	ldr.w	r1, [fp, #12]
 c007e1c:	f8bb 0008 	ldrh.w	r0, [fp, #8]
 c007e20:	f7ff fb7d 	bl	c00751e <boot_add_uint32_overflow_check>
 c007e24:	2800      	cmp	r0, #0
 c007e26:	d1e7      	bne.n	c007df8 <boot_read_image_headers.constprop.8+0x84>
    image_end = hdr->ih_hdr_size + hdr->ih_img_size;
 c007e28:	f8bb 0008 	ldrh.w	r0, [fp, #8]
 c007e2c:	f8db 200c 	ldr.w	r2, [fp, #12]
    if (boot_add_uint32_overflow_check(image_end, hdr->ih_protect_tlv_size)) {
 c007e30:	f8bb 100a 	ldrh.w	r1, [fp, #10]
 c007e34:	4410      	add	r0, r2
 c007e36:	f7ff fb72 	bl	c00751e <boot_add_uint32_overflow_check>
 c007e3a:	2800      	cmp	r0, #0
 c007e3c:	d0de      	beq.n	c007dfc <boot_read_image_headers.constprop.8+0x88>
 c007e3e:	e7db      	b.n	c007df8 <boot_read_image_headers.constprop.8+0x84>
 c007e40:	3003277c 	.word	0x3003277c
 c007e44:	96f3b83d 	.word	0x96f3b83d
 c007e48:	300322a8 	.word	0x300322a8

0c007e4c <boot_validate_slot.isra.2>:
boot_validate_slot(int slot, struct boot_status *bs)
 c007e4c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c007e50:	b087      	sub	sp, #28
 c007e52:	4605      	mov	r5, r0
    rc = flash_area_open(flash_area_id_from_image_slot(slot), &fap);
 c007e54:	f7ff fc64 	bl	c007720 <flash_area_id_from_image_slot>
 c007e58:	a904      	add	r1, sp, #16
 c007e5a:	b2c0      	uxtb	r0, r0
 c007e5c:	f7ff fbac 	bl	c0075b8 <flash_area_open>
    if (rc != 0) {
 c007e60:	2800      	cmp	r0, #0
 c007e62:	d15f      	bne.n	c007f24 <boot_validate_slot.isra.2+0xd8>
 c007e64:	4c30      	ldr	r4, [pc, #192]	; (c007f28 <boot_validate_slot.isra.2+0xdc>)
    rc = flash_area_open(flash_area_id_from_image_slot(slot), &fap);
 c007e66:	4628      	mov	r0, r5
 c007e68:	7827      	ldrb	r7, [r4, #0]
 c007e6a:	f7ff fc59 	bl	c007720 <flash_area_id_from_image_slot>
 c007e6e:	a905      	add	r1, sp, #20
 c007e70:	b2c0      	uxtb	r0, r0
 c007e72:	2630      	movs	r6, #48	; 0x30
 c007e74:	f7ff fba0 	bl	c0075b8 <flash_area_open>
 c007e78:	46a0      	mov	r8, r4
 c007e7a:	436e      	muls	r6, r5
 c007e7c:	4c2b      	ldr	r4, [pc, #172]	; (c007f2c <boot_validate_slot.isra.2+0xe0>)
    if (rc != 0) {
 c007e7e:	b1c0      	cbz	r0, c007eb2 <boot_validate_slot.isra.2+0x66>
        (hdr->ih_flags & IMAGE_F_NON_BOOTABLE)) {
 c007e80:	2230      	movs	r2, #48	; 0x30
 c007e82:	2060      	movs	r0, #96	; 0x60
 c007e84:	fb02 f105 	mul.w	r1, r2, r5
 c007e88:	fb00 1307 	mla	r3, r0, r7, r1
 c007e8c:	4423      	add	r3, r4
 c007e8e:	691b      	ldr	r3, [r3, #16]
    if ((boot_check_header_erased(slot) == 0) ||
 c007e90:	f013 0310 	ands.w	r3, r3, #16
 c007e94:	d11e      	bne.n	c007ed4 <boot_validate_slot.isra.2+0x88>
    if ((!BOOT_IMG_HDR_IS_VALID(&boot_data, slot)) ||
 c007e96:	f898 2000 	ldrb.w	r2, [r8]
 c007e9a:	fb00 1202 	mla	r2, r0, r2, r1
 c007e9e:	4422      	add	r2, r4
 c007ea0:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 c007ea4:	b9f2      	cbnz	r2, c007ee4 <boot_validate_slot.isra.2+0x98>
        if (slot != BOOT_PRIMARY_SLOT) {
 c007ea6:	bb9d      	cbnz	r5, c007f10 <boot_validate_slot.isra.2+0xc4>
        BOOT_LOG_ERR("Authentication failed! Image in the %s slot is not valid."
 c007ea8:	4921      	ldr	r1, [pc, #132]	; (c007f30 <boot_validate_slot.isra.2+0xe4>)
 c007eaa:	4822      	ldr	r0, [pc, #136]	; (c007f34 <boot_validate_slot.isra.2+0xe8>)
 c007eac:	f000 fcdc 	bl	c008868 <iprintf>
 c007eb0:	e010      	b.n	c007ed4 <boot_validate_slot.isra.2+0x88>
    erased_val = flash_area_erased_val(fap);
 c007eb2:	9805      	ldr	r0, [sp, #20]
 c007eb4:	f7ff fbc8 	bl	c007648 <flash_area_erased_val>
 c007eb8:	4681      	mov	r9, r0
    flash_area_close(fap);
 c007eba:	9805      	ldr	r0, [sp, #20]
 c007ebc:	f7ff fb96 	bl	c0075ec <flash_area_close>
    if (!boot_data_is_set_to(erased_val, &hdr->ih_magic,
 c007ec0:	2360      	movs	r3, #96	; 0x60
 c007ec2:	f898 2000 	ldrb.w	r2, [r8]
 c007ec6:	fb13 6302 	smlabb	r3, r3, r2, r6
 c007eca:	4423      	add	r3, r4
 c007ecc:	1e5a      	subs	r2, r3, #1
 c007ece:	3303      	adds	r3, #3
    for (i = 0; i < len; i++) {
 c007ed0:	429a      	cmp	r2, r3
 c007ed2:	d102      	bne.n	c007eda <boot_validate_slot.isra.2+0x8e>
        rc = -1;
 c007ed4:	f04f 34ff 	mov.w	r4, #4294967295
 c007ed8:	e013      	b.n	c007f02 <boot_validate_slot.isra.2+0xb6>
        if (val != p[i]) {
 c007eda:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 c007ede:	4549      	cmp	r1, r9
 c007ee0:	d0f6      	beq.n	c007ed0 <boot_validate_slot.isra.2+0x84>
 c007ee2:	e7cd      	b.n	c007e80 <boot_validate_slot.isra.2+0x34>
 c007ee4:	fb10 6007 	smlabb	r0, r0, r7, r6
    if (bootutil_img_validate(hdr, fap, tmpbuf, BOOT_TMPBUF_SZ,
 c007ee8:	e9cd 3301 	strd	r3, r3, [sp, #4]
 c007eec:	9300      	str	r3, [sp, #0]
 c007eee:	4420      	add	r0, r4
 c007ef0:	f44f 7380 	mov.w	r3, #256	; 0x100
 c007ef4:	4a10      	ldr	r2, [pc, #64]	; (c007f38 <boot_validate_slot.isra.2+0xec>)
 c007ef6:	9904      	ldr	r1, [sp, #16]
 c007ef8:	f7ff fdbe 	bl	c007a78 <bootutil_img_validate>
 c007efc:	4604      	mov	r4, r0
 c007efe:	2800      	cmp	r0, #0
 c007f00:	d1d1      	bne.n	c007ea6 <boot_validate_slot.isra.2+0x5a>
    flash_area_close(fap);
 c007f02:	9804      	ldr	r0, [sp, #16]
 c007f04:	f7ff fb72 	bl	c0075ec <flash_area_close>
}
 c007f08:	4620      	mov	r0, r4
 c007f0a:	b007      	add	sp, #28
 c007f0c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            rc = flash_area_erase(fap, 0, fap->fa_size);
 c007f10:	9804      	ldr	r0, [sp, #16]
 c007f12:	2100      	movs	r1, #0
 c007f14:	6882      	ldr	r2, [r0, #8]
 c007f16:	f7ff fbdd 	bl	c0076d4 <flash_area_erase>
            if(rc != 0) {
 c007f1a:	b908      	cbnz	r0, c007f20 <boot_validate_slot.isra.2+0xd4>
        BOOT_LOG_ERR("Authentication failed! Image in the %s slot is not valid."
 c007f1c:	4907      	ldr	r1, [pc, #28]	; (c007f3c <boot_validate_slot.isra.2+0xf0>)
 c007f1e:	e7c4      	b.n	c007eaa <boot_validate_slot.isra.2+0x5e>
                rc = BOOT_EFLASH;
 c007f20:	462c      	mov	r4, r5
 c007f22:	e7ee      	b.n	c007f02 <boot_validate_slot.isra.2+0xb6>
        return BOOT_EFLASH;
 c007f24:	2401      	movs	r4, #1
 c007f26:	e7ef      	b.n	c007f08 <boot_validate_slot.isra.2+0xbc>
 c007f28:	3003277c 	.word	0x3003277c
 c007f2c:	300322a8 	.word	0x300322a8
 c007f30:	0c00ab54 	.word	0x0c00ab54
 c007f34:	0c00ab5c 	.word	0x0c00ab5c
 c007f38:	30033860 	.word	0x30033860
 c007f3c:	0c00ab4a 	.word	0x0c00ab4a

0c007f40 <boot_initialize_area.constprop.10>:
    uint32_t num_sectors;
    struct flash_sector *out_sectors;
    size_t *out_num_sectors;
    int rc;

    num_sectors = BOOT_MAX_IMG_SECTORS;
 c007f40:	236c      	movs	r3, #108	; 0x6c
boot_initialize_area(struct boot_loader_state *state, int flash_area)
 c007f42:	b513      	push	{r0, r1, r4, lr}
    num_sectors = BOOT_MAX_IMG_SECTORS;
 c007f44:	9301      	str	r3, [sp, #4]

    if (flash_area == FLASH_AREA_IMAGE_PRIMARY) {
 c007f46:	4b1a      	ldr	r3, [pc, #104]	; (c007fb0 <boot_initialize_area.constprop.10+0x70>)
 c007f48:	781b      	ldrb	r3, [r3, #0]
 c007f4a:	b363      	cbz	r3, c007fa6 <boot_initialize_area.constprop.10+0x66>
 c007f4c:	2b01      	cmp	r3, #1
 c007f4e:	d121      	bne.n	c007f94 <boot_initialize_area.constprop.10+0x54>
 c007f50:	2802      	cmp	r0, #2
 c007f52:	d110      	bne.n	c007f76 <boot_initialize_area.constprop.10+0x36>
        out_sectors = BOOT_IMG(state, BOOT_PRIMARY_SLOT).sectors;
 c007f54:	2160      	movs	r1, #96	; 0x60
 c007f56:	4c17      	ldr	r4, [pc, #92]	; (c007fb4 <boot_initialize_area.constprop.10+0x74>)
 c007f58:	fb01 4203 	mla	r2, r1, r3, r4
        out_num_sectors = &BOOT_IMG(state, BOOT_PRIMARY_SLOT).num_sectors;
 c007f5c:	fb01 4303 	mla	r3, r1, r3, r4
        out_sectors = BOOT_IMG(state, BOOT_PRIMARY_SLOT).sectors;
 c007f60:	6a52      	ldr	r2, [r2, #36]	; 0x24
        out_num_sectors = &BOOT_IMG(state, BOOT_PRIMARY_SLOT).num_sectors;
 c007f62:	f103 0428 	add.w	r4, r3, #40	; 0x28
        out_num_sectors = &state->scratch.num_sectors;
    } else {
        return BOOT_EFLASH;
    }

    rc = flash_area_get_sectors(flash_area, &num_sectors, out_sectors);
 c007f66:	a901      	add	r1, sp, #4
 c007f68:	f7ff fbfe 	bl	c007768 <flash_area_get_sectors>
    if (rc != 0) {
 c007f6c:	b908      	cbnz	r0, c007f72 <boot_initialize_area.constprop.10+0x32>
        return rc;
    }
    *out_num_sectors = num_sectors;
 c007f6e:	9b01      	ldr	r3, [sp, #4]
 c007f70:	6023      	str	r3, [r4, #0]
    return 0;
}
 c007f72:	b002      	add	sp, #8
 c007f74:	bd10      	pop	{r4, pc}
    } else if (flash_area == FLASH_AREA_IMAGE_SECONDARY) {
 c007f76:	2204      	movs	r2, #4
 c007f78:	4290      	cmp	r0, r2
 c007f7a:	d10d      	bne.n	c007f98 <boot_initialize_area.constprop.10+0x58>
        out_sectors = BOOT_IMG(state, BOOT_SECONDARY_SLOT).sectors;
 c007f7c:	2160      	movs	r1, #96	; 0x60
 c007f7e:	4c0d      	ldr	r4, [pc, #52]	; (c007fb4 <boot_initialize_area.constprop.10+0x74>)
 c007f80:	fb01 4203 	mla	r2, r1, r3, r4
        out_num_sectors = &BOOT_IMG(state, BOOT_SECONDARY_SLOT).num_sectors;
 c007f84:	fb01 4303 	mla	r3, r1, r3, r4
        out_sectors = BOOT_IMG(state, BOOT_SECONDARY_SLOT).sectors;
 c007f88:	6d52      	ldr	r2, [r2, #84]	; 0x54
        out_num_sectors = &BOOT_IMG(state, BOOT_SECONDARY_SLOT).num_sectors;
 c007f8a:	f103 0458 	add.w	r4, r3, #88	; 0x58
 c007f8e:	e7ea      	b.n	c007f66 <boot_initialize_area.constprop.10+0x26>
        return BOOT_EFLASH;
 c007f90:	2001      	movs	r0, #1
 c007f92:	e7ee      	b.n	c007f72 <boot_initialize_area.constprop.10+0x32>
    if (flash_area == FLASH_AREA_IMAGE_PRIMARY) {
 c007f94:	28ff      	cmp	r0, #255	; 0xff
 c007f96:	d0dd      	beq.n	c007f54 <boot_initialize_area.constprop.10+0x14>
    } else if (flash_area == FLASH_AREA_IMAGE_SCRATCH) {
 c007f98:	2805      	cmp	r0, #5
 c007f9a:	d1f9      	bne.n	c007f90 <boot_initialize_area.constprop.10+0x50>
        out_sectors = state->scratch.sectors;
 c007f9c:	4c05      	ldr	r4, [pc, #20]	; (c007fb4 <boot_initialize_area.constprop.10+0x74>)
 c007f9e:	f8d4 20c4 	ldr.w	r2, [r4, #196]	; 0xc4
        out_num_sectors = &state->scratch.num_sectors;
 c007fa2:	34c8      	adds	r4, #200	; 0xc8
 c007fa4:	e7df      	b.n	c007f66 <boot_initialize_area.constprop.10+0x26>
    if (flash_area == FLASH_AREA_IMAGE_PRIMARY) {
 c007fa6:	2801      	cmp	r0, #1
 c007fa8:	d0d4      	beq.n	c007f54 <boot_initialize_area.constprop.10+0x14>
    } else if (flash_area == FLASH_AREA_IMAGE_SECONDARY) {
 c007faa:	2203      	movs	r2, #3
 c007fac:	e7e4      	b.n	c007f78 <boot_initialize_area.constprop.10+0x38>
 c007fae:	bf00      	nop
 c007fb0:	3003277c 	.word	0x3003277c
 c007fb4:	300322a8 	.word	0x300322a8

0c007fb8 <boot_go>:

    /* Iterate over all the images. By the end of the loop the swap type has
     * to be determined for each image and all aborted swaps have to be
     * completed.
     */
    for (current_image = 0; current_image < BOOT_IMAGE_NUMBER; ++current_image)
 c007fb8:	4ba6      	ldr	r3, [pc, #664]	; (c008254 <boot_go+0x29c>)
{
 c007fba:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    for (current_image = 0; current_image < BOOT_IMAGE_NUMBER; ++current_image)
 c007fbe:	2600      	movs	r6, #0
 c007fc0:	469b      	mov	fp, r3
 c007fc2:	461f      	mov	r7, r3
 c007fc4:	461d      	mov	r5, r3
{
 c007fc6:	b08f      	sub	sp, #60	; 0x3c
 c007fc8:	4ca3      	ldr	r4, [pc, #652]	; (c008258 <boot_go+0x2a0>)
 c007fca:	9002      	str	r0, [sp, #8]
    for (current_image = 0; current_image < BOOT_IMAGE_NUMBER; ++current_image)
 c007fcc:	701e      	strb	r6, [r3, #0]
 c007fce:	783b      	ldrb	r3, [r7, #0]
 c007fd0:	2b01      	cmp	r3, #1
 c007fd2:	d91c      	bls.n	c00800e <boot_go+0x56>
    current_image = 0;
 c007fd4:	2300      	movs	r3, #0
 c007fd6:	703b      	strb	r3, [r7, #0]
    while (current_image < BOOT_IMAGE_NUMBER) {
 c007fd8:	782b      	ldrb	r3, [r5, #0]
 c007fda:	2b01      	cmp	r3, #1
 c007fdc:	f240 8101 	bls.w	c0081e2 <boot_go+0x22a>

    /* Iterate over all the images. At this point there are no aborted swaps
     * and the swap types are determined for each image. By the end of the loop
     * all required update operations will have been finished.
     */
    for (current_image = 0; current_image < BOOT_IMAGE_NUMBER; ++current_image)
 c007fe0:	2300      	movs	r3, #0
 c007fe2:	702b      	strb	r3, [r5, #0]
 c007fe4:	782b      	ldrb	r3, [r5, #0]
 c007fe6:	2200      	movs	r2, #0
 c007fe8:	2b01      	cmp	r3, #1
 c007fea:	f240 81b8 	bls.w	c00835e <boot_go+0x3a6>
            }
        }

        /* Save boot status to shared memory area */
#if (BOOT_IMAGE_NUMBER > 1)
        rc = boot_save_boot_status((current_image == 0) ? SW_SPE : SW_NSPE,
 c007fee:	2760      	movs	r7, #96	; 0x60
                                   boot_img_hdr(&boot_data, BOOT_PRIMARY_SLOT),
                                   BOOT_IMG_AREA(&boot_data, BOOT_PRIMARY_SLOT)
                                  );
#endif
        if (rc) {
            BOOT_LOG_ERR("Failed to add Image %u data to shared area",
 c007ff0:	f8df 8290 	ldr.w	r8, [pc, #656]	; c008284 <boot_go+0x2cc>
    for (current_image = 0; current_image < BOOT_IMAGE_NUMBER; ++current_image)
 c007ff4:	702a      	strb	r2, [r5, #0]
 c007ff6:	782b      	ldrb	r3, [r5, #0]
 c007ff8:	2b01      	cmp	r3, #1
 c007ffa:	f240 8263 	bls.w	c0084c4 <boot_go+0x50c>
    }

    /* Always boot from the primary slot of Image 0. */
    current_image = 0;
    rsp->br_flash_dev_id =
            BOOT_IMG_AREA(&boot_data, BOOT_PRIMARY_SLOT)->fa_device_id;
 c007ffe:	6a23      	ldr	r3, [r4, #32]
    rsp->br_flash_dev_id =
 c008000:	9902      	ldr	r1, [sp, #8]
 c008002:	785a      	ldrb	r2, [r3, #1]
 c008004:	710a      	strb	r2, [r1, #4]
    rsp->br_image_off =
 c008006:	685b      	ldr	r3, [r3, #4]
            boot_img_slot_off(&boot_data, BOOT_PRIMARY_SLOT);
    rsp->br_hdr =
 c008008:	600c      	str	r4, [r1, #0]
    rsp->br_image_off =
 c00800a:	608b      	str	r3, [r1, #8]
 c00800c:	e26a      	b.n	c0084e4 <boot_go+0x52c>
 c00800e:	f44f 7258 	mov.w	r2, #864	; 0x360
        BOOT_IMG(&boot_data, BOOT_PRIMARY_SLOT).sectors =
 c008012:	2660      	movs	r6, #96	; 0x60
 c008014:	435a      	muls	r2, r3
 c008016:	fb06 4303 	mla	r3, r6, r3, r4
                                        primary_slot_sectors[current_image];
 c00801a:	4990      	ldr	r1, [pc, #576]	; (c00825c <boot_go+0x2a4>)
            fa_id = flash_area_id_from_image_slot(slot);
 c00801c:	2000      	movs	r0, #0
                                        primary_slot_sectors[current_image];
 c00801e:	4411      	add	r1, r2
        BOOT_IMG(&boot_data, BOOT_PRIMARY_SLOT).sectors =
 c008020:	6259      	str	r1, [r3, #36]	; 0x24
                                        secondary_slot_sectors[current_image];
 c008022:	498f      	ldr	r1, [pc, #572]	; (c008260 <boot_go+0x2a8>)
 c008024:	440a      	add	r2, r1
        BOOT_IMG(&boot_data, BOOT_SECONDARY_SLOT).sectors =
 c008026:	655a      	str	r2, [r3, #84]	; 0x54
        boot_data.scratch.sectors = scratch_sectors;
 c008028:	4b8e      	ldr	r3, [pc, #568]	; (c008264 <boot_go+0x2ac>)
 c00802a:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
            fa_id = flash_area_id_from_image_slot(slot);
 c00802e:	f7ff fb77 	bl	c007720 <flash_area_id_from_image_slot>
            rc = flash_area_open(fa_id, &BOOT_IMG_AREA(&boot_data, slot));
 c008032:	7839      	ldrb	r1, [r7, #0]
 c008034:	b2c0      	uxtb	r0, r0
 c008036:	fb06 4101 	mla	r1, r6, r1, r4
 c00803a:	3120      	adds	r1, #32
 c00803c:	f7ff fabc 	bl	c0075b8 <flash_area_open>
            fa_id = flash_area_id_from_image_slot(slot);
 c008040:	2001      	movs	r0, #1
 c008042:	f7ff fb6d 	bl	c007720 <flash_area_id_from_image_slot>
            rc = flash_area_open(fa_id, &BOOT_IMG_AREA(&boot_data, slot));
 c008046:	7839      	ldrb	r1, [r7, #0]
 c008048:	b2c0      	uxtb	r0, r0
 c00804a:	fb06 4101 	mla	r1, r6, r1, r4
 c00804e:	3150      	adds	r1, #80	; 0x50
 c008050:	f7ff fab2 	bl	c0075b8 <flash_area_open>
        rc = flash_area_open(FLASH_AREA_IMAGE_SCRATCH,
 c008054:	4984      	ldr	r1, [pc, #528]	; (c008268 <boot_go+0x2b0>)
 c008056:	2005      	movs	r0, #5
 c008058:	f7ff faae 	bl	c0075b8 <flash_area_open>
    rc = boot_initialize_area(&boot_data, FLASH_AREA_IMAGE_PRIMARY);
 c00805c:	783b      	ldrb	r3, [r7, #0]
        rc = flash_area_open(FLASH_AREA_IMAGE_SCRATCH,
 c00805e:	4606      	mov	r6, r0
    rc = boot_initialize_area(&boot_data, FLASH_AREA_IMAGE_PRIMARY);
 c008060:	b393      	cbz	r3, c0080c8 <boot_go+0x110>
 c008062:	2b01      	cmp	r3, #1
 c008064:	bf14      	ite	ne
 c008066:	20ff      	movne	r0, #255	; 0xff
 c008068:	2002      	moveq	r0, #2
 c00806a:	f7ff ff69 	bl	c007f40 <boot_initialize_area.constprop.10>
    if (rc != 0) {
 c00806e:	bb78      	cbnz	r0, c0080d0 <boot_go+0x118>
    rc = boot_initialize_area(&boot_data, FLASH_AREA_IMAGE_SECONDARY);
 c008070:	782b      	ldrb	r3, [r5, #0]
 c008072:	b35b      	cbz	r3, c0080cc <boot_go+0x114>
 c008074:	2b01      	cmp	r3, #1
 c008076:	bf14      	ite	ne
 c008078:	20ff      	movne	r0, #255	; 0xff
 c00807a:	2004      	moveq	r0, #4
 c00807c:	f7ff ff60 	bl	c007f40 <boot_initialize_area.constprop.10>
    if (rc != 0) {
 c008080:	bb30      	cbnz	r0, c0080d0 <boot_go+0x118>
    rc = boot_initialize_area(&boot_data, FLASH_AREA_IMAGE_SCRATCH);
 c008082:	2005      	movs	r0, #5
 c008084:	f7ff ff5c 	bl	c007f40 <boot_initialize_area.constprop.10>
    if (rc != 0) {
 c008088:	bb10      	cbnz	r0, c0080d0 <boot_go+0x118>
    elem_sz = flash_area_align(BOOT_IMG_AREA(&boot_data, BOOT_PRIMARY_SLOT));
 c00808a:	f04f 0860 	mov.w	r8, #96	; 0x60
 c00808e:	f89b 3000 	ldrb.w	r3, [fp]
 c008092:	fb08 4303 	mla	r3, r8, r3, r4
 c008096:	6a18      	ldr	r0, [r3, #32]
 c008098:	f7ff fb3a 	bl	c007710 <flash_area_align>
 c00809c:	4681      	mov	r9, r0
    align = flash_area_align(BOOT_SCRATCH_AREA(&boot_data));
 c00809e:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
 c0080a2:	f7ff fb35 	bl	c007710 <flash_area_align>
    BOOT_WRITE_SZ(&boot_data) = boot_write_sz();
 c0080a6:	4581      	cmp	r9, r0
 c0080a8:	bf2c      	ite	cs
 c0080aa:	f8c4 90d0 	strcs.w	r9, [r4, #208]	; 0xd0
 c0080ae:	f8c4 00d0 	strcc.w	r0, [r4, #208]	; 0xd0
    rc = boot_read_image_headers(false);
 c0080b2:	f7ff fe5f 	bl	c007d74 <boot_read_image_headers.constprop.8>
 c0080b6:	f89b 1000 	ldrb.w	r1, [fp]
    if (rc != 0) {
 c0080ba:	b198      	cbz	r0, c0080e4 <boot_go+0x12c>
        BOOT_LOG_WRN("Failed reading image headers; Image=%u", current_image);
 c0080bc:	486b      	ldr	r0, [pc, #428]	; (c00826c <boot_go+0x2b4>)
 c0080be:	f000 fbd3 	bl	c008868 <iprintf>
        BOOT_SWAP_TYPE(&boot_data) = BOOT_SWAP_TYPE_NONE;
 c0080c2:	f89b 3000 	ldrb.w	r3, [fp]
 c0080c6:	e008      	b.n	c0080da <boot_go+0x122>
    rc = boot_initialize_area(&boot_data, FLASH_AREA_IMAGE_PRIMARY);
 c0080c8:	2001      	movs	r0, #1
 c0080ca:	e7ce      	b.n	c00806a <boot_go+0xb2>
    rc = boot_initialize_area(&boot_data, FLASH_AREA_IMAGE_SECONDARY);
 c0080cc:	2003      	movs	r0, #3
 c0080ce:	e7d5      	b.n	c00807c <boot_go+0xc4>
        BOOT_LOG_WRN("Failed reading sectors; BOOT_MAX_IMG_SECTORS=%d"
 c0080d0:	216c      	movs	r1, #108	; 0x6c
 c0080d2:	4867      	ldr	r0, [pc, #412]	; (c008270 <boot_go+0x2b8>)
 c0080d4:	f000 fbc8 	bl	c008868 <iprintf>
        BOOT_SWAP_TYPE(&boot_data) = BOOT_SWAP_TYPE_NONE;
 c0080d8:	782b      	ldrb	r3, [r5, #0]
        BOOT_SWAP_TYPE(&boot_data) = BOOT_SWAP_TYPE_NONE;
 c0080da:	2201      	movs	r2, #1
 c0080dc:	4423      	add	r3, r4
 c0080de:	f883 20cc 	strb.w	r2, [r3, #204]	; 0xcc
 c0080e2:	e07a      	b.n	c0081da <boot_go+0x222>
    return BOOT_IMG(state, slot).num_sectors;
 c0080e4:	fb08 4101 	mla	r1, r8, r1, r4
 c0080e8:	6a8b      	ldr	r3, [r1, #40]	; 0x28
    if ((num_sectors_primary > BOOT_MAX_IMG_SECTORS) ||
 c0080ea:	2b6c      	cmp	r3, #108	; 0x6c
 c0080ec:	9300      	str	r3, [sp, #0]
 c0080ee:	d803      	bhi.n	c0080f8 <boot_go+0x140>
 c0080f0:	6d8b      	ldr	r3, [r1, #88]	; 0x58
 c0080f2:	2b6c      	cmp	r3, #108	; 0x6c
 c0080f4:	9301      	str	r3, [sp, #4]
 c0080f6:	d904      	bls.n	c008102 <boot_go+0x14a>
        BOOT_LOG_WRN("Cannot upgrade: more sectors than allowed");
 c0080f8:	485e      	ldr	r0, [pc, #376]	; (c008274 <boot_go+0x2bc>)
                BOOT_LOG_WRN("Cannot upgrade: not all sectors fit inside"
 c0080fa:	f000 fc29 	bl	c008950 <puts>
        BOOT_SWAP_TYPE(&boot_data) = BOOT_SWAP_TYPE_NONE;
 c0080fe:	783b      	ldrb	r3, [r7, #0]
 c008100:	e7eb      	b.n	c0080da <boot_go+0x122>
    j = sz1 = secondary_slot_sz = 0;
 c008102:	4684      	mov	ip, r0
    i = sz0 = primary_slot_sz = 0;
 c008104:	4686      	mov	lr, r0
    j = sz1 = secondary_slot_sz = 0;
 c008106:	4681      	mov	r9, r0
    i = sz0 = primary_slot_sz = 0;
 c008108:	4682      	mov	sl, r0
    return BOOT_SCRATCH_AREA(state)->fa_size;
 c00810a:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 c00810e:	689b      	ldr	r3, [r3, #8]
 c008110:	9303      	str	r3, [sp, #12]
            smaller = sz0 = sz1 = 0;
 c008112:	4680      	mov	r8, r0
 c008114:	4603      	mov	r3, r0
    while (i < num_sectors_primary || j < num_sectors_secondary) {
 c008116:	9a00      	ldr	r2, [sp, #0]
 c008118:	4572      	cmp	r2, lr
 c00811a:	d80b      	bhi.n	c008134 <boot_go+0x17c>
 c00811c:	9a01      	ldr	r2, [sp, #4]
 c00811e:	4562      	cmp	r2, ip
 c008120:	d808      	bhi.n	c008134 <boot_go+0x17c>
    if ((i != num_sectors_primary) ||
 c008122:	9b00      	ldr	r3, [sp, #0]
 c008124:	4573      	cmp	r3, lr
 c008126:	d103      	bne.n	c008130 <boot_go+0x178>
 c008128:	4562      	cmp	r2, ip
 c00812a:	d101      	bne.n	c008130 <boot_go+0x178>
        (j != num_sectors_secondary) ||
 c00812c:	45ca      	cmp	sl, r9
 c00812e:	d035      	beq.n	c00819c <boot_go+0x1e4>
        BOOT_LOG_WRN("Cannot upgrade: slots are not compatible");
 c008130:	4851      	ldr	r0, [pc, #324]	; (c008278 <boot_go+0x2c0>)
 c008132:	e7e2      	b.n	c0080fa <boot_go+0x142>
        if (sz0 == sz1) {
 c008134:	4543      	cmp	r3, r8
 c008136:	d116      	bne.n	c008166 <boot_go+0x1ae>
    return BOOT_IMG(state, slot).sectors[sector].fs_size;
 c008138:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 c00813a:	eb02 02ce 	add.w	r2, r2, lr, lsl #3
            sz0 += boot_img_sector_size(&boot_data, BOOT_PRIMARY_SLOT, i);
 c00813e:	6852      	ldr	r2, [r2, #4]
            i++;
 c008140:	f10e 0e01 	add.w	lr, lr, #1
            sz0 += boot_img_sector_size(&boot_data, BOOT_PRIMARY_SLOT, i);
 c008144:	4413      	add	r3, r2
 c008146:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 c008148:	eb02 02cc 	add.w	r2, r2, ip, lsl #3
            sz1 += boot_img_sector_size(&boot_data, BOOT_SECONDARY_SLOT, j);
 c00814c:	6852      	ldr	r2, [r2, #4]
            j++;
 c00814e:	f10c 0c01 	add.w	ip, ip, #1
            sz1 += boot_img_sector_size(&boot_data, BOOT_SECONDARY_SLOT, j);
 c008152:	4490      	add	r8, r2
        if (sz0 == sz1) {
 c008154:	4543      	cmp	r3, r8
 c008156:	d1de      	bne.n	c008116 <boot_go+0x15e>
            if (sz0 > scratch_sz || sz1 > scratch_sz) {
 c008158:	9a03      	ldr	r2, [sp, #12]
            primary_slot_sz += sz0;
 c00815a:	449a      	add	sl, r3
            if (sz0 > scratch_sz || sz1 > scratch_sz) {
 c00815c:	429a      	cmp	r2, r3
            secondary_slot_sz += sz1;
 c00815e:	4499      	add	r9, r3
            if (sz0 > scratch_sz || sz1 > scratch_sz) {
 c008160:	d21a      	bcs.n	c008198 <boot_go+0x1e0>
                BOOT_LOG_WRN("Cannot upgrade: not all sectors fit inside"
 c008162:	4846      	ldr	r0, [pc, #280]	; (c00827c <boot_go+0x2c4>)
 c008164:	e7c9      	b.n	c0080fa <boot_go+0x142>
        } else if (sz0 < sz1) {
 c008166:	d20c      	bcs.n	c008182 <boot_go+0x1ca>
 c008168:	6a4a      	ldr	r2, [r1, #36]	; 0x24
            if (smaller == 2) {
 c00816a:	2802      	cmp	r0, #2
 c00816c:	eb02 02ce 	add.w	r2, r2, lr, lsl #3
            sz0 += boot_img_sector_size(&boot_data, BOOT_PRIMARY_SLOT, i);
 c008170:	6852      	ldr	r2, [r2, #4]
 c008172:	4413      	add	r3, r2
            if (smaller == 2) {
 c008174:	d101      	bne.n	c00817a <boot_go+0x1c2>
                BOOT_LOG_WRN("Cannot upgrade: slots have non-compatible"
 c008176:	4842      	ldr	r0, [pc, #264]	; (c008280 <boot_go+0x2c8>)
 c008178:	e7bf      	b.n	c0080fa <boot_go+0x142>
            i++;
 c00817a:	f10e 0e01 	add.w	lr, lr, #1
            smaller = 1;
 c00817e:	2001      	movs	r0, #1
 c008180:	e7e8      	b.n	c008154 <boot_go+0x19c>
 c008182:	6d4a      	ldr	r2, [r1, #84]	; 0x54
            if (smaller == 1) {
 c008184:	2801      	cmp	r0, #1
 c008186:	eb02 02cc 	add.w	r2, r2, ip, lsl #3
            sz1 += boot_img_sector_size(&boot_data, BOOT_SECONDARY_SLOT, j);
 c00818a:	6852      	ldr	r2, [r2, #4]
 c00818c:	4490      	add	r8, r2
            if (smaller == 1) {
 c00818e:	d0f2      	beq.n	c008176 <boot_go+0x1be>
            j++;
 c008190:	f10c 0c01 	add.w	ip, ip, #1
            smaller = 2;
 c008194:	2002      	movs	r0, #2
 c008196:	e7dd      	b.n	c008154 <boot_go+0x19c>
            smaller = sz0 = sz1 = 0;
 c008198:	2000      	movs	r0, #0
 c00819a:	e7ba      	b.n	c008112 <boot_go+0x15a>
    memset(bs, 0, sizeof *bs);
 c00819c:	2300      	movs	r3, #0
    bs->idx = BOOT_STATUS_IDX_0;
 c00819e:	f04f 0901 	mov.w	r9, #1
    memset(bs, 0, sizeof *bs);
 c0081a2:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
    bs->idx = BOOT_STATUS_IDX_0;
 c0081a6:	f8cd 9020 	str.w	r9, [sp, #32]
    bs->state = BOOT_STATUS_STATE_0;
 c0081aa:	f88d 9024 	strb.w	r9, [sp, #36]	; 0x24
    bs->swap_type = BOOT_SWAP_TYPE_NONE;
 c0081ae:	f88d 9026 	strb.w	r9, [sp, #38]	; 0x26
    swap_type = boot_swap_type();
 c0081b2:	f7ff f92d 	bl	c007410 <boot_swap_type>
    switch (swap_type) {
 c0081b6:	1e83      	subs	r3, r0, #2
 c0081b8:	2b02      	cmp	r3, #2
    swap_type = boot_swap_type();
 c0081ba:	4680      	mov	r8, r0
    switch (swap_type) {
 c0081bc:	d806      	bhi.n	c0081cc <boot_go+0x214>
        if (boot_validate_slot(BOOT_SECONDARY_SLOT, bs) != 0) {
 c0081be:	4648      	mov	r0, r9
 c0081c0:	f7ff fe44 	bl	c007e4c <boot_validate_slot.isra.2>
            swap_type = BOOT_SWAP_TYPE_FAIL;
 c0081c4:	2800      	cmp	r0, #0
 c0081c6:	bf18      	it	ne
 c0081c8:	f04f 0805 	movne.w	r8, #5
                BOOT_SWAP_TYPE(&boot_data) = boot_validated_swap_type(bs);
 c0081cc:	783b      	ldrb	r3, [r7, #0]
            boot_review_image_swap_types(false);
 c0081ce:	2000      	movs	r0, #0
                BOOT_SWAP_TYPE(&boot_data) = boot_validated_swap_type(bs);
 c0081d0:	4423      	add	r3, r4
 c0081d2:	f883 80cc 	strb.w	r8, [r3, #204]	; 0xcc
            boot_review_image_swap_types(false);
 c0081d6:	f7ff fd87 	bl	c007ce8 <boot_review_image_swap_types>
    for (current_image = 0; current_image < BOOT_IMAGE_NUMBER; ++current_image)
 c0081da:	783b      	ldrb	r3, [r7, #0]
 c0081dc:	3301      	adds	r3, #1
 c0081de:	703b      	strb	r3, [r7, #0]
 c0081e0:	e6f5      	b.n	c007fce <boot_go+0x16>
    if (BOOT_SWAP_TYPE(&boot_data) != BOOT_SWAP_TYPE_NONE &&
 c0081e2:	4423      	add	r3, r4
 c0081e4:	f893 70cc 	ldrb.w	r7, [r3, #204]	; 0xcc
 c0081e8:	f007 07fb 	and.w	r7, r7, #251	; 0xfb
 c0081ec:	f117 37ff 	adds.w	r7, r7, #4294967295
 c0081f0:	bf18      	it	ne
 c0081f2:	2701      	movne	r7, #1
    rc = flash_area_open(flash_area_id_from_image_slot(slot), &fap);
 c0081f4:	4638      	mov	r0, r7
 c0081f6:	f7ff fa93 	bl	c007720 <flash_area_id_from_image_slot>
 c0081fa:	a905      	add	r1, sp, #20
 c0081fc:	b2c0      	uxtb	r0, r0
 c0081fe:	f7ff f9db 	bl	c0075b8 <flash_area_open>
    if (rc != 0) {
 c008202:	b160      	cbz	r0, c00821e <boot_go+0x266>
        rc = BOOT_EFLASH;
 c008204:	f04f 0801 	mov.w	r8, #1
    flash_area_close(fap);
 c008208:	9805      	ldr	r0, [sp, #20]
 c00820a:	f7ff f9ef 	bl	c0075ec <flash_area_close>
        if (rc == 0) {
 c00820e:	f1b8 0f00 	cmp.w	r8, #0
 c008212:	f040 809e 	bne.w	c008352 <boot_go+0x39a>
            current_image++;
 c008216:	782b      	ldrb	r3, [r5, #0]
 c008218:	3301      	adds	r3, #1
            current_image = 0;
 c00821a:	702b      	strb	r3, [r5, #0]
 c00821c:	e6dc      	b.n	c007fd8 <boot_go+0x20>
    off = hdr->ih_hdr_size + hdr->ih_img_size;
 c00821e:	2360      	movs	r3, #96	; 0x60
    return &BOOT_IMG(state, slot).hdr;
 c008220:	782a      	ldrb	r2, [r5, #0]
    rc = flash_area_read(fap, off, &info, sizeof(info));
 c008222:	9805      	ldr	r0, [sp, #20]
    off = hdr->ih_hdr_size + hdr->ih_img_size;
 c008224:	4353      	muls	r3, r2
 c008226:	2230      	movs	r2, #48	; 0x30
 c008228:	fb02 3707 	mla	r7, r2, r7, r3
 c00822c:	4427      	add	r7, r4
 c00822e:	893a      	ldrh	r2, [r7, #8]
 c008230:	68ff      	ldr	r7, [r7, #12]
    rc = flash_area_read(fap, off, &info, sizeof(info));
 c008232:	2304      	movs	r3, #4
    off = hdr->ih_hdr_size + hdr->ih_img_size;
 c008234:	4417      	add	r7, r2
    rc = flash_area_read(fap, off, &info, sizeof(info));
 c008236:	4639      	mov	r1, r7
 c008238:	aa06      	add	r2, sp, #24
 c00823a:	f7ff fa0d 	bl	c007658 <flash_area_read>
    if (rc != 0) {
 c00823e:	2800      	cmp	r0, #0
 c008240:	d1e0      	bne.n	c008204 <boot_go+0x24c>
    if (info.it_magic != IMAGE_TLV_INFO_MAGIC) {
 c008242:	f646 1307 	movw	r3, #26887	; 0x6907
 c008246:	f8bd 2018 	ldrh.w	r2, [sp, #24]
 c00824a:	429a      	cmp	r2, r3
 c00824c:	d01c      	beq.n	c008288 <boot_go+0x2d0>
        rc = BOOT_EBADIMAGE;
 c00824e:	f04f 0803 	mov.w	r8, #3
 c008252:	e7d9      	b.n	c008208 <boot_go+0x250>
 c008254:	3003277c 	.word	0x3003277c
 c008258:	300322a8 	.word	0x300322a8
 c00825c:	30032780 	.word	0x30032780
 c008260:	300331a0 	.word	0x300331a0
 c008264:	30032e40 	.word	0x30032e40
 c008268:	30032368 	.word	0x30032368
 c00826c:	0c00a8f5 	.word	0x0c00a8f5
 c008270:	0c00a8b0 	.word	0x0c00a8b0
 c008274:	0c00a924 	.word	0x0c00a924
 c008278:	0c00a9c8 	.word	0x0c00a9c8
 c00827c:	0c00a98e 	.word	0x0c00a98e
 c008280:	0c00a955 	.word	0x0c00a955
 c008284:	0c00ab17 	.word	0x0c00ab17
    if (boot_add_uint32_overflow_check(off, (info.it_tlv_tot + sizeof(info)))) {
 c008288:	f8bd 101a 	ldrh.w	r1, [sp, #26]
 c00828c:	4638      	mov	r0, r7
 c00828e:	3104      	adds	r1, #4
 c008290:	f7ff f945 	bl	c00751e <boot_add_uint32_overflow_check>
 c008294:	4680      	mov	r8, r0
 c008296:	2800      	cmp	r0, #0
 c008298:	f47f aea2 	bne.w	c007fe0 <boot_go+0x28>
    end = off + info.it_tlv_tot;
 c00829c:	f8bd 901a 	ldrh.w	r9, [sp, #26]
 c0082a0:	44b9      	add	r9, r7
    off += sizeof(info);
 c0082a2:	3704      	adds	r7, #4
    while(off < end) {
 c0082a4:	45b9      	cmp	r9, r7
 c0082a6:	9805      	ldr	r0, [sp, #20]
 c0082a8:	d940      	bls.n	c00832c <boot_go+0x374>
        rc = flash_area_read(fap, off, &tlv, sizeof(tlv));
 c0082aa:	2304      	movs	r3, #4
 c0082ac:	aa07      	add	r2, sp, #28
 c0082ae:	4639      	mov	r1, r7
 c0082b0:	f7ff f9d2 	bl	c007658 <flash_area_read>
        if (rc != 0) {
 c0082b4:	2800      	cmp	r0, #0
 c0082b6:	d1a5      	bne.n	c008204 <boot_go+0x24c>
        if (tlv.it_type == IMAGE_TLV_DEPENDENCY) {
 c0082b8:	f89d 301c 	ldrb.w	r3, [sp, #28]
 c0082bc:	2b40      	cmp	r3, #64	; 0x40
 c0082be:	d132      	bne.n	c008326 <boot_go+0x36e>
            if (tlv.it_len != sizeof(dep)) {
 c0082c0:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 c0082c4:	9805      	ldr	r0, [sp, #20]
 c0082c6:	2b0c      	cmp	r3, #12
 c0082c8:	d1c1      	bne.n	c00824e <boot_go+0x296>
            rc = flash_area_read(fap, off + sizeof(tlv), &dep, tlv.it_len);
 c0082ca:	aa0b      	add	r2, sp, #44	; 0x2c
 c0082cc:	1d39      	adds	r1, r7, #4
 c0082ce:	f7ff f9c3 	bl	c007658 <flash_area_read>
            if (rc != 0) {
 c0082d2:	2800      	cmp	r0, #0
 c0082d4:	d196      	bne.n	c008204 <boot_go+0x24c>
    dep_slot = (boot_data.swap_type[dep->image_id] != BOOT_SWAP_TYPE_NONE) ?
 c0082d6:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
    dep_version = &boot_data.imgs[dep->image_id][dep_slot].hdr.ih_ver;
 c0082da:	2014      	movs	r0, #20
    dep_slot = (boot_data.swap_type[dep->image_id] != BOOT_SWAP_TYPE_NONE) ?
 c0082dc:	18a3      	adds	r3, r4, r2
                BOOT_SECONDARY_SLOT : BOOT_PRIMARY_SLOT;
 c0082de:	f893 10cc 	ldrb.w	r1, [r3, #204]	; 0xcc
    dep_version = &boot_data.imgs[dep->image_id][dep_slot].hdr.ih_ver;
 c0082e2:	2360      	movs	r3, #96	; 0x60
                BOOT_SECONDARY_SLOT : BOOT_PRIMARY_SLOT;
 c0082e4:	f111 31ff 	adds.w	r1, r1, #4294967295
    dep_version = &boot_data.imgs[dep->image_id][dep_slot].hdr.ih_ver;
 c0082e8:	fb13 0302 	smlabb	r3, r3, r2, r0
                BOOT_SECONDARY_SLOT : BOOT_PRIMARY_SLOT;
 c0082ec:	bf18      	it	ne
 c0082ee:	2101      	movne	r1, #1
    dep_version = &boot_data.imgs[dep->image_id][dep_slot].hdr.ih_ver;
 c0082f0:	2230      	movs	r2, #48	; 0x30
 c0082f2:	fb02 3101 	mla	r1, r2, r1, r3
    rc = boot_is_version_sufficient(&dep->image_min_version, dep_version);
 c0082f6:	eb0d 0002 	add.w	r0, sp, r2
 c0082fa:	4421      	add	r1, r4
 c0082fc:	f7ff f8fa 	bl	c0074f4 <boot_is_version_sufficient>
    if (rc != 0) {
 c008300:	4680      	mov	r8, r0
 c008302:	b1b0      	cbz	r0, c008332 <boot_go+0x37a>
        switch (BOOT_SWAP_TYPE(&boot_data)) {
 c008304:	782b      	ldrb	r3, [r5, #0]
 c008306:	4423      	add	r3, r4
 c008308:	f893 20cc 	ldrb.w	r2, [r3, #204]	; 0xcc
 c00830c:	2a01      	cmp	r2, #1
 c00830e:	d008      	beq.n	c008322 <boot_go+0x36a>
 c008310:	f4ff af7a 	bcc.w	c008208 <boot_go+0x250>
 c008314:	2a03      	cmp	r2, #3
 c008316:	f63f af77 	bhi.w	c008208 <boot_go+0x250>
            BOOT_SWAP_TYPE(&boot_data) = BOOT_SWAP_TYPE_NONE;
 c00831a:	2201      	movs	r2, #1
            BOOT_SWAP_TYPE(&boot_data) = BOOT_SWAP_TYPE_REVERT;
 c00831c:	f883 20cc 	strb.w	r2, [r3, #204]	; 0xcc
 c008320:	e772      	b.n	c008208 <boot_go+0x250>
 c008322:	2204      	movs	r2, #4
 c008324:	e7fa      	b.n	c00831c <boot_go+0x364>
        } else if (dep_tlvs_found) {
 c008326:	f1b8 0f00 	cmp.w	r8, #0
 c00832a:	d004      	beq.n	c008336 <boot_go+0x37e>
        rc = flash_area_read(fap, off, &tlv, sizeof(tlv));
 c00832c:	f04f 0800 	mov.w	r8, #0
 c008330:	e76a      	b.n	c008208 <boot_go+0x250>
    if (rc != 0) {
 c008332:	f04f 0801 	mov.w	r8, #1
        if (boot_add_uint32_overflow_check(off, (sizeof(tlv) + tlv.it_len))) {
 c008336:	f8bd 101e 	ldrh.w	r1, [sp, #30]
 c00833a:	4638      	mov	r0, r7
 c00833c:	3104      	adds	r1, #4
 c00833e:	f7ff f8ee 	bl	c00751e <boot_add_uint32_overflow_check>
 c008342:	2800      	cmp	r0, #0
 c008344:	f47f ae4c 	bne.w	c007fe0 <boot_go+0x28>
            off += sizeof(tlv) + tlv.it_len;
 c008348:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 c00834c:	3304      	adds	r3, #4
 c00834e:	441f      	add	r7, r3
 c008350:	e7a8      	b.n	c0082a4 <boot_go+0x2ec>
        } else if (rc == BOOT_EBADVERSION) {
 c008352:	f1b8 0f09 	cmp.w	r8, #9
 c008356:	f47f ae43 	bne.w	c007fe0 <boot_go+0x28>
            current_image = 0;
 c00835a:	2300      	movs	r3, #0
 c00835c:	e75d      	b.n	c00821a <boot_go+0x262>
        memset(&bs, 0, sizeof bs);
 c00835e:	e9cd 2209 	strd	r2, r2, [sp, #36]	; 0x24
        bs.idx = BOOT_STATUS_IDX_0;
 c008362:	2201      	movs	r2, #1
 c008364:	9208      	str	r2, [sp, #32]
        bs.state = BOOT_STATUS_STATE_0;
 c008366:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
        bs.swap_type = BOOT_SWAP_TYPE(&boot_data);
 c00836a:	18e2      	adds	r2, r4, r3
 c00836c:	f892 20cc 	ldrb.w	r2, [r2, #204]	; 0xcc
 c008370:	f88d 2026 	strb.w	r2, [sp, #38]	; 0x26
        switch (BOOT_SWAP_TYPE(&boot_data)) {
 c008374:	3a01      	subs	r2, #1
 c008376:	2a04      	cmp	r2, #4
 c008378:	f200 809d 	bhi.w	c0084b6 <boot_go+0x4fe>
 c00837c:	e8df f002 	tbb	[pc, r2]
 c008380:	03030350 	.word	0x03030350
 c008384:	50          	.byte	0x50
 c008385:	00          	.byte	0x00
    BOOT_LOG_INF("Image upgrade secondary slot -> primary slot");
 c008386:	487b      	ldr	r0, [pc, #492]	; (c008574 <boot_go+0x5bc>)
 c008388:	f000 fae2 	bl	c008950 <puts>
    BOOT_LOG_INF("Erasing the primary slot");
 c00838c:	487a      	ldr	r0, [pc, #488]	; (c008578 <boot_go+0x5c0>)
 c00838e:	f000 fadf 	bl	c008950 <puts>
    rc = flash_area_open(FLASH_AREA_IMAGE_PRIMARY, &fap_primary_slot);
 c008392:	782b      	ldrb	r3, [r5, #0]
 c008394:	2b00      	cmp	r3, #0
 c008396:	d04d      	beq.n	c008434 <boot_go+0x47c>
 c008398:	2b01      	cmp	r3, #1
 c00839a:	bf14      	ite	ne
 c00839c:	20ff      	movne	r0, #255	; 0xff
 c00839e:	2002      	moveq	r0, #2
 c0083a0:	a907      	add	r1, sp, #28
 c0083a2:	f7ff f909 	bl	c0075b8 <flash_area_open>
    rc = flash_area_open(FLASH_AREA_IMAGE_SECONDARY, &fap_secondary_slot);
 c0083a6:	782b      	ldrb	r3, [r5, #0]
 c0083a8:	2b00      	cmp	r3, #0
 c0083aa:	d045      	beq.n	c008438 <boot_go+0x480>
 c0083ac:	2b01      	cmp	r3, #1
 c0083ae:	bf14      	ite	ne
 c0083b0:	20ff      	movne	r0, #255	; 0xff
 c0083b2:	2004      	moveq	r0, #4
    size_t size = 0;
 c0083b4:	2600      	movs	r6, #0
    return BOOT_IMG(state, slot).num_sectors;
 c0083b6:	f04f 0860 	mov.w	r8, #96	; 0x60
    for (sect = 0; sect < sect_count; sect++) {
 c0083ba:	4637      	mov	r7, r6
    rc = flash_area_open(FLASH_AREA_IMAGE_SECONDARY, &fap_secondary_slot);
 c0083bc:	a90b      	add	r1, sp, #44	; 0x2c
 c0083be:	f7ff f8fb 	bl	c0075b8 <flash_area_open>
 c0083c2:	782b      	ldrb	r3, [r5, #0]
 c0083c4:	fb08 4303 	mla	r3, r8, r3, r4
 c0083c8:	f8d3 a028 	ldr.w	sl, [r3, #40]	; 0x28
    for (sect = 0; sect < sect_count; sect++) {
 c0083cc:	45ba      	cmp	sl, r7
 c0083ce:	d135      	bne.n	c00843c <boot_go+0x484>
    bytes_copied = 0;
 c0083d0:	2700      	movs	r7, #0
    BOOT_LOG_INF("Copying the secondary slot to the primary slot: 0x%zx bytes",
 c0083d2:	4631      	mov	r1, r6
 c0083d4:	4869      	ldr	r0, [pc, #420]	; (c00857c <boot_go+0x5c4>)
 c0083d6:	f000 fa47 	bl	c008868 <iprintf>
    rc = boot_copy_sector(fap_secondary_slot, fap_primary_slot, 0, 0, size);
 c0083da:	9b07      	ldr	r3, [sp, #28]
 c0083dc:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
        rc = flash_area_read(fap_src, off_src + bytes_copied, buf, chunk_sz);
 c0083e0:	f8df 91a8 	ldr.w	r9, [pc, #424]	; c00858c <boot_go+0x5d4>
    rc = boot_copy_sector(fap_secondary_slot, fap_primary_slot, 0, 0, size);
 c0083e4:	9300      	str	r3, [sp, #0]
    while (bytes_copied < sz) {
 c0083e6:	42be      	cmp	r6, r7
 c0083e8:	d90d      	bls.n	c008406 <boot_go+0x44e>
        if (sz - bytes_copied > sizeof(buf)) {
 c0083ea:	eba6 0807 	sub.w	r8, r6, r7
 c0083ee:	f5b8 6f80 	cmp.w	r8, #1024	; 0x400
 c0083f2:	bf28      	it	cs
 c0083f4:	f44f 6880 	movcs.w	r8, #1024	; 0x400
        rc = flash_area_read(fap_src, off_src + bytes_copied, buf, chunk_sz);
 c0083f8:	464a      	mov	r2, r9
 c0083fa:	4643      	mov	r3, r8
 c0083fc:	4639      	mov	r1, r7
 c0083fe:	4650      	mov	r0, sl
 c008400:	f7ff f92a 	bl	c007658 <flash_area_read>
        if (rc != 0) {
 c008404:	b358      	cbz	r0, c00845e <boot_go+0x4a6>
    return &BOOT_IMG(state, slot).hdr;
 c008406:	2760      	movs	r7, #96	; 0x60
 c008408:	f89b 0000 	ldrb.w	r0, [fp]
 c00840c:	fb07 4000 	mla	r0, r7, r0, r4
    rc = boot_update_security_counter(BOOT_PRIMARY_SLOT,
 c008410:	3030      	adds	r0, #48	; 0x30
 c008412:	f7ff fc8b 	bl	c007d2c <boot_update_security_counter.constprop.7>
    if (rc != 0) {
 c008416:	4606      	mov	r6, r0
 c008418:	b358      	cbz	r0, c008472 <boot_go+0x4ba>
        BOOT_LOG_ERR("Security counter update failed after image upgrade.");
 c00841a:	4859      	ldr	r0, [pc, #356]	; (c008580 <boot_go+0x5c8>)
 c00841c:	f000 fa98 	bl	c008950 <puts>
        if (BOOT_SWAP_TYPE(&boot_data) == BOOT_SWAP_TYPE_PANIC) {
 c008420:	782b      	ldrb	r3, [r5, #0]
 c008422:	18e2      	adds	r2, r4, r3
 c008424:	f892 20cc 	ldrb.w	r2, [r2, #204]	; 0xcc
 c008428:	2aff      	cmp	r2, #255	; 0xff
 c00842a:	d149      	bne.n	c0084c0 <boot_go+0x508>
            BOOT_LOG_ERR("panic!");
 c00842c:	4855      	ldr	r0, [pc, #340]	; (c008584 <boot_go+0x5cc>)
 c00842e:	f000 fa8f 	bl	c008950 <puts>
 c008432:	e7fe      	b.n	c008432 <boot_go+0x47a>
    rc = flash_area_open(FLASH_AREA_IMAGE_PRIMARY, &fap_primary_slot);
 c008434:	2001      	movs	r0, #1
 c008436:	e7b3      	b.n	c0083a0 <boot_go+0x3e8>
    rc = flash_area_open(FLASH_AREA_IMAGE_SECONDARY, &fap_secondary_slot);
 c008438:	2003      	movs	r0, #3
 c00843a:	e7bb      	b.n	c0083b4 <boot_go+0x3fc>
    return BOOT_IMG(state, slot).sectors[sector].fs_size;
 c00843c:	f89b 3000 	ldrb.w	r3, [fp]
    return flash_area_erase(fap, off, sz);
 c008440:	4631      	mov	r1, r6
 c008442:	fb08 4303 	mla	r3, r8, r3, r4
 c008446:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 c008448:	9807      	ldr	r0, [sp, #28]
 c00844a:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 c00844e:	f8d3 9004 	ldr.w	r9, [r3, #4]
    for (sect = 0; sect < sect_count; sect++) {
 c008452:	3701      	adds	r7, #1
    return flash_area_erase(fap, off, sz);
 c008454:	464a      	mov	r2, r9
 c008456:	f7ff f93d 	bl	c0076d4 <flash_area_erase>
        size += this_size;
 c00845a:	444e      	add	r6, r9
 c00845c:	e7b6      	b.n	c0083cc <boot_go+0x414>
        rc = flash_area_write(fap_dst, off_dst + bytes_copied, buf, chunk_sz);
 c00845e:	4643      	mov	r3, r8
 c008460:	464a      	mov	r2, r9
 c008462:	4639      	mov	r1, r7
 c008464:	9800      	ldr	r0, [sp, #0]
 c008466:	f7ff f927 	bl	c0076b8 <flash_area_write>
        if (rc != 0) {
 c00846a:	2800      	cmp	r0, #0
 c00846c:	d1cb      	bne.n	c008406 <boot_go+0x44e>
        bytes_copied += chunk_sz;
 c00846e:	4447      	add	r7, r8
 c008470:	e7b9      	b.n	c0083e6 <boot_go+0x42e>
    return BOOT_IMG(state, slot).sectors[sector].fs_off -
 c008472:	f89b 3000 	ldrb.w	r3, [fp]
    return flash_area_erase(fap, off, sz);
 c008476:	4601      	mov	r1, r0
 c008478:	fb07 4303 	mla	r3, r7, r3, r4
    return BOOT_IMG(state, slot).sectors[sector].fs_size;
 c00847c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 c00847e:	980b      	ldr	r0, [sp, #44]	; 0x2c
 c008480:	685a      	ldr	r2, [r3, #4]
 c008482:	f7ff f927 	bl	c0076d4 <flash_area_erase>
    return BOOT_IMG(state, slot).num_sectors;
 c008486:	f89b 3000 	ldrb.w	r3, [fp]
    return BOOT_IMG(state, slot).sectors[sector].fs_off -
 c00848a:	fb07 4303 	mla	r3, r7, r3, r4
    last_sector = boot_img_num_sectors(&boot_data, BOOT_SECONDARY_SLOT) - 1;
 c00848e:	e9d3 2315 	ldrd	r2, r3, [r3, #84]	; 0x54
 c008492:	3b01      	subs	r3, #1
 c008494:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
 c008498:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
 c00849c:	6813      	ldr	r3, [r2, #0]
    return flash_area_erase(fap, off, sz);
 c00849e:	6842      	ldr	r2, [r0, #4]
 c0084a0:	1ac9      	subs	r1, r1, r3
 c0084a2:	980b      	ldr	r0, [sp, #44]	; 0x2c
 c0084a4:	f7ff f916 	bl	c0076d4 <flash_area_erase>
    flash_area_close(fap_primary_slot);
 c0084a8:	9807      	ldr	r0, [sp, #28]
 c0084aa:	f7ff f89f 	bl	c0075ec <flash_area_close>
    flash_area_close(fap_secondary_slot);
 c0084ae:	980b      	ldr	r0, [sp, #44]	; 0x2c
 c0084b0:	f7ff f89c 	bl	c0075ec <flash_area_close>
            break;
 c0084b4:	e7b4      	b.n	c008420 <boot_go+0x468>
            BOOT_SWAP_TYPE(&boot_data) = BOOT_SWAP_TYPE_PANIC;
 c0084b6:	22ff      	movs	r2, #255	; 0xff
 c0084b8:	4423      	add	r3, r4
 c0084ba:	f883 20cc 	strb.w	r2, [r3, #204]	; 0xcc
 c0084be:	e7af      	b.n	c008420 <boot_go+0x468>
    for (current_image = 0; current_image < BOOT_IMAGE_NUMBER; ++current_image)
 c0084c0:	3301      	adds	r3, #1
 c0084c2:	e58e      	b.n	c007fe2 <boot_go+0x2a>
        if (BOOT_SWAP_TYPE(&boot_data) != BOOT_SWAP_TYPE_NONE) {
 c0084c4:	4423      	add	r3, r4
 c0084c6:	f893 30cc 	ldrb.w	r3, [r3, #204]	; 0xcc
 c0084ca:	2b01      	cmp	r3, #1
 c0084cc:	d105      	bne.n	c0084da <boot_go+0x522>
        rc = boot_validate_slot(BOOT_PRIMARY_SLOT, NULL);
 c0084ce:	2000      	movs	r0, #0
 c0084d0:	f7ff fcbc 	bl	c007e4c <boot_validate_slot.isra.2>
        if (rc != 0) {
 c0084d4:	b180      	cbz	r0, c0084f8 <boot_go+0x540>
            rc = BOOT_EBADIMAGE;
 c0084d6:	2603      	movs	r6, #3
 c0084d8:	e004      	b.n	c0084e4 <boot_go+0x52c>
            rc = boot_read_image_headers(false);
 c0084da:	f7ff fc4b 	bl	c007d74 <boot_read_image_headers.constprop.8>
            if (rc != 0) {
 c0084de:	4606      	mov	r6, r0
 c0084e0:	2800      	cmp	r0, #0
 c0084e2:	d0f4      	beq.n	c0084ce <boot_go+0x516>
            boot_img_hdr(&boot_data, BOOT_PRIMARY_SLOT);

 out:
    for (current_image = 0; current_image < BOOT_IMAGE_NUMBER; ++current_image)
 c0084e4:	2300      	movs	r3, #0
    {
        flash_area_close(BOOT_SCRATCH_AREA(&boot_data));
        for (slot = 0; slot < BOOT_NUM_SLOTS; slot++) {
            flash_area_close(BOOT_IMG_AREA(&boot_data,
 c0084e6:	2760      	movs	r7, #96	; 0x60
    for (current_image = 0; current_image < BOOT_IMAGE_NUMBER; ++current_image)
 c0084e8:	702b      	strb	r3, [r5, #0]
 c0084ea:	782b      	ldrb	r3, [r5, #0]
 c0084ec:	2b01      	cmp	r3, #1
 c0084ee:	d92d      	bls.n	c00854c <boot_go+0x594>
                                           BOOT_NUM_SLOTS - 1 - slot));
        }
    }
    return rc;
}
 c0084f0:	4630      	mov	r0, r6
 c0084f2:	b00f      	add	sp, #60	; 0x3c
 c0084f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (BOOT_SWAP_TYPE(&boot_data) == BOOT_SWAP_TYPE_NONE) {
 c0084f8:	7828      	ldrb	r0, [r5, #0]
 c0084fa:	1823      	adds	r3, r4, r0
 c0084fc:	f893 30cc 	ldrb.w	r3, [r3, #204]	; 0xcc
 c008500:	2b01      	cmp	r3, #1
 c008502:	d10b      	bne.n	c00851c <boot_go+0x564>
            rc = boot_update_security_counter(BOOT_PRIMARY_SLOT,
 c008504:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 c008508:	eb04 1040 	add.w	r0, r4, r0, lsl #5
 c00850c:	f7ff fc0e 	bl	c007d2c <boot_update_security_counter.constprop.7>
            if (rc != 0) {
 c008510:	4606      	mov	r6, r0
 c008512:	b118      	cbz	r0, c00851c <boot_go+0x564>
                BOOT_LOG_ERR("Security counter update failed after image "
 c008514:	481c      	ldr	r0, [pc, #112]	; (c008588 <boot_go+0x5d0>)
 c008516:	f000 fa1b 	bl	c008950 <puts>
                goto out;
 c00851a:	e7e3      	b.n	c0084e4 <boot_go+0x52c>
        rc = boot_save_boot_status((current_image == 0) ? SW_SPE : SW_NSPE,
 c00851c:	7829      	ldrb	r1, [r5, #0]
 c00851e:	fb07 4301 	mla	r3, r7, r1, r4
 c008522:	2900      	cmp	r1, #0
    return &BOOT_IMG(state, slot).hdr;
 c008524:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 c008528:	6a1a      	ldr	r2, [r3, #32]
 c00852a:	eb04 1141 	add.w	r1, r4, r1, lsl #5
 c00852e:	bf14      	ite	ne
 c008530:	2005      	movne	r0, #5
 c008532:	2004      	moveq	r0, #4
 c008534:	f7fe fe20 	bl	c007178 <boot_save_boot_status>
        if (rc) {
 c008538:	4606      	mov	r6, r0
 c00853a:	b118      	cbz	r0, c008544 <boot_go+0x58c>
            BOOT_LOG_ERR("Failed to add Image %u data to shared area",
 c00853c:	7829      	ldrb	r1, [r5, #0]
 c00853e:	4640      	mov	r0, r8
 c008540:	f000 f992 	bl	c008868 <iprintf>
    for (current_image = 0; current_image < BOOT_IMAGE_NUMBER; ++current_image)
 c008544:	782b      	ldrb	r3, [r5, #0]
 c008546:	3301      	adds	r3, #1
 c008548:	702b      	strb	r3, [r5, #0]
 c00854a:	e554      	b.n	c007ff6 <boot_go+0x3e>
        flash_area_close(BOOT_SCRATCH_AREA(&boot_data));
 c00854c:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
 c008550:	f7ff f84c 	bl	c0075ec <flash_area_close>
            flash_area_close(BOOT_IMG_AREA(&boot_data,
 c008554:	782b      	ldrb	r3, [r5, #0]
 c008556:	fb07 4303 	mla	r3, r7, r3, r4
 c00855a:	6d18      	ldr	r0, [r3, #80]	; 0x50
 c00855c:	f7ff f846 	bl	c0075ec <flash_area_close>
 c008560:	782b      	ldrb	r3, [r5, #0]
 c008562:	fb07 4303 	mla	r3, r7, r3, r4
 c008566:	6a18      	ldr	r0, [r3, #32]
 c008568:	f7ff f840 	bl	c0075ec <flash_area_close>
    for (current_image = 0; current_image < BOOT_IMAGE_NUMBER; ++current_image)
 c00856c:	782b      	ldrb	r3, [r5, #0]
 c00856e:	3301      	adds	r3, #1
 c008570:	702b      	strb	r3, [r5, #0]
 c008572:	e7ba      	b.n	c0084ea <boot_go+0x532>
 c008574:	0c00a9f8 	.word	0x0c00a9f8
 c008578:	0c00aa2c 	.word	0x0c00aa2c
 c00857c:	0c00aa4c 	.word	0x0c00aa4c
 c008580:	0c00aa90 	.word	0x0c00aa90
 c008584:	0c00aacb 	.word	0x0c00aacb
 c008588:	0c00aad9 	.word	0x0c00aad9
 c00858c:	3003237c 	.word	0x3003237c

0c008590 <boot_nv_security_counter_init>:

    return (enum tfm_nv_counter_t)nv_counter;
}

int32_t boot_nv_security_counter_init(void)
{
 c008590:	b508      	push	{r3, lr}
    enum tfm_plat_err_t err;

    err = tfm_plat_init_nv_counter();
 c008592:	f7f8 fbe9 	bl	c000d68 <tfm_plat_init_nv_counter>
    if (err != TFM_PLAT_ERR_SUCCESS) {
 c008596:	3000      	adds	r0, #0
 c008598:	bf18      	it	ne
 c00859a:	2001      	movne	r0, #1
        return -1;
    }

    return 0;
}
 c00859c:	4240      	negs	r0, r0
 c00859e:	bd08      	pop	{r3, pc}

0c0085a0 <boot_nv_security_counter_get>:

int32_t boot_nv_security_counter_get(uint32_t image_id, uint32_t *security_cnt)
{
 c0085a0:	b508      	push	{r3, lr}
    enum tfm_nv_counter_t nv_counter;
    enum tfm_plat_err_t err;

    /* Check if it's a null-pointer. */
    if (!security_cnt) {
 c0085a2:	460a      	mov	r2, r1
 c0085a4:	b169      	cbz	r1, c0085c2 <boot_nv_security_counter_get+0x22>
    if ((UINT32_MAX - TFM_BOOT_NV_COUNTER_0) < image_id) {
 c0085a6:	1d03      	adds	r3, r0, #4
 c0085a8:	d80b      	bhi.n	c0085c2 <boot_nv_security_counter_get+0x22>
    nv_counter = TFM_BOOT_NV_COUNTER_0 + image_id;
 c0085aa:	3003      	adds	r0, #3
    if (nv_counter >= TFM_BOOT_NV_COUNTER_MAX) {
 c0085ac:	2804      	cmp	r0, #4
 c0085ae:	d808      	bhi.n	c0085c2 <boot_nv_security_counter_get+0x22>
    nv_counter = get_nv_counter_from_image_id(image_id);
    if (nv_counter == TFM_BOOT_NV_COUNTER_MAX) {
        return -1;
    }

    err = tfm_plat_read_nv_counter(nv_counter,
 c0085b0:	2104      	movs	r1, #4
 c0085b2:	b2c0      	uxtb	r0, r0
 c0085b4:	f7f8 fb94 	bl	c000ce0 <tfm_plat_read_nv_counter>
                                   sizeof(*security_cnt),
                                   (uint8_t *)security_cnt);
    if (err != TFM_PLAT_ERR_SUCCESS) {
 c0085b8:	3000      	adds	r0, #0
 c0085ba:	bf18      	it	ne
 c0085bc:	2001      	movne	r0, #1
 c0085be:	4240      	negs	r0, r0
        return -1;
    }

    return 0;
}
 c0085c0:	bd08      	pop	{r3, pc}
        return -1;
 c0085c2:	f04f 30ff 	mov.w	r0, #4294967295
 c0085c6:	e7fb      	b.n	c0085c0 <boot_nv_security_counter_get+0x20>

0c0085c8 <boot_nv_security_counter_update>:

int32_t boot_nv_security_counter_update(uint32_t image_id,
                                        uint32_t img_security_cnt)
{
 c0085c8:	b508      	push	{r3, lr}
    if ((UINT32_MAX - TFM_BOOT_NV_COUNTER_0) < image_id) {
 c0085ca:	1d03      	adds	r3, r0, #4
 c0085cc:	d80a      	bhi.n	c0085e4 <boot_nv_security_counter_update+0x1c>
    nv_counter = TFM_BOOT_NV_COUNTER_0 + image_id;
 c0085ce:	3003      	adds	r0, #3
    if (nv_counter >= TFM_BOOT_NV_COUNTER_MAX) {
 c0085d0:	2804      	cmp	r0, #4
 c0085d2:	d807      	bhi.n	c0085e4 <boot_nv_security_counter_update+0x1c>
    nv_counter = get_nv_counter_from_image_id(image_id);
    if (nv_counter == TFM_BOOT_NV_COUNTER_MAX) {
        return -1;
    }

    err = tfm_plat_set_nv_counter(nv_counter, img_security_cnt);
 c0085d4:	b2c0      	uxtb	r0, r0
 c0085d6:	f7f8 fce9 	bl	c000fac <tfm_plat_set_nv_counter>
    if (err != TFM_PLAT_ERR_SUCCESS) {
 c0085da:	3000      	adds	r0, #0
 c0085dc:	bf18      	it	ne
 c0085de:	2001      	movne	r0, #1
 c0085e0:	4240      	negs	r0, r0
        return -1;
    }

    return 0;
}
 c0085e2:	bd08      	pop	{r3, pc}
        return -1;
 c0085e4:	f04f 30ff 	mov.w	r0, #4294967295
 c0085e8:	e7fb      	b.n	c0085e2 <boot_nv_security_counter_update+0x1a>
	...

0c0085ec <_write>:
    return ch;
}
#elif defined(__GNUC__)
/* Redirects printf to TFM_DRIVER_STDIO in case of GNUARM */
int _write(int fd, char *str, int len)
{
 c0085ec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c0085ee:	460e      	mov	r6, r1
 c0085f0:	4615      	mov	r5, r2
    int i;

    for (i = 0; i < len; i++) {
 c0085f2:	460c      	mov	r4, r1
    ret = TFM_DRIVER_STDIO.Send(&c, 1);
 c0085f4:	4f08      	ldr	r7, [pc, #32]	; (c008618 <_write+0x2c>)
    for (i = 0; i < len; i++) {
 c0085f6:	1ba3      	subs	r3, r4, r6
 c0085f8:	429d      	cmp	r5, r3
 c0085fa:	dc02      	bgt.n	c008602 <_write+0x16>
        uart_putc(str[i]);
    }

    /* Return the number of characters written */
    return len;
}
 c0085fc:	4628      	mov	r0, r5
 c0085fe:	b003      	add	sp, #12
 c008600:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uart_putc(str[i]);
 c008602:	f814 3b01 	ldrb.w	r3, [r4], #1
    ret = TFM_DRIVER_STDIO.Send(&c, 1);
 c008606:	2101      	movs	r1, #1
 c008608:	f88d 3007 	strb.w	r3, [sp, #7]
 c00860c:	f10d 0007 	add.w	r0, sp, #7
 c008610:	697b      	ldr	r3, [r7, #20]
 c008612:	4798      	blx	r3
 c008614:	e7ef      	b.n	c0085f6 <_write+0xa>
 c008616:	bf00      	nop
 c008618:	0c00a000 	.word	0x0c00a000

0c00861c <stdio_init>:
    return ch;
}
#endif

void stdio_init(void)
{
 c00861c:	b510      	push	{r4, lr}
#ifdef NDEBUG
    __attribute__((unused))
#endif
    int32_t ret = ARM_DRIVER_OK;
    ret = TFM_DRIVER_STDIO.Initialize(NULL);
 c00861e:	4c05      	ldr	r4, [pc, #20]	; (c008634 <stdio_init+0x18>)
 c008620:	2000      	movs	r0, #0
 c008622:	68a3      	ldr	r3, [r4, #8]
 c008624:	4798      	blx	r3
    ASSERT_HIGH(ret);

    ret = TFM_DRIVER_STDIO.Control(ARM_USART_MODE_ASYNCHRONOUS, 115200);
 c008626:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 c008628:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
    ASSERT_HIGH(ret);
}
 c00862c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ret = TFM_DRIVER_STDIO.Control(ARM_USART_MODE_ASYNCHRONOUS, 115200);
 c008630:	2001      	movs	r0, #1
 c008632:	4718      	bx	r3
 c008634:	0c00a000 	.word	0x0c00a000

0c008638 <stdio_uninit>:
{
#ifdef NDEBUG
    __attribute__((unused))
#endif
    int32_t ret = ARM_DRIVER_OK;
    ret = TFM_DRIVER_STDIO.Uninitialize();
 c008638:	4b01      	ldr	r3, [pc, #4]	; (c008640 <stdio_uninit+0x8>)
 c00863a:	68db      	ldr	r3, [r3, #12]
 c00863c:	4718      	bx	r3
 c00863e:	bf00      	nop
 c008640:	0c00a000 	.word	0x0c00a000

0c008644 <calloc>:
 c008644:	4b02      	ldr	r3, [pc, #8]	; (c008650 <calloc+0xc>)
 c008646:	460a      	mov	r2, r1
 c008648:	4601      	mov	r1, r0
 c00864a:	6818      	ldr	r0, [r3, #0]
 c00864c:	f000 b855 	b.w	c0086fa <_calloc_r>
 c008650:	300300a0 	.word	0x300300a0

0c008654 <exit>:
 c008654:	b508      	push	{r3, lr}
 c008656:	4b07      	ldr	r3, [pc, #28]	; (c008674 <exit+0x20>)
 c008658:	4604      	mov	r4, r0
 c00865a:	b113      	cbz	r3, c008662 <exit+0xe>
 c00865c:	2100      	movs	r1, #0
 c00865e:	e000      	b.n	c008662 <exit+0xe>
 c008660:	bf00      	nop
 c008662:	4b05      	ldr	r3, [pc, #20]	; (c008678 <exit+0x24>)
 c008664:	6818      	ldr	r0, [r3, #0]
 c008666:	6a83      	ldr	r3, [r0, #40]	; 0x28
 c008668:	b103      	cbz	r3, c00866c <exit+0x18>
 c00866a:	4798      	blx	r3
 c00866c:	4620      	mov	r0, r4
 c00866e:	f001 fb6d 	bl	c009d4c <_exit>
 c008672:	bf00      	nop
 c008674:	00000000 	.word	0x00000000
 c008678:	0c00aba0 	.word	0x0c00aba0

0c00867c <__libc_init_array>:
 c00867c:	b570      	push	{r4, r5, r6, lr}
 c00867e:	4e0d      	ldr	r6, [pc, #52]	; (c0086b4 <__libc_init_array+0x38>)
 c008680:	2500      	movs	r5, #0
 c008682:	4c0d      	ldr	r4, [pc, #52]	; (c0086b8 <__libc_init_array+0x3c>)
 c008684:	1ba4      	subs	r4, r4, r6
 c008686:	10a4      	asrs	r4, r4, #2
 c008688:	42a5      	cmp	r5, r4
 c00868a:	d109      	bne.n	c0086a0 <__libc_init_array+0x24>
 c00868c:	4e0b      	ldr	r6, [pc, #44]	; (c0086bc <__libc_init_array+0x40>)
 c00868e:	2500      	movs	r5, #0
 c008690:	4c0b      	ldr	r4, [pc, #44]	; (c0086c0 <__libc_init_array+0x44>)
 c008692:	f001 fb5d 	bl	c009d50 <_init>
 c008696:	1ba4      	subs	r4, r4, r6
 c008698:	10a4      	asrs	r4, r4, #2
 c00869a:	42a5      	cmp	r5, r4
 c00869c:	d105      	bne.n	c0086aa <__libc_init_array+0x2e>
 c00869e:	bd70      	pop	{r4, r5, r6, pc}
 c0086a0:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 c0086a4:	3501      	adds	r5, #1
 c0086a6:	4798      	blx	r3
 c0086a8:	e7ee      	b.n	c008688 <__libc_init_array+0xc>
 c0086aa:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 c0086ae:	3501      	adds	r5, #1
 c0086b0:	4798      	blx	r3
 c0086b2:	e7f2      	b.n	c00869a <__libc_init_array+0x1e>
 c0086b4:	30030104 	.word	0x30030104
 c0086b8:	30030104 	.word	0x30030104
 c0086bc:	30030104 	.word	0x30030104
 c0086c0:	30030108 	.word	0x30030108

0c0086c4 <free>:
 c0086c4:	4b02      	ldr	r3, [pc, #8]	; (c0086d0 <free+0xc>)
 c0086c6:	4601      	mov	r1, r0
 c0086c8:	6818      	ldr	r0, [r3, #0]
 c0086ca:	f000 b825 	b.w	c008718 <_free_r>
 c0086ce:	bf00      	nop
 c0086d0:	300300a0 	.word	0x300300a0

0c0086d4 <memcpy>:
 c0086d4:	1e43      	subs	r3, r0, #1
 c0086d6:	440a      	add	r2, r1
 c0086d8:	b510      	push	{r4, lr}
 c0086da:	4291      	cmp	r1, r2
 c0086dc:	d100      	bne.n	c0086e0 <memcpy+0xc>
 c0086de:	bd10      	pop	{r4, pc}
 c0086e0:	f811 4b01 	ldrb.w	r4, [r1], #1
 c0086e4:	f803 4f01 	strb.w	r4, [r3, #1]!
 c0086e8:	e7f7      	b.n	c0086da <memcpy+0x6>

0c0086ea <memset>:
 c0086ea:	4402      	add	r2, r0
 c0086ec:	4603      	mov	r3, r0
 c0086ee:	4293      	cmp	r3, r2
 c0086f0:	d100      	bne.n	c0086f4 <memset+0xa>
 c0086f2:	4770      	bx	lr
 c0086f4:	f803 1b01 	strb.w	r1, [r3], #1
 c0086f8:	e7f9      	b.n	c0086ee <memset+0x4>

0c0086fa <_calloc_r>:
 c0086fa:	b538      	push	{r3, r4, r5, lr}
 c0086fc:	fb02 f401 	mul.w	r4, r2, r1
 c008700:	4621      	mov	r1, r4
 c008702:	f000 f857 	bl	c0087b4 <_malloc_r>
 c008706:	4605      	mov	r5, r0
 c008708:	b118      	cbz	r0, c008712 <_calloc_r+0x18>
 c00870a:	4622      	mov	r2, r4
 c00870c:	2100      	movs	r1, #0
 c00870e:	f7ff ffec 	bl	c0086ea <memset>
 c008712:	4628      	mov	r0, r5
 c008714:	bd38      	pop	{r3, r4, r5, pc}
	...

0c008718 <_free_r>:
 c008718:	b538      	push	{r3, r4, r5, lr}
 c00871a:	4605      	mov	r5, r0
 c00871c:	2900      	cmp	r1, #0
 c00871e:	d045      	beq.n	c0087ac <_free_r+0x94>
 c008720:	f851 3c04 	ldr.w	r3, [r1, #-4]
 c008724:	1f0c      	subs	r4, r1, #4
 c008726:	2b00      	cmp	r3, #0
 c008728:	bfb8      	it	lt
 c00872a:	18e4      	addlt	r4, r4, r3
 c00872c:	f000 fc00 	bl	c008f30 <__malloc_lock>
 c008730:	4a1f      	ldr	r2, [pc, #124]	; (c0087b0 <_free_r+0x98>)
 c008732:	6813      	ldr	r3, [r2, #0]
 c008734:	4610      	mov	r0, r2
 c008736:	b933      	cbnz	r3, c008746 <_free_r+0x2e>
 c008738:	6063      	str	r3, [r4, #4]
 c00873a:	6014      	str	r4, [r2, #0]
 c00873c:	4628      	mov	r0, r5
 c00873e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 c008742:	f000 bbf6 	b.w	c008f32 <__malloc_unlock>
 c008746:	42a3      	cmp	r3, r4
 c008748:	d90c      	bls.n	c008764 <_free_r+0x4c>
 c00874a:	6821      	ldr	r1, [r4, #0]
 c00874c:	1862      	adds	r2, r4, r1
 c00874e:	4293      	cmp	r3, r2
 c008750:	bf02      	ittt	eq
 c008752:	681a      	ldreq	r2, [r3, #0]
 c008754:	685b      	ldreq	r3, [r3, #4]
 c008756:	1852      	addeq	r2, r2, r1
 c008758:	6063      	str	r3, [r4, #4]
 c00875a:	bf08      	it	eq
 c00875c:	6022      	streq	r2, [r4, #0]
 c00875e:	6004      	str	r4, [r0, #0]
 c008760:	e7ec      	b.n	c00873c <_free_r+0x24>
 c008762:	4613      	mov	r3, r2
 c008764:	685a      	ldr	r2, [r3, #4]
 c008766:	b10a      	cbz	r2, c00876c <_free_r+0x54>
 c008768:	42a2      	cmp	r2, r4
 c00876a:	d9fa      	bls.n	c008762 <_free_r+0x4a>
 c00876c:	6819      	ldr	r1, [r3, #0]
 c00876e:	1858      	adds	r0, r3, r1
 c008770:	42a0      	cmp	r0, r4
 c008772:	d10b      	bne.n	c00878c <_free_r+0x74>
 c008774:	6820      	ldr	r0, [r4, #0]
 c008776:	4401      	add	r1, r0
 c008778:	1858      	adds	r0, r3, r1
 c00877a:	6019      	str	r1, [r3, #0]
 c00877c:	4282      	cmp	r2, r0
 c00877e:	d1dd      	bne.n	c00873c <_free_r+0x24>
 c008780:	6810      	ldr	r0, [r2, #0]
 c008782:	6852      	ldr	r2, [r2, #4]
 c008784:	4401      	add	r1, r0
 c008786:	605a      	str	r2, [r3, #4]
 c008788:	6019      	str	r1, [r3, #0]
 c00878a:	e7d7      	b.n	c00873c <_free_r+0x24>
 c00878c:	d902      	bls.n	c008794 <_free_r+0x7c>
 c00878e:	230c      	movs	r3, #12
 c008790:	602b      	str	r3, [r5, #0]
 c008792:	e7d3      	b.n	c00873c <_free_r+0x24>
 c008794:	6820      	ldr	r0, [r4, #0]
 c008796:	1821      	adds	r1, r4, r0
 c008798:	428a      	cmp	r2, r1
 c00879a:	bf02      	ittt	eq
 c00879c:	6811      	ldreq	r1, [r2, #0]
 c00879e:	6852      	ldreq	r2, [r2, #4]
 c0087a0:	1809      	addeq	r1, r1, r0
 c0087a2:	6062      	str	r2, [r4, #4]
 c0087a4:	bf08      	it	eq
 c0087a6:	6021      	streq	r1, [r4, #0]
 c0087a8:	605c      	str	r4, [r3, #4]
 c0087aa:	e7c7      	b.n	c00873c <_free_r+0x24>
 c0087ac:	bd38      	pop	{r3, r4, r5, pc}
 c0087ae:	bf00      	nop
 c0087b0:	30033960 	.word	0x30033960

0c0087b4 <_malloc_r>:
 c0087b4:	b570      	push	{r4, r5, r6, lr}
 c0087b6:	1ccd      	adds	r5, r1, #3
 c0087b8:	4606      	mov	r6, r0
 c0087ba:	f025 0503 	bic.w	r5, r5, #3
 c0087be:	3508      	adds	r5, #8
 c0087c0:	2d0c      	cmp	r5, #12
 c0087c2:	bf38      	it	cc
 c0087c4:	250c      	movcc	r5, #12
 c0087c6:	2d00      	cmp	r5, #0
 c0087c8:	db01      	blt.n	c0087ce <_malloc_r+0x1a>
 c0087ca:	42a9      	cmp	r1, r5
 c0087cc:	d903      	bls.n	c0087d6 <_malloc_r+0x22>
 c0087ce:	230c      	movs	r3, #12
 c0087d0:	6033      	str	r3, [r6, #0]
 c0087d2:	2000      	movs	r0, #0
 c0087d4:	bd70      	pop	{r4, r5, r6, pc}
 c0087d6:	f000 fbab 	bl	c008f30 <__malloc_lock>
 c0087da:	4a21      	ldr	r2, [pc, #132]	; (c008860 <_malloc_r+0xac>)
 c0087dc:	6814      	ldr	r4, [r2, #0]
 c0087de:	4621      	mov	r1, r4
 c0087e0:	b991      	cbnz	r1, c008808 <_malloc_r+0x54>
 c0087e2:	4c20      	ldr	r4, [pc, #128]	; (c008864 <_malloc_r+0xb0>)
 c0087e4:	6823      	ldr	r3, [r4, #0]
 c0087e6:	b91b      	cbnz	r3, c0087f0 <_malloc_r+0x3c>
 c0087e8:	4630      	mov	r0, r6
 c0087ea:	f000 f8b9 	bl	c008960 <_sbrk_r>
 c0087ee:	6020      	str	r0, [r4, #0]
 c0087f0:	4629      	mov	r1, r5
 c0087f2:	4630      	mov	r0, r6
 c0087f4:	f000 f8b4 	bl	c008960 <_sbrk_r>
 c0087f8:	1c43      	adds	r3, r0, #1
 c0087fa:	d124      	bne.n	c008846 <_malloc_r+0x92>
 c0087fc:	230c      	movs	r3, #12
 c0087fe:	4630      	mov	r0, r6
 c008800:	6033      	str	r3, [r6, #0]
 c008802:	f000 fb96 	bl	c008f32 <__malloc_unlock>
 c008806:	e7e4      	b.n	c0087d2 <_malloc_r+0x1e>
 c008808:	680b      	ldr	r3, [r1, #0]
 c00880a:	1b5b      	subs	r3, r3, r5
 c00880c:	d418      	bmi.n	c008840 <_malloc_r+0x8c>
 c00880e:	2b0b      	cmp	r3, #11
 c008810:	d90f      	bls.n	c008832 <_malloc_r+0x7e>
 c008812:	18cc      	adds	r4, r1, r3
 c008814:	600b      	str	r3, [r1, #0]
 c008816:	50cd      	str	r5, [r1, r3]
 c008818:	4630      	mov	r0, r6
 c00881a:	f000 fb8a 	bl	c008f32 <__malloc_unlock>
 c00881e:	f104 000b 	add.w	r0, r4, #11
 c008822:	1d23      	adds	r3, r4, #4
 c008824:	f020 0007 	bic.w	r0, r0, #7
 c008828:	1ac3      	subs	r3, r0, r3
 c00882a:	d0d3      	beq.n	c0087d4 <_malloc_r+0x20>
 c00882c:	425a      	negs	r2, r3
 c00882e:	50e2      	str	r2, [r4, r3]
 c008830:	e7d0      	b.n	c0087d4 <_malloc_r+0x20>
 c008832:	428c      	cmp	r4, r1
 c008834:	684b      	ldr	r3, [r1, #4]
 c008836:	bf1a      	itte	ne
 c008838:	6063      	strne	r3, [r4, #4]
 c00883a:	460c      	movne	r4, r1
 c00883c:	6013      	streq	r3, [r2, #0]
 c00883e:	e7eb      	b.n	c008818 <_malloc_r+0x64>
 c008840:	460c      	mov	r4, r1
 c008842:	6849      	ldr	r1, [r1, #4]
 c008844:	e7cc      	b.n	c0087e0 <_malloc_r+0x2c>
 c008846:	1cc4      	adds	r4, r0, #3
 c008848:	f024 0403 	bic.w	r4, r4, #3
 c00884c:	42a0      	cmp	r0, r4
 c00884e:	d005      	beq.n	c00885c <_malloc_r+0xa8>
 c008850:	1a21      	subs	r1, r4, r0
 c008852:	4630      	mov	r0, r6
 c008854:	f000 f884 	bl	c008960 <_sbrk_r>
 c008858:	3001      	adds	r0, #1
 c00885a:	d0cf      	beq.n	c0087fc <_malloc_r+0x48>
 c00885c:	6025      	str	r5, [r4, #0]
 c00885e:	e7db      	b.n	c008818 <_malloc_r+0x64>
 c008860:	30033960 	.word	0x30033960
 c008864:	30033964 	.word	0x30033964

0c008868 <iprintf>:
 c008868:	b40f      	push	{r0, r1, r2, r3}
 c00886a:	4b0a      	ldr	r3, [pc, #40]	; (c008894 <iprintf+0x2c>)
 c00886c:	b513      	push	{r0, r1, r4, lr}
 c00886e:	681c      	ldr	r4, [r3, #0]
 c008870:	b124      	cbz	r4, c00887c <iprintf+0x14>
 c008872:	69a3      	ldr	r3, [r4, #24]
 c008874:	b913      	cbnz	r3, c00887c <iprintf+0x14>
 c008876:	4620      	mov	r0, r4
 c008878:	f000 fa6c 	bl	c008d54 <__sinit>
 c00887c:	ab05      	add	r3, sp, #20
 c00887e:	9a04      	ldr	r2, [sp, #16]
 c008880:	68a1      	ldr	r1, [r4, #8]
 c008882:	4620      	mov	r0, r4
 c008884:	9301      	str	r3, [sp, #4]
 c008886:	f000 fcd1 	bl	c00922c <_vfiprintf_r>
 c00888a:	b002      	add	sp, #8
 c00888c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c008890:	b004      	add	sp, #16
 c008892:	4770      	bx	lr
 c008894:	300300a0 	.word	0x300300a0

0c008898 <_puts_r>:
 c008898:	b570      	push	{r4, r5, r6, lr}
 c00889a:	460e      	mov	r6, r1
 c00889c:	4605      	mov	r5, r0
 c00889e:	b118      	cbz	r0, c0088a8 <_puts_r+0x10>
 c0088a0:	6983      	ldr	r3, [r0, #24]
 c0088a2:	b90b      	cbnz	r3, c0088a8 <_puts_r+0x10>
 c0088a4:	f000 fa56 	bl	c008d54 <__sinit>
 c0088a8:	69ab      	ldr	r3, [r5, #24]
 c0088aa:	68ac      	ldr	r4, [r5, #8]
 c0088ac:	b913      	cbnz	r3, c0088b4 <_puts_r+0x1c>
 c0088ae:	4628      	mov	r0, r5
 c0088b0:	f000 fa50 	bl	c008d54 <__sinit>
 c0088b4:	4b23      	ldr	r3, [pc, #140]	; (c008944 <_puts_r+0xac>)
 c0088b6:	429c      	cmp	r4, r3
 c0088b8:	d117      	bne.n	c0088ea <_puts_r+0x52>
 c0088ba:	686c      	ldr	r4, [r5, #4]
 c0088bc:	89a3      	ldrh	r3, [r4, #12]
 c0088be:	071b      	lsls	r3, r3, #28
 c0088c0:	d51d      	bpl.n	c0088fe <_puts_r+0x66>
 c0088c2:	6923      	ldr	r3, [r4, #16]
 c0088c4:	b1db      	cbz	r3, c0088fe <_puts_r+0x66>
 c0088c6:	3e01      	subs	r6, #1
 c0088c8:	68a3      	ldr	r3, [r4, #8]
 c0088ca:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 c0088ce:	3b01      	subs	r3, #1
 c0088d0:	60a3      	str	r3, [r4, #8]
 c0088d2:	b9e9      	cbnz	r1, c008910 <_puts_r+0x78>
 c0088d4:	2b00      	cmp	r3, #0
 c0088d6:	da2e      	bge.n	c008936 <_puts_r+0x9e>
 c0088d8:	4622      	mov	r2, r4
 c0088da:	210a      	movs	r1, #10
 c0088dc:	4628      	mov	r0, r5
 c0088de:	f000 f88b 	bl	c0089f8 <__swbuf_r>
 c0088e2:	3001      	adds	r0, #1
 c0088e4:	d011      	beq.n	c00890a <_puts_r+0x72>
 c0088e6:	200a      	movs	r0, #10
 c0088e8:	e011      	b.n	c00890e <_puts_r+0x76>
 c0088ea:	4b17      	ldr	r3, [pc, #92]	; (c008948 <_puts_r+0xb0>)
 c0088ec:	429c      	cmp	r4, r3
 c0088ee:	d101      	bne.n	c0088f4 <_puts_r+0x5c>
 c0088f0:	68ac      	ldr	r4, [r5, #8]
 c0088f2:	e7e3      	b.n	c0088bc <_puts_r+0x24>
 c0088f4:	4b15      	ldr	r3, [pc, #84]	; (c00894c <_puts_r+0xb4>)
 c0088f6:	429c      	cmp	r4, r3
 c0088f8:	bf08      	it	eq
 c0088fa:	68ec      	ldreq	r4, [r5, #12]
 c0088fc:	e7de      	b.n	c0088bc <_puts_r+0x24>
 c0088fe:	4621      	mov	r1, r4
 c008900:	4628      	mov	r0, r5
 c008902:	f000 f8cb 	bl	c008a9c <__swsetup_r>
 c008906:	2800      	cmp	r0, #0
 c008908:	d0dd      	beq.n	c0088c6 <_puts_r+0x2e>
 c00890a:	f04f 30ff 	mov.w	r0, #4294967295
 c00890e:	bd70      	pop	{r4, r5, r6, pc}
 c008910:	2b00      	cmp	r3, #0
 c008912:	da04      	bge.n	c00891e <_puts_r+0x86>
 c008914:	69a2      	ldr	r2, [r4, #24]
 c008916:	429a      	cmp	r2, r3
 c008918:	dc06      	bgt.n	c008928 <_puts_r+0x90>
 c00891a:	290a      	cmp	r1, #10
 c00891c:	d004      	beq.n	c008928 <_puts_r+0x90>
 c00891e:	6823      	ldr	r3, [r4, #0]
 c008920:	1c5a      	adds	r2, r3, #1
 c008922:	6022      	str	r2, [r4, #0]
 c008924:	7019      	strb	r1, [r3, #0]
 c008926:	e7cf      	b.n	c0088c8 <_puts_r+0x30>
 c008928:	4622      	mov	r2, r4
 c00892a:	4628      	mov	r0, r5
 c00892c:	f000 f864 	bl	c0089f8 <__swbuf_r>
 c008930:	3001      	adds	r0, #1
 c008932:	d1c9      	bne.n	c0088c8 <_puts_r+0x30>
 c008934:	e7e9      	b.n	c00890a <_puts_r+0x72>
 c008936:	6823      	ldr	r3, [r4, #0]
 c008938:	200a      	movs	r0, #10
 c00893a:	1c5a      	adds	r2, r3, #1
 c00893c:	6022      	str	r2, [r4, #0]
 c00893e:	7018      	strb	r0, [r3, #0]
 c008940:	e7e5      	b.n	c00890e <_puts_r+0x76>
 c008942:	bf00      	nop
 c008944:	0c00abc4 	.word	0x0c00abc4
 c008948:	0c00abe4 	.word	0x0c00abe4
 c00894c:	0c00aba4 	.word	0x0c00aba4

0c008950 <puts>:
 c008950:	4b02      	ldr	r3, [pc, #8]	; (c00895c <puts+0xc>)
 c008952:	4601      	mov	r1, r0
 c008954:	6818      	ldr	r0, [r3, #0]
 c008956:	f7ff bf9f 	b.w	c008898 <_puts_r>
 c00895a:	bf00      	nop
 c00895c:	300300a0 	.word	0x300300a0

0c008960 <_sbrk_r>:
 c008960:	b538      	push	{r3, r4, r5, lr}
 c008962:	2300      	movs	r3, #0
 c008964:	4c05      	ldr	r4, [pc, #20]	; (c00897c <_sbrk_r+0x1c>)
 c008966:	4605      	mov	r5, r0
 c008968:	4608      	mov	r0, r1
 c00896a:	6023      	str	r3, [r4, #0]
 c00896c:	f001 f9e0 	bl	c009d30 <_sbrk>
 c008970:	1c43      	adds	r3, r0, #1
 c008972:	d102      	bne.n	c00897a <_sbrk_r+0x1a>
 c008974:	6823      	ldr	r3, [r4, #0]
 c008976:	b103      	cbz	r3, c00897a <_sbrk_r+0x1a>
 c008978:	602b      	str	r3, [r5, #0]
 c00897a:	bd38      	pop	{r3, r4, r5, pc}
 c00897c:	30033994 	.word	0x30033994

0c008980 <sniprintf>:
 c008980:	b40c      	push	{r2, r3}
 c008982:	4b18      	ldr	r3, [pc, #96]	; (c0089e4 <sniprintf+0x64>)
 c008984:	b530      	push	{r4, r5, lr}
 c008986:	1e0c      	subs	r4, r1, #0
 c008988:	b09d      	sub	sp, #116	; 0x74
 c00898a:	681d      	ldr	r5, [r3, #0]
 c00898c:	da08      	bge.n	c0089a0 <sniprintf+0x20>
 c00898e:	238b      	movs	r3, #139	; 0x8b
 c008990:	f04f 30ff 	mov.w	r0, #4294967295
 c008994:	602b      	str	r3, [r5, #0]
 c008996:	b01d      	add	sp, #116	; 0x74
 c008998:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 c00899c:	b002      	add	sp, #8
 c00899e:	4770      	bx	lr
 c0089a0:	f44f 7302 	mov.w	r3, #520	; 0x208
 c0089a4:	9002      	str	r0, [sp, #8]
 c0089a6:	9006      	str	r0, [sp, #24]
 c0089a8:	a902      	add	r1, sp, #8
 c0089aa:	f8ad 3014 	strh.w	r3, [sp, #20]
 c0089ae:	bf14      	ite	ne
 c0089b0:	f104 33ff 	addne.w	r3, r4, #4294967295
 c0089b4:	4623      	moveq	r3, r4
 c0089b6:	9a20      	ldr	r2, [sp, #128]	; 0x80
 c0089b8:	4628      	mov	r0, r5
 c0089ba:	9304      	str	r3, [sp, #16]
 c0089bc:	9307      	str	r3, [sp, #28]
 c0089be:	f64f 73ff 	movw	r3, #65535	; 0xffff
 c0089c2:	f8ad 3016 	strh.w	r3, [sp, #22]
 c0089c6:	ab21      	add	r3, sp, #132	; 0x84
 c0089c8:	9301      	str	r3, [sp, #4]
 c0089ca:	f000 fb0d 	bl	c008fe8 <_svfiprintf_r>
 c0089ce:	1c43      	adds	r3, r0, #1
 c0089d0:	bfbc      	itt	lt
 c0089d2:	238b      	movlt	r3, #139	; 0x8b
 c0089d4:	602b      	strlt	r3, [r5, #0]
 c0089d6:	2c00      	cmp	r4, #0
 c0089d8:	d0dd      	beq.n	c008996 <sniprintf+0x16>
 c0089da:	9b02      	ldr	r3, [sp, #8]
 c0089dc:	2200      	movs	r2, #0
 c0089de:	701a      	strb	r2, [r3, #0]
 c0089e0:	e7d9      	b.n	c008996 <sniprintf+0x16>
 c0089e2:	bf00      	nop
 c0089e4:	300300a0 	.word	0x300300a0

0c0089e8 <strlen>:
 c0089e8:	4603      	mov	r3, r0
 c0089ea:	f813 2b01 	ldrb.w	r2, [r3], #1
 c0089ee:	2a00      	cmp	r2, #0
 c0089f0:	d1fb      	bne.n	c0089ea <strlen+0x2>
 c0089f2:	1a18      	subs	r0, r3, r0
 c0089f4:	3801      	subs	r0, #1
 c0089f6:	4770      	bx	lr

0c0089f8 <__swbuf_r>:
 c0089f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c0089fa:	460e      	mov	r6, r1
 c0089fc:	4614      	mov	r4, r2
 c0089fe:	4605      	mov	r5, r0
 c008a00:	b118      	cbz	r0, c008a0a <__swbuf_r+0x12>
 c008a02:	6983      	ldr	r3, [r0, #24]
 c008a04:	b90b      	cbnz	r3, c008a0a <__swbuf_r+0x12>
 c008a06:	f000 f9a5 	bl	c008d54 <__sinit>
 c008a0a:	4b21      	ldr	r3, [pc, #132]	; (c008a90 <__swbuf_r+0x98>)
 c008a0c:	429c      	cmp	r4, r3
 c008a0e:	d12a      	bne.n	c008a66 <__swbuf_r+0x6e>
 c008a10:	686c      	ldr	r4, [r5, #4]
 c008a12:	69a3      	ldr	r3, [r4, #24]
 c008a14:	60a3      	str	r3, [r4, #8]
 c008a16:	89a3      	ldrh	r3, [r4, #12]
 c008a18:	071a      	lsls	r2, r3, #28
 c008a1a:	d52e      	bpl.n	c008a7a <__swbuf_r+0x82>
 c008a1c:	6923      	ldr	r3, [r4, #16]
 c008a1e:	b363      	cbz	r3, c008a7a <__swbuf_r+0x82>
 c008a20:	6923      	ldr	r3, [r4, #16]
 c008a22:	b2f6      	uxtb	r6, r6
 c008a24:	6820      	ldr	r0, [r4, #0]
 c008a26:	4637      	mov	r7, r6
 c008a28:	1ac0      	subs	r0, r0, r3
 c008a2a:	6963      	ldr	r3, [r4, #20]
 c008a2c:	4283      	cmp	r3, r0
 c008a2e:	dc04      	bgt.n	c008a3a <__swbuf_r+0x42>
 c008a30:	4621      	mov	r1, r4
 c008a32:	4628      	mov	r0, r5
 c008a34:	f000 f924 	bl	c008c80 <_fflush_r>
 c008a38:	bb28      	cbnz	r0, c008a86 <__swbuf_r+0x8e>
 c008a3a:	68a3      	ldr	r3, [r4, #8]
 c008a3c:	3001      	adds	r0, #1
 c008a3e:	3b01      	subs	r3, #1
 c008a40:	60a3      	str	r3, [r4, #8]
 c008a42:	6823      	ldr	r3, [r4, #0]
 c008a44:	1c5a      	adds	r2, r3, #1
 c008a46:	6022      	str	r2, [r4, #0]
 c008a48:	701e      	strb	r6, [r3, #0]
 c008a4a:	6963      	ldr	r3, [r4, #20]
 c008a4c:	4283      	cmp	r3, r0
 c008a4e:	d004      	beq.n	c008a5a <__swbuf_r+0x62>
 c008a50:	89a3      	ldrh	r3, [r4, #12]
 c008a52:	07db      	lsls	r3, r3, #31
 c008a54:	d519      	bpl.n	c008a8a <__swbuf_r+0x92>
 c008a56:	2e0a      	cmp	r6, #10
 c008a58:	d117      	bne.n	c008a8a <__swbuf_r+0x92>
 c008a5a:	4621      	mov	r1, r4
 c008a5c:	4628      	mov	r0, r5
 c008a5e:	f000 f90f 	bl	c008c80 <_fflush_r>
 c008a62:	b190      	cbz	r0, c008a8a <__swbuf_r+0x92>
 c008a64:	e00f      	b.n	c008a86 <__swbuf_r+0x8e>
 c008a66:	4b0b      	ldr	r3, [pc, #44]	; (c008a94 <__swbuf_r+0x9c>)
 c008a68:	429c      	cmp	r4, r3
 c008a6a:	d101      	bne.n	c008a70 <__swbuf_r+0x78>
 c008a6c:	68ac      	ldr	r4, [r5, #8]
 c008a6e:	e7d0      	b.n	c008a12 <__swbuf_r+0x1a>
 c008a70:	4b09      	ldr	r3, [pc, #36]	; (c008a98 <__swbuf_r+0xa0>)
 c008a72:	429c      	cmp	r4, r3
 c008a74:	bf08      	it	eq
 c008a76:	68ec      	ldreq	r4, [r5, #12]
 c008a78:	e7cb      	b.n	c008a12 <__swbuf_r+0x1a>
 c008a7a:	4621      	mov	r1, r4
 c008a7c:	4628      	mov	r0, r5
 c008a7e:	f000 f80d 	bl	c008a9c <__swsetup_r>
 c008a82:	2800      	cmp	r0, #0
 c008a84:	d0cc      	beq.n	c008a20 <__swbuf_r+0x28>
 c008a86:	f04f 37ff 	mov.w	r7, #4294967295
 c008a8a:	4638      	mov	r0, r7
 c008a8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c008a8e:	bf00      	nop
 c008a90:	0c00abc4 	.word	0x0c00abc4
 c008a94:	0c00abe4 	.word	0x0c00abe4
 c008a98:	0c00aba4 	.word	0x0c00aba4

0c008a9c <__swsetup_r>:
 c008a9c:	4b32      	ldr	r3, [pc, #200]	; (c008b68 <__swsetup_r+0xcc>)
 c008a9e:	b570      	push	{r4, r5, r6, lr}
 c008aa0:	681d      	ldr	r5, [r3, #0]
 c008aa2:	4606      	mov	r6, r0
 c008aa4:	460c      	mov	r4, r1
 c008aa6:	b125      	cbz	r5, c008ab2 <__swsetup_r+0x16>
 c008aa8:	69ab      	ldr	r3, [r5, #24]
 c008aaa:	b913      	cbnz	r3, c008ab2 <__swsetup_r+0x16>
 c008aac:	4628      	mov	r0, r5
 c008aae:	f000 f951 	bl	c008d54 <__sinit>
 c008ab2:	4b2e      	ldr	r3, [pc, #184]	; (c008b6c <__swsetup_r+0xd0>)
 c008ab4:	429c      	cmp	r4, r3
 c008ab6:	d10f      	bne.n	c008ad8 <__swsetup_r+0x3c>
 c008ab8:	686c      	ldr	r4, [r5, #4]
 c008aba:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c008abe:	b29a      	uxth	r2, r3
 c008ac0:	0715      	lsls	r5, r2, #28
 c008ac2:	d42c      	bmi.n	c008b1e <__swsetup_r+0x82>
 c008ac4:	06d0      	lsls	r0, r2, #27
 c008ac6:	d411      	bmi.n	c008aec <__swsetup_r+0x50>
 c008ac8:	2209      	movs	r2, #9
 c008aca:	6032      	str	r2, [r6, #0]
 c008acc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 c008ad0:	f04f 30ff 	mov.w	r0, #4294967295
 c008ad4:	81a3      	strh	r3, [r4, #12]
 c008ad6:	e03e      	b.n	c008b56 <__swsetup_r+0xba>
 c008ad8:	4b25      	ldr	r3, [pc, #148]	; (c008b70 <__swsetup_r+0xd4>)
 c008ada:	429c      	cmp	r4, r3
 c008adc:	d101      	bne.n	c008ae2 <__swsetup_r+0x46>
 c008ade:	68ac      	ldr	r4, [r5, #8]
 c008ae0:	e7eb      	b.n	c008aba <__swsetup_r+0x1e>
 c008ae2:	4b24      	ldr	r3, [pc, #144]	; (c008b74 <__swsetup_r+0xd8>)
 c008ae4:	429c      	cmp	r4, r3
 c008ae6:	bf08      	it	eq
 c008ae8:	68ec      	ldreq	r4, [r5, #12]
 c008aea:	e7e6      	b.n	c008aba <__swsetup_r+0x1e>
 c008aec:	0751      	lsls	r1, r2, #29
 c008aee:	d512      	bpl.n	c008b16 <__swsetup_r+0x7a>
 c008af0:	6b61      	ldr	r1, [r4, #52]	; 0x34
 c008af2:	b141      	cbz	r1, c008b06 <__swsetup_r+0x6a>
 c008af4:	f104 0344 	add.w	r3, r4, #68	; 0x44
 c008af8:	4299      	cmp	r1, r3
 c008afa:	d002      	beq.n	c008b02 <__swsetup_r+0x66>
 c008afc:	4630      	mov	r0, r6
 c008afe:	f7ff fe0b 	bl	c008718 <_free_r>
 c008b02:	2300      	movs	r3, #0
 c008b04:	6363      	str	r3, [r4, #52]	; 0x34
 c008b06:	89a3      	ldrh	r3, [r4, #12]
 c008b08:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 c008b0c:	81a3      	strh	r3, [r4, #12]
 c008b0e:	2300      	movs	r3, #0
 c008b10:	6063      	str	r3, [r4, #4]
 c008b12:	6923      	ldr	r3, [r4, #16]
 c008b14:	6023      	str	r3, [r4, #0]
 c008b16:	89a3      	ldrh	r3, [r4, #12]
 c008b18:	f043 0308 	orr.w	r3, r3, #8
 c008b1c:	81a3      	strh	r3, [r4, #12]
 c008b1e:	6923      	ldr	r3, [r4, #16]
 c008b20:	b94b      	cbnz	r3, c008b36 <__swsetup_r+0x9a>
 c008b22:	89a3      	ldrh	r3, [r4, #12]
 c008b24:	f403 7320 	and.w	r3, r3, #640	; 0x280
 c008b28:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 c008b2c:	d003      	beq.n	c008b36 <__swsetup_r+0x9a>
 c008b2e:	4621      	mov	r1, r4
 c008b30:	4630      	mov	r0, r6
 c008b32:	f000 f9bd 	bl	c008eb0 <__smakebuf_r>
 c008b36:	89a2      	ldrh	r2, [r4, #12]
 c008b38:	f012 0301 	ands.w	r3, r2, #1
 c008b3c:	d00c      	beq.n	c008b58 <__swsetup_r+0xbc>
 c008b3e:	2300      	movs	r3, #0
 c008b40:	60a3      	str	r3, [r4, #8]
 c008b42:	6963      	ldr	r3, [r4, #20]
 c008b44:	425b      	negs	r3, r3
 c008b46:	61a3      	str	r3, [r4, #24]
 c008b48:	6923      	ldr	r3, [r4, #16]
 c008b4a:	b953      	cbnz	r3, c008b62 <__swsetup_r+0xc6>
 c008b4c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c008b50:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 c008b54:	d1ba      	bne.n	c008acc <__swsetup_r+0x30>
 c008b56:	bd70      	pop	{r4, r5, r6, pc}
 c008b58:	0792      	lsls	r2, r2, #30
 c008b5a:	bf58      	it	pl
 c008b5c:	6963      	ldrpl	r3, [r4, #20]
 c008b5e:	60a3      	str	r3, [r4, #8]
 c008b60:	e7f2      	b.n	c008b48 <__swsetup_r+0xac>
 c008b62:	2000      	movs	r0, #0
 c008b64:	e7f7      	b.n	c008b56 <__swsetup_r+0xba>
 c008b66:	bf00      	nop
 c008b68:	300300a0 	.word	0x300300a0
 c008b6c:	0c00abc4 	.word	0x0c00abc4
 c008b70:	0c00abe4 	.word	0x0c00abe4
 c008b74:	0c00aba4 	.word	0x0c00aba4

0c008b78 <__sflush_r>:
 c008b78:	898a      	ldrh	r2, [r1, #12]
 c008b7a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c008b7e:	4605      	mov	r5, r0
 c008b80:	0710      	lsls	r0, r2, #28
 c008b82:	460c      	mov	r4, r1
 c008b84:	d458      	bmi.n	c008c38 <__sflush_r+0xc0>
 c008b86:	684b      	ldr	r3, [r1, #4]
 c008b88:	2b00      	cmp	r3, #0
 c008b8a:	dc05      	bgt.n	c008b98 <__sflush_r+0x20>
 c008b8c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 c008b8e:	2b00      	cmp	r3, #0
 c008b90:	dc02      	bgt.n	c008b98 <__sflush_r+0x20>
 c008b92:	2000      	movs	r0, #0
 c008b94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c008b98:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 c008b9a:	2e00      	cmp	r6, #0
 c008b9c:	d0f9      	beq.n	c008b92 <__sflush_r+0x1a>
 c008b9e:	2300      	movs	r3, #0
 c008ba0:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 c008ba4:	682f      	ldr	r7, [r5, #0]
 c008ba6:	6a21      	ldr	r1, [r4, #32]
 c008ba8:	602b      	str	r3, [r5, #0]
 c008baa:	d032      	beq.n	c008c12 <__sflush_r+0x9a>
 c008bac:	6d60      	ldr	r0, [r4, #84]	; 0x54
 c008bae:	89a3      	ldrh	r3, [r4, #12]
 c008bb0:	075a      	lsls	r2, r3, #29
 c008bb2:	d505      	bpl.n	c008bc0 <__sflush_r+0x48>
 c008bb4:	6863      	ldr	r3, [r4, #4]
 c008bb6:	1ac0      	subs	r0, r0, r3
 c008bb8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 c008bba:	b10b      	cbz	r3, c008bc0 <__sflush_r+0x48>
 c008bbc:	6c23      	ldr	r3, [r4, #64]	; 0x40
 c008bbe:	1ac0      	subs	r0, r0, r3
 c008bc0:	2300      	movs	r3, #0
 c008bc2:	4602      	mov	r2, r0
 c008bc4:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 c008bc6:	4628      	mov	r0, r5
 c008bc8:	6a21      	ldr	r1, [r4, #32]
 c008bca:	47b0      	blx	r6
 c008bcc:	1c43      	adds	r3, r0, #1
 c008bce:	89a3      	ldrh	r3, [r4, #12]
 c008bd0:	d106      	bne.n	c008be0 <__sflush_r+0x68>
 c008bd2:	6829      	ldr	r1, [r5, #0]
 c008bd4:	291d      	cmp	r1, #29
 c008bd6:	d847      	bhi.n	c008c68 <__sflush_r+0xf0>
 c008bd8:	4a28      	ldr	r2, [pc, #160]	; (c008c7c <__sflush_r+0x104>)
 c008bda:	40ca      	lsrs	r2, r1
 c008bdc:	07d6      	lsls	r6, r2, #31
 c008bde:	d543      	bpl.n	c008c68 <__sflush_r+0xf0>
 c008be0:	2200      	movs	r2, #0
 c008be2:	04d9      	lsls	r1, r3, #19
 c008be4:	6062      	str	r2, [r4, #4]
 c008be6:	6922      	ldr	r2, [r4, #16]
 c008be8:	6022      	str	r2, [r4, #0]
 c008bea:	d504      	bpl.n	c008bf6 <__sflush_r+0x7e>
 c008bec:	1c42      	adds	r2, r0, #1
 c008bee:	d101      	bne.n	c008bf4 <__sflush_r+0x7c>
 c008bf0:	682b      	ldr	r3, [r5, #0]
 c008bf2:	b903      	cbnz	r3, c008bf6 <__sflush_r+0x7e>
 c008bf4:	6560      	str	r0, [r4, #84]	; 0x54
 c008bf6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 c008bf8:	602f      	str	r7, [r5, #0]
 c008bfa:	2900      	cmp	r1, #0
 c008bfc:	d0c9      	beq.n	c008b92 <__sflush_r+0x1a>
 c008bfe:	f104 0344 	add.w	r3, r4, #68	; 0x44
 c008c02:	4299      	cmp	r1, r3
 c008c04:	d002      	beq.n	c008c0c <__sflush_r+0x94>
 c008c06:	4628      	mov	r0, r5
 c008c08:	f7ff fd86 	bl	c008718 <_free_r>
 c008c0c:	2000      	movs	r0, #0
 c008c0e:	6360      	str	r0, [r4, #52]	; 0x34
 c008c10:	e7c0      	b.n	c008b94 <__sflush_r+0x1c>
 c008c12:	2301      	movs	r3, #1
 c008c14:	4628      	mov	r0, r5
 c008c16:	47b0      	blx	r6
 c008c18:	1c41      	adds	r1, r0, #1
 c008c1a:	d1c8      	bne.n	c008bae <__sflush_r+0x36>
 c008c1c:	682b      	ldr	r3, [r5, #0]
 c008c1e:	2b00      	cmp	r3, #0
 c008c20:	d0c5      	beq.n	c008bae <__sflush_r+0x36>
 c008c22:	2b1d      	cmp	r3, #29
 c008c24:	d001      	beq.n	c008c2a <__sflush_r+0xb2>
 c008c26:	2b16      	cmp	r3, #22
 c008c28:	d101      	bne.n	c008c2e <__sflush_r+0xb6>
 c008c2a:	602f      	str	r7, [r5, #0]
 c008c2c:	e7b1      	b.n	c008b92 <__sflush_r+0x1a>
 c008c2e:	89a3      	ldrh	r3, [r4, #12]
 c008c30:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 c008c34:	81a3      	strh	r3, [r4, #12]
 c008c36:	e7ad      	b.n	c008b94 <__sflush_r+0x1c>
 c008c38:	690f      	ldr	r7, [r1, #16]
 c008c3a:	2f00      	cmp	r7, #0
 c008c3c:	d0a9      	beq.n	c008b92 <__sflush_r+0x1a>
 c008c3e:	0793      	lsls	r3, r2, #30
 c008c40:	680e      	ldr	r6, [r1, #0]
 c008c42:	600f      	str	r7, [r1, #0]
 c008c44:	bf0c      	ite	eq
 c008c46:	694b      	ldreq	r3, [r1, #20]
 c008c48:	2300      	movne	r3, #0
 c008c4a:	eba6 0807 	sub.w	r8, r6, r7
 c008c4e:	608b      	str	r3, [r1, #8]
 c008c50:	f1b8 0f00 	cmp.w	r8, #0
 c008c54:	dd9d      	ble.n	c008b92 <__sflush_r+0x1a>
 c008c56:	4643      	mov	r3, r8
 c008c58:	463a      	mov	r2, r7
 c008c5a:	6a21      	ldr	r1, [r4, #32]
 c008c5c:	4628      	mov	r0, r5
 c008c5e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 c008c60:	47b0      	blx	r6
 c008c62:	2800      	cmp	r0, #0
 c008c64:	dc06      	bgt.n	c008c74 <__sflush_r+0xfc>
 c008c66:	89a3      	ldrh	r3, [r4, #12]
 c008c68:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 c008c6c:	f04f 30ff 	mov.w	r0, #4294967295
 c008c70:	81a3      	strh	r3, [r4, #12]
 c008c72:	e78f      	b.n	c008b94 <__sflush_r+0x1c>
 c008c74:	4407      	add	r7, r0
 c008c76:	eba8 0800 	sub.w	r8, r8, r0
 c008c7a:	e7e9      	b.n	c008c50 <__sflush_r+0xd8>
 c008c7c:	20400001 	.word	0x20400001

0c008c80 <_fflush_r>:
 c008c80:	b538      	push	{r3, r4, r5, lr}
 c008c82:	690b      	ldr	r3, [r1, #16]
 c008c84:	4605      	mov	r5, r0
 c008c86:	460c      	mov	r4, r1
 c008c88:	b1db      	cbz	r3, c008cc2 <_fflush_r+0x42>
 c008c8a:	b118      	cbz	r0, c008c94 <_fflush_r+0x14>
 c008c8c:	6983      	ldr	r3, [r0, #24]
 c008c8e:	b90b      	cbnz	r3, c008c94 <_fflush_r+0x14>
 c008c90:	f000 f860 	bl	c008d54 <__sinit>
 c008c94:	4b0c      	ldr	r3, [pc, #48]	; (c008cc8 <_fflush_r+0x48>)
 c008c96:	429c      	cmp	r4, r3
 c008c98:	d109      	bne.n	c008cae <_fflush_r+0x2e>
 c008c9a:	686c      	ldr	r4, [r5, #4]
 c008c9c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c008ca0:	b17b      	cbz	r3, c008cc2 <_fflush_r+0x42>
 c008ca2:	4621      	mov	r1, r4
 c008ca4:	4628      	mov	r0, r5
 c008ca6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 c008caa:	f7ff bf65 	b.w	c008b78 <__sflush_r>
 c008cae:	4b07      	ldr	r3, [pc, #28]	; (c008ccc <_fflush_r+0x4c>)
 c008cb0:	429c      	cmp	r4, r3
 c008cb2:	d101      	bne.n	c008cb8 <_fflush_r+0x38>
 c008cb4:	68ac      	ldr	r4, [r5, #8]
 c008cb6:	e7f1      	b.n	c008c9c <_fflush_r+0x1c>
 c008cb8:	4b05      	ldr	r3, [pc, #20]	; (c008cd0 <_fflush_r+0x50>)
 c008cba:	429c      	cmp	r4, r3
 c008cbc:	bf08      	it	eq
 c008cbe:	68ec      	ldreq	r4, [r5, #12]
 c008cc0:	e7ec      	b.n	c008c9c <_fflush_r+0x1c>
 c008cc2:	2000      	movs	r0, #0
 c008cc4:	bd38      	pop	{r3, r4, r5, pc}
 c008cc6:	bf00      	nop
 c008cc8:	0c00abc4 	.word	0x0c00abc4
 c008ccc:	0c00abe4 	.word	0x0c00abe4
 c008cd0:	0c00aba4 	.word	0x0c00aba4

0c008cd4 <std>:
 c008cd4:	2300      	movs	r3, #0
 c008cd6:	b510      	push	{r4, lr}
 c008cd8:	4604      	mov	r4, r0
 c008cda:	6083      	str	r3, [r0, #8]
 c008cdc:	8181      	strh	r1, [r0, #12]
 c008cde:	4619      	mov	r1, r3
 c008ce0:	6643      	str	r3, [r0, #100]	; 0x64
 c008ce2:	81c2      	strh	r2, [r0, #14]
 c008ce4:	2208      	movs	r2, #8
 c008ce6:	6183      	str	r3, [r0, #24]
 c008ce8:	e9c0 3300 	strd	r3, r3, [r0]
 c008cec:	e9c0 3304 	strd	r3, r3, [r0, #16]
 c008cf0:	305c      	adds	r0, #92	; 0x5c
 c008cf2:	f7ff fcfa 	bl	c0086ea <memset>
 c008cf6:	4b05      	ldr	r3, [pc, #20]	; (c008d0c <std+0x38>)
 c008cf8:	6224      	str	r4, [r4, #32]
 c008cfa:	6263      	str	r3, [r4, #36]	; 0x24
 c008cfc:	4b04      	ldr	r3, [pc, #16]	; (c008d10 <std+0x3c>)
 c008cfe:	62a3      	str	r3, [r4, #40]	; 0x28
 c008d00:	4b04      	ldr	r3, [pc, #16]	; (c008d14 <std+0x40>)
 c008d02:	62e3      	str	r3, [r4, #44]	; 0x2c
 c008d04:	4b04      	ldr	r3, [pc, #16]	; (c008d18 <std+0x44>)
 c008d06:	6323      	str	r3, [r4, #48]	; 0x30
 c008d08:	bd10      	pop	{r4, pc}
 c008d0a:	bf00      	nop
 c008d0c:	0c00976d 	.word	0x0c00976d
 c008d10:	0c00978f 	.word	0x0c00978f
 c008d14:	0c0097c7 	.word	0x0c0097c7
 c008d18:	0c0097eb 	.word	0x0c0097eb

0c008d1c <_cleanup_r>:
 c008d1c:	4901      	ldr	r1, [pc, #4]	; (c008d24 <_cleanup_r+0x8>)
 c008d1e:	f000 b885 	b.w	c008e2c <_fwalk_reent>
 c008d22:	bf00      	nop
 c008d24:	0c008c81 	.word	0x0c008c81

0c008d28 <__sfmoreglue>:
 c008d28:	b570      	push	{r4, r5, r6, lr}
 c008d2a:	1e4a      	subs	r2, r1, #1
 c008d2c:	2568      	movs	r5, #104	; 0x68
 c008d2e:	460e      	mov	r6, r1
 c008d30:	4355      	muls	r5, r2
 c008d32:	f105 0174 	add.w	r1, r5, #116	; 0x74
 c008d36:	f7ff fd3d 	bl	c0087b4 <_malloc_r>
 c008d3a:	4604      	mov	r4, r0
 c008d3c:	b140      	cbz	r0, c008d50 <__sfmoreglue+0x28>
 c008d3e:	2100      	movs	r1, #0
 c008d40:	f105 0268 	add.w	r2, r5, #104	; 0x68
 c008d44:	e9c0 1600 	strd	r1, r6, [r0]
 c008d48:	300c      	adds	r0, #12
 c008d4a:	60a0      	str	r0, [r4, #8]
 c008d4c:	f7ff fccd 	bl	c0086ea <memset>
 c008d50:	4620      	mov	r0, r4
 c008d52:	bd70      	pop	{r4, r5, r6, pc}

0c008d54 <__sinit>:
 c008d54:	6983      	ldr	r3, [r0, #24]
 c008d56:	b510      	push	{r4, lr}
 c008d58:	4604      	mov	r4, r0
 c008d5a:	bb33      	cbnz	r3, c008daa <__sinit+0x56>
 c008d5c:	6503      	str	r3, [r0, #80]	; 0x50
 c008d5e:	4a13      	ldr	r2, [pc, #76]	; (c008dac <__sinit+0x58>)
 c008d60:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 c008d64:	4b12      	ldr	r3, [pc, #72]	; (c008db0 <__sinit+0x5c>)
 c008d66:	6282      	str	r2, [r0, #40]	; 0x28
 c008d68:	681b      	ldr	r3, [r3, #0]
 c008d6a:	4298      	cmp	r0, r3
 c008d6c:	bf04      	itt	eq
 c008d6e:	2301      	moveq	r3, #1
 c008d70:	6183      	streq	r3, [r0, #24]
 c008d72:	f000 f81f 	bl	c008db4 <__sfp>
 c008d76:	6060      	str	r0, [r4, #4]
 c008d78:	4620      	mov	r0, r4
 c008d7a:	f000 f81b 	bl	c008db4 <__sfp>
 c008d7e:	60a0      	str	r0, [r4, #8]
 c008d80:	4620      	mov	r0, r4
 c008d82:	f000 f817 	bl	c008db4 <__sfp>
 c008d86:	2200      	movs	r2, #0
 c008d88:	60e0      	str	r0, [r4, #12]
 c008d8a:	2104      	movs	r1, #4
 c008d8c:	6860      	ldr	r0, [r4, #4]
 c008d8e:	f7ff ffa1 	bl	c008cd4 <std>
 c008d92:	2201      	movs	r2, #1
 c008d94:	2109      	movs	r1, #9
 c008d96:	68a0      	ldr	r0, [r4, #8]
 c008d98:	f7ff ff9c 	bl	c008cd4 <std>
 c008d9c:	2202      	movs	r2, #2
 c008d9e:	2112      	movs	r1, #18
 c008da0:	68e0      	ldr	r0, [r4, #12]
 c008da2:	f7ff ff97 	bl	c008cd4 <std>
 c008da6:	2301      	movs	r3, #1
 c008da8:	61a3      	str	r3, [r4, #24]
 c008daa:	bd10      	pop	{r4, pc}
 c008dac:	0c008d1d 	.word	0x0c008d1d
 c008db0:	0c00aba0 	.word	0x0c00aba0

0c008db4 <__sfp>:
 c008db4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c008db6:	4b1b      	ldr	r3, [pc, #108]	; (c008e24 <__sfp+0x70>)
 c008db8:	4607      	mov	r7, r0
 c008dba:	681e      	ldr	r6, [r3, #0]
 c008dbc:	69b3      	ldr	r3, [r6, #24]
 c008dbe:	b913      	cbnz	r3, c008dc6 <__sfp+0x12>
 c008dc0:	4630      	mov	r0, r6
 c008dc2:	f7ff ffc7 	bl	c008d54 <__sinit>
 c008dc6:	3648      	adds	r6, #72	; 0x48
 c008dc8:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 c008dcc:	3b01      	subs	r3, #1
 c008dce:	d503      	bpl.n	c008dd8 <__sfp+0x24>
 c008dd0:	6833      	ldr	r3, [r6, #0]
 c008dd2:	b133      	cbz	r3, c008de2 <__sfp+0x2e>
 c008dd4:	6836      	ldr	r6, [r6, #0]
 c008dd6:	e7f7      	b.n	c008dc8 <__sfp+0x14>
 c008dd8:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 c008ddc:	b16d      	cbz	r5, c008dfa <__sfp+0x46>
 c008dde:	3468      	adds	r4, #104	; 0x68
 c008de0:	e7f4      	b.n	c008dcc <__sfp+0x18>
 c008de2:	2104      	movs	r1, #4
 c008de4:	4638      	mov	r0, r7
 c008de6:	f7ff ff9f 	bl	c008d28 <__sfmoreglue>
 c008dea:	6030      	str	r0, [r6, #0]
 c008dec:	2800      	cmp	r0, #0
 c008dee:	d1f1      	bne.n	c008dd4 <__sfp+0x20>
 c008df0:	230c      	movs	r3, #12
 c008df2:	4604      	mov	r4, r0
 c008df4:	603b      	str	r3, [r7, #0]
 c008df6:	4620      	mov	r0, r4
 c008df8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c008dfa:	4b0b      	ldr	r3, [pc, #44]	; (c008e28 <__sfp+0x74>)
 c008dfc:	2208      	movs	r2, #8
 c008dfe:	6665      	str	r5, [r4, #100]	; 0x64
 c008e00:	4629      	mov	r1, r5
 c008e02:	60a5      	str	r5, [r4, #8]
 c008e04:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 c008e08:	e9c4 5500 	strd	r5, r5, [r4]
 c008e0c:	e9c4 3503 	strd	r3, r5, [r4, #12]
 c008e10:	e9c4 5505 	strd	r5, r5, [r4, #20]
 c008e14:	f7ff fc69 	bl	c0086ea <memset>
 c008e18:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 c008e1c:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 c008e20:	e7e9      	b.n	c008df6 <__sfp+0x42>
 c008e22:	bf00      	nop
 c008e24:	0c00aba0 	.word	0x0c00aba0
 c008e28:	ffff0001 	.word	0xffff0001

0c008e2c <_fwalk_reent>:
 c008e2c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c008e30:	4680      	mov	r8, r0
 c008e32:	4689      	mov	r9, r1
 c008e34:	f100 0448 	add.w	r4, r0, #72	; 0x48
 c008e38:	2600      	movs	r6, #0
 c008e3a:	b914      	cbnz	r4, c008e42 <_fwalk_reent+0x16>
 c008e3c:	4630      	mov	r0, r6
 c008e3e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c008e42:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 c008e46:	3f01      	subs	r7, #1
 c008e48:	d501      	bpl.n	c008e4e <_fwalk_reent+0x22>
 c008e4a:	6824      	ldr	r4, [r4, #0]
 c008e4c:	e7f5      	b.n	c008e3a <_fwalk_reent+0xe>
 c008e4e:	89ab      	ldrh	r3, [r5, #12]
 c008e50:	2b01      	cmp	r3, #1
 c008e52:	d907      	bls.n	c008e64 <_fwalk_reent+0x38>
 c008e54:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 c008e58:	3301      	adds	r3, #1
 c008e5a:	d003      	beq.n	c008e64 <_fwalk_reent+0x38>
 c008e5c:	4629      	mov	r1, r5
 c008e5e:	4640      	mov	r0, r8
 c008e60:	47c8      	blx	r9
 c008e62:	4306      	orrs	r6, r0
 c008e64:	3568      	adds	r5, #104	; 0x68
 c008e66:	e7ee      	b.n	c008e46 <_fwalk_reent+0x1a>

0c008e68 <__swhatbuf_r>:
 c008e68:	b570      	push	{r4, r5, r6, lr}
 c008e6a:	460e      	mov	r6, r1
 c008e6c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c008e70:	b096      	sub	sp, #88	; 0x58
 c008e72:	4614      	mov	r4, r2
 c008e74:	2900      	cmp	r1, #0
 c008e76:	461d      	mov	r5, r3
 c008e78:	da07      	bge.n	c008e8a <__swhatbuf_r+0x22>
 c008e7a:	2300      	movs	r3, #0
 c008e7c:	602b      	str	r3, [r5, #0]
 c008e7e:	89b3      	ldrh	r3, [r6, #12]
 c008e80:	061a      	lsls	r2, r3, #24
 c008e82:	d410      	bmi.n	c008ea6 <__swhatbuf_r+0x3e>
 c008e84:	f44f 6380 	mov.w	r3, #1024	; 0x400
 c008e88:	e00e      	b.n	c008ea8 <__swhatbuf_r+0x40>
 c008e8a:	466a      	mov	r2, sp
 c008e8c:	f000 fcd4 	bl	c009838 <_fstat_r>
 c008e90:	2800      	cmp	r0, #0
 c008e92:	dbf2      	blt.n	c008e7a <__swhatbuf_r+0x12>
 c008e94:	9a01      	ldr	r2, [sp, #4]
 c008e96:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 c008e9a:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 c008e9e:	425a      	negs	r2, r3
 c008ea0:	415a      	adcs	r2, r3
 c008ea2:	602a      	str	r2, [r5, #0]
 c008ea4:	e7ee      	b.n	c008e84 <__swhatbuf_r+0x1c>
 c008ea6:	2340      	movs	r3, #64	; 0x40
 c008ea8:	2000      	movs	r0, #0
 c008eaa:	6023      	str	r3, [r4, #0]
 c008eac:	b016      	add	sp, #88	; 0x58
 c008eae:	bd70      	pop	{r4, r5, r6, pc}

0c008eb0 <__smakebuf_r>:
 c008eb0:	898b      	ldrh	r3, [r1, #12]
 c008eb2:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c008eb4:	079d      	lsls	r5, r3, #30
 c008eb6:	4606      	mov	r6, r0
 c008eb8:	460c      	mov	r4, r1
 c008eba:	d507      	bpl.n	c008ecc <__smakebuf_r+0x1c>
 c008ebc:	f104 0347 	add.w	r3, r4, #71	; 0x47
 c008ec0:	6023      	str	r3, [r4, #0]
 c008ec2:	6123      	str	r3, [r4, #16]
 c008ec4:	2301      	movs	r3, #1
 c008ec6:	6163      	str	r3, [r4, #20]
 c008ec8:	b002      	add	sp, #8
 c008eca:	bd70      	pop	{r4, r5, r6, pc}
 c008ecc:	ab01      	add	r3, sp, #4
 c008ece:	466a      	mov	r2, sp
 c008ed0:	f7ff ffca 	bl	c008e68 <__swhatbuf_r>
 c008ed4:	9900      	ldr	r1, [sp, #0]
 c008ed6:	4605      	mov	r5, r0
 c008ed8:	4630      	mov	r0, r6
 c008eda:	f7ff fc6b 	bl	c0087b4 <_malloc_r>
 c008ede:	b948      	cbnz	r0, c008ef4 <__smakebuf_r+0x44>
 c008ee0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c008ee4:	059a      	lsls	r2, r3, #22
 c008ee6:	d4ef      	bmi.n	c008ec8 <__smakebuf_r+0x18>
 c008ee8:	f023 0303 	bic.w	r3, r3, #3
 c008eec:	f043 0302 	orr.w	r3, r3, #2
 c008ef0:	81a3      	strh	r3, [r4, #12]
 c008ef2:	e7e3      	b.n	c008ebc <__smakebuf_r+0xc>
 c008ef4:	4b0d      	ldr	r3, [pc, #52]	; (c008f2c <__smakebuf_r+0x7c>)
 c008ef6:	62b3      	str	r3, [r6, #40]	; 0x28
 c008ef8:	89a3      	ldrh	r3, [r4, #12]
 c008efa:	6020      	str	r0, [r4, #0]
 c008efc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 c008f00:	6120      	str	r0, [r4, #16]
 c008f02:	81a3      	strh	r3, [r4, #12]
 c008f04:	9b00      	ldr	r3, [sp, #0]
 c008f06:	6163      	str	r3, [r4, #20]
 c008f08:	9b01      	ldr	r3, [sp, #4]
 c008f0a:	b15b      	cbz	r3, c008f24 <__smakebuf_r+0x74>
 c008f0c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 c008f10:	4630      	mov	r0, r6
 c008f12:	f000 fca3 	bl	c00985c <_isatty_r>
 c008f16:	b128      	cbz	r0, c008f24 <__smakebuf_r+0x74>
 c008f18:	89a3      	ldrh	r3, [r4, #12]
 c008f1a:	f023 0303 	bic.w	r3, r3, #3
 c008f1e:	f043 0301 	orr.w	r3, r3, #1
 c008f22:	81a3      	strh	r3, [r4, #12]
 c008f24:	89a3      	ldrh	r3, [r4, #12]
 c008f26:	431d      	orrs	r5, r3
 c008f28:	81a5      	strh	r5, [r4, #12]
 c008f2a:	e7cd      	b.n	c008ec8 <__smakebuf_r+0x18>
 c008f2c:	0c008d1d 	.word	0x0c008d1d

0c008f30 <__malloc_lock>:
 c008f30:	4770      	bx	lr

0c008f32 <__malloc_unlock>:
 c008f32:	4770      	bx	lr

0c008f34 <__ssputs_r>:
 c008f34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c008f38:	688e      	ldr	r6, [r1, #8]
 c008f3a:	4682      	mov	sl, r0
 c008f3c:	460c      	mov	r4, r1
 c008f3e:	4690      	mov	r8, r2
 c008f40:	429e      	cmp	r6, r3
 c008f42:	4699      	mov	r9, r3
 c008f44:	d837      	bhi.n	c008fb6 <__ssputs_r+0x82>
 c008f46:	898a      	ldrh	r2, [r1, #12]
 c008f48:	f412 6f90 	tst.w	r2, #1152	; 0x480
 c008f4c:	d031      	beq.n	c008fb2 <__ssputs_r+0x7e>
 c008f4e:	6825      	ldr	r5, [r4, #0]
 c008f50:	2302      	movs	r3, #2
 c008f52:	6909      	ldr	r1, [r1, #16]
 c008f54:	1a6f      	subs	r7, r5, r1
 c008f56:	6965      	ldr	r5, [r4, #20]
 c008f58:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 c008f5c:	fb95 f5f3 	sdiv	r5, r5, r3
 c008f60:	f109 0301 	add.w	r3, r9, #1
 c008f64:	443b      	add	r3, r7
 c008f66:	429d      	cmp	r5, r3
 c008f68:	bf38      	it	cc
 c008f6a:	461d      	movcc	r5, r3
 c008f6c:	0553      	lsls	r3, r2, #21
 c008f6e:	d530      	bpl.n	c008fd2 <__ssputs_r+0x9e>
 c008f70:	4629      	mov	r1, r5
 c008f72:	f7ff fc1f 	bl	c0087b4 <_malloc_r>
 c008f76:	4606      	mov	r6, r0
 c008f78:	b950      	cbnz	r0, c008f90 <__ssputs_r+0x5c>
 c008f7a:	230c      	movs	r3, #12
 c008f7c:	f04f 30ff 	mov.w	r0, #4294967295
 c008f80:	f8ca 3000 	str.w	r3, [sl]
 c008f84:	89a3      	ldrh	r3, [r4, #12]
 c008f86:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 c008f8a:	81a3      	strh	r3, [r4, #12]
 c008f8c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c008f90:	463a      	mov	r2, r7
 c008f92:	6921      	ldr	r1, [r4, #16]
 c008f94:	f7ff fb9e 	bl	c0086d4 <memcpy>
 c008f98:	89a3      	ldrh	r3, [r4, #12]
 c008f9a:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 c008f9e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 c008fa2:	81a3      	strh	r3, [r4, #12]
 c008fa4:	6126      	str	r6, [r4, #16]
 c008fa6:	443e      	add	r6, r7
 c008fa8:	6165      	str	r5, [r4, #20]
 c008faa:	1bed      	subs	r5, r5, r7
 c008fac:	6026      	str	r6, [r4, #0]
 c008fae:	464e      	mov	r6, r9
 c008fb0:	60a5      	str	r5, [r4, #8]
 c008fb2:	454e      	cmp	r6, r9
 c008fb4:	d900      	bls.n	c008fb8 <__ssputs_r+0x84>
 c008fb6:	464e      	mov	r6, r9
 c008fb8:	4632      	mov	r2, r6
 c008fba:	4641      	mov	r1, r8
 c008fbc:	6820      	ldr	r0, [r4, #0]
 c008fbe:	f000 fc7d 	bl	c0098bc <memmove>
 c008fc2:	68a3      	ldr	r3, [r4, #8]
 c008fc4:	2000      	movs	r0, #0
 c008fc6:	1b9b      	subs	r3, r3, r6
 c008fc8:	60a3      	str	r3, [r4, #8]
 c008fca:	6823      	ldr	r3, [r4, #0]
 c008fcc:	441e      	add	r6, r3
 c008fce:	6026      	str	r6, [r4, #0]
 c008fd0:	e7dc      	b.n	c008f8c <__ssputs_r+0x58>
 c008fd2:	462a      	mov	r2, r5
 c008fd4:	f000 fc8b 	bl	c0098ee <_realloc_r>
 c008fd8:	4606      	mov	r6, r0
 c008fda:	2800      	cmp	r0, #0
 c008fdc:	d1e2      	bne.n	c008fa4 <__ssputs_r+0x70>
 c008fde:	6921      	ldr	r1, [r4, #16]
 c008fe0:	4650      	mov	r0, sl
 c008fe2:	f7ff fb99 	bl	c008718 <_free_r>
 c008fe6:	e7c8      	b.n	c008f7a <__ssputs_r+0x46>

0c008fe8 <_svfiprintf_r>:
 c008fe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c008fec:	461d      	mov	r5, r3
 c008fee:	898b      	ldrh	r3, [r1, #12]
 c008ff0:	b09d      	sub	sp, #116	; 0x74
 c008ff2:	4680      	mov	r8, r0
 c008ff4:	061f      	lsls	r7, r3, #24
 c008ff6:	460c      	mov	r4, r1
 c008ff8:	4616      	mov	r6, r2
 c008ffa:	d50f      	bpl.n	c00901c <_svfiprintf_r+0x34>
 c008ffc:	690b      	ldr	r3, [r1, #16]
 c008ffe:	b96b      	cbnz	r3, c00901c <_svfiprintf_r+0x34>
 c009000:	2140      	movs	r1, #64	; 0x40
 c009002:	f7ff fbd7 	bl	c0087b4 <_malloc_r>
 c009006:	6020      	str	r0, [r4, #0]
 c009008:	6120      	str	r0, [r4, #16]
 c00900a:	b928      	cbnz	r0, c009018 <_svfiprintf_r+0x30>
 c00900c:	230c      	movs	r3, #12
 c00900e:	f8c8 3000 	str.w	r3, [r8]
 c009012:	f04f 30ff 	mov.w	r0, #4294967295
 c009016:	e0c8      	b.n	c0091aa <_svfiprintf_r+0x1c2>
 c009018:	2340      	movs	r3, #64	; 0x40
 c00901a:	6163      	str	r3, [r4, #20]
 c00901c:	2300      	movs	r3, #0
 c00901e:	f04f 0b01 	mov.w	fp, #1
 c009022:	9503      	str	r5, [sp, #12]
 c009024:	9309      	str	r3, [sp, #36]	; 0x24
 c009026:	2320      	movs	r3, #32
 c009028:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 c00902c:	2330      	movs	r3, #48	; 0x30
 c00902e:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 c009032:	4637      	mov	r7, r6
 c009034:	463d      	mov	r5, r7
 c009036:	f815 3b01 	ldrb.w	r3, [r5], #1
 c00903a:	b10b      	cbz	r3, c009040 <_svfiprintf_r+0x58>
 c00903c:	2b25      	cmp	r3, #37	; 0x25
 c00903e:	d13e      	bne.n	c0090be <_svfiprintf_r+0xd6>
 c009040:	ebb7 0a06 	subs.w	sl, r7, r6
 c009044:	d00b      	beq.n	c00905e <_svfiprintf_r+0x76>
 c009046:	4653      	mov	r3, sl
 c009048:	4632      	mov	r2, r6
 c00904a:	4621      	mov	r1, r4
 c00904c:	4640      	mov	r0, r8
 c00904e:	f7ff ff71 	bl	c008f34 <__ssputs_r>
 c009052:	3001      	adds	r0, #1
 c009054:	f000 80a4 	beq.w	c0091a0 <_svfiprintf_r+0x1b8>
 c009058:	9b09      	ldr	r3, [sp, #36]	; 0x24
 c00905a:	4453      	add	r3, sl
 c00905c:	9309      	str	r3, [sp, #36]	; 0x24
 c00905e:	783b      	ldrb	r3, [r7, #0]
 c009060:	2b00      	cmp	r3, #0
 c009062:	f000 809d 	beq.w	c0091a0 <_svfiprintf_r+0x1b8>
 c009066:	2300      	movs	r3, #0
 c009068:	f04f 32ff 	mov.w	r2, #4294967295
 c00906c:	9304      	str	r3, [sp, #16]
 c00906e:	9307      	str	r3, [sp, #28]
 c009070:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 c009074:	931a      	str	r3, [sp, #104]	; 0x68
 c009076:	e9cd 2305 	strd	r2, r3, [sp, #20]
 c00907a:	462f      	mov	r7, r5
 c00907c:	2205      	movs	r2, #5
 c00907e:	4851      	ldr	r0, [pc, #324]	; (c0091c4 <_svfiprintf_r+0x1dc>)
 c009080:	f817 1b01 	ldrb.w	r1, [r7], #1
 c009084:	f000 fc0c 	bl	c0098a0 <memchr>
 c009088:	9b04      	ldr	r3, [sp, #16]
 c00908a:	b9d0      	cbnz	r0, c0090c2 <_svfiprintf_r+0xda>
 c00908c:	06d9      	lsls	r1, r3, #27
 c00908e:	bf44      	itt	mi
 c009090:	2220      	movmi	r2, #32
 c009092:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 c009096:	071a      	lsls	r2, r3, #28
 c009098:	bf44      	itt	mi
 c00909a:	222b      	movmi	r2, #43	; 0x2b
 c00909c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 c0090a0:	782a      	ldrb	r2, [r5, #0]
 c0090a2:	2a2a      	cmp	r2, #42	; 0x2a
 c0090a4:	d015      	beq.n	c0090d2 <_svfiprintf_r+0xea>
 c0090a6:	462f      	mov	r7, r5
 c0090a8:	9a07      	ldr	r2, [sp, #28]
 c0090aa:	2000      	movs	r0, #0
 c0090ac:	250a      	movs	r5, #10
 c0090ae:	4639      	mov	r1, r7
 c0090b0:	f811 3b01 	ldrb.w	r3, [r1], #1
 c0090b4:	3b30      	subs	r3, #48	; 0x30
 c0090b6:	2b09      	cmp	r3, #9
 c0090b8:	d94d      	bls.n	c009156 <_svfiprintf_r+0x16e>
 c0090ba:	b1b8      	cbz	r0, c0090ec <_svfiprintf_r+0x104>
 c0090bc:	e00f      	b.n	c0090de <_svfiprintf_r+0xf6>
 c0090be:	462f      	mov	r7, r5
 c0090c0:	e7b8      	b.n	c009034 <_svfiprintf_r+0x4c>
 c0090c2:	4a40      	ldr	r2, [pc, #256]	; (c0091c4 <_svfiprintf_r+0x1dc>)
 c0090c4:	463d      	mov	r5, r7
 c0090c6:	1a80      	subs	r0, r0, r2
 c0090c8:	fa0b f000 	lsl.w	r0, fp, r0
 c0090cc:	4318      	orrs	r0, r3
 c0090ce:	9004      	str	r0, [sp, #16]
 c0090d0:	e7d3      	b.n	c00907a <_svfiprintf_r+0x92>
 c0090d2:	9a03      	ldr	r2, [sp, #12]
 c0090d4:	1d11      	adds	r1, r2, #4
 c0090d6:	6812      	ldr	r2, [r2, #0]
 c0090d8:	2a00      	cmp	r2, #0
 c0090da:	9103      	str	r1, [sp, #12]
 c0090dc:	db01      	blt.n	c0090e2 <_svfiprintf_r+0xfa>
 c0090de:	9207      	str	r2, [sp, #28]
 c0090e0:	e004      	b.n	c0090ec <_svfiprintf_r+0x104>
 c0090e2:	4252      	negs	r2, r2
 c0090e4:	f043 0302 	orr.w	r3, r3, #2
 c0090e8:	9207      	str	r2, [sp, #28]
 c0090ea:	9304      	str	r3, [sp, #16]
 c0090ec:	783b      	ldrb	r3, [r7, #0]
 c0090ee:	2b2e      	cmp	r3, #46	; 0x2e
 c0090f0:	d10c      	bne.n	c00910c <_svfiprintf_r+0x124>
 c0090f2:	787b      	ldrb	r3, [r7, #1]
 c0090f4:	2b2a      	cmp	r3, #42	; 0x2a
 c0090f6:	d133      	bne.n	c009160 <_svfiprintf_r+0x178>
 c0090f8:	9b03      	ldr	r3, [sp, #12]
 c0090fa:	3702      	adds	r7, #2
 c0090fc:	1d1a      	adds	r2, r3, #4
 c0090fe:	681b      	ldr	r3, [r3, #0]
 c009100:	2b00      	cmp	r3, #0
 c009102:	9203      	str	r2, [sp, #12]
 c009104:	bfb8      	it	lt
 c009106:	f04f 33ff 	movlt.w	r3, #4294967295
 c00910a:	9305      	str	r3, [sp, #20]
 c00910c:	4d2e      	ldr	r5, [pc, #184]	; (c0091c8 <_svfiprintf_r+0x1e0>)
 c00910e:	2203      	movs	r2, #3
 c009110:	7839      	ldrb	r1, [r7, #0]
 c009112:	4628      	mov	r0, r5
 c009114:	f000 fbc4 	bl	c0098a0 <memchr>
 c009118:	b138      	cbz	r0, c00912a <_svfiprintf_r+0x142>
 c00911a:	2340      	movs	r3, #64	; 0x40
 c00911c:	1b40      	subs	r0, r0, r5
 c00911e:	3701      	adds	r7, #1
 c009120:	fa03 f000 	lsl.w	r0, r3, r0
 c009124:	9b04      	ldr	r3, [sp, #16]
 c009126:	4303      	orrs	r3, r0
 c009128:	9304      	str	r3, [sp, #16]
 c00912a:	7839      	ldrb	r1, [r7, #0]
 c00912c:	2206      	movs	r2, #6
 c00912e:	4827      	ldr	r0, [pc, #156]	; (c0091cc <_svfiprintf_r+0x1e4>)
 c009130:	1c7e      	adds	r6, r7, #1
 c009132:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 c009136:	f000 fbb3 	bl	c0098a0 <memchr>
 c00913a:	2800      	cmp	r0, #0
 c00913c:	d038      	beq.n	c0091b0 <_svfiprintf_r+0x1c8>
 c00913e:	4b24      	ldr	r3, [pc, #144]	; (c0091d0 <_svfiprintf_r+0x1e8>)
 c009140:	bb13      	cbnz	r3, c009188 <_svfiprintf_r+0x1a0>
 c009142:	9b03      	ldr	r3, [sp, #12]
 c009144:	3307      	adds	r3, #7
 c009146:	f023 0307 	bic.w	r3, r3, #7
 c00914a:	3308      	adds	r3, #8
 c00914c:	9303      	str	r3, [sp, #12]
 c00914e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 c009150:	444b      	add	r3, r9
 c009152:	9309      	str	r3, [sp, #36]	; 0x24
 c009154:	e76d      	b.n	c009032 <_svfiprintf_r+0x4a>
 c009156:	fb05 3202 	mla	r2, r5, r2, r3
 c00915a:	2001      	movs	r0, #1
 c00915c:	460f      	mov	r7, r1
 c00915e:	e7a6      	b.n	c0090ae <_svfiprintf_r+0xc6>
 c009160:	2300      	movs	r3, #0
 c009162:	3701      	adds	r7, #1
 c009164:	250a      	movs	r5, #10
 c009166:	4619      	mov	r1, r3
 c009168:	9305      	str	r3, [sp, #20]
 c00916a:	4638      	mov	r0, r7
 c00916c:	f810 2b01 	ldrb.w	r2, [r0], #1
 c009170:	3a30      	subs	r2, #48	; 0x30
 c009172:	2a09      	cmp	r2, #9
 c009174:	d903      	bls.n	c00917e <_svfiprintf_r+0x196>
 c009176:	2b00      	cmp	r3, #0
 c009178:	d0c8      	beq.n	c00910c <_svfiprintf_r+0x124>
 c00917a:	9105      	str	r1, [sp, #20]
 c00917c:	e7c6      	b.n	c00910c <_svfiprintf_r+0x124>
 c00917e:	fb05 2101 	mla	r1, r5, r1, r2
 c009182:	2301      	movs	r3, #1
 c009184:	4607      	mov	r7, r0
 c009186:	e7f0      	b.n	c00916a <_svfiprintf_r+0x182>
 c009188:	ab03      	add	r3, sp, #12
 c00918a:	4622      	mov	r2, r4
 c00918c:	a904      	add	r1, sp, #16
 c00918e:	4640      	mov	r0, r8
 c009190:	9300      	str	r3, [sp, #0]
 c009192:	4b10      	ldr	r3, [pc, #64]	; (c0091d4 <_svfiprintf_r+0x1ec>)
 c009194:	e000      	b.n	c009198 <_svfiprintf_r+0x1b0>
 c009196:	bf00      	nop
 c009198:	f1b0 3fff 	cmp.w	r0, #4294967295
 c00919c:	4681      	mov	r9, r0
 c00919e:	d1d6      	bne.n	c00914e <_svfiprintf_r+0x166>
 c0091a0:	89a3      	ldrh	r3, [r4, #12]
 c0091a2:	065b      	lsls	r3, r3, #25
 c0091a4:	f53f af35 	bmi.w	c009012 <_svfiprintf_r+0x2a>
 c0091a8:	9809      	ldr	r0, [sp, #36]	; 0x24
 c0091aa:	b01d      	add	sp, #116	; 0x74
 c0091ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c0091b0:	ab03      	add	r3, sp, #12
 c0091b2:	4622      	mov	r2, r4
 c0091b4:	a904      	add	r1, sp, #16
 c0091b6:	4640      	mov	r0, r8
 c0091b8:	9300      	str	r3, [sp, #0]
 c0091ba:	4b06      	ldr	r3, [pc, #24]	; (c0091d4 <_svfiprintf_r+0x1ec>)
 c0091bc:	f000 f9c4 	bl	c009548 <_printf_i>
 c0091c0:	e7ea      	b.n	c009198 <_svfiprintf_r+0x1b0>
 c0091c2:	bf00      	nop
 c0091c4:	0c00ac04 	.word	0x0c00ac04
 c0091c8:	0c00ac0a 	.word	0x0c00ac0a
 c0091cc:	0c00ac0e 	.word	0x0c00ac0e
 c0091d0:	00000000 	.word	0x00000000
 c0091d4:	0c008f35 	.word	0x0c008f35

0c0091d8 <__sfputc_r>:
 c0091d8:	6893      	ldr	r3, [r2, #8]
 c0091da:	3b01      	subs	r3, #1
 c0091dc:	2b00      	cmp	r3, #0
 c0091de:	6093      	str	r3, [r2, #8]
 c0091e0:	b410      	push	{r4}
 c0091e2:	da08      	bge.n	c0091f6 <__sfputc_r+0x1e>
 c0091e4:	6994      	ldr	r4, [r2, #24]
 c0091e6:	42a3      	cmp	r3, r4
 c0091e8:	db01      	blt.n	c0091ee <__sfputc_r+0x16>
 c0091ea:	290a      	cmp	r1, #10
 c0091ec:	d103      	bne.n	c0091f6 <__sfputc_r+0x1e>
 c0091ee:	f85d 4b04 	ldr.w	r4, [sp], #4
 c0091f2:	f7ff bc01 	b.w	c0089f8 <__swbuf_r>
 c0091f6:	6813      	ldr	r3, [r2, #0]
 c0091f8:	1c58      	adds	r0, r3, #1
 c0091fa:	6010      	str	r0, [r2, #0]
 c0091fc:	4608      	mov	r0, r1
 c0091fe:	7019      	strb	r1, [r3, #0]
 c009200:	f85d 4b04 	ldr.w	r4, [sp], #4
 c009204:	4770      	bx	lr

0c009206 <__sfputs_r>:
 c009206:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c009208:	4606      	mov	r6, r0
 c00920a:	460f      	mov	r7, r1
 c00920c:	4614      	mov	r4, r2
 c00920e:	18d5      	adds	r5, r2, r3
 c009210:	42ac      	cmp	r4, r5
 c009212:	d101      	bne.n	c009218 <__sfputs_r+0x12>
 c009214:	2000      	movs	r0, #0
 c009216:	e007      	b.n	c009228 <__sfputs_r+0x22>
 c009218:	463a      	mov	r2, r7
 c00921a:	f814 1b01 	ldrb.w	r1, [r4], #1
 c00921e:	4630      	mov	r0, r6
 c009220:	f7ff ffda 	bl	c0091d8 <__sfputc_r>
 c009224:	1c43      	adds	r3, r0, #1
 c009226:	d1f3      	bne.n	c009210 <__sfputs_r+0xa>
 c009228:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0c00922c <_vfiprintf_r>:
 c00922c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c009230:	460c      	mov	r4, r1
 c009232:	b09d      	sub	sp, #116	; 0x74
 c009234:	4617      	mov	r7, r2
 c009236:	461d      	mov	r5, r3
 c009238:	4606      	mov	r6, r0
 c00923a:	b118      	cbz	r0, c009244 <_vfiprintf_r+0x18>
 c00923c:	6983      	ldr	r3, [r0, #24]
 c00923e:	b90b      	cbnz	r3, c009244 <_vfiprintf_r+0x18>
 c009240:	f7ff fd88 	bl	c008d54 <__sinit>
 c009244:	4b7c      	ldr	r3, [pc, #496]	; (c009438 <_vfiprintf_r+0x20c>)
 c009246:	429c      	cmp	r4, r3
 c009248:	d158      	bne.n	c0092fc <_vfiprintf_r+0xd0>
 c00924a:	6874      	ldr	r4, [r6, #4]
 c00924c:	89a3      	ldrh	r3, [r4, #12]
 c00924e:	0718      	lsls	r0, r3, #28
 c009250:	d55e      	bpl.n	c009310 <_vfiprintf_r+0xe4>
 c009252:	6923      	ldr	r3, [r4, #16]
 c009254:	2b00      	cmp	r3, #0
 c009256:	d05b      	beq.n	c009310 <_vfiprintf_r+0xe4>
 c009258:	2300      	movs	r3, #0
 c00925a:	f04f 0b01 	mov.w	fp, #1
 c00925e:	9503      	str	r5, [sp, #12]
 c009260:	9309      	str	r3, [sp, #36]	; 0x24
 c009262:	2320      	movs	r3, #32
 c009264:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 c009268:	2330      	movs	r3, #48	; 0x30
 c00926a:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 c00926e:	46b8      	mov	r8, r7
 c009270:	4645      	mov	r5, r8
 c009272:	f815 3b01 	ldrb.w	r3, [r5], #1
 c009276:	b10b      	cbz	r3, c00927c <_vfiprintf_r+0x50>
 c009278:	2b25      	cmp	r3, #37	; 0x25
 c00927a:	d154      	bne.n	c009326 <_vfiprintf_r+0xfa>
 c00927c:	ebb8 0a07 	subs.w	sl, r8, r7
 c009280:	d00b      	beq.n	c00929a <_vfiprintf_r+0x6e>
 c009282:	4653      	mov	r3, sl
 c009284:	463a      	mov	r2, r7
 c009286:	4621      	mov	r1, r4
 c009288:	4630      	mov	r0, r6
 c00928a:	f7ff ffbc 	bl	c009206 <__sfputs_r>
 c00928e:	3001      	adds	r0, #1
 c009290:	f000 80c2 	beq.w	c009418 <_vfiprintf_r+0x1ec>
 c009294:	9b09      	ldr	r3, [sp, #36]	; 0x24
 c009296:	4453      	add	r3, sl
 c009298:	9309      	str	r3, [sp, #36]	; 0x24
 c00929a:	f898 3000 	ldrb.w	r3, [r8]
 c00929e:	2b00      	cmp	r3, #0
 c0092a0:	f000 80ba 	beq.w	c009418 <_vfiprintf_r+0x1ec>
 c0092a4:	2300      	movs	r3, #0
 c0092a6:	f04f 32ff 	mov.w	r2, #4294967295
 c0092aa:	9304      	str	r3, [sp, #16]
 c0092ac:	9307      	str	r3, [sp, #28]
 c0092ae:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 c0092b2:	931a      	str	r3, [sp, #104]	; 0x68
 c0092b4:	e9cd 2305 	strd	r2, r3, [sp, #20]
 c0092b8:	46a8      	mov	r8, r5
 c0092ba:	2205      	movs	r2, #5
 c0092bc:	485f      	ldr	r0, [pc, #380]	; (c00943c <_vfiprintf_r+0x210>)
 c0092be:	f818 1b01 	ldrb.w	r1, [r8], #1
 c0092c2:	f000 faed 	bl	c0098a0 <memchr>
 c0092c6:	9b04      	ldr	r3, [sp, #16]
 c0092c8:	bb78      	cbnz	r0, c00932a <_vfiprintf_r+0xfe>
 c0092ca:	06d9      	lsls	r1, r3, #27
 c0092cc:	bf44      	itt	mi
 c0092ce:	2220      	movmi	r2, #32
 c0092d0:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 c0092d4:	071a      	lsls	r2, r3, #28
 c0092d6:	bf44      	itt	mi
 c0092d8:	222b      	movmi	r2, #43	; 0x2b
 c0092da:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 c0092de:	782a      	ldrb	r2, [r5, #0]
 c0092e0:	2a2a      	cmp	r2, #42	; 0x2a
 c0092e2:	d02a      	beq.n	c00933a <_vfiprintf_r+0x10e>
 c0092e4:	46a8      	mov	r8, r5
 c0092e6:	9a07      	ldr	r2, [sp, #28]
 c0092e8:	2000      	movs	r0, #0
 c0092ea:	250a      	movs	r5, #10
 c0092ec:	4641      	mov	r1, r8
 c0092ee:	f811 3b01 	ldrb.w	r3, [r1], #1
 c0092f2:	3b30      	subs	r3, #48	; 0x30
 c0092f4:	2b09      	cmp	r3, #9
 c0092f6:	d969      	bls.n	c0093cc <_vfiprintf_r+0x1a0>
 c0092f8:	b360      	cbz	r0, c009354 <_vfiprintf_r+0x128>
 c0092fa:	e024      	b.n	c009346 <_vfiprintf_r+0x11a>
 c0092fc:	4b50      	ldr	r3, [pc, #320]	; (c009440 <_vfiprintf_r+0x214>)
 c0092fe:	429c      	cmp	r4, r3
 c009300:	d101      	bne.n	c009306 <_vfiprintf_r+0xda>
 c009302:	68b4      	ldr	r4, [r6, #8]
 c009304:	e7a2      	b.n	c00924c <_vfiprintf_r+0x20>
 c009306:	4b4f      	ldr	r3, [pc, #316]	; (c009444 <_vfiprintf_r+0x218>)
 c009308:	429c      	cmp	r4, r3
 c00930a:	bf08      	it	eq
 c00930c:	68f4      	ldreq	r4, [r6, #12]
 c00930e:	e79d      	b.n	c00924c <_vfiprintf_r+0x20>
 c009310:	4621      	mov	r1, r4
 c009312:	4630      	mov	r0, r6
 c009314:	f7ff fbc2 	bl	c008a9c <__swsetup_r>
 c009318:	2800      	cmp	r0, #0
 c00931a:	d09d      	beq.n	c009258 <_vfiprintf_r+0x2c>
 c00931c:	f04f 30ff 	mov.w	r0, #4294967295
 c009320:	b01d      	add	sp, #116	; 0x74
 c009322:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c009326:	46a8      	mov	r8, r5
 c009328:	e7a2      	b.n	c009270 <_vfiprintf_r+0x44>
 c00932a:	4a44      	ldr	r2, [pc, #272]	; (c00943c <_vfiprintf_r+0x210>)
 c00932c:	4645      	mov	r5, r8
 c00932e:	1a80      	subs	r0, r0, r2
 c009330:	fa0b f000 	lsl.w	r0, fp, r0
 c009334:	4318      	orrs	r0, r3
 c009336:	9004      	str	r0, [sp, #16]
 c009338:	e7be      	b.n	c0092b8 <_vfiprintf_r+0x8c>
 c00933a:	9a03      	ldr	r2, [sp, #12]
 c00933c:	1d11      	adds	r1, r2, #4
 c00933e:	6812      	ldr	r2, [r2, #0]
 c009340:	2a00      	cmp	r2, #0
 c009342:	9103      	str	r1, [sp, #12]
 c009344:	db01      	blt.n	c00934a <_vfiprintf_r+0x11e>
 c009346:	9207      	str	r2, [sp, #28]
 c009348:	e004      	b.n	c009354 <_vfiprintf_r+0x128>
 c00934a:	4252      	negs	r2, r2
 c00934c:	f043 0302 	orr.w	r3, r3, #2
 c009350:	9207      	str	r2, [sp, #28]
 c009352:	9304      	str	r3, [sp, #16]
 c009354:	f898 3000 	ldrb.w	r3, [r8]
 c009358:	2b2e      	cmp	r3, #46	; 0x2e
 c00935a:	d10e      	bne.n	c00937a <_vfiprintf_r+0x14e>
 c00935c:	f898 3001 	ldrb.w	r3, [r8, #1]
 c009360:	2b2a      	cmp	r3, #42	; 0x2a
 c009362:	d138      	bne.n	c0093d6 <_vfiprintf_r+0x1aa>
 c009364:	9b03      	ldr	r3, [sp, #12]
 c009366:	f108 0802 	add.w	r8, r8, #2
 c00936a:	1d1a      	adds	r2, r3, #4
 c00936c:	681b      	ldr	r3, [r3, #0]
 c00936e:	2b00      	cmp	r3, #0
 c009370:	9203      	str	r2, [sp, #12]
 c009372:	bfb8      	it	lt
 c009374:	f04f 33ff 	movlt.w	r3, #4294967295
 c009378:	9305      	str	r3, [sp, #20]
 c00937a:	4d33      	ldr	r5, [pc, #204]	; (c009448 <_vfiprintf_r+0x21c>)
 c00937c:	2203      	movs	r2, #3
 c00937e:	f898 1000 	ldrb.w	r1, [r8]
 c009382:	4628      	mov	r0, r5
 c009384:	f000 fa8c 	bl	c0098a0 <memchr>
 c009388:	b140      	cbz	r0, c00939c <_vfiprintf_r+0x170>
 c00938a:	2340      	movs	r3, #64	; 0x40
 c00938c:	1b40      	subs	r0, r0, r5
 c00938e:	f108 0801 	add.w	r8, r8, #1
 c009392:	fa03 f000 	lsl.w	r0, r3, r0
 c009396:	9b04      	ldr	r3, [sp, #16]
 c009398:	4303      	orrs	r3, r0
 c00939a:	9304      	str	r3, [sp, #16]
 c00939c:	f898 1000 	ldrb.w	r1, [r8]
 c0093a0:	2206      	movs	r2, #6
 c0093a2:	482a      	ldr	r0, [pc, #168]	; (c00944c <_vfiprintf_r+0x220>)
 c0093a4:	f108 0701 	add.w	r7, r8, #1
 c0093a8:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 c0093ac:	f000 fa78 	bl	c0098a0 <memchr>
 c0093b0:	2800      	cmp	r0, #0
 c0093b2:	d037      	beq.n	c009424 <_vfiprintf_r+0x1f8>
 c0093b4:	4b26      	ldr	r3, [pc, #152]	; (c009450 <_vfiprintf_r+0x224>)
 c0093b6:	bb1b      	cbnz	r3, c009400 <_vfiprintf_r+0x1d4>
 c0093b8:	9b03      	ldr	r3, [sp, #12]
 c0093ba:	3307      	adds	r3, #7
 c0093bc:	f023 0307 	bic.w	r3, r3, #7
 c0093c0:	3308      	adds	r3, #8
 c0093c2:	9303      	str	r3, [sp, #12]
 c0093c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 c0093c6:	444b      	add	r3, r9
 c0093c8:	9309      	str	r3, [sp, #36]	; 0x24
 c0093ca:	e750      	b.n	c00926e <_vfiprintf_r+0x42>
 c0093cc:	fb05 3202 	mla	r2, r5, r2, r3
 c0093d0:	2001      	movs	r0, #1
 c0093d2:	4688      	mov	r8, r1
 c0093d4:	e78a      	b.n	c0092ec <_vfiprintf_r+0xc0>
 c0093d6:	2300      	movs	r3, #0
 c0093d8:	f108 0801 	add.w	r8, r8, #1
 c0093dc:	250a      	movs	r5, #10
 c0093de:	4619      	mov	r1, r3
 c0093e0:	9305      	str	r3, [sp, #20]
 c0093e2:	4640      	mov	r0, r8
 c0093e4:	f810 2b01 	ldrb.w	r2, [r0], #1
 c0093e8:	3a30      	subs	r2, #48	; 0x30
 c0093ea:	2a09      	cmp	r2, #9
 c0093ec:	d903      	bls.n	c0093f6 <_vfiprintf_r+0x1ca>
 c0093ee:	2b00      	cmp	r3, #0
 c0093f0:	d0c3      	beq.n	c00937a <_vfiprintf_r+0x14e>
 c0093f2:	9105      	str	r1, [sp, #20]
 c0093f4:	e7c1      	b.n	c00937a <_vfiprintf_r+0x14e>
 c0093f6:	fb05 2101 	mla	r1, r5, r1, r2
 c0093fa:	2301      	movs	r3, #1
 c0093fc:	4680      	mov	r8, r0
 c0093fe:	e7f0      	b.n	c0093e2 <_vfiprintf_r+0x1b6>
 c009400:	ab03      	add	r3, sp, #12
 c009402:	4622      	mov	r2, r4
 c009404:	a904      	add	r1, sp, #16
 c009406:	4630      	mov	r0, r6
 c009408:	9300      	str	r3, [sp, #0]
 c00940a:	4b12      	ldr	r3, [pc, #72]	; (c009454 <_vfiprintf_r+0x228>)
 c00940c:	e000      	b.n	c009410 <_vfiprintf_r+0x1e4>
 c00940e:	bf00      	nop
 c009410:	f1b0 3fff 	cmp.w	r0, #4294967295
 c009414:	4681      	mov	r9, r0
 c009416:	d1d5      	bne.n	c0093c4 <_vfiprintf_r+0x198>
 c009418:	89a3      	ldrh	r3, [r4, #12]
 c00941a:	065b      	lsls	r3, r3, #25
 c00941c:	f53f af7e 	bmi.w	c00931c <_vfiprintf_r+0xf0>
 c009420:	9809      	ldr	r0, [sp, #36]	; 0x24
 c009422:	e77d      	b.n	c009320 <_vfiprintf_r+0xf4>
 c009424:	ab03      	add	r3, sp, #12
 c009426:	4622      	mov	r2, r4
 c009428:	a904      	add	r1, sp, #16
 c00942a:	4630      	mov	r0, r6
 c00942c:	9300      	str	r3, [sp, #0]
 c00942e:	4b09      	ldr	r3, [pc, #36]	; (c009454 <_vfiprintf_r+0x228>)
 c009430:	f000 f88a 	bl	c009548 <_printf_i>
 c009434:	e7ec      	b.n	c009410 <_vfiprintf_r+0x1e4>
 c009436:	bf00      	nop
 c009438:	0c00abc4 	.word	0x0c00abc4
 c00943c:	0c00ac04 	.word	0x0c00ac04
 c009440:	0c00abe4 	.word	0x0c00abe4
 c009444:	0c00aba4 	.word	0x0c00aba4
 c009448:	0c00ac0a 	.word	0x0c00ac0a
 c00944c:	0c00ac0e 	.word	0x0c00ac0e
 c009450:	00000000 	.word	0x00000000
 c009454:	0c009207 	.word	0x0c009207

0c009458 <_printf_common>:
 c009458:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c00945c:	4691      	mov	r9, r2
 c00945e:	461f      	mov	r7, r3
 c009460:	688a      	ldr	r2, [r1, #8]
 c009462:	4606      	mov	r6, r0
 c009464:	690b      	ldr	r3, [r1, #16]
 c009466:	460c      	mov	r4, r1
 c009468:	f8dd 8020 	ldr.w	r8, [sp, #32]
 c00946c:	4293      	cmp	r3, r2
 c00946e:	bfb8      	it	lt
 c009470:	4613      	movlt	r3, r2
 c009472:	f8c9 3000 	str.w	r3, [r9]
 c009476:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 c00947a:	b112      	cbz	r2, c009482 <_printf_common+0x2a>
 c00947c:	3301      	adds	r3, #1
 c00947e:	f8c9 3000 	str.w	r3, [r9]
 c009482:	6823      	ldr	r3, [r4, #0]
 c009484:	0699      	lsls	r1, r3, #26
 c009486:	bf42      	ittt	mi
 c009488:	f8d9 3000 	ldrmi.w	r3, [r9]
 c00948c:	3302      	addmi	r3, #2
 c00948e:	f8c9 3000 	strmi.w	r3, [r9]
 c009492:	6825      	ldr	r5, [r4, #0]
 c009494:	f015 0506 	ands.w	r5, r5, #6
 c009498:	d107      	bne.n	c0094aa <_printf_common+0x52>
 c00949a:	f104 0a19 	add.w	sl, r4, #25
 c00949e:	68e3      	ldr	r3, [r4, #12]
 c0094a0:	f8d9 2000 	ldr.w	r2, [r9]
 c0094a4:	1a9b      	subs	r3, r3, r2
 c0094a6:	42ab      	cmp	r3, r5
 c0094a8:	dc2b      	bgt.n	c009502 <_printf_common+0xaa>
 c0094aa:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 c0094ae:	6822      	ldr	r2, [r4, #0]
 c0094b0:	3300      	adds	r3, #0
 c0094b2:	bf18      	it	ne
 c0094b4:	2301      	movne	r3, #1
 c0094b6:	0692      	lsls	r2, r2, #26
 c0094b8:	d430      	bmi.n	c00951c <_printf_common+0xc4>
 c0094ba:	f104 0243 	add.w	r2, r4, #67	; 0x43
 c0094be:	4639      	mov	r1, r7
 c0094c0:	4630      	mov	r0, r6
 c0094c2:	47c0      	blx	r8
 c0094c4:	3001      	adds	r0, #1
 c0094c6:	d023      	beq.n	c009510 <_printf_common+0xb8>
 c0094c8:	6823      	ldr	r3, [r4, #0]
 c0094ca:	341a      	adds	r4, #26
 c0094cc:	f854 5c0e 	ldr.w	r5, [r4, #-14]
 c0094d0:	f003 0306 	and.w	r3, r3, #6
 c0094d4:	f8d9 2000 	ldr.w	r2, [r9]
 c0094d8:	f04f 0900 	mov.w	r9, #0
 c0094dc:	2b04      	cmp	r3, #4
 c0094de:	f854 3c12 	ldr.w	r3, [r4, #-18]
 c0094e2:	bf08      	it	eq
 c0094e4:	1aad      	subeq	r5, r5, r2
 c0094e6:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 c0094ea:	bf14      	ite	ne
 c0094ec:	2500      	movne	r5, #0
 c0094ee:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 c0094f2:	4293      	cmp	r3, r2
 c0094f4:	bfc4      	itt	gt
 c0094f6:	1a9b      	subgt	r3, r3, r2
 c0094f8:	18ed      	addgt	r5, r5, r3
 c0094fa:	454d      	cmp	r5, r9
 c0094fc:	d11a      	bne.n	c009534 <_printf_common+0xdc>
 c0094fe:	2000      	movs	r0, #0
 c009500:	e008      	b.n	c009514 <_printf_common+0xbc>
 c009502:	2301      	movs	r3, #1
 c009504:	4652      	mov	r2, sl
 c009506:	4639      	mov	r1, r7
 c009508:	4630      	mov	r0, r6
 c00950a:	47c0      	blx	r8
 c00950c:	3001      	adds	r0, #1
 c00950e:	d103      	bne.n	c009518 <_printf_common+0xc0>
 c009510:	f04f 30ff 	mov.w	r0, #4294967295
 c009514:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c009518:	3501      	adds	r5, #1
 c00951a:	e7c0      	b.n	c00949e <_printf_common+0x46>
 c00951c:	18e1      	adds	r1, r4, r3
 c00951e:	1c5a      	adds	r2, r3, #1
 c009520:	2030      	movs	r0, #48	; 0x30
 c009522:	3302      	adds	r3, #2
 c009524:	4422      	add	r2, r4
 c009526:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 c00952a:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 c00952e:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 c009532:	e7c2      	b.n	c0094ba <_printf_common+0x62>
 c009534:	2301      	movs	r3, #1
 c009536:	4622      	mov	r2, r4
 c009538:	4639      	mov	r1, r7
 c00953a:	4630      	mov	r0, r6
 c00953c:	47c0      	blx	r8
 c00953e:	3001      	adds	r0, #1
 c009540:	d0e6      	beq.n	c009510 <_printf_common+0xb8>
 c009542:	f109 0901 	add.w	r9, r9, #1
 c009546:	e7d8      	b.n	c0094fa <_printf_common+0xa2>

0c009548 <_printf_i>:
 c009548:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c00954c:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 c009550:	460c      	mov	r4, r1
 c009552:	7e09      	ldrb	r1, [r1, #24]
 c009554:	b085      	sub	sp, #20
 c009556:	4617      	mov	r7, r2
 c009558:	4606      	mov	r6, r0
 c00955a:	296e      	cmp	r1, #110	; 0x6e
 c00955c:	4698      	mov	r8, r3
 c00955e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 c009560:	f000 80b3 	beq.w	c0096ca <_printf_i+0x182>
 c009564:	d822      	bhi.n	c0095ac <_printf_i+0x64>
 c009566:	2963      	cmp	r1, #99	; 0x63
 c009568:	d036      	beq.n	c0095d8 <_printf_i+0x90>
 c00956a:	d80a      	bhi.n	c009582 <_printf_i+0x3a>
 c00956c:	2900      	cmp	r1, #0
 c00956e:	f000 80b9 	beq.w	c0096e4 <_printf_i+0x19c>
 c009572:	2958      	cmp	r1, #88	; 0x58
 c009574:	f000 8083 	beq.w	c00967e <_printf_i+0x136>
 c009578:	f104 0542 	add.w	r5, r4, #66	; 0x42
 c00957c:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 c009580:	e032      	b.n	c0095e8 <_printf_i+0xa0>
 c009582:	2964      	cmp	r1, #100	; 0x64
 c009584:	d001      	beq.n	c00958a <_printf_i+0x42>
 c009586:	2969      	cmp	r1, #105	; 0x69
 c009588:	d1f6      	bne.n	c009578 <_printf_i+0x30>
 c00958a:	6820      	ldr	r0, [r4, #0]
 c00958c:	6813      	ldr	r3, [r2, #0]
 c00958e:	0605      	lsls	r5, r0, #24
 c009590:	f103 0104 	add.w	r1, r3, #4
 c009594:	d52a      	bpl.n	c0095ec <_printf_i+0xa4>
 c009596:	681b      	ldr	r3, [r3, #0]
 c009598:	6011      	str	r1, [r2, #0]
 c00959a:	2b00      	cmp	r3, #0
 c00959c:	da03      	bge.n	c0095a6 <_printf_i+0x5e>
 c00959e:	222d      	movs	r2, #45	; 0x2d
 c0095a0:	425b      	negs	r3, r3
 c0095a2:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 c0095a6:	486f      	ldr	r0, [pc, #444]	; (c009764 <_printf_i+0x21c>)
 c0095a8:	220a      	movs	r2, #10
 c0095aa:	e039      	b.n	c009620 <_printf_i+0xd8>
 c0095ac:	2973      	cmp	r1, #115	; 0x73
 c0095ae:	f000 809d 	beq.w	c0096ec <_printf_i+0x1a4>
 c0095b2:	d808      	bhi.n	c0095c6 <_printf_i+0x7e>
 c0095b4:	296f      	cmp	r1, #111	; 0x6f
 c0095b6:	d020      	beq.n	c0095fa <_printf_i+0xb2>
 c0095b8:	2970      	cmp	r1, #112	; 0x70
 c0095ba:	d1dd      	bne.n	c009578 <_printf_i+0x30>
 c0095bc:	6823      	ldr	r3, [r4, #0]
 c0095be:	f043 0320 	orr.w	r3, r3, #32
 c0095c2:	6023      	str	r3, [r4, #0]
 c0095c4:	e003      	b.n	c0095ce <_printf_i+0x86>
 c0095c6:	2975      	cmp	r1, #117	; 0x75
 c0095c8:	d017      	beq.n	c0095fa <_printf_i+0xb2>
 c0095ca:	2978      	cmp	r1, #120	; 0x78
 c0095cc:	d1d4      	bne.n	c009578 <_printf_i+0x30>
 c0095ce:	2378      	movs	r3, #120	; 0x78
 c0095d0:	4865      	ldr	r0, [pc, #404]	; (c009768 <_printf_i+0x220>)
 c0095d2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 c0095d6:	e055      	b.n	c009684 <_printf_i+0x13c>
 c0095d8:	6813      	ldr	r3, [r2, #0]
 c0095da:	f104 0542 	add.w	r5, r4, #66	; 0x42
 c0095de:	1d19      	adds	r1, r3, #4
 c0095e0:	681b      	ldr	r3, [r3, #0]
 c0095e2:	6011      	str	r1, [r2, #0]
 c0095e4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 c0095e8:	2301      	movs	r3, #1
 c0095ea:	e08c      	b.n	c009706 <_printf_i+0x1be>
 c0095ec:	681b      	ldr	r3, [r3, #0]
 c0095ee:	f010 0f40 	tst.w	r0, #64	; 0x40
 c0095f2:	6011      	str	r1, [r2, #0]
 c0095f4:	bf18      	it	ne
 c0095f6:	b21b      	sxthne	r3, r3
 c0095f8:	e7cf      	b.n	c00959a <_printf_i+0x52>
 c0095fa:	6813      	ldr	r3, [r2, #0]
 c0095fc:	6825      	ldr	r5, [r4, #0]
 c0095fe:	1d18      	adds	r0, r3, #4
 c009600:	6010      	str	r0, [r2, #0]
 c009602:	0628      	lsls	r0, r5, #24
 c009604:	d501      	bpl.n	c00960a <_printf_i+0xc2>
 c009606:	681b      	ldr	r3, [r3, #0]
 c009608:	e002      	b.n	c009610 <_printf_i+0xc8>
 c00960a:	0668      	lsls	r0, r5, #25
 c00960c:	d5fb      	bpl.n	c009606 <_printf_i+0xbe>
 c00960e:	881b      	ldrh	r3, [r3, #0]
 c009610:	296f      	cmp	r1, #111	; 0x6f
 c009612:	4854      	ldr	r0, [pc, #336]	; (c009764 <_printf_i+0x21c>)
 c009614:	bf14      	ite	ne
 c009616:	220a      	movne	r2, #10
 c009618:	2208      	moveq	r2, #8
 c00961a:	2100      	movs	r1, #0
 c00961c:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 c009620:	6865      	ldr	r5, [r4, #4]
 c009622:	2d00      	cmp	r5, #0
 c009624:	60a5      	str	r5, [r4, #8]
 c009626:	f2c0 8095 	blt.w	c009754 <_printf_i+0x20c>
 c00962a:	6821      	ldr	r1, [r4, #0]
 c00962c:	f021 0104 	bic.w	r1, r1, #4
 c009630:	6021      	str	r1, [r4, #0]
 c009632:	2b00      	cmp	r3, #0
 c009634:	d13d      	bne.n	c0096b2 <_printf_i+0x16a>
 c009636:	2d00      	cmp	r5, #0
 c009638:	f040 808e 	bne.w	c009758 <_printf_i+0x210>
 c00963c:	4665      	mov	r5, ip
 c00963e:	2a08      	cmp	r2, #8
 c009640:	d10b      	bne.n	c00965a <_printf_i+0x112>
 c009642:	6823      	ldr	r3, [r4, #0]
 c009644:	07db      	lsls	r3, r3, #31
 c009646:	d508      	bpl.n	c00965a <_printf_i+0x112>
 c009648:	6923      	ldr	r3, [r4, #16]
 c00964a:	6862      	ldr	r2, [r4, #4]
 c00964c:	429a      	cmp	r2, r3
 c00964e:	bfde      	ittt	le
 c009650:	2330      	movle	r3, #48	; 0x30
 c009652:	f805 3c01 	strble.w	r3, [r5, #-1]
 c009656:	f105 35ff 	addle.w	r5, r5, #4294967295
 c00965a:	ebac 0305 	sub.w	r3, ip, r5
 c00965e:	6123      	str	r3, [r4, #16]
 c009660:	f8cd 8000 	str.w	r8, [sp]
 c009664:	463b      	mov	r3, r7
 c009666:	aa03      	add	r2, sp, #12
 c009668:	4621      	mov	r1, r4
 c00966a:	4630      	mov	r0, r6
 c00966c:	f7ff fef4 	bl	c009458 <_printf_common>
 c009670:	3001      	adds	r0, #1
 c009672:	d14d      	bne.n	c009710 <_printf_i+0x1c8>
 c009674:	f04f 30ff 	mov.w	r0, #4294967295
 c009678:	b005      	add	sp, #20
 c00967a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 c00967e:	4839      	ldr	r0, [pc, #228]	; (c009764 <_printf_i+0x21c>)
 c009680:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 c009684:	6813      	ldr	r3, [r2, #0]
 c009686:	6821      	ldr	r1, [r4, #0]
 c009688:	1d1d      	adds	r5, r3, #4
 c00968a:	681b      	ldr	r3, [r3, #0]
 c00968c:	6015      	str	r5, [r2, #0]
 c00968e:	060a      	lsls	r2, r1, #24
 c009690:	d50b      	bpl.n	c0096aa <_printf_i+0x162>
 c009692:	07ca      	lsls	r2, r1, #31
 c009694:	bf44      	itt	mi
 c009696:	f041 0120 	orrmi.w	r1, r1, #32
 c00969a:	6021      	strmi	r1, [r4, #0]
 c00969c:	b91b      	cbnz	r3, c0096a6 <_printf_i+0x15e>
 c00969e:	6822      	ldr	r2, [r4, #0]
 c0096a0:	f022 0220 	bic.w	r2, r2, #32
 c0096a4:	6022      	str	r2, [r4, #0]
 c0096a6:	2210      	movs	r2, #16
 c0096a8:	e7b7      	b.n	c00961a <_printf_i+0xd2>
 c0096aa:	064d      	lsls	r5, r1, #25
 c0096ac:	bf48      	it	mi
 c0096ae:	b29b      	uxthmi	r3, r3
 c0096b0:	e7ef      	b.n	c009692 <_printf_i+0x14a>
 c0096b2:	4665      	mov	r5, ip
 c0096b4:	fbb3 f1f2 	udiv	r1, r3, r2
 c0096b8:	fb02 3311 	mls	r3, r2, r1, r3
 c0096bc:	5cc3      	ldrb	r3, [r0, r3]
 c0096be:	f805 3d01 	strb.w	r3, [r5, #-1]!
 c0096c2:	460b      	mov	r3, r1
 c0096c4:	2900      	cmp	r1, #0
 c0096c6:	d1f5      	bne.n	c0096b4 <_printf_i+0x16c>
 c0096c8:	e7b9      	b.n	c00963e <_printf_i+0xf6>
 c0096ca:	6813      	ldr	r3, [r2, #0]
 c0096cc:	6825      	ldr	r5, [r4, #0]
 c0096ce:	1d18      	adds	r0, r3, #4
 c0096d0:	6961      	ldr	r1, [r4, #20]
 c0096d2:	6010      	str	r0, [r2, #0]
 c0096d4:	0628      	lsls	r0, r5, #24
 c0096d6:	681b      	ldr	r3, [r3, #0]
 c0096d8:	d501      	bpl.n	c0096de <_printf_i+0x196>
 c0096da:	6019      	str	r1, [r3, #0]
 c0096dc:	e002      	b.n	c0096e4 <_printf_i+0x19c>
 c0096de:	066a      	lsls	r2, r5, #25
 c0096e0:	d5fb      	bpl.n	c0096da <_printf_i+0x192>
 c0096e2:	8019      	strh	r1, [r3, #0]
 c0096e4:	2300      	movs	r3, #0
 c0096e6:	4665      	mov	r5, ip
 c0096e8:	6123      	str	r3, [r4, #16]
 c0096ea:	e7b9      	b.n	c009660 <_printf_i+0x118>
 c0096ec:	6813      	ldr	r3, [r2, #0]
 c0096ee:	1d19      	adds	r1, r3, #4
 c0096f0:	6011      	str	r1, [r2, #0]
 c0096f2:	2100      	movs	r1, #0
 c0096f4:	681d      	ldr	r5, [r3, #0]
 c0096f6:	6862      	ldr	r2, [r4, #4]
 c0096f8:	4628      	mov	r0, r5
 c0096fa:	f000 f8d1 	bl	c0098a0 <memchr>
 c0096fe:	b108      	cbz	r0, c009704 <_printf_i+0x1bc>
 c009700:	1b40      	subs	r0, r0, r5
 c009702:	6060      	str	r0, [r4, #4]
 c009704:	6863      	ldr	r3, [r4, #4]
 c009706:	6123      	str	r3, [r4, #16]
 c009708:	2300      	movs	r3, #0
 c00970a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 c00970e:	e7a7      	b.n	c009660 <_printf_i+0x118>
 c009710:	6923      	ldr	r3, [r4, #16]
 c009712:	462a      	mov	r2, r5
 c009714:	4639      	mov	r1, r7
 c009716:	4630      	mov	r0, r6
 c009718:	47c0      	blx	r8
 c00971a:	3001      	adds	r0, #1
 c00971c:	d0aa      	beq.n	c009674 <_printf_i+0x12c>
 c00971e:	6823      	ldr	r3, [r4, #0]
 c009720:	079b      	lsls	r3, r3, #30
 c009722:	d413      	bmi.n	c00974c <_printf_i+0x204>
 c009724:	68e0      	ldr	r0, [r4, #12]
 c009726:	9b03      	ldr	r3, [sp, #12]
 c009728:	4298      	cmp	r0, r3
 c00972a:	bfb8      	it	lt
 c00972c:	4618      	movlt	r0, r3
 c00972e:	e7a3      	b.n	c009678 <_printf_i+0x130>
 c009730:	2301      	movs	r3, #1
 c009732:	464a      	mov	r2, r9
 c009734:	4639      	mov	r1, r7
 c009736:	4630      	mov	r0, r6
 c009738:	47c0      	blx	r8
 c00973a:	3001      	adds	r0, #1
 c00973c:	d09a      	beq.n	c009674 <_printf_i+0x12c>
 c00973e:	3501      	adds	r5, #1
 c009740:	68e3      	ldr	r3, [r4, #12]
 c009742:	9a03      	ldr	r2, [sp, #12]
 c009744:	1a9b      	subs	r3, r3, r2
 c009746:	42ab      	cmp	r3, r5
 c009748:	dcf2      	bgt.n	c009730 <_printf_i+0x1e8>
 c00974a:	e7eb      	b.n	c009724 <_printf_i+0x1dc>
 c00974c:	2500      	movs	r5, #0
 c00974e:	f104 0919 	add.w	r9, r4, #25
 c009752:	e7f5      	b.n	c009740 <_printf_i+0x1f8>
 c009754:	2b00      	cmp	r3, #0
 c009756:	d1ac      	bne.n	c0096b2 <_printf_i+0x16a>
 c009758:	7803      	ldrb	r3, [r0, #0]
 c00975a:	f104 0542 	add.w	r5, r4, #66	; 0x42
 c00975e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 c009762:	e76c      	b.n	c00963e <_printf_i+0xf6>
 c009764:	0c00ac15 	.word	0x0c00ac15
 c009768:	0c00ac26 	.word	0x0c00ac26

0c00976c <__sread>:
 c00976c:	b510      	push	{r4, lr}
 c00976e:	460c      	mov	r4, r1
 c009770:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c009774:	f000 f8e2 	bl	c00993c <_read_r>
 c009778:	2800      	cmp	r0, #0
 c00977a:	bfab      	itete	ge
 c00977c:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 c00977e:	89a3      	ldrhlt	r3, [r4, #12]
 c009780:	181b      	addge	r3, r3, r0
 c009782:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 c009786:	bfac      	ite	ge
 c009788:	6563      	strge	r3, [r4, #84]	; 0x54
 c00978a:	81a3      	strhlt	r3, [r4, #12]
 c00978c:	bd10      	pop	{r4, pc}

0c00978e <__swrite>:
 c00978e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c009792:	461f      	mov	r7, r3
 c009794:	898b      	ldrh	r3, [r1, #12]
 c009796:	4605      	mov	r5, r0
 c009798:	460c      	mov	r4, r1
 c00979a:	05db      	lsls	r3, r3, #23
 c00979c:	4616      	mov	r6, r2
 c00979e:	d505      	bpl.n	c0097ac <__swrite+0x1e>
 c0097a0:	2302      	movs	r3, #2
 c0097a2:	2200      	movs	r2, #0
 c0097a4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c0097a8:	f000 f868 	bl	c00987c <_lseek_r>
 c0097ac:	89a3      	ldrh	r3, [r4, #12]
 c0097ae:	4632      	mov	r2, r6
 c0097b0:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 c0097b4:	4628      	mov	r0, r5
 c0097b6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 c0097ba:	81a3      	strh	r3, [r4, #12]
 c0097bc:	463b      	mov	r3, r7
 c0097be:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 c0097c2:	f000 b817 	b.w	c0097f4 <_write_r>

0c0097c6 <__sseek>:
 c0097c6:	b510      	push	{r4, lr}
 c0097c8:	460c      	mov	r4, r1
 c0097ca:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c0097ce:	f000 f855 	bl	c00987c <_lseek_r>
 c0097d2:	1c43      	adds	r3, r0, #1
 c0097d4:	89a3      	ldrh	r3, [r4, #12]
 c0097d6:	bf15      	itete	ne
 c0097d8:	6560      	strne	r0, [r4, #84]	; 0x54
 c0097da:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 c0097de:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 c0097e2:	81a3      	strheq	r3, [r4, #12]
 c0097e4:	bf18      	it	ne
 c0097e6:	81a3      	strhne	r3, [r4, #12]
 c0097e8:	bd10      	pop	{r4, pc}

0c0097ea <__sclose>:
 c0097ea:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c0097ee:	f000 b813 	b.w	c009818 <_close_r>
	...

0c0097f4 <_write_r>:
 c0097f4:	b538      	push	{r3, r4, r5, lr}
 c0097f6:	4605      	mov	r5, r0
 c0097f8:	4c06      	ldr	r4, [pc, #24]	; (c009814 <_write_r+0x20>)
 c0097fa:	4608      	mov	r0, r1
 c0097fc:	4611      	mov	r1, r2
 c0097fe:	2200      	movs	r2, #0
 c009800:	6022      	str	r2, [r4, #0]
 c009802:	461a      	mov	r2, r3
 c009804:	f7fe fef2 	bl	c0085ec <_write>
 c009808:	1c43      	adds	r3, r0, #1
 c00980a:	d102      	bne.n	c009812 <_write_r+0x1e>
 c00980c:	6823      	ldr	r3, [r4, #0]
 c00980e:	b103      	cbz	r3, c009812 <_write_r+0x1e>
 c009810:	602b      	str	r3, [r5, #0]
 c009812:	bd38      	pop	{r3, r4, r5, pc}
 c009814:	30033994 	.word	0x30033994

0c009818 <_close_r>:
 c009818:	b538      	push	{r3, r4, r5, lr}
 c00981a:	2300      	movs	r3, #0
 c00981c:	4c05      	ldr	r4, [pc, #20]	; (c009834 <_close_r+0x1c>)
 c00981e:	4605      	mov	r5, r0
 c009820:	4608      	mov	r0, r1
 c009822:	6023      	str	r3, [r4, #0]
 c009824:	f000 fa5c 	bl	c009ce0 <_close>
 c009828:	1c43      	adds	r3, r0, #1
 c00982a:	d102      	bne.n	c009832 <_close_r+0x1a>
 c00982c:	6823      	ldr	r3, [r4, #0]
 c00982e:	b103      	cbz	r3, c009832 <_close_r+0x1a>
 c009830:	602b      	str	r3, [r5, #0]
 c009832:	bd38      	pop	{r3, r4, r5, pc}
 c009834:	30033994 	.word	0x30033994

0c009838 <_fstat_r>:
 c009838:	b538      	push	{r3, r4, r5, lr}
 c00983a:	2300      	movs	r3, #0
 c00983c:	4c06      	ldr	r4, [pc, #24]	; (c009858 <_fstat_r+0x20>)
 c00983e:	4605      	mov	r5, r0
 c009840:	4608      	mov	r0, r1
 c009842:	4611      	mov	r1, r2
 c009844:	6023      	str	r3, [r4, #0]
 c009846:	f000 fa53 	bl	c009cf0 <_fstat>
 c00984a:	1c43      	adds	r3, r0, #1
 c00984c:	d102      	bne.n	c009854 <_fstat_r+0x1c>
 c00984e:	6823      	ldr	r3, [r4, #0]
 c009850:	b103      	cbz	r3, c009854 <_fstat_r+0x1c>
 c009852:	602b      	str	r3, [r5, #0]
 c009854:	bd38      	pop	{r3, r4, r5, pc}
 c009856:	bf00      	nop
 c009858:	30033994 	.word	0x30033994

0c00985c <_isatty_r>:
 c00985c:	b538      	push	{r3, r4, r5, lr}
 c00985e:	2300      	movs	r3, #0
 c009860:	4c05      	ldr	r4, [pc, #20]	; (c009878 <_isatty_r+0x1c>)
 c009862:	4605      	mov	r5, r0
 c009864:	4608      	mov	r0, r1
 c009866:	6023      	str	r3, [r4, #0]
 c009868:	f000 fa4a 	bl	c009d00 <_isatty>
 c00986c:	1c43      	adds	r3, r0, #1
 c00986e:	d102      	bne.n	c009876 <_isatty_r+0x1a>
 c009870:	6823      	ldr	r3, [r4, #0]
 c009872:	b103      	cbz	r3, c009876 <_isatty_r+0x1a>
 c009874:	602b      	str	r3, [r5, #0]
 c009876:	bd38      	pop	{r3, r4, r5, pc}
 c009878:	30033994 	.word	0x30033994

0c00987c <_lseek_r>:
 c00987c:	b538      	push	{r3, r4, r5, lr}
 c00987e:	4605      	mov	r5, r0
 c009880:	4c06      	ldr	r4, [pc, #24]	; (c00989c <_lseek_r+0x20>)
 c009882:	4608      	mov	r0, r1
 c009884:	4611      	mov	r1, r2
 c009886:	2200      	movs	r2, #0
 c009888:	6022      	str	r2, [r4, #0]
 c00988a:	461a      	mov	r2, r3
 c00988c:	f000 fa40 	bl	c009d10 <_lseek>
 c009890:	1c43      	adds	r3, r0, #1
 c009892:	d102      	bne.n	c00989a <_lseek_r+0x1e>
 c009894:	6823      	ldr	r3, [r4, #0]
 c009896:	b103      	cbz	r3, c00989a <_lseek_r+0x1e>
 c009898:	602b      	str	r3, [r5, #0]
 c00989a:	bd38      	pop	{r3, r4, r5, pc}
 c00989c:	30033994 	.word	0x30033994

0c0098a0 <memchr>:
 c0098a0:	b2c9      	uxtb	r1, r1
 c0098a2:	4402      	add	r2, r0
 c0098a4:	b510      	push	{r4, lr}
 c0098a6:	4290      	cmp	r0, r2
 c0098a8:	4603      	mov	r3, r0
 c0098aa:	d101      	bne.n	c0098b0 <memchr+0x10>
 c0098ac:	2300      	movs	r3, #0
 c0098ae:	e003      	b.n	c0098b8 <memchr+0x18>
 c0098b0:	781c      	ldrb	r4, [r3, #0]
 c0098b2:	3001      	adds	r0, #1
 c0098b4:	428c      	cmp	r4, r1
 c0098b6:	d1f6      	bne.n	c0098a6 <memchr+0x6>
 c0098b8:	4618      	mov	r0, r3
 c0098ba:	bd10      	pop	{r4, pc}

0c0098bc <memmove>:
 c0098bc:	4288      	cmp	r0, r1
 c0098be:	eb01 0302 	add.w	r3, r1, r2
 c0098c2:	b510      	push	{r4, lr}
 c0098c4:	d807      	bhi.n	c0098d6 <memmove+0x1a>
 c0098c6:	1e42      	subs	r2, r0, #1
 c0098c8:	4299      	cmp	r1, r3
 c0098ca:	d00a      	beq.n	c0098e2 <memmove+0x26>
 c0098cc:	f811 4b01 	ldrb.w	r4, [r1], #1
 c0098d0:	f802 4f01 	strb.w	r4, [r2, #1]!
 c0098d4:	e7f8      	b.n	c0098c8 <memmove+0xc>
 c0098d6:	4283      	cmp	r3, r0
 c0098d8:	d9f5      	bls.n	c0098c6 <memmove+0xa>
 c0098da:	1881      	adds	r1, r0, r2
 c0098dc:	1ad2      	subs	r2, r2, r3
 c0098de:	42d3      	cmn	r3, r2
 c0098e0:	d100      	bne.n	c0098e4 <memmove+0x28>
 c0098e2:	bd10      	pop	{r4, pc}
 c0098e4:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 c0098e8:	f801 4d01 	strb.w	r4, [r1, #-1]!
 c0098ec:	e7f7      	b.n	c0098de <memmove+0x22>

0c0098ee <_realloc_r>:
 c0098ee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c0098f0:	4607      	mov	r7, r0
 c0098f2:	4614      	mov	r4, r2
 c0098f4:	460e      	mov	r6, r1
 c0098f6:	b921      	cbnz	r1, c009902 <_realloc_r+0x14>
 c0098f8:	4611      	mov	r1, r2
 c0098fa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 c0098fe:	f7fe bf59 	b.w	c0087b4 <_malloc_r>
 c009902:	b922      	cbnz	r2, c00990e <_realloc_r+0x20>
 c009904:	4625      	mov	r5, r4
 c009906:	f7fe ff07 	bl	c008718 <_free_r>
 c00990a:	4628      	mov	r0, r5
 c00990c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c00990e:	f000 f827 	bl	c009960 <_malloc_usable_size_r>
 c009912:	42a0      	cmp	r0, r4
 c009914:	d20f      	bcs.n	c009936 <_realloc_r+0x48>
 c009916:	4621      	mov	r1, r4
 c009918:	4638      	mov	r0, r7
 c00991a:	f7fe ff4b 	bl	c0087b4 <_malloc_r>
 c00991e:	4605      	mov	r5, r0
 c009920:	2800      	cmp	r0, #0
 c009922:	d0f2      	beq.n	c00990a <_realloc_r+0x1c>
 c009924:	4631      	mov	r1, r6
 c009926:	4622      	mov	r2, r4
 c009928:	f7fe fed4 	bl	c0086d4 <memcpy>
 c00992c:	4631      	mov	r1, r6
 c00992e:	4638      	mov	r0, r7
 c009930:	f7fe fef2 	bl	c008718 <_free_r>
 c009934:	e7e9      	b.n	c00990a <_realloc_r+0x1c>
 c009936:	4635      	mov	r5, r6
 c009938:	e7e7      	b.n	c00990a <_realloc_r+0x1c>
	...

0c00993c <_read_r>:
 c00993c:	b538      	push	{r3, r4, r5, lr}
 c00993e:	4605      	mov	r5, r0
 c009940:	4c06      	ldr	r4, [pc, #24]	; (c00995c <_read_r+0x20>)
 c009942:	4608      	mov	r0, r1
 c009944:	4611      	mov	r1, r2
 c009946:	2200      	movs	r2, #0
 c009948:	6022      	str	r2, [r4, #0]
 c00994a:	461a      	mov	r2, r3
 c00994c:	f000 f9e8 	bl	c009d20 <_read>
 c009950:	1c43      	adds	r3, r0, #1
 c009952:	d102      	bne.n	c00995a <_read_r+0x1e>
 c009954:	6823      	ldr	r3, [r4, #0]
 c009956:	b103      	cbz	r3, c00995a <_read_r+0x1e>
 c009958:	602b      	str	r3, [r5, #0]
 c00995a:	bd38      	pop	{r3, r4, r5, pc}
 c00995c:	30033994 	.word	0x30033994

0c009960 <_malloc_usable_size_r>:
 c009960:	f851 3c04 	ldr.w	r3, [r1, #-4]
 c009964:	1f18      	subs	r0, r3, #4
 c009966:	2b00      	cmp	r3, #0
 c009968:	bfbc      	itt	lt
 c00996a:	580b      	ldrlt	r3, [r1, r0]
 c00996c:	18c0      	addlt	r0, r0, r3
 c00996e:	4770      	bx	lr

0c009970 <__gnu_cmse_nonsecure_call>:
 c009970:	e92d 4fe0 	stmdb	sp!, {r5, r6, r7, r8, r9, sl, fp, lr}
 c009974:	4627      	mov	r7, r4
 c009976:	46a0      	mov	r8, r4
 c009978:	46a1      	mov	r9, r4
 c00997a:	46a2      	mov	sl, r4
 c00997c:	46a3      	mov	fp, r4
 c00997e:	46a4      	mov	ip, r4
 c009980:	ed2d 8b10 	vpush	{d8-d15}
 c009984:	f04f 0500 	mov.w	r5, #0
 c009988:	ec45 5b18 	vmov	d8, r5, r5
 c00998c:	ec45 5a19 	vmov	s18, s19, r5, r5
 c009990:	ec45 5a1a 	vmov	s20, s21, r5, r5
 c009994:	ec45 5a1b 	vmov	s22, s23, r5, r5
 c009998:	ec45 5a1c 	vmov	s24, s25, r5, r5
 c00999c:	ec45 5a1d 	vmov	s26, s27, r5, r5
 c0099a0:	ec45 5a1e 	vmov	s28, s29, r5, r5
 c0099a4:	ec45 5a1f 	vmov	s30, s31, r5, r5
 c0099a8:	eef1 5a10 	vmrs	r5, fpscr
 c0099ac:	f64f 7660 	movw	r6, #65376	; 0xff60
 c0099b0:	f6c0 76ff 	movt	r6, #4095	; 0xfff
 c0099b4:	4035      	ands	r5, r6
 c0099b6:	eee1 5a10 	vmsr	fpscr, r5
 c0099ba:	f384 8800 	msr	CPSR_f, r4
 c0099be:	4625      	mov	r5, r4
 c0099c0:	4626      	mov	r6, r4
 c0099c2:	47a4      	blxns	r4
 c0099c4:	ecbd 8b10 	vpop	{d8-d15}
 c0099c8:	e8bd 8fe0 	ldmia.w	sp!, {r5, r6, r7, r8, r9, sl, fp, pc}

0c0099cc <__aeabi_uldivmod>:
 c0099cc:	b953      	cbnz	r3, c0099e4 <__aeabi_uldivmod+0x18>
 c0099ce:	b94a      	cbnz	r2, c0099e4 <__aeabi_uldivmod+0x18>
 c0099d0:	2900      	cmp	r1, #0
 c0099d2:	bf08      	it	eq
 c0099d4:	2800      	cmpeq	r0, #0
 c0099d6:	bf1c      	itt	ne
 c0099d8:	f04f 31ff 	movne.w	r1, #4294967295
 c0099dc:	f04f 30ff 	movne.w	r0, #4294967295
 c0099e0:	f000 b97c 	b.w	c009cdc <__aeabi_idiv0>
 c0099e4:	f1ad 0c08 	sub.w	ip, sp, #8
 c0099e8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 c0099ec:	f000 f806 	bl	c0099fc <__udivmoddi4>
 c0099f0:	f8dd e004 	ldr.w	lr, [sp, #4]
 c0099f4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 c0099f8:	b004      	add	sp, #16
 c0099fa:	4770      	bx	lr

0c0099fc <__udivmoddi4>:
 c0099fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c009a00:	468c      	mov	ip, r1
 c009a02:	9d08      	ldr	r5, [sp, #32]
 c009a04:	4604      	mov	r4, r0
 c009a06:	468a      	mov	sl, r1
 c009a08:	2b00      	cmp	r3, #0
 c009a0a:	d14a      	bne.n	c009aa2 <__udivmoddi4+0xa6>
 c009a0c:	428a      	cmp	r2, r1
 c009a0e:	4617      	mov	r7, r2
 c009a10:	d962      	bls.n	c009ad8 <__udivmoddi4+0xdc>
 c009a12:	fab2 f682 	clz	r6, r2
 c009a16:	b14e      	cbz	r6, c009a2c <__udivmoddi4+0x30>
 c009a18:	f1c6 0e20 	rsb	lr, r6, #32
 c009a1c:	fa01 f306 	lsl.w	r3, r1, r6
 c009a20:	40b7      	lsls	r7, r6
 c009a22:	40b4      	lsls	r4, r6
 c009a24:	fa20 fe0e 	lsr.w	lr, r0, lr
 c009a28:	ea4e 0a03 	orr.w	sl, lr, r3
 c009a2c:	ea4f 4817 	mov.w	r8, r7, lsr #16
 c009a30:	0c23      	lsrs	r3, r4, #16
 c009a32:	fa1f f987 	uxth.w	r9, r7
 c009a36:	fbba fef8 	udiv	lr, sl, r8
 c009a3a:	fb08 aa1e 	mls	sl, r8, lr, sl
 c009a3e:	fb0e f209 	mul.w	r2, lr, r9
 c009a42:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
 c009a46:	429a      	cmp	r2, r3
 c009a48:	d90b      	bls.n	c009a62 <__udivmoddi4+0x66>
 c009a4a:	18fb      	adds	r3, r7, r3
 c009a4c:	f10e 31ff 	add.w	r1, lr, #4294967295
 c009a50:	bf2c      	ite	cs
 c009a52:	2001      	movcs	r0, #1
 c009a54:	2000      	movcc	r0, #0
 c009a56:	429a      	cmp	r2, r3
 c009a58:	d902      	bls.n	c009a60 <__udivmoddi4+0x64>
 c009a5a:	2800      	cmp	r0, #0
 c009a5c:	f000 812a 	beq.w	c009cb4 <__udivmoddi4+0x2b8>
 c009a60:	468e      	mov	lr, r1
 c009a62:	1a9a      	subs	r2, r3, r2
 c009a64:	b2a3      	uxth	r3, r4
 c009a66:	fbb2 f0f8 	udiv	r0, r2, r8
 c009a6a:	fb08 2210 	mls	r2, r8, r0, r2
 c009a6e:	fb00 f909 	mul.w	r9, r0, r9
 c009a72:	ea43 4402 	orr.w	r4, r3, r2, lsl #16
 c009a76:	45a1      	cmp	r9, r4
 c009a78:	d907      	bls.n	c009a8a <__udivmoddi4+0x8e>
 c009a7a:	193c      	adds	r4, r7, r4
 c009a7c:	f100 33ff 	add.w	r3, r0, #4294967295
 c009a80:	d202      	bcs.n	c009a88 <__udivmoddi4+0x8c>
 c009a82:	45a1      	cmp	r9, r4
 c009a84:	f200 8110 	bhi.w	c009ca8 <__udivmoddi4+0x2ac>
 c009a88:	4618      	mov	r0, r3
 c009a8a:	eba4 0409 	sub.w	r4, r4, r9
 c009a8e:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
 c009a92:	2100      	movs	r1, #0
 c009a94:	b11d      	cbz	r5, c009a9e <__udivmoddi4+0xa2>
 c009a96:	40f4      	lsrs	r4, r6
 c009a98:	2300      	movs	r3, #0
 c009a9a:	e9c5 4300 	strd	r4, r3, [r5]
 c009a9e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c009aa2:	428b      	cmp	r3, r1
 c009aa4:	d908      	bls.n	c009ab8 <__udivmoddi4+0xbc>
 c009aa6:	2d00      	cmp	r5, #0
 c009aa8:	f000 80f2 	beq.w	c009c90 <__udivmoddi4+0x294>
 c009aac:	2100      	movs	r1, #0
 c009aae:	e9c5 0c00 	strd	r0, ip, [r5]
 c009ab2:	4608      	mov	r0, r1
 c009ab4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c009ab8:	fab3 f183 	clz	r1, r3
 c009abc:	2900      	cmp	r1, #0
 c009abe:	d14e      	bne.n	c009b5e <__udivmoddi4+0x162>
 c009ac0:	4563      	cmp	r3, ip
 c009ac2:	f0c0 80e8 	bcc.w	c009c96 <__udivmoddi4+0x29a>
 c009ac6:	4282      	cmp	r2, r0
 c009ac8:	f240 80e5 	bls.w	c009c96 <__udivmoddi4+0x29a>
 c009acc:	4608      	mov	r0, r1
 c009ace:	2d00      	cmp	r5, #0
 c009ad0:	d0e5      	beq.n	c009a9e <__udivmoddi4+0xa2>
 c009ad2:	e9c5 4a00 	strd	r4, sl, [r5]
 c009ad6:	e7e2      	b.n	c009a9e <__udivmoddi4+0xa2>
 c009ad8:	b902      	cbnz	r2, c009adc <__udivmoddi4+0xe0>
 c009ada:	deff      	udf	#255	; 0xff
 c009adc:	fab2 f682 	clz	r6, r2
 c009ae0:	2e00      	cmp	r6, #0
 c009ae2:	f040 8099 	bne.w	c009c18 <__udivmoddi4+0x21c>
 c009ae6:	1a8b      	subs	r3, r1, r2
 c009ae8:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 c009aec:	fa1f f882 	uxth.w	r8, r2
 c009af0:	2101      	movs	r1, #1
 c009af2:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 c009af6:	fbb3 f2fe 	udiv	r2, r3, lr
 c009afa:	fb0e 3012 	mls	r0, lr, r2, r3
 c009afe:	fb08 f902 	mul.w	r9, r8, r2
 c009b02:	ea4c 4c00 	orr.w	ip, ip, r0, lsl #16
 c009b06:	45e1      	cmp	r9, ip
 c009b08:	d908      	bls.n	c009b1c <__udivmoddi4+0x120>
 c009b0a:	eb17 0c0c 	adds.w	ip, r7, ip
 c009b0e:	f102 33ff 	add.w	r3, r2, #4294967295
 c009b12:	d202      	bcs.n	c009b1a <__udivmoddi4+0x11e>
 c009b14:	45e1      	cmp	r9, ip
 c009b16:	f200 80ca 	bhi.w	c009cae <__udivmoddi4+0x2b2>
 c009b1a:	461a      	mov	r2, r3
 c009b1c:	ebac 0c09 	sub.w	ip, ip, r9
 c009b20:	b2a3      	uxth	r3, r4
 c009b22:	fbbc f0fe 	udiv	r0, ip, lr
 c009b26:	fb0e cc10 	mls	ip, lr, r0, ip
 c009b2a:	fb08 f800 	mul.w	r8, r8, r0
 c009b2e:	ea43 440c 	orr.w	r4, r3, ip, lsl #16
 c009b32:	45a0      	cmp	r8, r4
 c009b34:	d90e      	bls.n	c009b54 <__udivmoddi4+0x158>
 c009b36:	193c      	adds	r4, r7, r4
 c009b38:	f100 33ff 	add.w	r3, r0, #4294967295
 c009b3c:	bf2c      	ite	cs
 c009b3e:	f04f 0c01 	movcs.w	ip, #1
 c009b42:	f04f 0c00 	movcc.w	ip, #0
 c009b46:	45a0      	cmp	r8, r4
 c009b48:	d903      	bls.n	c009b52 <__udivmoddi4+0x156>
 c009b4a:	f1bc 0f00 	cmp.w	ip, #0
 c009b4e:	f000 80a8 	beq.w	c009ca2 <__udivmoddi4+0x2a6>
 c009b52:	4618      	mov	r0, r3
 c009b54:	eba4 0408 	sub.w	r4, r4, r8
 c009b58:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 c009b5c:	e79a      	b.n	c009a94 <__udivmoddi4+0x98>
 c009b5e:	f1c1 0420 	rsb	r4, r1, #32
 c009b62:	408b      	lsls	r3, r1
 c009b64:	fa02 fe01 	lsl.w	lr, r2, r1
 c009b68:	fa0c f601 	lsl.w	r6, ip, r1
 c009b6c:	40e2      	lsrs	r2, r4
 c009b6e:	fa20 f704 	lsr.w	r7, r0, r4
 c009b72:	fa2c fc04 	lsr.w	ip, ip, r4
 c009b76:	fa00 f801 	lsl.w	r8, r0, r1
 c009b7a:	4313      	orrs	r3, r2
 c009b7c:	433e      	orrs	r6, r7
 c009b7e:	0c1f      	lsrs	r7, r3, #16
 c009b80:	0c32      	lsrs	r2, r6, #16
 c009b82:	fa1f f983 	uxth.w	r9, r3
 c009b86:	fbbc f0f7 	udiv	r0, ip, r7
 c009b8a:	fb07 cc10 	mls	ip, r7, r0, ip
 c009b8e:	fb00 fa09 	mul.w	sl, r0, r9
 c009b92:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
 c009b96:	45e2      	cmp	sl, ip
 c009b98:	d908      	bls.n	c009bac <__udivmoddi4+0x1b0>
 c009b9a:	eb13 0c0c 	adds.w	ip, r3, ip
 c009b9e:	f100 32ff 	add.w	r2, r0, #4294967295
 c009ba2:	d202      	bcs.n	c009baa <__udivmoddi4+0x1ae>
 c009ba4:	45e2      	cmp	sl, ip
 c009ba6:	f200 8089 	bhi.w	c009cbc <__udivmoddi4+0x2c0>
 c009baa:	4610      	mov	r0, r2
 c009bac:	ebac 0c0a 	sub.w	ip, ip, sl
 c009bb0:	b2b6      	uxth	r6, r6
 c009bb2:	fbbc faf7 	udiv	sl, ip, r7
 c009bb6:	fb07 cc1a 	mls	ip, r7, sl, ip
 c009bba:	fb0a f909 	mul.w	r9, sl, r9
 c009bbe:	ea46 420c 	orr.w	r2, r6, ip, lsl #16
 c009bc2:	4591      	cmp	r9, r2
 c009bc4:	d906      	bls.n	c009bd4 <__udivmoddi4+0x1d8>
 c009bc6:	189a      	adds	r2, r3, r2
 c009bc8:	f10a 36ff 	add.w	r6, sl, #4294967295
 c009bcc:	d201      	bcs.n	c009bd2 <__udivmoddi4+0x1d6>
 c009bce:	4591      	cmp	r9, r2
 c009bd0:	d87a      	bhi.n	c009cc8 <__udivmoddi4+0x2cc>
 c009bd2:	46b2      	mov	sl, r6
 c009bd4:	ea4a 4000 	orr.w	r0, sl, r0, lsl #16
 c009bd8:	eba2 0209 	sub.w	r2, r2, r9
 c009bdc:	fba0 670e 	umull	r6, r7, r0, lr
 c009be0:	42ba      	cmp	r2, r7
 c009be2:	46b4      	mov	ip, r6
 c009be4:	46b9      	mov	r9, r7
 c009be6:	d302      	bcc.n	c009bee <__udivmoddi4+0x1f2>
 c009be8:	d107      	bne.n	c009bfa <__udivmoddi4+0x1fe>
 c009bea:	45b0      	cmp	r8, r6
 c009bec:	d205      	bcs.n	c009bfa <__udivmoddi4+0x1fe>
 c009bee:	ebb6 0c0e 	subs.w	ip, r6, lr
 c009bf2:	eb67 0303 	sbc.w	r3, r7, r3
 c009bf6:	3801      	subs	r0, #1
 c009bf8:	4699      	mov	r9, r3
 c009bfa:	2d00      	cmp	r5, #0
 c009bfc:	d06b      	beq.n	c009cd6 <__udivmoddi4+0x2da>
 c009bfe:	ebb8 030c 	subs.w	r3, r8, ip
 c009c02:	eb62 0209 	sbc.w	r2, r2, r9
 c009c06:	fa02 f404 	lsl.w	r4, r2, r4
 c009c0a:	40cb      	lsrs	r3, r1
 c009c0c:	40ca      	lsrs	r2, r1
 c009c0e:	2100      	movs	r1, #0
 c009c10:	431c      	orrs	r4, r3
 c009c12:	e9c5 4200 	strd	r4, r2, [r5]
 c009c16:	e742      	b.n	c009a9e <__udivmoddi4+0xa2>
 c009c18:	40b7      	lsls	r7, r6
 c009c1a:	f1c6 0220 	rsb	r2, r6, #32
 c009c1e:	fa01 f306 	lsl.w	r3, r1, r6
 c009c22:	40b4      	lsls	r4, r6
 c009c24:	fa21 fc02 	lsr.w	ip, r1, r2
 c009c28:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 c009c2c:	fa20 f202 	lsr.w	r2, r0, r2
 c009c30:	fa1f f887 	uxth.w	r8, r7
 c009c34:	fbbc f1fe 	udiv	r1, ip, lr
 c009c38:	431a      	orrs	r2, r3
 c009c3a:	fb0e cc11 	mls	ip, lr, r1, ip
 c009c3e:	fb01 f008 	mul.w	r0, r1, r8
 c009c42:	0c13      	lsrs	r3, r2, #16
 c009c44:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
 c009c48:	4560      	cmp	r0, ip
 c009c4a:	d907      	bls.n	c009c5c <__udivmoddi4+0x260>
 c009c4c:	eb17 0c0c 	adds.w	ip, r7, ip
 c009c50:	f101 33ff 	add.w	r3, r1, #4294967295
 c009c54:	d201      	bcs.n	c009c5a <__udivmoddi4+0x25e>
 c009c56:	4560      	cmp	r0, ip
 c009c58:	d833      	bhi.n	c009cc2 <__udivmoddi4+0x2c6>
 c009c5a:	4619      	mov	r1, r3
 c009c5c:	ebac 0c00 	sub.w	ip, ip, r0
 c009c60:	b292      	uxth	r2, r2
 c009c62:	fbbc f0fe 	udiv	r0, ip, lr
 c009c66:	fb0e cc10 	mls	ip, lr, r0, ip
 c009c6a:	fb00 f308 	mul.w	r3, r0, r8
 c009c6e:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
 c009c72:	4563      	cmp	r3, ip
 c009c74:	d907      	bls.n	c009c86 <__udivmoddi4+0x28a>
 c009c76:	eb17 0c0c 	adds.w	ip, r7, ip
 c009c7a:	f100 32ff 	add.w	r2, r0, #4294967295
 c009c7e:	d201      	bcs.n	c009c84 <__udivmoddi4+0x288>
 c009c80:	4563      	cmp	r3, ip
 c009c82:	d825      	bhi.n	c009cd0 <__udivmoddi4+0x2d4>
 c009c84:	4610      	mov	r0, r2
 c009c86:	ebac 0303 	sub.w	r3, ip, r3
 c009c8a:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 c009c8e:	e730      	b.n	c009af2 <__udivmoddi4+0xf6>
 c009c90:	4629      	mov	r1, r5
 c009c92:	4628      	mov	r0, r5
 c009c94:	e703      	b.n	c009a9e <__udivmoddi4+0xa2>
 c009c96:	1a84      	subs	r4, r0, r2
 c009c98:	eb6c 0303 	sbc.w	r3, ip, r3
 c009c9c:	2001      	movs	r0, #1
 c009c9e:	469a      	mov	sl, r3
 c009ca0:	e715      	b.n	c009ace <__udivmoddi4+0xd2>
 c009ca2:	3802      	subs	r0, #2
 c009ca4:	443c      	add	r4, r7
 c009ca6:	e755      	b.n	c009b54 <__udivmoddi4+0x158>
 c009ca8:	3802      	subs	r0, #2
 c009caa:	443c      	add	r4, r7
 c009cac:	e6ed      	b.n	c009a8a <__udivmoddi4+0x8e>
 c009cae:	3a02      	subs	r2, #2
 c009cb0:	44bc      	add	ip, r7
 c009cb2:	e733      	b.n	c009b1c <__udivmoddi4+0x120>
 c009cb4:	f1ae 0e02 	sub.w	lr, lr, #2
 c009cb8:	443b      	add	r3, r7
 c009cba:	e6d2      	b.n	c009a62 <__udivmoddi4+0x66>
 c009cbc:	3802      	subs	r0, #2
 c009cbe:	449c      	add	ip, r3
 c009cc0:	e774      	b.n	c009bac <__udivmoddi4+0x1b0>
 c009cc2:	3902      	subs	r1, #2
 c009cc4:	44bc      	add	ip, r7
 c009cc6:	e7c9      	b.n	c009c5c <__udivmoddi4+0x260>
 c009cc8:	f1aa 0a02 	sub.w	sl, sl, #2
 c009ccc:	441a      	add	r2, r3
 c009cce:	e781      	b.n	c009bd4 <__udivmoddi4+0x1d8>
 c009cd0:	3802      	subs	r0, #2
 c009cd2:	44bc      	add	ip, r7
 c009cd4:	e7d7      	b.n	c009c86 <__udivmoddi4+0x28a>
 c009cd6:	4629      	mov	r1, r5
 c009cd8:	e6e1      	b.n	c009a9e <__udivmoddi4+0xa2>
 c009cda:	bf00      	nop

0c009cdc <__aeabi_idiv0>:
 c009cdc:	4770      	bx	lr
 c009cde:	bf00      	nop

0c009ce0 <_close>:
 c009ce0:	4b02      	ldr	r3, [pc, #8]	; (c009cec <_close+0xc>)
 c009ce2:	2258      	movs	r2, #88	; 0x58
 c009ce4:	f04f 30ff 	mov.w	r0, #4294967295
 c009ce8:	601a      	str	r2, [r3, #0]
 c009cea:	4770      	bx	lr
 c009cec:	30033994 	.word	0x30033994

0c009cf0 <_fstat>:
 c009cf0:	4b02      	ldr	r3, [pc, #8]	; (c009cfc <_fstat+0xc>)
 c009cf2:	2258      	movs	r2, #88	; 0x58
 c009cf4:	f04f 30ff 	mov.w	r0, #4294967295
 c009cf8:	601a      	str	r2, [r3, #0]
 c009cfa:	4770      	bx	lr
 c009cfc:	30033994 	.word	0x30033994

0c009d00 <_isatty>:
 c009d00:	4b02      	ldr	r3, [pc, #8]	; (c009d0c <_isatty+0xc>)
 c009d02:	2258      	movs	r2, #88	; 0x58
 c009d04:	2000      	movs	r0, #0
 c009d06:	601a      	str	r2, [r3, #0]
 c009d08:	4770      	bx	lr
 c009d0a:	bf00      	nop
 c009d0c:	30033994 	.word	0x30033994

0c009d10 <_lseek>:
 c009d10:	4b02      	ldr	r3, [pc, #8]	; (c009d1c <_lseek+0xc>)
 c009d12:	2258      	movs	r2, #88	; 0x58
 c009d14:	f04f 30ff 	mov.w	r0, #4294967295
 c009d18:	601a      	str	r2, [r3, #0]
 c009d1a:	4770      	bx	lr
 c009d1c:	30033994 	.word	0x30033994

0c009d20 <_read>:
 c009d20:	4b02      	ldr	r3, [pc, #8]	; (c009d2c <_read+0xc>)
 c009d22:	2258      	movs	r2, #88	; 0x58
 c009d24:	f04f 30ff 	mov.w	r0, #4294967295
 c009d28:	601a      	str	r2, [r3, #0]
 c009d2a:	4770      	bx	lr
 c009d2c:	30033994 	.word	0x30033994

0c009d30 <_sbrk>:
 c009d30:	4b04      	ldr	r3, [pc, #16]	; (c009d44 <_sbrk+0x14>)
 c009d32:	4602      	mov	r2, r0
 c009d34:	6819      	ldr	r1, [r3, #0]
 c009d36:	b909      	cbnz	r1, c009d3c <_sbrk+0xc>
 c009d38:	4903      	ldr	r1, [pc, #12]	; (c009d48 <_sbrk+0x18>)
 c009d3a:	6019      	str	r1, [r3, #0]
 c009d3c:	6818      	ldr	r0, [r3, #0]
 c009d3e:	4402      	add	r2, r0
 c009d40:	601a      	str	r2, [r3, #0]
 c009d42:	4770      	bx	lr
 c009d44:	30033968 	.word	0x30033968
 c009d48:	30033998 	.word	0x30033998

0c009d4c <_exit>:
 c009d4c:	e7fe      	b.n	c009d4c <_exit>
	...

0c009d50 <_init>:
 c009d50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c009d52:	bf00      	nop
 c009d54:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c009d56:	bc08      	pop	{r3}
 c009d58:	469e      	mov	lr, r3
 c009d5a:	4770      	bx	lr

0c009d5c <_fini>:
 c009d5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c009d5e:	bf00      	nop
 c009d60:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c009d62:	bc08      	pop	{r3}
 c009d64:	469e      	mov	lr, r3
 c009d66:	4770      	bx	lr
 c009d68:	464e495b 	.word	0x464e495b
 c009d6c:	6e49205d 	.word	0x6e49205d
 c009d70:	61697469 	.word	0x61697469
 c009d74:	697a696c 	.word	0x697a696c
 c009d78:	4220676e 	.word	0x4220676e
 c009d7c:	4e20324c 	.word	0x4e20324c
 c009d80:	72612056 	.word	0x72612056
 c009d84:	3a206165 	.word	0x3a206165
 c009d88:	776f5020 	.word	0x776f5020
 c009d8c:	64207265 	.word	0x64207265
 c009d90:	2f6e776f 	.word	0x2f6e776f
 c009d94:	65736572 	.word	0x65736572
 c009d98:	6f6e2074 	.word	0x6f6e2074
 c009d9c:	75732074 	.word	0x75732074
 c009da0:	726f7070 	.word	0x726f7070
 c009da4:	2e646574 	.word	0x2e646574
 c009da8:	000d2e2e 	.word	0x000d2e2e
 c009dac:	5252455b 	.word	0x5252455b
 c009db0:	6e49205d 	.word	0x6e49205d
 c009db4:	42207469 	.word	0x42207469
 c009db8:	4e20324c 	.word	0x4e20324c
 c009dbc:	65482056 	.word	0x65482056
 c009dc0:	72656461 	.word	0x72656461
 c009dc4:	65726120 	.word	0x65726120
 c009dc8:	46203a61 	.word	0x46203a61
 c009dcc:	656c6961 	.word	0x656c6961
 c009dd0:	5b000d64 	.word	0x5b000d64
 c009dd4:	5d464e49 	.word	0x5d464e49
 c009dd8:	696e4920 	.word	0x696e4920
 c009ddc:	4c422074 	.word	0x4c422074
 c009de0:	564e2032 	.word	0x564e2032
 c009de4:	61654820 	.word	0x61654820
 c009de8:	20726564 	.word	0x20726564
 c009dec:	61657261 	.word	0x61657261
 c009df0:	6f44203a 	.word	0x6f44203a
 c009df4:	000d656e 	.word	0x000d656e
 c009df8:	464e495b 	.word	0x464e495b
 c009dfc:	6e49205d 	.word	0x6e49205d
 c009e00:	61697469 	.word	0x61697469
 c009e04:	697a696c 	.word	0x697a696c
 c009e08:	4220676e 	.word	0x4220676e
 c009e0c:	4e20324c 	.word	0x4e20324c
 c009e10:	6f432056 	.word	0x6f432056
 c009e14:	65746e75 	.word	0x65746e75
 c009e18:	000d7372 	.word	0x000d7372
 c009e1c:	464e495b 	.word	0x464e495b
 c009e20:	6843205d 	.word	0x6843205d
 c009e24:	696b6365 	.word	0x696b6365
 c009e28:	4220676e 	.word	0x4220676e
 c009e2c:	4e20324c 	.word	0x4e20324c
 c009e30:	72612056 	.word	0x72612056
 c009e34:	000d6165 	.word	0x000d6165
 c009e38:	464e495b 	.word	0x464e495b
 c009e3c:	6843205d 	.word	0x6843205d
 c009e40:	696b6365 	.word	0x696b6365
 c009e44:	4220676e 	.word	0x4220676e
 c009e48:	4e20324c 	.word	0x4e20324c
 c009e4c:	72612056 	.word	0x72612056
 c009e50:	68206165 	.word	0x68206165
 c009e54:	65646165 	.word	0x65646165
 c009e58:	5b000d72 	.word	0x5b000d72
 c009e5c:	5d525245 	.word	0x5d525245
 c009e60:	6f725720 	.word	0x6f725720
 c009e64:	4220676e 	.word	0x4220676e
 c009e68:	4e20324c 	.word	0x4e20324c
 c009e6c:	72412056 	.word	0x72412056
 c009e70:	68206165 	.word	0x68206165
 c009e74:	65646165 	.word	0x65646165
 c009e78:	5b000d72 	.word	0x5b000d72
 c009e7c:	5d464e49 	.word	0x5d464e49
 c009e80:	65684320 	.word	0x65684320
 c009e84:	6e696b63 	.word	0x6e696b63
 c009e88:	4c422067 	.word	0x4c422067
 c009e8c:	564e2032 	.word	0x564e2032
 c009e90:	756f4320 	.word	0x756f4320
 c009e94:	7265746e 	.word	0x7265746e
 c009e98:	6e6f6320 	.word	0x6e6f6320
 c009e9c:	65746973 	.word	0x65746973
 c009ea0:	0d79636e 	.word	0x0d79636e
 c009ea4:	52455b00 	.word	0x52455b00
 c009ea8:	4e205d52 	.word	0x4e205d52
 c009eac:	6f432056 	.word	0x6f432056
 c009eb0:	65746e75 	.word	0x65746e75
 c009eb4:	6f4e2072 	.word	0x6f4e2072
 c009eb8:	6f632074 	.word	0x6f632074
 c009ebc:	7469736e 	.word	0x7469736e
 c009ec0:	20746e65 	.word	0x20746e65
 c009ec4:	0a0d6425 	.word	0x0a0d6425
 c009ec8:	4e495b00 	.word	0x4e495b00
 c009ecc:	43205d46 	.word	0x43205d46
 c009ed0:	69736e6f 	.word	0x69736e6f
 c009ed4:	6e657473 	.word	0x6e657473
 c009ed8:	4c422074 	.word	0x4c422074
 c009edc:	564e2032 	.word	0x564e2032
 c009ee0:	756f4320 	.word	0x756f4320
 c009ee4:	7265746e 	.word	0x7265746e
 c009ee8:	20642520 	.word	0x20642520
 c009eec:	30203d20 	.word	0x30203d20
 c009ef0:	0d782578 	.word	0x0d782578
 c009ef4:	455b000a 	.word	0x455b000a
 c009ef8:	205d5252 	.word	0x205d5252
 c009efc:	74696e49 	.word	0x74696e49
 c009f00:	324c4220 	.word	0x324c4220
 c009f04:	20564e20 	.word	0x20564e20
 c009f08:	6e756f63 	.word	0x6e756f63
 c009f0c:	73726574 	.word	0x73726574
 c009f10:	46203a20 	.word	0x46203a20
 c009f14:	656c6961 	.word	0x656c6961
 c009f18:	5b000d64 	.word	0x5b000d64
 c009f1c:	5d464e49 	.word	0x5d464e49
 c009f20:	696e4920 	.word	0x696e4920
 c009f24:	4c422074 	.word	0x4c422074
 c009f28:	564e2032 	.word	0x564e2032
 c009f2c:	756f6320 	.word	0x756f6320
 c009f30:	7265746e 	.word	0x7265746e
 c009f34:	6f742073 	.word	0x6f742073
 c009f38:	3a203020 	.word	0x3a203020
 c009f3c:	6e6f4420 	.word	0x6e6f4420
 c009f40:	5b000d65 	.word	0x5b000d65
 c009f44:	5d464e49 	.word	0x5d464e49
 c009f48:	324c4220 	.word	0x324c4220
 c009f4c:	20564e20 	.word	0x20564e20
 c009f50:	61657241 	.word	0x61657241
 c009f54:	696e4920 	.word	0x696e4920
 c009f58:	6c616974 	.word	0x6c616974
 c009f5c:	64657a69 	.word	0x64657a69
 c009f60:	50203a20 	.word	0x50203a20
 c009f64:	7265776f 	.word	0x7265776f
 c009f68:	776f4420 	.word	0x776f4420
 c009f6c:	65722f6e 	.word	0x65722f6e
 c009f70:	20746573 	.word	0x20746573
 c009f74:	70707573 	.word	0x70707573
 c009f78:	6574726f 	.word	0x6574726f
 c009f7c:	0d64      	.short	0x0d64
 c009f7e:	00          	.byte	0x00
 c009f7f:	5b          	.byte	0x5b
 c009f80:	5d464e49 	.word	0x5d464e49
 c009f84:	756f4320 	.word	0x756f4320
 c009f88:	7265746e 	.word	0x7265746e
 c009f8c:	20642520 	.word	0x20642520
 c009f90:	20746573 	.word	0x20746573
 c009f94:	30206f74 	.word	0x30206f74
 c009f98:	0d782578 	.word	0x0d782578
 c009f9c:	000a      	.short	0x000a
 c009f9e:	455b      	.short	0x455b
 c009fa0:	205d5252 	.word	0x205d5252
 c009fa4:	6e6f7257 	.word	0x6e6f7257
 c009fa8:	6f422067 	.word	0x6f422067
 c009fac:	6f4c746f 	.word	0x6f4c746f
 c009fb0:	72656461 	.word	0x72656461
 c009fb4:	72657620 	.word	0x72657620
 c009fb8:	6e6f6973 	.word	0x6e6f6973
 c009fbc:	7830203a 	.word	0x7830203a
 c009fc0:	2c783125 	.word	0x2c783125
 c009fc4:	50444820 	.word	0x50444820
 c009fc8:	77732820 	.word	0x77732820
 c009fcc:	68637469 	.word	0x68637469
 c009fd0:	4d465420 	.word	0x4d465420
 c009fd4:	5044485f 	.word	0x5044485f
 c009fd8:	4f52505f 	.word	0x4f52505f
 c009fdc:	54434554 	.word	0x54434554
 c009fe0:	414e455f 	.word	0x414e455f
 c009fe4:	29454c42 	.word	0x29454c42
 c009fe8:	73756d20 	.word	0x73756d20
 c009fec:	65622074 	.word	0x65622074
 c009ff0:	73696420 	.word	0x73696420
 c009ff4:	656c6261 	.word	0x656c6261
 c009ff8:	000a0d64 	.word	0x000a0d64

0c009ffc <DriverVersion>:
 c009ffc:	02020203                                ....

0c00a000 <TFM_Driver_USART0>:
 c00a000:	0c0010ad 0c0010c1 0c00113d 0c0010c5     ........=.......
 c00a010:	0c0010c9 0c001119 0c0010f9 0c0010cf     ................
 c00a020:	0c0010d5 0c001207 0c0010db 0c0010df     ................
 c00a030:	0c001201 0c0010eb                       ........

0c00a038 <ARM_FLASH0_DEV_DATA>:
 c00a038:	00000000 00000080 00001000 00000800     ................
 c00a048:	00000008 000000ff                       ........

0c00a050 <DriverVersion>:
 c00a050:	01000201                                ....

0c00a054 <TFM_Driver_FLASH0>:
 c00a054:	0c00120d 0c001221 0c0012b9 0c001225     ....!.......%...
 c00a064:	0c001229 0c00125d 0c0012c9 0c001391     )...]...........
 c00a074:	0c00123f 0c001245 0c001251              ?...E...Q...

0c00a080 <AHBPrescTable>:
	...
 c00a088:	04030201 09080706                       ........

0c00a090 <APBPrescTable>:
 c00a090:	00000000 04030201                       ........

0c00a098 <MSIRangeTable>:
 c00a098:	000186a0 00030d40 00061a80 000c3500     ....@........5..
 c00a0a8:	000f4240 001e8480 003d0900 007a1200     @B........=...z.
 c00a0b8:	00f42400 016e3600 01e84800 02dc6c00     .$...6n..H...l..
	...
 c00a0d8:	5252455b 4c42205d 4f422032 5320544f     [ERR] BL2 BOOT S
 c00a0e8:	20444545 656e6567 69746172 46206e6f     EED generation F
 c00a0f8:	656c6961 21212064 455b000d 205d5252     ailed !!..[ERR] 
 c00a108:	20324c42 204b5548 20746573 20324c42     BL2 HUK set BL2 
 c00a118:	52414853 44204445 20415441 6c696146     SHARED DATA Fail
 c00a128:	21206465 5b000d21 5d464e49 414c4620     ed !!..[INF] FLA
 c00a138:	44204853 45564952 43412052 53534543     SH DRIVER ACCESS
 c00a148:	74657320 206f7420 56495250 47454c45      set to PRIVELEG
 c00a158:	4f204445 0d594c4e 52455b00 45205d52     ED ONLY..[ERR] E
 c00a168:	726f7272 69687720 6320656c 6b636568     rror while check
 c00a178:	20676e69 4e455a54 6c617620 000d6575     ing TZEN value..
 c00a188:	5252455b 7245205d 20726f72 6c696877     [ERR] Error whil
 c00a198:	68632065 696b6365 6420676e 206c6175     e checking dual 
 c00a1a8:	6b6e6162 6e6f6320 75676966 69746172     bank configurati
 c00a1b8:	000d6e6f 464e495b 6f42205d 6441746f     on..[INF] BootAd
 c00a1c8:	30207264 0d782578 455b000a 205d5252     dr 0x%x...[ERR] 
 c00a1d8:	6f727245 68772072 20656c69 63656863     Error while chec
 c00a1e8:	676e696b 43455320 4f4f4220 64412054     king SEC BOOT Ad
 c00a1f8:	73657264 5b000d73 5d464e49 4e414220     dress..[INF] BAN
 c00a208:	2031204b 75636573 66206572 6873616c     K 1 secure flash
 c00a218:	64255b20 6425202c 203a205d 5b20424f      [%d, %d] : OB [
 c00a228:	202c6425 0d5d6425 455b000a 205d5252     %d, %d]...[ERR] 
 c00a238:	6f727245 68772072 20656c69 63656863     Error while chec
 c00a248:	676e696b 63657320 20657275 73616c66     king secure flas
 c00a258:	72702068 6365746f 6e6f6974 65733a20     h protection :se
 c00a268:	6d772074 31636573 495b000d 205d464e     t wmsec1..[INF] 
 c00a278:	4b4e4142 66203120 6873616c 69727720     BANK 1 flash wri
 c00a288:	70206574 65746f72 6f697463 255b206e     te protection [%
 c00a298:	25202c64 3a205d64 5b424f20 202c6425     d, %d] : OB[%d, 
 c00a2a8:	0d5d6425 455b000a 205d5252 6f727245     %d]...[ERR] Erro
 c00a2b8:	68772072 20656c69 63656863 676e696b     r while checking
 c00a2c8:	69727720 70206574 65746f72 6f697463      write protectio
 c00a2d8:	203a206e 20746573 31707277 495b000d     n : set wrp1..[I
 c00a2e8:	205d464e 4b4e4142 73203120 72756365     NF] BANK 1 secur
 c00a2f8:	73752065 66207265 6873616c 64255b20     e user flash [%d
 c00a308:	6425202c 4f3a205d 255b2042 25202c64     , %d] :OB [%d, %
 c00a318:	0a0d5d64 52455b00 45205d52 726f7272     d]...[ERR] Error
 c00a328:	69687720 6320656c 6b636568 20676e69      while checking 
 c00a338:	75636573 75206572 20726573 73616c66     secure user flas
 c00a348:	72702068 6365746f 6e6f6974 73203a20     h protection : s
 c00a358:	68207465 0d317064 52455b00 45205d52     et hdp1..[ERR] E
 c00a368:	726f7272 69687720 6320656c 6b636568     rror while check
 c00a378:	20676e69 6620424f 5320726f 324d4152     ing OB for SRAM2
 c00a388:	41524520 61204553 65522074 0d746573      ERASE at Reset.
 c00a398:	52455b00 45205d52 726f7272 69687720     .[ERR] Error whi
 c00a3a8:	6320656c 6b636568 20676e69 5220424f     le checking OB R
 c00a3b8:	74205044 7270206f 6172676f 000d6d6d     DP to programm..
 c00a3c8:	5252455b 7245205d 20726f72 6c696877     [ERR] Error whil
 c00a3d8:	68632065 696b6365 6220676e 206b6e61     e checking bank 
 c00a3e8:	424f2032 50525720 45524120 74202041     2 OB WRP AREA  t
 c00a3f8:	7270206f 6172676f 000d6d6d 5252455b     o programm..[ERR
 c00a408:	7245205d 20726f72 6c696877 68632065     ] Error while ch
 c00a418:	696b6365 6220676e 206b6e61 424f2031     ecking bank 1 OB
 c00a428:	50525720 45524120 74202041 7270206f      WRP AREA  to pr
 c00a438:	6172676f 000d6d6d 5252455b 7245205d     ogramm..[ERR] Er
 c00a448:	20726f72 6c696877 65732065 6e697474     ror while settin
 c00a458:	424f2067 6e614220 6320316b 69666e6f     g OB Bank1 confi
 c00a468:	5b000d67 5d525245 72724520 7720726f     g..[ERR] Error w
 c00a478:	656c6968 65786520 69747563 4f206e6f     hile execution O
 c00a488:	614c5f42 68636e75 495b000d 205d464e     B_Launch..[INF] 
 c00a498:	746f6f42 6b636f4c 25783020 000a0d78     BootLock 0x%x...
 c00a4a8:	5252455b 7245205d 20726f72 6c696877     [ERR] Error whil
 c00a4b8:	68632065 696b6365 5320676e 42204345     e checking SEC B
 c00a4c8:	20544f4f 4b434f4c 495b000d 205d464e     OOT LOCK..[INF] 
 c00a4d8:	4c504452 6c657665 25783020 30282078     RDPLevel 0x%x (0
 c00a4e8:	29782578 5b000a0d 5d525245 72724520     x%x)...[ERR] Err
 c00a4f8:	7720726f 656c6968 65686320 6e696b63     or while checkin
 c00a508:	44522067 656c2050 0d6c6576 4e495b00     g RDP level..[IN
 c00a518:	50205d46 72676f72 696d6d61 5220676e     F] Programming R
 c00a528:	74205044 7825206f 5b000a0d 5d525245     DP to %x...[ERR]
 c00a538:	72724520 7720726f 656c6968 74657320      Error while set
 c00a548:	676e6974 20424f20 6b6e6142 6e6f6320     ting OB Bank con
 c00a558:	20676966 72746572 5b000d79 5d525245     fig retry..[ERR]
 c00a568:	72724520 7720726f 656c6968 74657320      Error while set
 c00a578:	676e6974 20424f20 6b6e6142 6e6f6320     ting OB Bank con
 c00a588:	0d676966                                 fig..

0c00a58d <CSWTCH.301>:
 c00a58d:	08020401                                ....

0c00a591 <CSWTCH.302>:
 c00a591:	10101000 10101004 10101002 4e495b08     .............[IN
 c00a5a1:	53205d46 74726174 20676e69 746f6f62     F] Starting boot
 c00a5b1:	64616f6c 000d7265 5252455b 7245205d     loader..[ERR] Er
 c00a5c1:	20726f72 6c696877 6e692065 61697469     ror while initia
 c00a5d1:	697a696c 4620676e 6873616c 746e4920     lizing Flash Int
 c00a5e1:	61667265 000d6563 5252455b 7245205d     erface..[ERR] Er
 c00a5f1:	20726f72 6c696877 6e692065 61697469     ror while initia
 c00a601:	697a696c 7420676e 73206568 72756365     lizing the secur
 c00a611:	20797469 6e756f63 0d726574 52455b00     ity counter..[ER
 c00a621:	55205d52 6c62616e 6f742065 6e696620     R] Unable to fin
 c00a631:	6f622064 6261746f 6920656c 6567616d     d bootable image
 c00a641:	495b000d 205d464e 746f6f42 64616f6c     ..[INF] Bootload
 c00a651:	63207265 6e696168 64616f6c 64646120     er chainload add
 c00a661:	73736572 66666f20 3a746573 25783020     ress offset: 0x%
 c00a671:	000a0d78 464e495b 754a205d 6e69706d     x...[INF] Jumpin
 c00a681:	6f742067 65687420 72696620 69207473     g to the first i
 c00a691:	6567616d 6f6c7320 5b000d74 5d525245     mage slot..[ERR]
 c00a6a1:	72724520 7720726f 656c6968 696e7520      Error while uni
 c00a6b1:	6974696e 7a696c61 20676e69 73616c46     nitializing Flas
 c00a6c1:	6e492068 66726574 0d656361 52455b00     h Interface..[ER
 c00a6d1:	4e205d52 72657665 6f687320 20646c75     R] Never should 
 c00a6e1:	20746567 65726568 7525000d 2e75252e     get here..%u.%u.
 c00a6f1:	53007525 35324148                        %u.SHA256.

0c00a6fb <sw_comp_ns.11063>:
 c00a6fb:	4550534e                                 NSPE.

0c00a700 <sw_comp_ns_s.11064>:
 c00a700:	4550534e 4550535f                        NSPE_SPE.

0c00a709 <sw_comp_s.11062>:
 c00a709:	00455053                                 SPE....

0c00a710 <boot_img_magic>:
 c00a710:	f395c277 7fefd260 0f505235 8079b62c     w...`...5RP.,.y.

0c00a720 <boot_swap_tables>:
 c00a720:	03040104 01040204 03040104 04030301     ................
 c00a730:	65700401 74006d72 00747365 3b475542     ..perm.test.BUG;
 c00a740:	6e616320 68207427 65707061 6572006e      can't happen.re
 c00a750:	74726576 4e495b00 53205d46 20706177     vert.[INF] Swap 
 c00a760:	65707974 7325203a 5b000a0d 5d464e49     type: %s...[INF]
 c00a770:	61775320 79742070 203a6570 656e6f6e      Swap type: none
 c00a780:	455b000d 205d5252 61766e69 2064696c     ..[ERR] invalid 
 c00a790:	61657261 20702520 20646928 0d297525     area %p (id %u).
 c00a7a0:	455b000a 205d5252 61657261 20752520     ..[ERR] area %u 
 c00a7b0:	20657375 6e756f63 6e752074 66726564     use count underf
 c00a7c0:	0d776f6c 455b000a 205d5252 61657261     low...[ERR] area
 c00a7d0:	20642520 657a6973 25783020 6f6e2078      %d size 0x%x no
 c00a7e0:	69642074 69736976 20656c62 73207962     t divisible by s
 c00a7f0:	6f746365 69732072 3020657a 0d782578     ector size 0x%x.
 c00a800:	455b000a 205d5252 73616c66 72612068     ..[ERR] flash ar
 c00a810:	25206165 65732064 726f7463 756f6320     ea %d sector cou
 c00a820:	6f20746e 66726576 0d776f6c 575b000a     nt overflow...[W
 c00a830:	205d4e52 61657261 20752520 20736168     RN] area %u has 
 c00a840:	75207525 73726573 5b000a0d 5d525245     %u users...[ERR]
 c00a850:	766e6920 64696c61 616c6620 49206873      invalid flash I
 c00a860:	64252044 7865203b 74636570 25206465     D %d; expected %
 c00a870:	000a0d64 5252455b 6e75205d 776f6e6b     d...[ERR] unknow
 c00a880:	6c66206e 20687361 61657261 0d642520     n flash area %d.
 c00a890:	                                         ..

0c00a892 <pss_zeros>:
	...

0c00a89c <bootutil_key_cnt>:
 c00a89c:	00000002                                ....

0c00a8a0 <bootutil_keys>:
 c00a8a0:	0c000240 0c00023c 0c0000ac 0c0000a8     @...<...........
 c00a8b0:	4e52575b 6146205d 64656c69 61657220     [WRN] Failed rea
 c00a8c0:	676e6964 63657320 73726f74 4f42203b     ding sectors; BO
 c00a8d0:	4d5f544f 495f5841 535f474d 4f544345     OT_MAX_IMG_SECTO
 c00a8e0:	253d5352 202d2064 206f6f74 6c616d73     RS=%d - too smal
 c00a8f0:	0a0d3f6c 52575b00 46205d4e 656c6961     l?...[WRN] Faile
 c00a900:	65722064 6e696461 6d692067 20656761     d reading image 
 c00a910:	64616568 3b737265 616d4920 253d6567     headers; Image=%
 c00a920:	000a0d75 4e52575b 6143205d 746f6e6e     u...[WRN] Cannot
 c00a930:	67707520 65646172 6f6d203a 73206572      upgrade: more s
 c00a940:	6f746365 74207372 206e6168 6f6c6c61     ectors than allo
 c00a950:	0d646577 52575b00 43205d4e 6f6e6e61     wed..[WRN] Canno
 c00a960:	70752074 64617267 73203a65 73746f6c     t upgrade: slots
 c00a970:	76616820 6f6e2065 6f632d6e 7461706d      have non-compat
 c00a980:	656c6269 63657320 73726f74 575b000d     ible sectors..[W
 c00a990:	205d4e52 6e6e6143 7520746f 61726770     RN] Cannot upgra
 c00a9a0:	203a6564 20746f6e 206c6c61 74636573     de: not all sect
 c00a9b0:	2073726f 20746966 69736e69 73206564     ors fit inside s
 c00a9c0:	74617263 000d6863 4e52575b 6143205d     cratch..[WRN] Ca
 c00a9d0:	746f6e6e 67707520 65646172 6c73203a     nnot upgrade: sl
 c00a9e0:	2073746f 20657261 20746f6e 706d6f63     ots are not comp
 c00a9f0:	62697461 000d656c 464e495b 6d49205d     atible..[INF] Im
 c00aa00:	20656761 72677075 20656461 6f636573     age upgrade seco
 c00aa10:	7261646e 6c732079 2d20746f 7270203e     ndary slot -> pr
 c00aa20:	72616d69 6c732079 000d746f 464e495b     imary slot..[INF
 c00aa30:	7245205d 6e697361 68742067 72702065     ] Erasing the pr
 c00aa40:	72616d69 6c732079 000d746f 464e495b     imary slot..[INF
 c00aa50:	6f43205d 6e697970 68742067 65732065     ] Copying the se
 c00aa60:	646e6f63 20797261 746f6c73 206f7420     condary slot to 
 c00aa70:	20656874 6d697270 20797261 746f6c73     the primary slot
 c00aa80:	7830203a 20787a25 65747962 000a0d73     : 0x%zx bytes...
 c00aa90:	5252455b 6553205d 69727563 63207974     [ERR] Security c
 c00aaa0:	746e756f 75207265 74616470 61662065     ounter update fa
 c00aab0:	64656c69 74666120 69207265 6567616d     iled after image
 c00aac0:	67707520 65646172 5b000d2e 5d525245      upgrade...[ERR]
 c00aad0:	6e617020 0d216369 52455b00 53205d52      panic!..[ERR] S
 c00aae0:	72756365 20797469 6e756f63 20726574     ecurity counter 
 c00aaf0:	61647075 66206574 656c6961 66612064     update failed af
 c00ab00:	20726574 67616d69 61762065 6164696c     ter image valida
 c00ab10:	6e6f6974 5b000d2e 5d525245 69614620     tion...[ERR] Fai
 c00ab20:	2064656c 61206f74 49206464 6567616d     led to add Image
 c00ab30:	20752520 61746164 206f7420 72616873      %u data to shar
 c00ab40:	61206465 0d616572 6573000a 646e6f63     ed area...second
 c00ab50:	00797261 6d697270 00797261 5252455b     ary.primary.[ERR
 c00ab60:	7541205d 6e656874 61636974 6e6f6974     ] Authentication
 c00ab70:	69616620 2164656c 616d4920 69206567      failed! Image i
 c00ab80:	6874206e 73252065 6f6c7320 73692074     n the %s slot is
 c00ab90:	746f6e20 6c617620 0d2e6469 0000000a      not valid......

0c00aba0 <_global_impure_ptr>:
 c00aba0:	300300a4                                ...0

0c00aba4 <__sf_fake_stderr>:
	...

0c00abc4 <__sf_fake_stdin>:
	...

0c00abe4 <__sf_fake_stdout>:
	...
 c00ac04:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
 c00ac14:	32313000 36353433 41393837 45444342     .0123456789ABCDE
 c00ac24:	31300046 35343332 39383736 64636261     F.0123456789abcd
 c00ac34:	00006665                                ef..

0c00ac38 <__EH_FRAME_BEGIN__>:
 c00ac38:	00000000                                ....
